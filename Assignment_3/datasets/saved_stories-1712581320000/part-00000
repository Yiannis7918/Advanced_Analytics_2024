{"aid": "39966969", "title": "Let's Kerberos", "url": "https://www.imperialviolet.org/2024/04/07/letskerberos.html", "domain": "imperialviolet.org", "votes": 1, "user": "tatersolid", "posted_at": "2024-04-08 06:59:43", "comments": 0, "source_title": "ImperialViolet - Let's Kerberos", "source_text": "ImperialViolet - Let's Kerberos\n\n# ImperialViolet\n\n### Let's Kerberos (07 Apr 2024)\n\n(I think this is worth pondering, but I don\u2019t mean it too seriously\u2014don\u2019t\npanic.)\n\nAre the sizes of post-quantum signatures getting you down? Are you despairing\nof deploying a post-quantum Web PKI? Don\u2019t fret! Symmetric cryptography is\npost-quantum too!\n\nWhen you connect to a site, also fetch a record from DNS that contains a\nhandful of \u201cCA\u201d records. Each contains:\n\n  * a UUID that identifies a CA\n  * E_CA-key(server-CA-key, AAD=server-hostname)\n  * A key ID so that the CA can find \u201cCA-key\u201d from the previous field.\n\n\u201cCA-key\u201d is a symmetric key known only to the CA, and \u201cserver-CA-key\u201d is a\nsymmetric key known to the server and the CA.\n\nThe client finds three of these CA records where the UUID matches a CA that\nthe client trusts. It then sends a message to each CA containing:\n\n  * E_CA-key\u2019(client-CA-key) \u2014 i.e. a key that the client and CA share, encrypted to a key that only the CA knows. We\u2019ll get to how the client has such a value later.\n  * A key ID for CA-key\u2019.\n  * E_client-CA-key(client-server-key) \u2014 the client randomly generates a client\u2013server key for each CA.\n  * The CA record from the server\u2019s DNS.\n  * The hostname that the client is connecting to.\n\nThe CA can decrypt \u201cclient-CA-key\u201d and then it can decrypt \u201cserver-CA-key\u201d\n(from the DNS information that the client sent) using an AAD that\u2019s either the\nclient\u2019s specified hostname, or else that hostname with the first label\nreplaced with *, for wildcard records.\n\nThe CA replies with E_server-CA-key(client-server-key), i.e. the client\u2019s\nchosen key, encrypted to the server. The client can then start a TLS\nconnection with the server, send it the three encrypted client\u2013server keys,\nand the client and server can authenticate a Kyber key-agreement using the\nthree shared keys concatenated.\n\nBoth the client and server need symmetric keys established with each CA for\nthis to work. To do this, they\u2019ll need to establish a public-key authenticated\nconnection to the CA. So these connections will need large post-quantum\nsignatures, but that cost can be amortised over many connections between\nclients and servers. (And the servers will have to pass standard challenges in\norder to prove that they can legitimately speak for a given hostname.)\n\nSome points:\n\n  * The CAs get to see which servers clients are talking to, like OCSP servers used to. Technical and policy controls will be needed to prevent that information from being misused. E.g. CAs run audited code in at least SEV/TDX.\n  * You need to compromise at least three CAs in order to achieve anything. While we have Certificate Transparency today, that\u2019s a post-hoc auditing mechanism and a single CA compromise is still a problem in the current WebPKI.\n  * The CAs can be required to publish a log of server key IDs that they recognise for each hostname. They could choose not to log a record, but three of them need to be evil to compromise anything.\n  * There\u2019s additional latency from having to contact the CAs. However, one might be able to overlap that with doing the Kyber exchange with the server. Certainly clients could cache and reuse client-server keys for a while.\n  * CAs can generate new keys every day. Old keys can continue to work for a few days. Servers are renewing shared keys with the CAs daily. (ACME-like automation is very much assumed here.)\n  * The public-keys that parties use to establish shared keys are very long term, however. Like roots are today.\n  * Distrusting a CA in this model needn\u2019t be a Whole Big Thing like it is today: Require sites to be set up with at least five trusted CAs so that any CA can be distrusted without impact. I.e. it\u2019s like distrusting a Certificate Transparency log.\n  * Revocation by CAs is easy and can be immediately effective.\n  * CAs should be highly available, but the system can handle a CA being unavailable by using other ones. The high-availability part of CA processing is designed to be nearly stateless so should scale very well and be reasonably robust using anycast addresses.\n\n", "frontpage": false}
