{"aid": "40087052", "title": "Rust Tokio task cancellation patterns", "url": "https://cybernetist.com/2024/04/19/rust-tokio-task-cancellation-patterns/", "domain": "cybernetist.com", "votes": 3, "user": "todsacerdoti", "posted_at": "2024-04-19 14:11:37", "comments": 0, "source_title": "Rust tokio task cancellation patterns", "source_text": "Rust tokio task cancellation patterns - Cybernetist\n\n# Rust tokio task cancellation patterns\n\n| 11 minutes | 2332 words | Milos Gajdos\n\nI have been trying to pick up Rust again recently. It\u2019s been a bit of a slow\nburn at the beginning but I think I\u2019m finally starting to feel the compounding\neffects kicking in. Maybe it\u2019s just my brain playing a trick on me, but I\u2019m\nfeeling at much more ease when writing Rust now than I was a few weeks back.\n\nI dabbled with Rust in the past but never built anything \u201csubstantial\u201d which\nis where the biggest learning usually happens because you get to face issues\nthat don\u2019t tend to surface on smaller-scale projects. This is not to say that\nbuilding small projects is useless! On the contrary! They\u2019re an excellent way\nto get your feet wet with any new language! It\u2019s just that the small projects\nusually don\u2019t highlight the lack of knowledge in some areas of language you\ndidn\u2019t need when building them.\n\nOne of those areas for me was concurrency. Rust provides support for async\nprogramming which lets you spawn asynchronous tasks which are then scheduled\nfor execution across OS threads via a runtime executor. As with everything in\nRust, async programming has to be memory-safe so you need to make sure the\nborrow checker is happy. Which is a proper challenge at times.\n\nTo make things a bit weirder in the Rust land, whilst async programming is the\nfirst class citizen, the standard library (i.e. async_std) is rather limited\nor at least seems like it to an untrained beginner\u2019s eyes like my own.\n\nTurns out people tend to use tokio crate instead which provides a wealth of\nfeatures and has a really great tutorial. Most of what I know about Rust async\nprogramming I learnt by following the tokio tutorial.\n\nOne thing the tutorial doesn\u2019t go into much detail is task cancellations,\nwhich is something I had a need for in one of my projects. Specifically, I\nneeded to spin a bunch of worker tasks and I needed a way to cancel either any\nor all of them. I did a bit of research and hacking aside and came up with a\nfew patterns I wanted to put somewhere where I could both easily access them\nand share them with anyone who might find them useful.\n\nMy intention in this blog post and the accompanying GitHub repo is to document\nthese patterns and I expect this post to be more of a living document that\nwill receive continuous updates based on the new tokio tricks I\u2019m hoping to\nlearn in the future. As I said, I\u2019m a major Rust noob at the moment so these\n\u201cpatterns\u201d might be completely bogus \u2013 if you find them to be so, please leave\na comment at the end of the post and I\u2019ll be happy to update it.\n\n# Select and Channels\n\nAt the heart of all of these patterns are two tokio features (assuming one is\nfamiliar with spawning the tasks, indeed):\n\n  * channels: used for inter-task communication\n  * select: used for waiting on multiple async computations (not necessaily tasks!)\n\nAt first sight they seem eerily similar to Go channels and select but the\ndevil lies in the details. Whilst Go offers a single channel construct, the\nsemantics of which (send/receive) are \u201ctuned\u201d via the optional <-/-> operators\n(checked by the compiler _only when explicitly written out \u2013 unfortunately\nthis is easily forgettable and more often than not, simply omitted by many Go\nprogrammers); tokio channels are seemingly a bit more complex, but at the same\ntime more powerful as far as memory safety and resilience of your program is\nconcerned.\n\nTokio channels create two distinct objects for communicating between tasks.\nYou can\u2019t use a single channel for both receiving and sending. This prevents a\nwhole class of problems I have faced many times when programming in Go such as\nwhen you accidentally omit the optional channel semantics and send data to a\nchannel that was supposed to be receive only \u2013 Go compiler sees nothing wrong\nwith it, but you spend hours debugging why are things not working.\n\nAnother interesting feature from a Go programmer\u2019s point of view is that you\ncan create a multiple-producer-single-consumer channels \u2013 referred to via the\nmpsc acronym \u2013 which prevents another class of problems I\u2019ve faced in Go\nprograms: multiple receivers modifying the same object thus causing a very sad\ndata races which can be hard to find. In Go you can happily send a pointer\ndown a channel to multiple consumers and make a promise to yourself that it\u2019s\neither read-only or you\u2019ll never try modifying it; the problem is, Go\ncompiuler does not enforce these things \u2013 this is literally just some sort of\nconvention/unwritten rule you are hoping others who use your code will follow.\nHaving a compiler that can help you enforicing this is pretty handy and bodes\nwell with Rust\u2019s memory safety mantrar. Actually, the story of concurrent type\nsafety is a bit more interesting and involves discussing Send and Sync traits,\nbut this post is about task cancellation patterns, so I\u2019ll leave it to you to\ndig into these traits.\n\nIf you do need to send many values to many consumers Tokio does have your\nback, worry not: tokio provides the broadcast channel.\n\nIn general, there are actually four types of channels provided by Tokio:\n\n  * mpsc: multiple producers single consumer, described above\n  * oneshot: for sending a receiving a single value; once sent, the channels is closed\n  * broadcast: describe above - multiple senders, multiple consumers\n  * watch: single producer, multiple consumers\n\nAs I said these are nicely documented and discussed in the tokio tutorial. It\ntook me a bit of time to digest these concepts as I naturally tend to compare\nthem to their Go language equivalents but they\u2019re subtly different. But\nanyway, let\u2019s move on to the actual cancellation patterns that leverage select\nand channels.\n\nThe following is an incomplete list of the patterns I came up with. Some of\nthese might feel a bit contrived to the experienced Rust programmer\u2019s eye, but\nthey worked rather well for me, as I said I\u2019m still a Rust n00b so I\u2019m likely\ndoing something wrong. Here goes!\n\n# Dropping JoinHandle\n\nEvery time you spawn a task in tokio you get back JoinHandle. You can use the\njoin handle to await the task to complete, but you can equally use it to\nforcefully terminate the task by simply dropping it. Here\u2019s a silly example\n\n    \n    \n    use tokio::time::{self, Duration}; #[tokio::main] async fn main() { let handle = tokio::spawn(async { // do some work tokio::time::sleep(Duration::from_secs(10)).await; println!(\"Task completed\"); }); // Cancel the task after 1 second time::sleep(Duration::from_millis(100)).await; drop(handle); println!(\"Task was cancelled\"); }\n\nThis is the simplest form of cancellation giving the spawned task no chance to\ndo any cleanup. If you run it you get the following output\n\n    \n    \n    Task was cancelled\n\nAs you can see we didn\u2019t wait for the task to complete. We just nuked it.\n\nYou could just as well simply rely on Rust dropping the handle by creating it\nin a code block:\n\n    \n    \n    use tokio::time::{self, Duration}; #[tokio::main] async fn main() { { let handle = tokio::spawn(async { // do some work tokio::time::sleep(Duration::from_secs(10)).await; println!(\"Task completed\"); }); // Cancel the task after 1 second time::sleep(Duration::from_millis(100)).await; } println!(\"Task was cancelled\"); }\n\n# Using the oneshot channel\n\nIf you just need a one-off cancellation to be broadcast to multiple tasks, the\noneshot channel works like a charm.\n\nThe oneshot channel allows a single send on the channel which can be listened\nto by multiple receivers. Unlike the drop this pattern lets your channels do\nsome cleanup. Here\u2019s an example:\n\n    \n    \n    use tokio::time::Duration; use tokio::sync::oneshot; #[tokio::main] async fn main() { let (tx, rx) = oneshot::channel(); let task = tokio::spawn(async move { tokio::select! { _ = rx => { println!(\"Task is cancelling...\"); } _ = tokio::time::sleep(Duration::from_secs(10)) => { println!(\"Task completed normally\"); } } println!(\"Task is cleaning up\"); }); tokio::time::sleep(Duration::from_millis(100)).await; // Send a cancellation signal let _ = tx.send(()); // Wait for the tasks to finish // NOTE: we could do this instead: // let _ = tokio::join!(task); let _ = task.await; }\n\nNow, if you run this you\u2019ll get something like this:\n\n    \n    \n    Task is cancelling... Task is cleaning up\n\nThe limitation of the oneshot channel is that you can\u2019t use it to cancel\nmultiple tasks. It\u2019s literally designed and optimised for one-off\nnotifications. So beware of that!\n\n# Using the broadcast channel to cancel multiple tasks\n\nIf you want to cancel multiple tasks you can use the broadcast channel. You\ncan have multiple producers sending to the channel as well as multiple\nconsumers receiving from it. Each receiver sees every value sent on the\nchannel. Handy!\n\nHere\u2019s a simple example how to use it to cancel multiple tasks and let them\nclean up:\n\n    \n    \n    use tokio::sync::broadcast; use tokio::time::Duration; #[tokio::main] async fn main() { let (tx, mut rx1) = broadcast::channel(1); let mut rx2 = tx.subscribe(); let task1 = tokio::spawn(async move { tokio::select! { _ = rx1.recv() => { println!(\"Task 1 is cancelling...\"); } _ = tokio::time::sleep(Duration::from_secs(10)) => { println!(\"Task 1 completed normally\"); } } println!(\"Task 1 is cleaning up\"); }); let task2 = tokio::spawn(async move { tokio::select! { _ = rx2.recv() => { println!(\"Task 2 is cancelling...\"); } _ = tokio::time::sleep(Duration::from_secs(10)) => { println!(\"Task 2 completed normally\"); } } println!(\"Task 2 is cleaning up\"); }); tokio::time::sleep(Duration::from_millis(100)).await; // Send a cancellation signal let _ = tx.send(()); // Wait for the tasks to finish let _ = tokio::join!(task1, task2); }\n\nIf you run this program you\u2019ll get something like this:\n\n    \n    \n    Task 2 is cancelling... Task 2 is cleaning up Task 1 is cancelling... Task 1 is cleaning up\n\nNote that the order of the cancellation may vary in your case as the tasks\nmight be cancelled in a different order!\n\nThe broadcast channel might be a bit of an overkill if you just want to send a\ncancellation signal from a single task to multiple tasks because it provides\nall the machinery for passing messages between multiple tasks.\n\nThis is handy if you need both the messaging passing and cancellation but if\nneed just the cancellation there is a better way. Or maybe not necessarily\nbetter but one with less overhead: watch channel.\n\n# Using the watch to cancel multiple tasks\n\nThe watch channel is a single producer of multiple consumer channels. Again,\nthe watch channel gives the task the opportunity the clean up after\nthemselves. The downside is, that the consumers only see the most recent value\nsent on the channel \u2013 meaning if your task is launched after a value has been\nsent on the channel it might miss it and thus not get cancelled, so beware of\nthis. Here\u2019s a simple example:\n\n    \n    \n    use tokio::sync::watch; use tokio::time::Duration; #[tokio::main] async fn main() { let (tx, mut rx1) = watch::channel(false); let mut rx2 = tx.subscribe(); let task1 = tokio::spawn(async move { loop { tokio::select! { _ = rx1.changed() => { if *rx1.borrow() { println!(\"Task 1 is cancelling...\"); break; } } _ = tokio::time::sleep(Duration::from_secs(10)) => { println!(\"Task 1 completed normally\"); break; } } } println!(\"Task 1 is cleaning up\"); }); let task2 = tokio::spawn(async move { loop { tokio::select! { _ = rx2.changed() => { if *rx2.borrow() { println!(\"Task 2 is cancelling...\"); break; } } _ = tokio::time::sleep(Duration::from_secs(10)) => { println!(\"Task 2 completed normally\"); break; } } } println!(\"Task 2 is cleaning up\"); }); tokio::time::sleep(Duration::from_millis(100)).await; // Send a cancellation signal let _ = tx.send(true); // Wait for the tasks to finish let _ = tokio::join!(task1, task2); }\n\nThis channel was designed to watch for changes in your program. Kinda like\npub/sub on a specific piece of data: the docs mention watching configuration\nchanges as a canonical example, but you can use it just as well for\ncancellation.\n\nNote how we send false on the channel when we initialized it and how we use\ntrue for sending the cancellation. Each task has to check if they received the\ntrue as they may as well receive false. We could also send some enum or String\ndown like Foo::cancel or \"cancel\", but again, each task would have to check if\nit\u2019s a cancellation signal and do some cleanup if it is and then exit.\n\n# Cancellation tokens\n\nThe official tokio documentation lists something called a CancellationToken in\nthe article about graceful shutdown. This isn\u2019t available in the tokio crate\nitself, but instead in the related toko_util crate.\n\nI\u2019ve not used it in any of my projects as I\u2019m trying to avoid pulling it more\ndependencies than the ones I\u2019m already using, but it\u2019s another interesting\noption that is actually geared for cancellations.\n\n    \n    \n    use tokio::time::{sleep, Duration}; use tokio_util::sync::CancellationToken; #[tokio::main] async fn main() { // Create a CancellationToken let token = CancellationToken::new(); let token1 = token.clone(); let token2 = token.clone(); let task1 = tokio::spawn(async move { loop { tokio::select! { _ = token1.cancelled() => { println!(\"Task 1 is cancelling...\"); break; } _ = tokio::time::sleep(Duration::from_secs(10)) => { println!(\"Task 1 completed normally\"); break; } } } println!(\"Task 1 is cleaning up\"); }); let task2 = tokio::spawn(async move { loop { tokio::select! { _ = token2.cancelled() => { println!(\"Task 2 is cancelling...\"); break; } _ = tokio::time::sleep(Duration::from_secs(10)) => { println!(\"Task 2 completed normally\"); break; } } } println!(\"Task 2 is cleaning up\"); }); sleep(Duration::from_millis(100)).await; // Send a cancellation signal token.cancel(); // Wait for the tasks to finish let _ = tokio::join!(task1, task2); }\n\nNotice how we cloned the token so we can move it to individual async tasks.\nOne thing worth mentioning is there is also something called child_token\nwhich, to quote the official documentation:\n\n> Unlike a cloned CancellationToken, cancelling a child token does not cancel\n> the parent token.\n\n# Conclusion\n\nThis is the list of the cancellation options I\u2019ve compiled together over the\npast couple of weeks whilst learning about tokio. As I said it\u2019s by no means a\ncomplete list and there are likely many more options at one\u2019s disposal which\nI\u2019m keen to learn about so don\u2019t be shy and hit me in the comments. You can\nfind all the code samples listed in this blog post on GitHub for reference.\nDon\u2019t be shhy and open a PR with new patterns or fixing the existing ones!\n\nrust rust concurrency concurrency\n\n#### See also\n\n  * Circular Buffer Performance Trick\n\n  * \u2190 Previous Post\n\nMilos Gajdos \u2022 \u00a9 2024 \u2022 Cybernetist\n\nHugo v0.124.1 powered \u2022 Theme Beautiful Hugo adapted from Beautiful Jekyll\n\n", "frontpage": false}
