{"aid": "39960716", "title": "Type-checked keypaths in Rust. (2021)", "url": "http://www.cmyr.net/blog/keypaths.html", "domain": "cmyr.net", "votes": 2, "user": "fanf2", "posted_at": "2024-04-07 13:42:04", "comments": 0, "source_title": "Type-checked keypaths in Rust", "source_text": "Type-checked keypaths in Rust\n\nType-checked keypaths in Rust\n\nHome/| -  \n---|---  \nblog/| -  \nType-checked keypaths in Rust| 2021-06-22  \n  \nLike a number of other folks, I have recently been exploring some slightly\nless well-worn corners of the Rust type system. In my particular case, this\ninvolves revisiting Swift-style keypaths. My previous experiments in this\ndirection (which began at the recurse center) have never really gone anywhere,\nbut recently I\u2019ve come up with a new approach that feels promising; a\npreliminary sketch of this work is available as the keypath crate. With this\ncrate, you can write the following:\n\n    \n    \n    #[derive(Keyable)] struct Playlist { songs: Vec<Song>, } #[derive(Keyable)] struct Song { name: String, artist: String, length: u32, favourite: bool, } fn main() { let playlist = make_sample_playlist(); let first_song_name = keypath!(Playlist.songs[0].name); println!(\"first song title: {}\", playlist[&first_song_name]); }\n\n## Motivation\n\nThe idea behind a keypath is that it provides an uninvoked reference to a\nfield on some type, and that field can be arbitrarily deep in a graph of\nobjects.\n\nThis is particularly interesting to me in the context of my work on Druid, and\nmore generally exploring patterns for building GUIs in Rust. Recently I have\nbeen spending quite a bit of time studying SwiftUI, where keypaths are used\nheavily. They can be helpful in a number of ways: for instance if you make a\ncaller mutate something by passing a value and a keypath, you can apply custom\nupdate logic before or after the mutation (such as invalidating some\ndependency, or scheduling a redraw); similarly by abstracting away field\naccess from the fields themselves, you can do fancy things like transparently\ndelegate certain properties to an inner type. More prosaically, they provide a\nsimple and ergonomic way to declare data relationships. For instance, imagine\nwe have a have a Checkbox widget; we want this widget to toggle a bool when it\nis clicked, but we do not otherwise care about the data that bool comes from.\nWe might have something like,\n\n    \n    \n    let checkbox = Checkbox::new(keypath!(Playlist.now_playing.favourite));\n\nWithout keypaths, the main way you might do something like this would probably\nbe with closures, and you\u2019d need separate closures for reading and writing:\n\n    \n    \n    let checkbox: Checkbox<Playlist> = Checkbox::new( |playlist| &playlist.now_playing.favourite, |playlist| &mut playlist.now_playing.favourite);\n\nIn this simple case, keypaths are easier to use and easier to reason about.\n\n## Implementation\n\nI think it\u2019s helpful to explain the implementation in two parts: the path\ntraversal part, which is relatively straight-forward, and the type checking\npart, which is hackier.\n\n### Path traversal\n\nUltimately, the path traversal component of this work is not especially\ncomplicated. Types that wish to participate in keypaths have to implement the\nfollowing trait:\n\n    \n    \n    /// A trait for types that expose their properties via keypath. pub trait RawKeyable: 'static { fn as_any(&self) -> &dyn Any; fn as_any_mut(&mut self) -> &mut dyn Any; fn get_field(&self, path: &[PathComponent]) -> Result<&dyn RawKeyable, FieldError>; fn get_field_mut(&mut self, path: &[PathComponent]) -> Result<&mut dyn RawKeyable, FieldError>; }\n\nWhere PathComponent is an enum of different possible \u2018members\u2019 a type might\nhave, which currently looks like this (although it may certainly expand or\nchange in the future):\n\n    \n    \n    /// A component of a keypath. #[derive(Debug, Clone, Copy)] pub enum PathComponent { /// An unnamed field, such as on a tuple or tuple struct Unnamed(usize), /// A named field. Named(&'static str), /// An index into a sequence, such as a vec. IndexInt(usize), /// An index into a map with string keys. IndexStr(&'static str), }\n\nIn any case, all of the work here is done in the get_field[_mut] methods.\nThese are called recursively, starting at the top object; at each layer, the\nimplementor looks at the path slice. If it is empty, it means we\u2019re at the end\nof the path, and we return self. Otherwise, we split off the first item in the\npath, and see if we have have a corresponding \u2018member\u2019. If we do, we call that\nmember with the rest of the path, and if not we return an error.\n\nAs a concrete example, here is what an implementation might look like for a\nsimple type (ignoring the _mut methods, which are trivially similar to their\nnon-mut equivalents):\n\n    \n    \n    struct Person { name: String, friends: Vec<String>, } impl RawKeyable for Person { fn as_any(&self) -> &dyn Any { self } fn get_field(&self, path: &[PathComponent]) -> Result<&dyn RawKeyable, FieldError> { let (head, rest) = match path.split_first() { None => return Ok(self), Some(tup) => tup, }; match head { PathComponent::Named(\"name\") => self.name.get_field(rest), PathComponent::Named(\"friends\") => self.friends.get_field(rest), _ => Err(FieldError::some_error()) } } }\n\nThis fairly simple trait gets us pretty far: we can make a slice of\nPathComponents, pass it to the appropriate type, and if the path exists we\nwill get back a &dyn RawKeyable, which we can then try to downcast to a\nconcrete type, by going through as_any. Putting this all together, we could\nwrite something like,\n\n    \n    \n    let person = Person { name: \"coco\".to_string(), friends: vec![\"kiki\".to_string(), \"jojo\".to_string()], } let path = &[PathComponent::Named(\"friends\"), PathComponent::IndexInt(0)]; let kiki = person.get_field(&path).unwrap().as_any().downcast_ref::<String>(); assert_eq!(kiki.unwrap(), \"kiki\");\n\nWhat is especially compelling about this approach is that (at least in clear\ncases like this) the compiler is smart enough to figure out what we\u2019re doing,\nand when building for --release this generates the same code as direct field\naccess (see godbolt).\n\n## Compile-time type-checking\n\nWhile path traversal is important, it is the least exciting of the two parts\nof the story. The bit I find especially interesting is built on top of that\ntraversal, and lets us validate at compile time that a given keypath exists,\nand that the to generate a strongly-typed KeyPath object that represents that\nknown route, as well as the types of the first object and the final value. We\nthen take advantage of this with a new trait, that allows infallible access to\nthe values of known keypaths, which lets us write code like this:\n\n    \n    \n    let kiki: Keypath<Person, String> = keypath!(Person.friends_names[0]); assert_eq!(person[&kiki], \"kiki\");\n\n### Implementation\n\nGetting this working was... a journey. Beyond just stretching my comfort with\nRust, it stretches my ability to communicate about Rust.\n\nOur goal is simple enough: we want a way to generate code, at compile time,\nthat can verify that a particular path exists, starting at a base type (the\nroot) and ending up at some other type (the value). Importantly, we need to do\nthis with only access to types; we can\u2019t work with actual instances of those\ntypes. This sort of type-level programming is tricky in Rust.\n\nTo explain the eventual solution, I will first sketch out what an \u2018ideal\u2019\nsolution might look like: by this I mean a fairly clear, plausible-seeming\nimplementation strategy.\n\n### What we want\n\nLet\u2019s start with a KeyPath type, that looks something like:\n\n    \n    \n    KeyPath<Root, Value> { _root: PhantomData<Root>, _value: PhantomData<Value>, path: Vec<PathComponent>, }\n\nFor the purpose of these examples, let\u2019s work with the following structs:\n\n    \n    \n    struct Person { name: String, stats: Stats, } struct Stats { // in furlongs per fortnight speed: f32, // in kilograms per meter per second viscosity: f32, }\n\nWe would like to be able to write keypath!(Person.stats.speed), and generate a\nKeyPath<Person, f32>; and we would like keypath!(Person.stats.missing_field)\nto fail to compile. What should this look like?\n\nAs a first approach, maybe we could do all of the work in the KeyPath type, by\ndefining the routes in impl blocks there; and then we need some way of getting\na \u2018root\u2019 keypath to begin from. For instance, here, we might have:\n\n    \n    \n    impl Person { fn __keypath_root() -> KeyPath<Person, Person> { KeyPath::infer_types(vec![]) } } impl<T> KeyPath<T, Person> { fn name(self) -> KeyPath<Person, String> { let mut path = self.path; path.append(PathComponent::Named(\"name\")); KeyPath::infer_types(path) } fn stats(self) -> KeyPath<Person, Stats> { /* generate keypath */ } } impl<T> KeyPath<T, Stats> { fn speed(self) -> KeyPath<Person, f32> { /* generate keypath */ } fn viscosity(self) -> KeyPath<Person, f32> { /* generate keypath */ } }\n\nAnd then we could imagine generating code that looked like,\n\n    \n    \n    let valid_keypath = Person::__keypath_root().stats().speed();\n\nThat looks nice! Unfortunately, this approach does not work. The first problem\nis with the \u2018inherent impl\u2019 that we declare for the different KeyPath types;\nthat is, the routes. Rust does not allow you to make \u2018inherent impl\u2019 for a\ntype in an external crate; in this case, the KeyPath type is declared in the\nkeypath crate, which means it is external to wherever this code is being\ngenerated. We could work around this by requiring the user to declare an\nappropriate KeyPath struct in their crate root, but then we bump into the\nsecond problem: we\u2019re also using inherent impls to generate the root keypaths,\nso there would be no way to add get the root keypath for a std type like a\nHashMap or a Vec, and that does not feel like an acceptable limitation.\n\n### What we get\n\nAfter experimenting with a bunch of ways to try and make this work, I settled\non something that is slightly less elegant; this involves generating \u2018mirror\u2019\nstructs. The basic idea is that each participating type implements a trait\nthat has an associated type, the mirror.\n\n    \n    \n    trait Keyable { type Mirror; fn mirror() -> Self::Mirror; }\n\nThe mirror type itself is a way of inspecting the types of the fields on the\nmain struct; the mirror has the same fields as the parent type, but those\nfields themselves return the mirror of the type of the parent\u2019s corresponding\nfield.\n\n    \n    \n    struct Stats { // in furlongs per fortnight speed: f32, // in kilograms per meter per second viscosity: f32, } struct StatsMirror { speed: <f32 as Keyable>::Mirror, viscosity: <f32 as Keyable>::Mirror, }\n\nAside: it was only when writing this up that I realized the above syntax was\neven legal; prior to this I was doing another weird trick to declare the\nfields.\n\n(For non-fields (indexes into collections) mirrors have specially-named\nmethods that return the mirror of the collection\u2019s member type.)\n\nThis gives us a nice way to check at compile-time that fields exist; the final\nstep is to create the correct KeyPath type once we\u2019ve verified the path. This\nis simple enough; we know the root type already, and we know the type of the\nmirrored object when we generate the mirror; so we can just add a method to\neach mirror type that looks like,\n\n    \n    \n    impl StatsMirror { fn to_key_path_with_root<Root>(self, fields: &[PathComponent]) -> KeyPath<Root, Stats> { /* */ } }\n\nPut this all together, and the code let path = keypath!(Person.stats.speed);\nends up generating (approximately) the following code:\n\n    \n    \n    let path = Person::mirror() .size .height .to_key_path_with_root::<Person>(&[ PathComponent::Named(\"stats\"), PathComponent::Named(\"speed\") ]);\n\nAnd that works just fine. A nice quality of the mirror objects is that they\nare all zero-sized types, and shouldn\u2019t have any impact on the generated\nbinary; they\u2019re only used at compile-time, to ensure that paths are valid.\n(Impact on compile time is still possible, and I haven\u2019t investigated that\nenough to say anything useful).\n\n### Codegen and performance\n\nDespite all of the use of Any and all the generated types, the generated code\ncan be quite efficient. In particular the \u2018mirror\u2019 types are all zero-sized,\nand don\u2019t make it into the final binary; and in many cases the traversal of\nthe fields can be inlined, and the generated code for accessing a keypath\nlooks identical to direct field access.\n\nThe main overhead is in the additional code generated for the Keyable trait,\nbut this should be modest in comparison to the code that is generated for\nthings like serde.\n\nI haven\u2019t investigated performance as deeply as I hope to, but the preliminary\nindications are encouraging.\n\n## Some possible next steps\n\nMy focus thus far has been on proving out the concept: figuring out how to\ntraverse the object graph, and then figuring out how to generate type\ninformation at compile time. This seems to work, but I haven\u2019t put much work\ninto making it useful, although I have some ideas in this direction.\n\n### refine the API\n\nAn important next step is going to be figuring out what the API should look\nlike. Currently, we only support strongly-typed keys, but we may want to\nconsider a sort of hierarchy of types. Swift distinguishes between AnyKeyPath\n(with neither root nor value types known) PartialKeyPath (with only the root\ntype known) and KeyPath, which knows both. In particular, PartialKeyPath may\nbe useful in that you could store paths with different value types in a single\ncollection. It might also be interesting to do things like allow types to\ninspect and override paths, or to provide custom \u2018fields\u2019 backed by functions,\netcetera. Similarly the derive macro could be improved with the addition of\nvarious attributes and customizations, and it could be possible to support\nkeypaths for enums, with collection-like behaviour; if a given path is only\nvalid for a subset of enum variants, it could resolve to Option<T>.\n\n### Better collection support\n\nCurrently collection access will panic at runtime if a key or index doesn\u2019t\nexist in the collection. I would like to refine this, and either make\ncollection access always return some sort of Option type, or else introduce\nsyntax into the macro to allow the user to opt-in to cascading optionals. For\ninstance, we might have syntax like,\n\n    \n    \n    let key: KeyPath<Person, u16> = keypath!(Person.friends[0].age); let opt_key: KeyPath<Person, Option<u16>> = keypath!(Person.friends[0]?.age);\n\nwhere explicitly providing a ? in the keypath allows the collection access to\nreturn an Option<T> that is propagated through to the user.\n\nIn addition, it may be interesting to provide an additional API for working\nwith types like serde_json::Value, which contain heterogeneous data. The idea\nhere is that it would be nice to be able to retrieve specific forms of data\nfrom these sorts of collections, so that you can attempt to retrieve a key as\na u64, instead of as a serde_json::Number.\n\n### Fun stuff: predicates, orderings, etc\n\nAnother possible case for keypaths is as a DSL for creating predicates and\norderings for things like constructing database queries or filtering\ncollections. We could imagine writing something like,\n\n    \n    \n    let keypath: KeyPath<Person, DateTime> = keypath!(Person.registration.date); let is_old_user: Predicate<Person> = keypath.less_than(REFERENCE_DATE); let is_precocious: Predicate<Person> = keypath!(Person.info.age).less_than(3); // oh no: let extremely_precocious = is_old_user && is_precocious; for person in data.people.iter().filter_by_predicate(&extremely_precocious) { /* hihi */ }\n\nOr for orderings,\n\n    \n    \n    let ordering: Ordering<Person> = keypath!(Person.rank) .descending() .then(keypath!(Person.registration.signup_date).ascending()) data.people.sort_by_ordering(&ordering);\n\nIn any case this is all very speculative, and intended primarily as an\nillustration of some of the things that this might make possible.\n\n## conclusions\n\nThis work is not quite developed enough to be currently useful, but I do think\nit\u2019s at a point where it\u2019s worth sharing. In particular, I think there are a\nbunch of possible directions for this work that could be interesting, and I\u2019m\nsure there are lots of good ideas that just haven\u2019t occurred to me personally.\nI also have some reservations about the implementation, and I\u2019m curious if\nthere are problems with my approach that I haven\u2019t identified yet.\n\n", "frontpage": false}
