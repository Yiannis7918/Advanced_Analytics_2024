{"aid": "40025654", "title": "Combinatory Programming", "url": "https://blog.zdsmith.com/posts/combinatory-programming.html", "domain": "zdsmith.com", "votes": 1, "user": "Tomte", "posted_at": "2024-04-13 20:11:50", "comments": 0, "source_title": "Subset Park: Combinatory Programming", "source_text": "Subset Park: Combinatory Programming\n\n  * Subset Park\n  * Posts\n  * Notes\n  * About\n  * Illustrated Whist\n  * Culture-Games\n\n# Combinatory Programming\n\n2024-04-06\n\n## To The Programmer\n\nA combinator is a kind of function. Specifically, it\u2019s a function that applies\nits arguments\u2014and only its arguments\u2014to each other in a particular shape and\norder. The number of possible shapes is of course infinite; but in practice a\nfew fairly simple shapes crop up more often than others, and those specific\nshapes have names. A very few of them are so common and so famous that their\nnames and shapes are already well-known to programmers; because they\u2019re well-\nknown there are often functions available in standard libraries that apply\ntheir arguments in shapes corresponding to them. Function composition is one:\nmany languages available today recognize that f(g(x)) is a sufficiently common\npattern, and that, for instance, writing xs.map(x => f(g(x))) is sufficiently\ncommon, inconvenient, and at times error-prone, that they allow the programmer\nto write xs.map(compose(f, g)) instead.\n\nIt therefore seems worthwhile to push at the boundaries of this set of well-\nknown shapes; are there others that crop up often enough that we can give them\nnames, and in so doing abstract away some of the repetitive guts of our code?\n\n## The Field\n\nCombinatory logic\u2014the field from which we draw the name and, loosely, the\nconcept of combinators\u2014is adjacent to computer programming in several\ndifferent directions. It\u2019s often of interest to computer programmers, though\nusually because those programmers are interested in logic itself, recreational\nmathematics, or programming language design; thus much of the available\nmaterial, if you squint, can be applied to how we write our programs and\nwhether we can write them better\u2014but you\u2019ve got to squint. The material is\nrarely straightforwardly applicable for the everyday programmer.\n\nIt is, for instance, often written in a minimal lambda calculus syntax\u2014\u03bbxy.xyy\nand the like\u2014which is more readable to the theorist. It often also dwells on\nminimal systems, like the SKI calculus, whose simple elements are sufficient\nfor the construction of arbitrarily complex expressions. A useful and\nintriguing theoretical basis but no more useful to the working programmer than\nlearning how to write programs for a Turing machine.\n\nWe must also talk about The Bird Book. Smullyan\u2019s To Mock a Mockingbird is\ndoubtless the most popular treatment of combinatory logic. It\u2019s beloved to\nmany people who love math and logic puzzles, programmers and non-programmers.\nIn it, we\u2019re introduced to the various combinators under the guise of birds\nwhose names begin with the same letter as their traditional academic names. \u039a,\nfor instance, is introduced as the Kestrel. Instead of dealing with function\napplication, Smullyan\u2019s birds say each other\u2019s names.\n\nIs this a good idea? From a pedagogical perspective, I\u2019m not sure; the\nmetaphor has absolutely never landed with me and the actual book is written\nwith lots of other logical and mathematical verbiage, so I don\u2019t know how far\nit gets you.\n\nWhere I do feel on firmer footing is to claim that whatever the merits of\ncalling \u03bbxy.x \u201cKestrel\u201d in the context of recreational mathematics, that name\nbecomes even less useful in the context of writing computer programs.\n\nIn the modern era, Conor Hoekstra has probably done the most to document and\npopularize the use of combinators within computer programming\u2014or at least to\nview computer programming and programming languages according to the extent to\nwhich they enable the use of combinatory function application forms, and the\nextent to which that use results in more concise, more elegant programs. He is\nthe maintainer of https://combinatorylogic.com, which has quite a few\nresources worth reading, listening to, and watching (many of which he himself\nhas produced).\n\nHoekstra is an array language enthusiast. This is not a coincidence: one of\nthe most dramatic effects obtainable in programs through the use of\ncombinators is that of tacit programming, that is, code that \u201cdoes not refer\nto values by name\u201d, and it\u2019s in the discourse around the array\nlanguages\u2014starting with J and expanding to the wider family of so-called\n\u201cIversonian\u201d languages\u2014that one most reliably encounters discussion and\ncelebration of tacit forms.\n\nAnd it\u2019s Hoekstra who has most effectively beat the drum that the array\nlanguages\u2019 so-called trains\u2014one of the critical ways that those languages\nenable tacit code\u2014are best understood as extremely concise syntactic\nrealizations of particular and particularly useful combinators\u2014in the case of\nJ, for instance, the S and \u03a6 combinators, among others.\n\nThe work that follows can be understood as an attempt to continue in the\ndirection in which he has set out; in part by embracing that particular class\nof functions as worthy of consideration in the writing of computer programs,\nand in part by more completely separating the topic of combinators from the\narray-language context in which Hoekstra most often discusses them.\n\nHoekstra is an array language enthusiast (as am I) and holds that the array\nlanguages are by far the best place to make full use of combinators in\nprogramming; I don\u2019t disagree, but I think that in order to present them\nclearly to the wider community and to hopefully convince that community of\ntheir utility, it\u2019s worth going further than he has in presenting them in as\n\u201cneutral\u201d a context as possible; the array languages are fascinating and\npowerful, but also forbidding and at times obscure.\n\nI want to try to isolate these concepts not just to make them as accessible as\npossible: it also remains an open question whether a function for \u03a6 would be\nof use to the programmer in a more \u201cgeneric\u201d context like, say, a Javascript\ncodebase that made sufficient use of higher-order functions\u2014or whether its\nutility only emerges in the full syntactic and operational context of a\nlanguage like J.\n\n## Names\n\nI want to propose that the value of tacit programming is analogous to the\nvalue of functional programming: when applied in the right places, it allows\nthe programmer to \u201cabstract away\u201d repetitive behaviours consisting of many\nmoving parts into operations that are conceptually simpler, more uniform, and\ncan be applied to a wide variety of situations. When those core operations\nhave been intuitively grasped, the resulting code is easier to understand; and\nthe appearance of fewer of those moving parts means fewer places for bugs.\n\nStripped of all of its theoretical apparatus, the higher-order function\nmap\u2014well-known to many programmers, functional and otherwise\u2014is \u201cjust\u201d the\nsimplest form of structure-preserving iteration. Nevertheless, its value in an\neveryday programming context is that this form of iteration is easy to\nconceptualize, form a mental model of, and predict the behaviour of.\nCritically, incorporating the universal name map into our vocabulary allows us\ngreater economy with names inside of our code. Observing a paradigmatic\ninvocation of map:\n\n    \n    \n    const adjustedScores = [] for (const score of scores) { adjustedScores.push(Math.abs(score)) }\n\nbecomes\n\n    \n    \n    const adjustedScores = scores.map(Math.abs)\n\nWe see that we have saved quite a bit of typing. But we have also eliminated\none name, score, entirely; the conceptual inventory of our code has decreased\nby precisely one. We might even then say that the number of names eliminated\nfrom our code, without any of its sense being lost, is a crude measure of the\ndegree to which we have been able to abstract it.\n\nJust as map\u2014once we can recognize the patterns in our code that it can\nreplace\u2014allows us to simplify both the code\u2019s text and its conceptual\ninventory, so too do the combinators: giving universal names to certain fixed\npatterns of function application, in exchange for a greater economy of the\nlocal, domain-specific names in our code.\n\n## Vocabulary\n\nSo we come to the problem of names. I\u2019ve been using bold sans-serif single\nletters up till now, because that\u2019s what Haskell Curry and WVO Quine did in\nthe literature of combinatory logic, following Sch\u00f6nfinkel. These are all well\nand good in a theoretical context. But to our purposes, the name B is no\nbetter than Smullyan\u2019s Bluebird. Neither one gives us the slightest conceptual\ntoehold when it comes to remembering what it does. So we call it function\ncomposition instead; the relationship between \u201ccomposition\u201d and f(g(x)) is not\nunimpeachably pellucid but it\u2019s a start.\n\nThe way forward is less obvious with the more exotic patterns. In J, we call \u03a6\na \u201cfork\u201d, because that\u2019s what a diagram of its function application looks\nlike; in Haskell, they call it liftA2, for category-theoretic reasons that we\nwon\u2019t go into. Fork isn\u2019t that bad, but it\u2019s not terribly suggestive; and it\nalso means something rather concrete in most computer systems.\n\nOf the many, many combinators in the forest, there are some that are useful to\nprogrammers. These are the ones that correspond to the most common patterns of\nfunction application that your average programmer tends to encounter, and\nthus, the ones that it\u2019s worthwhile to give names to. A very few\u2014I count\nidentity and compose\u2014are so common that they have names that are widespread\nand sufficiently meaningful. As to the rest: we might imagine a world where,\nsomeday, they\u2019re part of the standard library of every programming language.\nTo get there, their corresponding patterns need to be trivially recognizable\nby any programmer, as trivially as x => x. To get there: I can\u2019t escape the\nconclusion that we need to give them better names. Names that relate\nconcretely, or as concretely as possible, to what they do; names that are\nconcise but not at the expense of their meanings.\n\nTo go with those names:\n\n  * We can describe the function application patterns in a function syntax that is more recognizable to everyday programmers. I will use Javascript\u2019s arrow syntax (see x => x above), not because I particularly like it, but because it\u2019s widespread.\n  * We can offer motivations for their use: not as theoretical bases of formal systems, or as recreation, but in something approximating actual programs.^1\n\nWhat follows is such an attempt. In cases where a combinator already has a\ncommon name, or where some literature\u2014the Haskell standard library, array\nlanguage discourse\u2014has established a sufficiently reasonable candidate, I\u2019ll\nuse that; otherwise I\u2019ll try to come up with something myself.\n\nFor some existing motivating examples, see:\n\n  * Hoekstra, Combinatory Logic and Combinators in Array Languages, \u00a79\n  * J Hooks Evaluation\n  * J Primer, Hook\n  * J Primer, Fork\n  * J Wiki, Vocabulary/hook\n  * J Wiki, Vocabulary/fork\n  * J for C Programmers, Forks, Hooks, and Compound Adverbs\n\nIf convenient, I will reproduce them shamelessly here.\n\nFurther, I\u2019m indebted to the members of the APL Farm for additional motivating\nexamples.\n\n# A Practical Combinator Library\n\n## identity\n\n    \n    \n    const identity = x => x\n\n### A Motivation: No-Op\n\nidentity is easily understood as a no-op; it\u2019s in the context of other\nfunctional programming techniques that the need for such a function arises.\nWhereas, in a less functional style, we might have an if statement combined\nwith a mutating operation, when using techniques from functional programming\nwe can easily find ourselves needing a function which means \u201cdo nothing\u201d.\n\n    \n    \n    const maybeAbs = shouldShouldNormalizeNegatives ? Math.abs : identity return nums.map(maybeAbs)\n\n## constant\n\n    \n    \n    function constant(x) { return y => x }\n\n### A Motivation\n\nThe case for constant is similar to that for identity; in an imperative\ncontext, it is almost always superfluous. In a context making use of higher-\norder functions, it often has a role to play.\n\n    \n    \n    const maybeRedact = shouldRedactNames ? constant(\"**REDACTED**\") : identity return names.map(maybeRedact)\n\n## compose\n\n    \n    \n    function compose(f, g) { return x => f(g(x)) }\n\n### A Motivation: Data Pipelining\n\nThe following example is restricted in scope, but only because for\nsimplicity\u2019s sake we\u2019ve defined compose to take exactly two arguments. An\nindustrial strength compose should probably take any number of functions,\nwhere the extension from 2 to n is hopefully self-evident.\n\n    \n    \n    const cleanData = compose(removeUndefineds, coalesceNaNs) const cleanedData = cleanData(dirtyData)\n\n### A Motivation: Absolute Difference\n\nJust as we can imagine a variadic compose, where compose(f, g, h) is\nequivalent to compose(f, compose(g, h)), and so on: we can also imagine that\nan industrial strength compose might return a variadic function, that is, that\nthe result of compose should pass not just x to the innermost function but\n...x, with all subsequent functions expecting a single argument.\n\n    \n    \n    function composeN(f, g) { return (...x) => f(g(...x)) } const absoluteDifference = composeN(Math.abs, _.subtract) return absoluteDifference(9, 13) // => 4\n\n## apply\n\n    \n    \n    function apply(f) { return xs => f(...xs) }\n\n### A Motivation\n\nWhen applied to a single argument, apply is redundant; apply(f)(x) is\nequivalent to f(x). When f is a function that takes multiple arguments,\nthere\u2019s often syntactic sugar to apply it to some variable xs that contains\nmultiple values: as seen above, in Javascript, it\u2019s the spread operator ...\n(there\u2019s also the appropriately-named prototype method apply). In Janet, it\u2019s\nsplice, spelled ;, as in (f ;xs). The functional form apply, on the other\nhand, allows tacit forms to be used in a functional style.\n\n    \n    \n    const basesAndExponents = [[0, 1], [1, 2], [3, 5], [8, 13]] return basesAndExponents.map(apply(Math.pow)) // => [ 0, 1, 243, 549755813888 ]\n\n## flip\n\n    \n    \n    function flip(f) { return (x, y) => f(y, x) }\n\n### A Motivation\n\nWe could imagine standalone functions to permute any number of arguments; in\npractice, three or more arguments that need to be rearranged should probably\nbe bound to local variables and called explicitly. On the other hand, when two\narguments need to be reversed, the effect is quite intuitive.\n\n    \n    \n    const exponentsAndBases = [[0, 1], [1, 2], [3, 5], [8, 13]] return exponentsAndBases.map(apply(flip(Math.pow))) // => [ 1, 2, 125, 815730721 ]\n\n## duplicate\n\n    \n    \n    function duplicate(f) { return x => f(x, x) }\n\n### A Motivation\n\n    \n    \n    const square = duplicate(_.multiply) return square(6) // => 36\n\n## left\n\n    \n    \n    const left = (x, y) => x\n\n## right\n\n    \n    \n    const right = (x, y) => y\n\n## recombine^2\n\n    \n    \n    function recombine(f, g, h) { return x => f(g(x), h(x)) }\n\n### A Motivation\n\nrecombine can be seen as a generic form for functions that need to reuse their\narguments in more than one position.\n\nWe\u2019ll appropriate the canonical example from demonstrations of J: the\narithmetic mean of a sequence of values is the sum of those values divided by\nthe length of the sequence.\n\n    \n    \n    const mean = recombine(_.divide, _.sum, _.size) return mean([0, 1, 1, 2, 3, 5, 8, 13]) // => 4.125\n\n### A Motivation: Min-max / Span of Values\n\n    \n    \n    const minMax = recombine(Array.of, _.min, _.max) const spanOfValues = recombine(_.subtract, _.max, _.min) const values = [1, 1, 2, 3, 5, 8, 13] return minMax(values) // => [ 1, 13 ] return spanOfValues(values) // => 12\n\n### A Motivation: Plus or Minus\n\nIn the same way that we can imagine a variadic extension of the higher-order\nfunction produced by compose, we can imagine one for the higher-order function\nproduced by recombine. It can be extended to pass ...x to both g and h, while\npreserving the existing behaviour.\n\n    \n    \n    function recombineN(f, g, h) { return (...x) => f(g(...x), h(...x)) } const plusOrMinus = recombineN(Array.of, _.add, _.subtract) return plusOrMinus(13, 8) // => [ 21, 5 ]\n\n### A Motivation: Splitting Arrays\n\nIn researching this example, I was astonished to learn that there\u2019s no native\nway in the Javascript standard library to split an array at a given index.\n\n    \n    \n    const splitAt = recombineN(Array.of, _.take, _.drop) return splitAt([0, 1, 1, 2, 3, 5, 8, 13], 5) // => [ [ 0, 1, 1, 2, 3 ], [ 5, 8, 13 ] ]\n\n### A Motivation: Is Palindrome, Harshad Numbers, eachValueIsUnique\n\nThere\u2019s a special case of of recombine that we might see cropping up fairly\noften: an operation between some value, and a function of that same value.\n\nIf we like, we could spell that thus:\n\n    \n    \n    x => f(x, g(x))\n\nBut we can also spell it as an application of recombine that has identity as\neither g or h. This has the same behaviour:\n\n    \n    \n    const isPalindrome = recombine(_.isEqual, _.reverse, identity) return isPalindrome([0, 1, 0])\n    \n    \n    /** * A harshad number is any number that is divisible by the sum of its digits. */ const isHarshadNumber = recombine(isDivisible, identity, sumOfDigits)\n    \n    \n    const eachValueIsUnique = recombine(_.isEqual, identity, _.uniq) return eachValueIsUnique([0, 1, 1, 2, 3, 5, 8, 13]) // => false return eachValueIsUnique([0, 1, 2, 3, 5, 8, 13]) // => true\n\nSince there\u2019s no great and widespread name for this special case, I\u2019ll prefer\nto spell it in terms of recombine and identity.\n\n### A Motivation: Percentage difference\n\nThe left and right functions are fairly specialized but can come in handy in\nthe cases covered by combineN:\n\n    \n    \n    const percentageDifference = recombineN(_.divide, _.subtract, right) return percentageDifference(12, 10) // => 0.2\n\nAs with duplicate: to go with left and right we can imagine functions that\nreturn the third, fourth, etc. argument that they\u2019re given, but it might get\nunwieldy for functions of three arguments or more.\n\n## under^3\n\n    \n    \n    function under(f, g) { return (x, y) => f(g(x), g(y)) }\n\n### A Motivation\n\n    \n    \n    const isAnagram = under(_.isEqual, _.sortBy) return isAnagram(\"live\", \"evil\")\n\n### A Motivation: areAnagrams\n\nBecause under applies the same g to each argument passed to the resulting\nhigher-order-function, it\u2019s also fairly intuitive to generalize that function\nfrom 2 arguments to n.\n\n    \n    \n    function underN(f, g) { return (...xs) => f(...xs.map(g)) } const areAnagrams = underN(_.isEqual, _.sortBy) return areAnagrams(\"live\", \"evil\", \"veil\")\n\n  1. Javascript syntax is widespread and often-understood; unfortunately, the base Javascript ecosystem, by itself, is not great for functional programming. Many of its functions are either operators or object methods, that can\u2019t easily be passed in to higher-order functions.\n\nIn these examples we\u2019ll often make use of the lodash library to fill in some\nof these gaps. \u21a9\n\n  2. The name for this combinator, which the literature calls \u03a6 and which J calls fork, is a novel suggestion of Nate Pinsky. \u21a9\n\n  3. The name for this combinator, which the literature calls \u03a8, collides\u2014unfortunately\u2014with some existing nomenclature in J. J\u2019s Under has an analogous function, in that it applies some g to one or more arguments and then applies some f to the results. The difference is that J\u2019s then attempts to undo g by calling the so-called obverse of g on the result of the call to f.\n\nThe collision is regrettable, but nevertheless the most suggestive metaphor\nfor \u03a8 seems to be that it calls f under g. \u21a9\n\n## Recent Posts\n\n2024-04-06| Combinatory Programming  \n---|---  \n2023-09-03| An Algebraic Sketch of Poetic Form  \n2023-01-15| 2023: The Year of Ulti  \n2022-12-27| What Makes a Good Culture-Game?  \n2022-12-02| On Culture-Games  \n  \nBuilt with Bagatto.\n\n", "frontpage": false}
