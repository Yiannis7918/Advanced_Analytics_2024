{"aid": "40030224", "title": "Building Cross-Platform GUI Applications with Fyne", "url": "https://www.packtpub.com/product/building-cross-platform-gui-applications-with-fyne/9781800563162", "domain": "packtpub.com", "votes": 1, "user": "teleforce", "posted_at": "2024-04-14 10:52:44", "comments": 0, "source_title": "Building Cross-Platform GUI Applications with Fyne | Packt", "source_text": "Building Cross-Platform GUI Applications with Fyne | Packt\n\nHome Programming Building Cross-Platform GUI Applications with Fyne\n\n# Building Cross-Platform GUI Applications with Fyne\n\nBy Andrew Williams\n\nBook\n\neBook $29.99\n\nPrint $43.99\n\nSubscription $15.99 $10 p/m for three months\n\n  * eBook\n  * Print\n\nBUY NOW\n\n$10 p/m for first 3 months. $15.99 p/m after that. Cancel Anytime!\n\nWhat do you get with a Packt Subscription?\n\nThis book & 7000+ ebooks & video courses on 1000+ technologies\n\n60+ curated reading lists for various learning paths\n\n50+ new titles added every month on new and emerging tech\n\nEarly Access to eBooks as they are being written\n\nPersonalised content suggestions\n\nCustomised display settings for better reading experience\n\n50+ new titles added every month on new and emerging tech\n\nPlaylists, Notes and Bookmarks to easily manage your learning\n\nMobile App with offline access\n\nWhat do you get with a Packt Subscription?\n\nThis book & 6500+ ebooks & video courses on 1000+ technologies\n\n60+ curated reading lists for various learning paths\n\n50+ new titles added every month on new and emerging tech\n\nEarly Access to eBooks as they are being written\n\nPersonalised content suggestions\n\nCustomised display settings for better reading experience\n\n50+ new titles added every month on new and emerging tech\n\nPlaylists, Notes and Bookmarks to easily manage your learning\n\nMobile App with offline access\n\nWhat do you get with eBook + Subscription?\n\nDownload this book in EPUB and PDF formats, plus a monthly download credit\n\nThis book & 6500+ ebooks & video courses on 1000+ technologies\n\n60+ curated reading lists for various learning paths\n\n50+ new titles added every month on new and emerging tech\n\nEarly Access to eBooks as they are being written\n\nPersonalised content suggestions\n\nCustomised display settings for better reading experience\n\n50+ new titles added every month on new and emerging tech\n\nPlaylists, Notes and Bookmarks to easily manage your learning\n\nMobile App with offline access\n\nWhat do you get with a Packt Subscription?\n\nThis book & 6500+ ebooks & video courses on 1000+ technologies\n\n60+ curated reading lists for various learning paths\n\n50+ new titles added every month on new and emerging tech\n\nEarly Access to eBooks as they are being written\n\nPersonalised content suggestions\n\nCustomised display settings for better reading experience\n\n50+ new titles added every month on new and emerging tech\n\nPlaylists, Notes and Bookmarks to easily manage your learning\n\nMobile App with offline access\n\nWhat do you get with eBook?\n\nDownload this book in EPUB and PDF formats\n\nAccess this title in our online reader\n\nDRM FREE - Read whenever, wherever and however you want\n\nOnline reader with customised display settings for better reading experience\n\nWhat do I get with Print?\n\nGet a paperback copy of the book delivered to your specified Address*\n\nDownload this book in EPUB and PDF formats\n\nAccess this title in our online reader\n\nDRM FREE - Read whenever, wherever and however you want\n\nOnline reader with customised display settings for better reading experience\n\nWhat do I get with Print?\n\nGet a paperback copy of the book delivered to your specified Address*\n\nAccess this title in our online reader\n\nOnline reader with customised display settings for better reading experience\n\nWhat do you get with video?\n\nDownload this video in MP4 format\n\nAccess this title in our online reader\n\nDRM FREE - Watch whenever, wherever and however you want\n\nOnline reader with customised display settings for better learning experience\n\nWhat do you get with video?\n\nStream this video\n\nAccess this title in our online reader\n\nDRM FREE - Watch whenever, wherever and however you want\n\nOnline reader with customised display settings for better learning experience\n\nWhat do you get with Audiobook?\n\nDownload a zip folder consisting of audio files (in MP3 Format) along with\nsupplementary PDF\n\nWhat do you get with Exam Trainer?\n\nFlashcards, Mock exams, Exam Tips, Practice Questions\n\nAccess these resources with our interactive certification platform\n\nMobile compatible-Practice whenever, wherever, however you want\n\n  * eBook\n  * Print\n\nBUY NOW $10 p/m for first 3 months. $15.99 p/m after that. Cancel Anytime!\n\neBook $29.99\n\nPrint $43.99\n\nSubscription $15.99 $10 p/m for three months\n\nWhat do you get with a Packt Subscription?\n\nThis book & 7000+ ebooks & video courses on 1000+ technologies\n\n60+ curated reading lists for various learning paths\n\n50+ new titles added every month on new and emerging tech\n\nEarly Access to eBooks as they are being written\n\nPersonalised content suggestions\n\nCustomised display settings for better reading experience\n\n50+ new titles added every month on new and emerging tech\n\nPlaylists, Notes and Bookmarks to easily manage your learning\n\nMobile App with offline access\n\nWhat do you get with a Packt Subscription?\n\nThis book & 6500+ ebooks & video courses on 1000+ technologies\n\n60+ curated reading lists for various learning paths\n\n50+ new titles added every month on new and emerging tech\n\nEarly Access to eBooks as they are being written\n\nPersonalised content suggestions\n\nCustomised display settings for better reading experience\n\n50+ new titles added every month on new and emerging tech\n\nPlaylists, Notes and Bookmarks to easily manage your learning\n\nMobile App with offline access\n\nWhat do you get with eBook + Subscription?\n\nDownload this book in EPUB and PDF formats, plus a monthly download credit\n\nThis book & 6500+ ebooks & video courses on 1000+ technologies\n\n60+ curated reading lists for various learning paths\n\n50+ new titles added every month on new and emerging tech\n\nEarly Access to eBooks as they are being written\n\nPersonalised content suggestions\n\nCustomised display settings for better reading experience\n\n50+ new titles added every month on new and emerging tech\n\nPlaylists, Notes and Bookmarks to easily manage your learning\n\nMobile App with offline access\n\nWhat do you get with a Packt Subscription?\n\nThis book & 6500+ ebooks & video courses on 1000+ technologies\n\n60+ curated reading lists for various learning paths\n\n50+ new titles added every month on new and emerging tech\n\nEarly Access to eBooks as they are being written\n\nPersonalised content suggestions\n\nCustomised display settings for better reading experience\n\n50+ new titles added every month on new and emerging tech\n\nPlaylists, Notes and Bookmarks to easily manage your learning\n\nMobile App with offline access\n\nWhat do you get with eBook?\n\nDownload this book in EPUB and PDF formats\n\nAccess this title in our online reader\n\nDRM FREE - Read whenever, wherever and however you want\n\nOnline reader with customised display settings for better reading experience\n\nWhat do I get with Print?\n\nGet a paperback copy of the book delivered to your specified Address*\n\nDownload this book in EPUB and PDF formats\n\nAccess this title in our online reader\n\nDRM FREE - Read whenever, wherever and however you want\n\nOnline reader with customised display settings for better reading experience\n\nWhat do I get with Print?\n\nGet a paperback copy of the book delivered to your specified Address*\n\nAccess this title in our online reader\n\nOnline reader with customised display settings for better reading experience\n\nWhat do you get with video?\n\nDownload this video in MP4 format\n\nAccess this title in our online reader\n\nDRM FREE - Watch whenever, wherever and however you want\n\nOnline reader with customised display settings for better learning experience\n\nWhat do you get with video?\n\nStream this video\n\nAccess this title in our online reader\n\nDRM FREE - Watch whenever, wherever and however you want\n\nOnline reader with customised display settings for better learning experience\n\nWhat do you get with Audiobook?\n\nDownload a zip folder consisting of audio files (in MP3 Format) along with\nsupplementary PDF\n\nWhat do you get with Exam Trainer?\n\nFlashcards, Mock exams, Exam Tips, Practice Questions\n\nAccess these resources with our interactive certification platform\n\nMobile compatible-Practice whenever, wherever, however you want\n\n  1. Section 1: Why Fyne? The Reason for Being and a Vision of the Future\n\n     * Section 1: Why Fyne? The Reason for Being and a Vision of the Future\n\n  2. Free Chapter\n\nChapter 1: A Brief History of GUI Toolkits and Cross-Platform Development\n\n     * Chapter 1: A Brief History of GUI Toolkits and Cross-Platform Development\n     * Understanding the history of the graphical user interface\n     * Exploring the evolution of GUI toolkits\n     * Comparing native graphical apps to web UIs\n     * Options for cross-platform native toolkits\n     * Summary\n\n  3. Chapter 2: The Future According to Fyne\n\n     * Chapter 2: The Future According to Fyne\n     * Technical requirements\n     * Starting with a clean slate\n     * How Go is a great fit for this challenge\n     * Looking good with Material Design\n     * Designing APIs for simplicity and maintainability\n     * A vision of the future\n     * Summary\n     * Further reading\n\n  4. Section 2: Components of a Fyne App\n\n     * Section 2: Components of a Fyne App\n\n  5. Chapter 3: Window, Canvas, and Drawing\n\n     * Chapter 3: Window, Canvas, and Drawing\n     * Technical requirements\n     * Anatomy of a Fyne application\n     * Understanding CanvasObject and the canvas package\n     * Scalable drawing primitives\n     * Pixel output \u2013 rendering images\n     * Implementing a simple game\n\n  6. Chapter 4: Layout and File Handling\n\n     * Chapter 4: Layout and File Handling\n     * Technical requirements\n     * Laying out containers\n     * Standard layouts\n     * Cross-platform file handling\n     * Implementing an image browser application\n     * Summary\n\n  7. Chapter 5: Widget Library and Themes\n\n     * Chapter 5: Widget Library and Themes\n     * Technical requirements\n     * Exploring the design of the Widget API\n     * Grouping with the collection widgets\n     * Adding structure with container widgets\n     * Using common dialogs\n     * Custom dialogs\n     * Understanding themes\n     * Implementing a task list application\n     * Summary\n\n  8. Chapter 6: Data Binding and Storage\n\n     * Chapter 6: Data Binding and Storage\n     * Technical requirements\n     * Binding data to widgets\n     * Adapting data types for display\n     * Binding complex data types\n     * Storing data using the Preferences API\n     * Implementing a water consumption tracker\n     * Summary\n\n  9. Chapter 7: Building Custom Widgets and Themes\n\n     * Chapter 7: Building Custom Widgets and Themes\n     * Technical requirements\n     * Extending existing widgets\n     * Creating a component from scratch\n     * Implementing a chat app user interface\n     * Summary\n\n  10. Section 3: Packaging and Distribution\n\n     * Section 3: Packaging and Distribution\n\n  11. Chapter 8: Project Structure and Best Practices\n\n     * Chapter 8: Project Structure and Best Practices\n     * Technical requirements\n     * Organizing your project\n     * Test driving your development\n     * Managing platform-specific code\n     * Summary\n\n  12. Chapter 9: Bundling Resources and Preparing for Release\n\n     * Chapter 9: Bundling Resources and Preparing for Release\n     * Technical requirements\n     * Bundling assets\n     * Checking for UI hints\n     * Choosing metadata, icons, and app IDs\n     * Packaging applications (desktop and mobile)\n     * Installing your application\n     * Cross-compiling with ease\n     * Summary\n\n  13. Chapter 10: Distribution \u2013 App Stores and Beyond\n\n     * Chapter 10: Distribution \u2013 App Stores and Beyond\n     * Technical requirements\n     * Building your application for release\n     * Distributing apps to desktop app stores\n     * Uploading apps to Google Play and the iOS App Store\n     * Summary\n\n  14. Other Books You May Enjoy\n\n     * Other Books You May Enjoy\n     * Packt is searching for authors like you\n     * Leave a review - let other readers know what you think\n\nYou might also be interested in\n\nLearn Microsoft Power Apps\n\nBook\n\nMr. Matthew Weston | Elisa B\u00e1rcena Mart\u00edn Sep 2023 702 pages\n\nNo Rating\n\n$35.99\n\n  * eBook\n  * Print\n\nSecurity-Driven Software Development\n\nBook\n\nMr. Aspen Olmsted Mar 2024 262 pages\n\nNo Rating\n\n$31.99\n\n  * eBook\n  * Print\n\nAsynchronous Programming in Rust\n\nBook\n\nCarl Fredrik Samson Feb 2024 306 pages\n\nNo Rating\n\n$31.99\n\n  * eBook\n  * Print\n\n50 Algorithms Every Programmer Should Know\n\nBook\n\nSomaieh Nikpoor | Imran Ahmad Sep 2023 538 pages\n\n4\n\n$39.99\n\n  * eBook\n  * Print\n\nC++ High Performance for Financial Systems\n\nBook\n\nMr. Ariel Silahian Mar 2024 316 pages\n\nNo Rating\n\n$36.99\n\n  * eBook\n  * Print\n\nComplete Python Course with 10 Real-World Projects\n\nVideo\n\nArdit Sulce Feb 2023 1627 mins\n\n5\n\n$109.99\n\n.NET MAUI Cross-Platform Application Development\n\nBook\n\nMr. Roger Ye Mar 2024 496 pages\n\nNo Rating\n\n$32.99\n\n  * eBook\n  * Print\n\nSolutions Architect\u2019s Handbook\n\nBook\n\nNeelanjali Srivastav | Saurabh Shrivastava Jan 2022 590 pages\n\n4\n\n$43.99\n\n  * eBook\n  * Print\n\nExpert Delphi\n\nBook\n\nMarco Cant\u00f9 | Pawe\u0142 G\u0142owacki Feb 2024 424 pages\n\nNo Rating\n\n$36.99\n\n  * eBook\n  * Print\n\nModern C++ Programming Cookbook\n\nBook\n\nMarius Bancila Feb 2024 816 pages\n\nNo Rating\n\n$43.99\n\n  * eBook\n  * Print\n\nLearn Microsoft Power Apps\n\nBook\n\nMr. Matthew Weston | Elisa B\u00e1rcena Mart\u00edn Sep 2023 702 pages\n\nNo Rating\n\n$35.99\n\n  * eBook\n  * Print\n\nSecurity-Driven Software Development\n\nBook\n\nMr. Aspen Olmsted Mar 2024 262 pages\n\nNo Rating\n\n$31.99\n\n  * eBook\n  * Print\n\nAsynchronous Programming in Rust\n\nBook\n\nCarl Fredrik Samson Feb 2024 306 pages\n\nNo Rating\n\n$31.99\n\n  * eBook\n  * Print\n\n50 Algorithms Every Programmer Should Know\n\nBook\n\nSomaieh Nikpoor | Imran Ahmad Sep 2023 538 pages\n\n4\n\n$39.99\n\n  * eBook\n  * Print\n\nC++ High Performance for Financial Systems\n\nBook\n\nMr. Ariel Silahian Mar 2024 316 pages\n\nNo Rating\n\n$36.99\n\n  * eBook\n  * Print\n\nComplete Python Course with 10 Real-World Projects\n\nVideo\n\nArdit Sulce Feb 2023 1627 mins\n\n5\n\n$109.99\n\n.NET MAUI Cross-Platform Application Development\n\nBook\n\nMr. Roger Ye Mar 2024 496 pages\n\nNo Rating\n\n$32.99\n\n  * eBook\n  * Print\n\nSolutions Architect\u2019s Handbook\n\nBook\n\nNeelanjali Srivastav | Saurabh Shrivastava Jan 2022 590 pages\n\n4\n\n$43.99\n\n  * eBook\n  * Print\n\nExpert Delphi\n\nBook\n\nMarco Cant\u00f9 | Pawe\u0142 G\u0142owacki Feb 2024 424 pages\n\nNo Rating\n\n$36.99\n\n  * eBook\n  * Print\n\nModern C++ Programming Cookbook\n\nBook\n\nMarius Bancila Feb 2024 816 pages\n\nNo Rating\n\n$43.99\n\n  * eBook\n  * Print\n\nLearn Microsoft Power Apps\n\nBook\n\nMr. Matthew Weston | Elisa B\u00e1rcena Mart\u00edn Sep 2023 702 pages\n\nNo Rating\n\n$35.99\n\n  * eBook\n  * Print\n\nSecurity-Driven Software Development\n\nBook\n\nMr. Aspen Olmsted Mar 2024 262 pages\n\nNo Rating\n\n$31.99\n\n  * eBook\n  * Print\n\nView All\n\nAbout this book\n\nThe history of graphical application development is long and complicated, with\nvarious development challenges that persist to this day. The mix of\ntechnologies involved and the need to use different programming languages led\nto a very steep learning curve for developers looking to build applications\nacross multiple platforms. In Building Cross-Platform GUI Applications with\nFyne, you'll understand how the Go language, when paired with a modern\ngraphical toolkit such as Fyne, can overcome these issues and make application\ndevelopment much easier. To provide an easy-to-use framework for cross-\nplatform app development, the Fyne project offers many graphical concepts and\ndesign principles that are outlined throughout this book. By working through\nfive example projects, you'll learn how to build apps effectively, focusing on\neach of the main areas, including the canvas, layouts, file handling, widgets,\ndata binding, and themes. The book will also show you how the completed\napplications can then be run on your desktop computer, laptop, and smartphone.\nAfter completing these projects, you will discover how to prepare applications\nfor release and distribute them to platform marketplaces and app stores. By\nthe end of this book, you'll be able to create cross-platform graphical\napplications with visually appealing user interfaces and concise code.\n\nPublication date:\n\n    January 2021\n\nPublisher\n\n    Packt\n\nPages\n\n    318\n\nISBN\n\n    9781800563162\n\nDownload code from GitHub\n\nRelated Tags: New Releases Django AJAX Web Development Most Popular\n\n# Chapter 1: A Brief History of GUI Toolkits and Cross-Platform Development\n\nThis book is aimed at exploring how to easily build robust and beautiful\ngraphical applications that will work well across all operating systems and\ndevices. Before we start looking at the details of how this is accomplished,\nit is important to consider the history of these devices and the landscape of\ngraphical toolkits throughout the last 50 years. We start with a reminder of\nwhere GUI-based applications started and how far they have come.\n\nIn this chapter, you will be reintroduced to the Graphical User Interface\n(GUI), along with learning about toolkits that support app development and how\nthey offer different approaches to cross-platform development. We will explore\nthe benefits of coding a native GUI for responsive user experience and\nplatform integration. Upon completion of this chapter, you should be familiar\nwith the origins and challenges of graphical toolkits and the different\napproaches that have been taken during this journey.\n\nIn this chapter, we'll cover the following topics to provide a short history\nof GUI toolkits and cross-platform development:\n\n  * Where GUI toolkits came from\n  * How they have adapted (or stayed the same) over time\n  * Historical approaches to cross-platform development\n\n# Understanding the history of the graphical user interface\n\nIn 1973, the Palo Alto Research Center (Xerox PARC) completed the Alto\ncomputer, the first commercial example of a graphical desktop computer. In\nmost contemporary histories, this was the first example of what we understand\nas the GUI. While the screen orientation and lack of colors make it a little\npeculiar to the modern eye, it's clearly recognizable and includes many key\ncomponents as well as a mouse and keyboard for interaction. While it took\nanother 7 years to become generally available to the public in 1981 as the\nXerox Star, it was clear that this was a dramatic step forward:\n\nFigure 1.1 \u2013 Dynabook environment desktop (1976; Smalltalk-76 running on\nAlto). Copyright SUMIM.ST, licensed CC BY-SA 4.0\n\nThis development was a huge leap forward for the usability of computers. Up to\nthis time, all interaction was through text-mode computer screens and keyboard\nor other text input devices. The graphical interface is much easier to learn\nfor a novice looking to get started, and allows the quicker discovery of\nadvanced features. While the command-line interface remains popular with\nprogrammers and other pro users, the GUI is the largest contributing factor to\nthe rise of the desktop computer.\n\n## Popularity of the desktop computer\n\nThe introduction of a user-friendly graphical environment brought about a\nsignificant growth in the use of desktop computers. Around the time of the\nAlto computer, there were an estimated 48,000 desktop computers around the\nworld. By 2001, this number had increased dramatically to over 125,000,000\npersonal computers shipped\n(https://en.wikipedia.org/wiki/History_of_personal_computers#Market_size). In\n2002, the industry celebrated a billion computers shipped\n(http://news.bbc.co.uk/1/hi/sci/tech/2077986.stm), though numbers have\ndeclined more recently (see the Smartphones and mobile apps section later in\nthis chapter) and fewer than 300 million were reported shipped in 2018\n(https://venturebeat.com/2019/01/10/gartner-and-idc-hp-and-lenovo-shipped-the-\nmost-pcs-in-2018-but-total-numbers-fell/).\n\nAs these devices reached the hands of consumers, and hardware became more\ncapable, we started to see a focus on creating attractive user interfaces as\nwell as a trend to establish or match fashion trends. The following are some\nimportant versions of Microsoft's Windows operating system:\n\nThe copyright for all screenshots belongs to Microsoft. Each image used with\npermission\n\nAs you can see in the previous screenshots, each major revision of the desktop\nenvironment brought new styles for the buttons, fonts, and other user\ninterface elements. This is all controlled by the toolkit and represents an\nevolution in usability and style choices that we'll explore later in this\nchapter.\n\nWhilst Microsoft were progressing with their GUIs, there were also many\ncompetitors, some of which may appear familiar and others with their own\ndistinct styles; for example, the following popular systems:\n\nDesktop screenshots from various operating systems 1985-2015. Each image has\nbeen used with the required permission under fair use policies\n\nAs you can see from the preceding desktop screenshots for various operating\nsystems from 1985 to 2015, there have been dramatic shifts in the look and\nfeel, whilst maintaining a certain familiarity. These desktop systems are all\ndesigned for running multiple application windows typically centered around\ndocument editing, file management, and utility apps. Additional software, such\nas games, photo management, and music players, appeared over the years, but\nthe most ubiquitous, the web browser, was not commonplace until the late\n1990s. The addition of internet access started a shift to a new era of\ncomputing.\n\n## Moving to the web\n\nWith the increasing availability of reliable internet connections, we started\nto see an increase in the amount of information being accessed from servers on\nthe World Wide Web (WWW). Providing a good user web browser experience became\nof paramount importance and the fierce competition saw operating system\nmanufacturers up against independent software developers (search browser wars\nin your favorite search engine to know more).\n\nThe WWW was first proposed by Sir Tim Berners Lee in 1981 and development\nbegan within the CERN (https://home.cern) project (codenamed ENQUIRE). The\nearly web was made available to the public in 1993. As a distributed system\nthat anyone is able to add to, innovation in design was even more rapid than\nin the desktop operating systems we saw earlier. Trends in design and\nusability quickly caught up with, overtook, and started to lead traditional\nsoftware development:\n\nTrends in website design (via Web Design Museum); copyrights belong to their\nrespective owners\n\nThe web started as a project for providing access to data, born out of a\nfrustration of how difficult it could be to access information on a different\ncomputer. What started as simple information retrieval quickly became a\npolished presentation of more complex information, and then began to become a\nplace to submit or manipulate information as well.\n\nA simple data access platform quickly grew into much more and before long,\nthis emerged as a full application platform. In fact, due to the standards-\nbased approach (overseen by the World Wide Web Consortium (W3C)), this was one\nof the first truly cross-platform development opportunities. A web-based\napplication would be developed and made available to all computers in one go\u2014a\nbig advancement over previous attempts to develop for multiple platforms.\n\nAn additional benefit of delivering applications through a web-based solution\nwas that you could support multiple types of application accessing the\nunderlying data or functionality. A web-based API (Application Programming\nInterface) that had historically powered the user-visible website could be\nused by other devices as well. This design allowed traditional software to\naccess the same data as the web-based delivery systems and contributed to the\ndevelopment of common-place architectures that support a multitude of\ndifferent types of software \u2013 including the more recent mobile-based\napplications.\n\n## Smartphones and mobile apps\n\nIn 2007, Apple's Steve Jobs introduced the iPhone, a fresh new design for the\nconcept of mobile computing. Although portable smartphone devices existed for\nmany years before this event, the introduction of a slick new user interface,\ntouchscreen input, and large screen for displaying video and web content had a\nsignificant impact on the market. Competitors (existing and newly created)\nwere now racing to create the best user experience that could fit in the\nconsumers' pockets. Although early devices touted that you could browse any\nwebsite with ease, developers quickly adapted the content to be better\npresented on these smaller screens\u2014often focusing on information that mattered\non the move.\n\nTo satisfy the user demand for a more sophisticated and faster experience on\nthese more limited (by hardware or internet connectivity) devices, the concept\nof a mobile app was born. These small pieces of software were designed\nspecifically for a certain type of mobile phone (Android, iPhone, and others)\nand were made available by the platform's store or marketplace. Such software\nhad large benefits over the web-based solutions that came earlier as they\ncould be installed on the device, so they ran faster and were developed\nspecifically for the given hardware, creating a better user experience and\nallowing access to the more advanced capabilities of each device (such as\nlocation detection, thumbprint sensors, and Bluetooth).\n\nThese native apps provided the ultimate user experience. The applications\ncould be very fast (as they were installed on the device), adapt to the user\n(through access to local settings and data), and also interact with the\noperating system features (such as calendars, voice controls, and cutting-edge\nhardware sensors), all of which are not really possible when delivered through\na web app. However, they came with a disadvantage for developers\u2014not only did\neach platform look different, meaning that designs may need to be adapted, but\nthey were also distributed separately and typically required different\nprogramming languages to develop. Now instead of reaching the whole world with\na single application, a software company would need at least three different\napps to reach their customers through their favorite devices:\n\niPhone and Android devices showing their similarities and differences\n\nWe will come back to the challenges of developing for multiple different\nhardware platforms later, but first, we will explore the graphical toolkits\nthat underpinned the various technologies we have seen in this section.\n\n# Exploring the evolution of GUI toolkits\n\nGUIs must be programmed like any other computer program, and just like\nlibraries are created to provide standard components, a GUI toolkit exists to\nsupport building the graphical elements of an application. Many toolkits exist\nfor different reasons\u2014Wikipedia maintains a list of nearly 50 different\nprojects, and growing, at\nhttps://en.wikipedia.org/wiki/List_of_widget_toolkits and\nhttps://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries. To\nmake sense of the huge number of options, we split them into categories,\nlooking first at those built for specific operating systems.\n\n## Platform-specific toolkits\n\nEach graphical operating system or desktop environment has a distinct look and\nprogramming style, therefore a graphical toolkit was traditionally created for\neach platform. Windows had the WinAPI (as well as WinForms and foundation\nclasses), Atari was programmed using GEM, and BeOS used the Be API.\nApplications developed for Apple products have used various toolkits, but\nsince macOS X it's called Cocoa (with desktops using AppKit and mobile devices\nusing UIKit). Android devices are programmed with their own toolkit and other\nmobile platforms have explored other options.\n\nThe Unix and Linux operating systems have a more complicated story. Although\nthe Motif toolkit was one of the first, the fact that its design offers\nmultiple choices has meant there is no one true look or library. In the 1980s,\nbefore Motif was created, there was the OpenLook project that aimed to provide\na standard interface look and feel for Unix systems. Although there were many\ndifferent designs and toolkits to choose from, the main contributors to Unix\ndecided that unification would help it compete with Windows and other desktop\nplatforms. And so, in 1993, they chose Motif for future development.\n\nOne of the common features of desktop environment design is that it is\nfrequently updated, as you could see in the screenshots of Microsoft Windows\nearlier in this chapter. Whether due to changes in fashion or advances in\nusability, these changes are expected and the Motif system did not adapt to\nthem, and so new projects were created as alternatives. Later in the 90s, the\nGTK+ and Qt projects were started and provided a more modern, polished-looking\nuser interface. Also, the Java platform launched with AWT (Abstract Widget\nToolkit) in 1995, all of which were not platform-specific, opening a new world\nof cross-platform GUI libraries.\n\n## Cross-platform toolkits\n\nThe toolkits mentioned in the earlier subsection were all developed for a\nspecific platform. They evolved along with the operating system design and are\noften developed using the manufacturer's preferred programming language. These\nchallenges make it difficult (if not impossible) to create a single app that\nwill work on all platforms. For that reason, the move to create a cross-\nplatform toolkit requires taking a different approach and so developers\nstarted to design a library that could be written independently of platform\nspecifics in a language that could be compiled for any of the operating\nsystems it supports.\n\nWhen GTK+ and Qt were created in the mid-1990s, they chose C and C++ (an\nobject-based language derived from C), respectively. Both languages had wide\nadoption across most operating systems and were in use with some other\ntoolkits already, keeping the barrier of learning low. The Java approach,\nhowever, was broader\u2014to create a whole new language that would work across all\nof these platforms and deliver a graphical toolkit built on top.\n\nOperating system and computer manufacturers have market power to sway\ntechnologies, and as new languages became available, they are able to force\ndevelopers in the same new directions (such as Apple moving to Swift,\nMicrosoft to C#, and Google moving their apps to Dart). However, the large\nopen source communities built around cross-platform technologies are generally\nloyal to the language it is built with and so don't typically embrace such\nlarge changes. Therefore, these projects can be left behind in some senses and\ncan encourage developers to look in new directions, such as web technologies.\n\n## Hybrid apps\n\nAs discussed earlier in the chapter, the WWW offered an attractive platform\nfor delivering applications to users on multiple operating systems as well as\nproviding a way to build apps once and run them on any computer. A web browser\noffers a highly customizable canvas so that, using Cascading Style Sheets\n(CSS), any HyperText Markup Language (HTML)-based application can be made to\nlook like any design. This benefit brought a lot of popularity to web\napplication development and even influenced some native toolkits to expand\ntheir theme capabilities to mimic this.\n\nWebsites, as described earlier in this chapter, were designed for information\ntransfer\u2014initially for read-only, and later for sending and editing data too.\nTo get from this to a fully interactive application requires additional\nprogramming capabilities, and for this JavaScript is used. In the years since\nits creation, JavaScript has grown in popularity and complexity\u2014there are now\nmultiple package managers to handle the thousands of available packages that\ncan be used in any JavaScript-powered app. Of these libraries, many are\ngraphical toolkits for handling application interaction and layout, much like\na traditional GUI toolkit. Of these, the most popular are currently React,\nVue.js, and JQuery, though that list changes regularly.\n\nWhen developing such JS based web-apps, the focus is on the user interface\nentirely (the frontend), whereas a full application may contain business logic\nand algorithms that may be part of the server infrastructure (the backend) of\na web application. Historically, these separate parts of a complex application\nare created using different programming languages. This makes sense as there\nare different requirements for each area of a large infrastructure. However,\nfor smaller applications, or to reduce technical complexity, it can be useful\nto use the same language for all parts\u2014and so Node.js was created to support\nthe JavaScript-based backend elements of an application as well.\n\nDespite the benefits of distributing over the web, many companies still want\nto provide a traditional application that is downloaded and installed (the\nreasons are explored in the next section). To balance the speed of development\nand other benefits of web applications with the standard application package\nthat developers are familiar with, a new breed of applications was created,\nnicknamed hybrid apps. These new apps are loaded in a standard container that\nloads the custom web application in a regular window like any other\napplication on the system. Electron, Ionic, and React Native are all projects\nworking in this space, offering a web-based app framework with varying levels\nof access to the system they are running on.\n\nAlongside the evolution of graphical toolkits for cross-platform development,\nwe cannot ignore the ubiquity of the web browser. Although it has the benefit\nof being present on most modern computers, it may not be the right solution\nfor building your product \u2013 let's take a look at how these approaches differ.\n\n# Comparing native graphical apps to web UIs\n\nDespite the benefits that web-based applications can deliver, every technology\nchoice means making a trade-off in some area, so let's look at a few of the\ncommon issues that might influence your decision of whether to build a native\napp or web-based hybrid.\n\n## Development speed versus delivery\n\nOne of the main reasons to pick a web technology to build your application is\nthe speed of development. The very nature of developing in this way means that\nyou can live-preview your work in a web browser. The availability of browser-\nbased editors also means that a design team can tweak the user interface\nwithout much code experience. Large portions of your web app could also be\nused in your hybrid application (or the other way round) to provide a high\nlevel of reuse and minimal additional work to support desktop and mobile\ndelivery.\n\nThe trade-off regarding speed is found at runtime\u2014as the applications require\na web view to run the code, there is an impact on how fast the application can\nbe loaded and executed. Each time a hybrid app is loaded, it creates a small\nversion of a web browser inside the window, loading the code like a web page\nand starting the execution of the bundled JavaScript. To most users, this may\nnot be so slow as to be frustrating, but when compared to natively-compiled\napplications, there can be a noticeable difference. Depending on the framework\nchosen, it is also common for this model to require a lot of memory\u2014indeed,\nElectron has a reputation for requiring a lot of RAM, with the simplest\napplication using nearly 70 MB just to show 'Hello World'.\n\nThe actual speed of execution may also be noticeably slower for applications\nbuilt on web technologies. Due to the layers of abstraction, a web-based app\nwill typically take more time and CPU cycles to perform the same operations\nthan a compiled native application (though technologies such as WebGL and WASM\n(short for Web Assembly) are attempting to improve this). Therefore, if your\napplication is likely to be CPU-intensive, or have lots of animated graphics,\nyou may wish to benchmark different approaches to determine which platforms\nare capable of meeting your requirements for app responsiveness.\n\nAnother consideration may be automatic updates\u2014would you like your apps to\nalways be running the latest version? Some web-based toolkits offer the\nfunctionality to download application updates and dynamically load the new\nversion without the user having to worry. This can be a large benefit, but\ncould also be frustrating if your customers expect the software to work\nexactly the same every day until they opt to update it. Some people are also\nconcerned about how applications of this nature may appear to phone home\u2014that\nis, reporting back to a central server about how the apps are being used, and\nwhere, as part of the update process.\n\n## Visual style\n\nAnother main decision point for choosing web technology-based app development\nmay be the power of the presentation layer (CSS). It is possible, using a\ncombination of image assets and style-sheet code, to create almost any visual\nstyle desired. For developers (or indeed, the designers on their team) that\ndesire a completely bespoke look to their application, this could be a great\nfit. It is worth considering how your users will use the application, however,\nand whether a completely custom look will inhibit the usability in any way.\n\nThis benefit of complete customization can become challenging if the\napplication is intended to match the user interface style of the current\nsystem. As the rendering is infinitely flexible, developers can of course add\ntweaks to a style that make it look subtly (or substantially) different when\nrunning on certain systems. This type of adjustment can end up taking a\nsurprising amount of additional effort\u2014as each platform can have a different\nstyle over time. A GUI that attempts to match the system style but does not\nquite manage this is far more off-putting than the one that is clearly\nfollowing its own style guide.\n\nTherefore, it is probably best to avoid hybrid apps if you desire to blend in\nwith the other apps on a system. Web technologies do offer a fast-to-develop,\nadaptable platform for cross-platform applications, but there are constraints\nto this approach that should be considered as well.\n\n## Technical constraints\n\nApplications built with web technologies, even those built to look like system\napps with hybrid frameworks, run in a sandbox. This means that they are\nlimited in certain ways regarding access to devices and system features. The\nJavaScript APIs that grant access to underlying functionalities are constantly\nexpanding to work around these constraints, but if your application would\nbenefit from non-standard peripherals or integration into specific operating\nsystem features, then a web UI may not be the right choice for you.\n\nAccess to communications ports, peripheral devices not included in typical web\nAPIs, and process management are some low-level elements of an application\nthat would not be supported by default. Additionally, interacting with a\ndesktop environment's system tray, search features, and some advanced file\nmanagement may be difficult to access from within the JavaScript code. To\nattempt to bridge this gap, some hybrid toolkits allow native code to be\nwritten and loaded as libraries to access this functionality. Such extensions,\nhowever, would need to be written in the platform's own language (usually C or\nC++) and then compiled for each supported platform. Not only does this\nincrease the complexity of application distribution; it can also detract from\nthe single-codebase app design technique that using web tools offers.\n\nIn comparison to this, other approaches to cross-platform development\ntypically provide an abstraction over all supported operating systems so that\nan app can be built just once, but where support is missing, they provide a\nway to get direct access to the underlying features. This is often in the form\nof a language bridge or a way to load system libraries from the higher-level\nlanguage. This can involve needing to build with different programming\nlanguages, as discussed earlier, but with cross-platform technologies outside\nof the web sandbox, it does not normally increase the distribution complexity\nas much. Additionally, it is far rarer to find devices not supported by a\nnative cross-platform toolkit in comparison to one that is based in an\nembedded web browser.\n\nIf some of the constraints of web technology cross-platform development\nmentioned in this section might impact your app, or if you would prefer not to\nbe coding with HTML and JavaScript, then native toolkits are probably the\nright approach, which we will look at next.\n\n# Options for cross-platform native toolkits\n\nAs indicated earlier in this chapter, the idea of a cross-platform toolkit is\nnot new\u2014in fact, they date back to the mid-1990s, barely 10 years into the\nhistory of GUI development. It is important to understand that even among\nnative cross-platform toolkits there are distinct approaches with different\nbenefits and drawbacks.\n\n## Visual style\n\nCross-platform toolkits can be divided into two distinct visual approaches\u2014the\ndesire to match the look and feel of the system at runtime versus the delivery\nof a distinct look that will be consistent across all the environments. The Qt\nand GTK+ toolkits began with their own visual style that added the ability to\nbe controlled by visual themes. Over time, they developed operating system-\nspecific themes that allowed them to match the design of other applications on\na system. In contrast, the Java AWT library was created as a code-level\nabstraction, meaning that programs would use operating system widgets to\nrender despite the application being written for no specific platform.\nInterestingly, in 1998, Sun (the creators of Java) introduced the Swing\ntoolkit, which offered a whole new look and feel that would be consistent\nacross all platforms. This replacement user interface library slowly gained\npopularity as AWT was phased out. In an interesting twist, Sun introduced\noperating system lookalike themes that a developer could choose to enable in\ntheir app (unlike in GTK+ and Qt, this was not a user preference).\n\n## Compiled versus interpreted\n\nThe other factor that commonly defines a toolkit is the choice of programming\nlanguage\u2014these can be split between those that are compiled into an\napplication binary versus those distributed as source code that is interpreted\nat runtime. This distinction commonly correlates with statically typed\nlanguages compared to dynamically typed languages, which impacts programming\nstyles and the design of associated APIs. In a compiled language that uses\nstatic typing, all variables are defined and checked at compile time. Their\ntypes (that is, the sort of content they contain or refer to) are set in the\ndefinition and never change. This approach typically catches programming\nerrors early and can lead to robust code, but can be criticized as leading to\nslower application development. A compiled application will usually work\ndirectly on the computer it is built for, meaning that it does not require the\ninstallation of supporting technologies alongside the application. To achieve\nthis, however, the apps will typically need to be compiled for each supported\nplatform\u2014again leading to longer development times required, this time for\ndistribution tasks.\n\nIn comparison, an interpreted language is typically held up as supporting\nfaster development and quicker delivery. By allowing variables to be used for\ndifferent types of content, the source code of an application can be shorter\nwith fewer complications during the programming phase. Conversely, the reduced\nrigor means that it is usually required to have a more solid test\ninfrastructure (through unit tests or automated user interface testing) that\ncan ensure the correctness of the software. Distributing apps in this way will\nrequire a runtime environment to be installed so that the code can be executed\n(like the embedded web browser we saw when discussing hybrid apps). For some\noperating systems, there may be interpreters installed already, and for\nothers, they may have to be installed by the user. Interestingly, there are\nsome compilers available for interpreted languages that allow them to be\ndistributed like any other binary application, though with the preceding\ntrade-off that applications must be built for each target platform\nindividually.\n\n## Interpreted options\n\nDue to the popularity of building GUIs, each of the main interpreted languages\nhas its preferred toolkit. The Java runtime includes its own graphics\nroutines, which means it can include a bespoke user interface, namely Swing.\nMore recently, the JavaFX library has been built on top of the same graphical\ncode. As mentioned earlier, Java also includes the AWT library, which\ndelegates to system components.\n\nOther popular programming language runtimes do not ship with the same\ngraphical components and so they typically rely on an underlying library.\nTkInter is the standard GUI library for Python, based on the Tk library, while\nthe Ruby language does not recommend a standard library. Language bindings,\nwhich allow programmers to create applications using an interpreted language\nwhile using an underlying existing widget toolkit, such as Tk, GTK+, or Qt,\nare very popular. Using this method, there are too many options available to\nlist, but they usually have the same drawback of not being designed for the\nlanguage and so can be less intuitive to program than options built\nspecifically for the language being used.\n\n## Compiled options (C-based)\n\nAs shown earlier in this chapter, GUI development has a long history and the\nmost popular toolkits were initially designed many years ago. GTK+ and Qt are\nboth exceptionally popular, but they were designed for the C and C++\nlanguages, respectively. While this does not stop them from being effective\nchoices, it can make them seem a little outdated to the modern programmer.\nPossibly due in part to this reason, these GUI frameworks have seen language\nbindings made available for almost every programming language that exists.\nHowever, this does mean that you need to know a little about how the\nunderlying system works to be most effective in development. For example,\nmemory management in a C library is a complex and manual task, and not one\nthat most developers want to worry about. Additionally, a C++-based library\nwill have a different threading model beneath the surface that may not\ninteract well with the higher-level language methodologies.\n\nAn additional consideration for toolkits that were designed decades ago is\nthat they may not be best suited for the modern landscape of graphical\ncomputing devices. Screens, whether on a desktop, laptop, or mobile device,\nnow come in a wide variety of sizes and pixel densities. This can bring\nchallenges if code was built assuming that a pixel is a certain size, as used\nto be true. 96 dots per inch (DPI) was a common assumption, meaning that\nsomething 96 pixels high would measure about an inch when displayed. However,\nbased on current devices, it could be anywhere from an inch down to 3/16ths of\nan inch (only 20% of the intended size), so it is important to understand how\nthis will impact your application design. Older toolkits are typically based\non pixel measurements, where the display is simplified to be a certain number\nof pixels (1, 2, 3, or 4) to represent each source pixel's size (which would\nbe 1, 4, 9, or 16 pixels to display a square). Using a toolkit that scales in\nthis manner can result in pixelated output if the application does not adapt\ncarefully to the device.\n\n## Compiled options (other languages)\n\nIn part due to the legacy of the older C/C++-based GUI toolkits, but also in\npart because new programming languages bring benefits over the old ones, most\nof the newer compiled languages also have a toolkit built alongside. These\nmore modern toolkits typically handle today's variety of devices much more\neffectively due to their more recent design. The challenges with pixel- or\nbitmap-based design is being overcome by moving to a vector image-based\ndesign. Vector images can be displayed at a higher quality output on screens\nof any pixel density. They do this by defining image elements such as lines,\nrectangles, and curves independently of output pixels; they are only drawn\nafter the number of pixels available has been determined, resulting in higher\nquality on most output devices.\n\nAs we saw earlier, an operating system manufacturer often dictates the\nprogramming language used, and can push for new versions or programming\nlanguages when required. We can see this with Apple's recent move to Swift for\nthe latest version of their UIKit and AppKit frameworks (this language is\nintended primarily for Apple devices but the trend is still noteworthy).\nMicrosoft's development platform is currently geared toward C#, having\npreviously used C, C++, and Visual Basic. Google is putting its energy into\nthe Dart programming language and the Flutter toolkit built on top.\n\nOther languages, such as Go, do not have an official GUI toolkit or widget\nlibrary. In these situations, we can see various projects emerge with\ndifferent ways of addressing the gap. In Go, the most active projects are\nandlabs UI, Fyne, and Gio. The andlabs project aims to use the current system\nstyle\u2014in fact, it wraps the code to display them with a simple Go API\u2014much\nlike Java AWT discussed earlier. Gio is an immediate-mode GUI toolkit that\naims to provide as much control as possible to the application developer,\nrequiring the app to manage the rendering and event processing. The Fyne\nproject aims for an API that is simple to learn and extend, without needing to\nworry about the rendering process\u2014this is commonly known as retained mode as\nthe widget state is managed by the library.\n\n# Summary\n\nIn this chapter, we explored the history of graphical applications and the\ntoolkits that power them. We saw that over the last half-century, many things\nhave changed, and yet a lot of aspects have stayed the same. Through an\nillustration of trends in graphical design and technical capability, it became\nclear that these technologies, while adapting and improving in the eyes of the\nend user, can be slow to embrace the speed of improvement that developers\nexpect. We saw that there are many different approaches to supporting the\ncreation of GUIs that work across multiple platforms, but also that they can\nhave drawbacks as well.\n\nIn the next chapter, we will learn more about the Fyne toolkit's vision and\ndesign, and why the project team believes this provides the easiest way to\nbuild robust and performant graphical apps for any platform.\n\nRead more Unlock this book with a 7 day free trial.\n\nAbout the Author\n\n  * Andrew Williams\n\nAndrew Williams graduated from the University of Edinburgh in 2003 with a\nbachelor's degree, with honors, in computer science. After university, he went\nto work as a software engineer and has gained over 15 years of commercial\nsoftware development experience across a variety of programming languages,\nincluding Java, C, Objective-C, and Go. Andrew has spent many years working as\na CTO with many early-stage and growing software start-ups. He has been a core\ndeveloper in large open source projects, including Enlightenment, EFL, and\nMaven, as well as involved in maintaining various community websites and\ntutorials. Andrew's passion for building tools and services that make software\ndevelopment simpler led him to start authoring books on the subject.\n\nBrowse publications by this author\n\nLatest Reviews (1 reviews total)\n\nI seldom post reviews for products that I've brought, but I've given 5 stars\nfor this book and, by extension, for Fyne itself. The book is concise and well\nwritten, as is the example code and the explanations. Fyne code is\nrefreshingly easy to read and write, something I've not not experienced in a\nGUI framework since my Visual Basic days.\n\n5\n\n28 November 2023 Stuart Rackham\n\nRecommended For You\n\nFlutter Cookbook\n\nDiscover how to build, scale, and debug native iOS and Android applications\nfrom a single codebase using the Dart programming language\n\nBy Simone Alessandria and 1 more\n\nJun 2021 646 pages\n\nC# 9 and .NET 5 \u2013 Modern Cross-Platform Development - Fifth Edition\n\nA comprehensive guide for beginners to learn the key concepts, real-world\napplications, and latest features of C# 9 and .NET 5 with hands-on exercises\nusing VS Code\n\nBy Mark J. Price\n\nNov 2020 822 pages\n\nResponsive Web Design with HTML5 and CSS - Third Edition\n\nHarness the latest capabilities of HTML5 and CSS to create a single UI that\nworks flawlessly on mobile phones, tablets, and desktops \u2014 plus everything in-\nbetween\n\nBy Ben Frain\n\nApr 2020 408 pages\n\nWeb Development with Django\n\nLearn how to create your own websites simply, safely, and quickly with Django\nby tackling practical activities based on realistic case studies\n\nBy Ben Shaw and 4 more\n\nFeb 2021 826 pages\n\nUnlock this book and the full library FREE for 7 days Expires: 81h 18m 31s\n\nGet all the quality content you\u2019ll ever need to stay ahead with a Packt\nsubscription \u2013 access over 7,500 online books and videos on everything in\ntech.\n\nStart now\n\nUseful Links\n\n  * About us\n  * Our Authors\n  * Careers\n  * Privacy Policy\n  * View our Cookie Policy\n\nHelp & Support\n\n  * Frequently Asked Questions\n  * Code Download & Errata\n  * Submit Errata\n  * Contact Us\n\nSocial\n\nSign up to our emails for regular updates, bespoke offers, exclusive discounts\nand great free content.\n\nSocial\n\nThe word 'Packt' and the Packt logo are registered trademarks belonging to\nPackt Publishing Limited. All rights reserved\n\n", "frontpage": false}
