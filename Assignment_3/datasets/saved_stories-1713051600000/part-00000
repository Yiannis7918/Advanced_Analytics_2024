{"aid": "40024651", "title": "Introducing rcompat", "url": "https://primatejs.com/blog/introducing-rcompat", "domain": "primatejs.com", "votes": 2, "user": "sarumake", "posted_at": "2024-04-13 17:38:42", "comments": 0, "source_title": "Primate - Introducing rcompat", "source_text": "Primate - Introducing rcompat\n\n  * Guide\n  * Modules\n  * Blog\n\n# Introducing rcompat\n\n13 Apr 2024 by terrablue\n\nToday we're officially introducing rcompat, a JavaScript interoperability and\nruntime compatibility layer for servers which has been doing most of the heavy\nlifting behind Primate and its multi-runtime support for a while now.\n\nrcompat is a unified interface for Node, Deno and Bun. You can think of\nrcompat as a server-side counterpart to jQuery.\n\n## Native speed gains\n\nWhile tools like Bun strive to be fully compatible with Node's built-in\nmodules and NPM, with Deno also moving in that direction, those backwards\ncompatibilities carry a lot of cruft and in the end, you're just using another\nruntime to run code written for Node, without taking advantage of the inherent\nspeed gains that modern APIs introduce. rcompat abstracts that away for you.\nYou write code once and, wherever possible, it will take advantage of native\nAPIs. This allows you not only to run the same code with different runtimes,\nbut also speed it up if you choose Bun or Deno over Node during production.\nYou can easily switch between the runtimes, testing stability vs. modern\nfeatures, finding the best runtime for a given app.\n\n## Forward compatibility\n\nrcompat offers forward compatibility in the sense that it can add support for\nnew runtimes as they emerge even on minor updates (as this isn't considered\nbreaking existing code), allowing you to run old code that was written with\nrcompat by newer runtimes. No other server-side interoperability layer for\nJavaScript offers this kind of flexibility.\n\n## Batteries included\n\nrcompat is designed with many submodules in mind, including rcompat/fs for\nfilesystem operations, rcompat/http for using a modern HTTP server working\nwith WHATWG Request/Response (which Node doesn't support; rcompat wraps a Node\nrequest object into a WHATWG Request as it comes in), rcompat/invariant for\nensuring runtime invariants, rcompat/object for object transformations, and\nmany more useful modules and abstractions.\n\nThe standard library is designed to accommodate modern development needs: for\nexample, rcompat/http supports WebSockets (natively on Deno/Bun, and using\nNPM's ws on Node), while rcompat/fs.File offers globbing, listing and\nmanipulation of files, similarly to Python's pathlib.\n\nFor example, to set up a server with rcompat, use the serve export of\nrcompat/http -- the server-side equivalent of fetch.\n\n    \n    \n    import { serve } from \"rcompat/http\"; serve(request => new Response(\"Hi!\"), { host: \"localhost\", port: 6161 });\n\nThis code runs successfully with either node app.js (if you set your\npackage.json to { \"type\": \"module\" }; otherwise use app.mjs), deno run\n--allow-all app.js or bun --bun app.js, taking advantage of native\noptimizations.\n\n## Another standard library?\n\nThe JavaScript ecosystem is replete with standard libraries. To take the\nexample of filesystem access, Node has at least three ways of accessing the\nfilesystem (sync, callbacks, promises), and then there's Deno's own filesystem\nAPIs, while Bun has its APIs too. Those all have their pros and cons, and if\nyou want to target all of them, you're going to have to write a lot of\nbranching code. rcompat is an abstraction over that, as it plays the role of\nboth a standard library and a runtime compatibility layer -- write once,\ntarget everything.\n\nFor example, here's how you can read a file and parse it as JSON.\n\n    \n    \n    import FS from \"rcompat/fs\"; // or import individually, shadowing globalThis.File, WHATWG's File class // import { File } from \"rcompat/fs\"; console.log(await FS.File.json(\"./users.json\"));\n\nAgain, this code runs successfully on Node, Deno or Bun, taking advantage of\noptimizations native to every runtime.\n\n## Evolving standard \u2014 input needed\n\nrcompat has been quietly developed the last few months in conjunction with\nPrimate's development and is largely influenced by its needs. We'd like to\ninvite more participation by other projects / individuals in order to converge\non APIs that best serve everyone and are the most useful on a broad basis.\n\nTo illustrate this, Primate 0.31 will be using rcompat/fs's upcoming Router\nclass, which is meant to be used by frameworks using filesystem-routing (such\nas Primate, Next, SvelteKit, etc.) to resolve requests to routes. The design\nis aimed to be generic, but undoubtedly will be influenced by Primate's needs.\nExternal feedback will help keep it useful for other frameworks as well. Once\nFS.Router is ready, we will also aim to upstream our ideas to Bun's native\nFileSystemRouter class such that rcompat can delegate to it natively on Bun.\n\n## Participation\n\nYou are cordially invited to take part in rcompat's development at\nhttps://github.com/rcompat/rcompat. We will be setting up a documentation\nwebsite in the foreseeable future, and until then, the source code is the best\nform of documentation.\n\nrcompat is MIT licensed.\n\n## Fin\n\nIf you like Primate, consider joining our channel #primate on irc.libera.chat.\nThis channel is currently also used for rcompat's development, until the need\nfor a separate channel arises.\n\n#### On this page\n\n  * Native speed gains\n  * Forward compatibility\n  * Batteries included\n  * Another standard library?\n  * Evolving standard \u2014 input needed\n  * Participation\n  * Fin\n\n", "frontpage": false}
