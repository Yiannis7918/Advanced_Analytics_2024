{"aid": "40024653", "title": "Finding and Fixing Standard Misconceptions About Program Behavior", "url": "https://blog.brownplt.org/2024/04/12/behavior-misconceptions.html", "domain": "brownplt.org", "votes": 1, "user": "MaysonL", "posted_at": "2024-04-13 17:39:11", "comments": 0, "source_title": "Finding and Fixing Standard Misconceptions About Program Behavior", "source_text": "Finding and Fixing Standard Misconceptions About Program Behavior\n\n# The Brown PLT Blog\n\nRSS\n\nCONTACT\n\nGROUP PAGE\n\nPREVIOUS POSTS\n\n  * Finding and Fixing Standard Misconceptions About Program Behavior\n  * Privacy-Respecting Type Error Telemetry at Scale\n  * Profiling Programming Language Learning\n  * The Examplar Project: A Summary\n  * A Core Calculus for Documents\n  * Observations on the Design of Program Planning Notations for Students\n  * Conceptual Mutation Testing\n  * Generating Programs Trivially: Student Use of Large Language Models\n  * A Grounded Conceptual Model for Ownership Types in Rust\n  * What Happens When Students Switch (Functional) Languages\n  * Typed-Untyped Interactions: A Comparative Analysis\n  * Little Tricky Logics\n  * Identifying Problem Misconceptions\n  * Performance Preconceptions\n  * Structural Versus Pipeline Composition of Higher-Order Functions\n  * Plan Composition Using Higher-Order Functions\n  * Towards a Notional Machine for Runtime Stacks and Scope\n  * Gradual Soundness: Lessons from Static Python\n  * Applying Cognitive Principles to Model-Finding Output\n  * Automated, Targeted Testing of Property-Based Testing Predicates\n  * A Benchmark for Tabular Types\n  * Student Help-Seeking for (Un)Specified Behaviors\n  * Adding Function Transformers to CODAP\n  * Developing Behavioral Concepts of Higher-Order Functions\n  * Adversarial Thinking Early in Post-Secondary Education\n  * Teaching and Assessing Property-Based Testing\n  * Students Testing Without Coercion\n  * Using Design Alternatives to Learn About Data Organizations\n  * What Help Do Students Seek in TA Office Hours?\n  * Combating Misconceptions by Encouraging Example-Writing\n  * The Hidden Perils of Automated Assessment\n  * Mystery Languages\n  * Resugaring Type Rules\n  * Picking Colors for Pyret Error Messages\n  * Can We Crowdsource Language Design?\n  * Crowdsourcing User Studies for Formal Methods\n  * User Studies of Principled Model Finder Output\n  * A Third Perspective on Hygiene\n  * Scope Inference, a.k.a. Resugaring Scope Rules\n  * The PerMission Store\n  * Examining the Privacy Decisions Facing Users\n  * The Pyret Programming Language: Why Pyret?\n  * Resugaring Evaluation Sequences\n  * Slimming Languages by Reducing Sugar\n  * In-flow Peer Review: An Overview\n  * Tierless Programming for SDNs: Differential Analysis\n  * Tierless Programming for SDNs: Verification\n  * Tierless Programming for SDNs: Optimality\n  * Tierless Programming for SDNs: Events\n  * Tierless Programming for Software-Defined Networks\n  * CS Student Work/Sleep Habits Revealed As Possibly Dangerously Normal\n  * Parley: User Studies for Syntax Design\n  * Typechecking Uses of the jQuery Language\n  * Verifying Extensions\u2019 Compliance with Firefox's Private Browsing Mode\n  * From MOOC Students to Researchers\n  * Social Ratings of Application Permissions (Part 4: The Goal)\n  * Social Ratings of Application Permissions (Part 3: Permissions Within a Domain)\n  * Social Ratings of Application Permissions (Part 2: The Effect of Branding)\n  * Social Ratings of Application Permissions (Part 1: Some Basic Conditions)\n  * Aluminum: Principled Scenario Exploration Through Minimality\n  * A Privacy-Affecting Change in Firefox 20\n  * The New MOOR's Law\n  * Essentials of Garbage Collection\n  * (Sub)Typing First Class Field Names\n  * Typing First Class Field Names\n  * S5: Engineering Eval\n  * Progressive Types\n  * Modeling DOM Events\n  * Mechanized LambdaJS\n  * ECMA Announces Official \u03bbJS Adoption\n  * Objects in Scripting Languages\n  * S5: Wat?\n  * Belay Lessons: Smarter Web Programming\n  * S5: Semantics for Accessors\n  * S5: A Semantics for Today's JavaScript\n  * The Essence of JavaScript\n  * ADsafety\n\n## Finding and Fixing Standard Misconceptions About Program Behavior\n\nPosted on 12 April 2024.\n\nA large number of modern languages \u2014 from Java and C# to Python and JavaScript\nto Racket and OCaml \u2014 share a common semantic core:\n\n  * variables are lexically scoped\n  * scope can be nested\n  * evaluation is eager\n  * evaluation is sequential (per \u201cthread\u201d)\n  * variables are mutable, but first-order\n  * structures (e.g., vectors/arrays and objects) are mutable, and first-class\n  * functions can be higher-order, and close over lexical bindings\n  * memory is managed automatically (e.g., garbage collection)\n\nWe call this the Standard Model of Languages (SMoL).\n\nSMoL potentially has huge pedagogic benefit:\n\n  * If students master SMoL, they have a good handle on the core of several of these languages.\n\n  * Students may find it easier to port their knowledge between languages: instead of being lost in a sea of different syntax, they can find familiar signposts in the common semantic features. This may also make it easier to learn new languages.\n\n  * The differences between the languages are thrown into sharper contrast.\n\n  * Students can see that, by going beyond syntax, there are several big semantic ideas that underlie all these languages, many of which we consider \u201cbest practices\u201d in programming language design.\n\nWe have therefore spent the past four years working on the pedagogy of SMoL:\n\n  * Finding errors in the understanding of SMoL program behavior.\n\n  * Finding the (mis)conceptions behind these errors.\n\n  * Collating these into clean instruments that are easy to deploy.\n\n  * Building a tutor to help students correct these misconceptions.\n\n  * Validating all of the above.\n\nWe are now ready to present a checkpoint of this effort. We have distilled the\nessence of this work into a tool:\n\nThe SMoL Tutor\n\nIt identifies and tries to fix student misconceptions. The Tutor assumes users\nhave a baseline of programming knowledge typically found after 1\u20132 courses:\nvariables, assignments, structured values (like vectors/arrays), functions,\nand higher-order functions (lambdas). Unlike most tutors, instead of teaching\nthese concepts, it investigates how well the user actually understands them.\nWherever the user makes a mistake, the tutor uses an educational device called\na refutation text to help them understand where they went wrong and to correct\ntheir conception. The Tutor lets the user switch between multiple syntaxes,\nboth so they can work with whichever they find most comfortable (so that\nsyntactic unfamiliarity or discomfort does not itself become a source of\nerrors), and so they can see the semantic unity beneath these languages.\n\nAlong the way, to better classify student responses, we invent a concept\ncalled the misinterpreter. A misinterpreter is an intentionally incorrect\ninterpreter. Concretely, for each misconception, we create a corresponding\nmisinterpreter: one that has the same semantics as SMoL except on that one\nfeature, where it implements the misconception instead of the correct concept.\nBy making misconceptions executable, we can mechanically check whether student\nresponses correspond to a misconception.\n\nThere are many interesting lessons here:\n\n  * Many of the problematic programs are likely to be startlingly simple to experts.\n\n  * The combination of state, aliasing, and functions is complicated for students. (Yet most introductory courses plunge students into this maelstrom of topics without a second thought or care.)\n\n  * Misinterpreters are an interesting concept in their own right, and are likely to have value independent of the above use.\n\nIn addition, we have not directly studied the following claims but believe\nthey are well warranted based on observations from this work and from\nexperience teaching and discussing programming languages:\n\n  * In SMoL languages, local and top-level bindings behave the same as the binding induced by a function call. However, students often do not realize that these have a uniform semantics. In part this may be caused by our focus on the \u201ccall by\u201d terminology, which focuses on calls (and makes them seem special). We believe it would be an improvement to replace these with \u201cbind by\u201d.\n\n  * We also believe that the terms \u201ccall-by-value\u201d and \u201ccall-by-reference\u201d are so hopelessly muddled at this point (between students, instructors, blogs, the Web...) that finding better terminology overall would be helpful.\n\n  * The way we informally talk about programming concepts (like \u201cpass a variable\u201d), and the syntactic choices our languages make (like return x), are almost certainly also sources of confusion. The former can naturally lead students to believe variables are being aliased, and the latter can lead them to believe the variable, rather than its value, is being returned.\n\nFor more details about the work, see the paper. The paper is based on an old\nversion of the Tutor, where all programs were presented in parenthetical\nsyntax. The Tutor now supports multiple syntaxes, so you don\u2019t have to worry\nabout being constrained by that. Indeed, it\u2019s being used right now in a course\nthat uses Scala 3.\n\nMost of all, the SMoL Tutor is free to use! We welcome and encourage\ninstructors of programming courses to consider using it \u2014 you may be surprised\nby the mistakes your students make on these seemingly very simple programs.\nBut we also welcome learners of all stripes to give it a try!\n\n", "frontpage": false}
