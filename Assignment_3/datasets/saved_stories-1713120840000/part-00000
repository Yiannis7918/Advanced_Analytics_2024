{"aid": "40030746", "title": "Redis Re-Implemented with SQLite", "url": "https://github.com/nalgeon/redka", "domain": "github.com/nalgeon", "votes": 9, "user": "tosh", "posted_at": "2024-04-14 12:51:51", "comments": 0, "source_title": "GitHub - nalgeon/redka: Redis re-implemented with SQLite", "source_text": "GitHub - nalgeon/redka: Redis re-implemented with SQLite\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nnalgeon / redka Public\n\n  * Notifications\n  * Fork 0\n  * Star 20\n\nRedis re-implemented with SQLite\n\n### License\n\nBSD-3-Clause license\n\n20 stars 0 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# nalgeon/redka\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n2 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nnalgeondoc: download links08e1d7c \u00b7\n\n## History\n\n69 Commits  \n  \n### .github/workflows\n\n|\n\n### .github/workflows\n\n| build: docker tags  \n  \n### cmd\n\n|\n\n### cmd\n\n| refactor: redka - database options  \n  \n### example\n\n|\n\n### example\n\n| refactor: redka - database options  \n  \n### internal\n\n|\n\n### internal\n\n| fix: db - not null in schema  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| initial commit  \n  \n### Dockerfile\n\n|\n\n### Dockerfile\n\n| build: cli in docker  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| initial commit  \n  \n### Makefile\n\n|\n\n### Makefile\n\n| build: cli in docker  \n  \n### README.md\n\n|\n\n### README.md\n\n| doc: download links  \n  \n### go.mod\n\n|\n\n### go.mod\n\n| initial commit  \n  \n### go.sum\n\n|\n\n### go.sum\n\n| initial commit  \n  \n### logo.svg\n\n|\n\n### logo.svg\n\n| doc: logo  \n  \n### redka.go\n\n|\n\n### redka.go\n\n| refactor: redka - database options  \n  \n### redka_test.go\n\n|\n\n### redka_test.go\n\n| refactor: redka - database options  \n  \n## Repository files navigation\n\nRedka aims to reimplement the good parts of Redis with SQLite, while remaining\ncompatible with Redis API.\n\nNotable features:\n\n  * Data does not have to fit in RAM.\n  * ACID transactions.\n  * SQL views for better introspection and reporting.\n  * Both in-process (Go API) and standalone (RESP) servers.\n  * Redis-compatible commands and wire protocol.\n\nThis is a work in progress. See below for the current status and roadmap.\n\nCommands \u2022 Installation \u2022 Usage \u2022 Persistence \u2022 Performance \u2022 Roadmap \u2022 More\n\n## Commands\n\nRedka aims to support five core Redis data types: strings, lists, sets,\nhashes, and sorted sets.\n\n### Strings\n\nStrings are the most basic Redis type, representing a sequence of bytes. Redka\nsupports the following string-related commands:\n\nCommand| Go API| Description  \n---|---|---  \nDECR| DB.Str().Incr| Decrements the integer value of a key by one.  \nDECRBY| DB.Str().Incr| Decrements a number from the integer value of a key.  \nGET| DB.Str().Get| Returns the value of a key.  \nGETSET| DB.Str().GetSet| Sets the key to a new value and returns the prev\nvalue.  \nINCR| DB.Str().Incr| Increments the integer value of a key by one.  \nINCRBY| DB.Str().Incr| Increments the integer value of a key by a number.  \nINCRBYFLOAT| DB.Str().IncrFloat| Increments the float value of a key by a\nnumber.  \nMGET| DB.Str().GetMany| Returns the values of one or more keys.  \nMSET| DB.Str().SetMany| Sets the values of one or more keys.  \nMSETNX| DB.Str().SetManyNX| Sets the values of one or more keys when all keys\ndon't exist.  \nPSETEX| DB.Str().SetExpires| Sets the value and expiration time (in ms) of a\nkey.  \nSET| DB.Str().Set| Sets the value of a key.  \nSETEX| DB.Str().SetExpires| Sets the value and expiration (in sec) time of a\nkey.  \nSETNX| DB.Str().SetNotExists| Sets the value of a key when the key doesn't\nexist.  \n  \nThe following string-related commands are not planned for 1.0:\n\n    \n    \n    APPEND GETDEL GETEX GETRANGE LCS SETRANGE STRLEN SUBSTR\n\n### Lists\n\nLists are lists of strings sorted by insertion order. Redka aims to support\nthe following list-related commands in 1.0:\n\n    \n    \n    LINDEX LINSERT LLEN LPOP LPUSHX LRANGE LREM LSET LTRIM RPOP RPOPLPUSH RPUSH RPUSHX\n\n### Sets\n\nSets are unordered collections of unique strings. Redka aims to support the\nfollowing set-related commands in 1.0:\n\n    \n    \n    SADD SCARD SDIFF SDIFFSTORE SINTER SINTERSTORE SISMEMBER SMEMBERS SMOVE SPOP SRANDMEMBER SREM SUNION SUNIONSTORE\n\n### Hashes\n\nHashes are field-value (hash)maps. Redka supports the following hash-related\ncommands:\n\nCommand| Go API| Description  \n---|---|---  \nHDEL| DB.Hash().Delete| Deletes one or more fields and their values.  \nHEXISTS| DB.Hash().Exists| Determines whether a field exists.  \nHGET| DB.Hash().Get| Returns the value of a field.  \nHGETALL| DB.Hash().Items| Returns all fields and values.  \nHINCRBY| DB.Hash().Incr| Increments the integer value of a field.  \nHINCRBYFLOAT| DB.Hash().IncrFloat| Increments the float value of a field.  \nHKEYS| DB.Hash().Keys| Returns all fields.  \nHLEN| DB.Hash().Len| Returns the number of fields.  \nHMGET| DB.Hash().GetMany| Returns the values of multiple fields.  \nHMSET| DB.Hash().SetMany| Sets the values of multiple fields.  \nHSCAN| DB.Hash().Scanner| Iterates over fields and values.  \nHSET| DB.Hash().SetMany| Sets the values of one ore more fields.  \nHSETNX| DB.Hash().SetNotExists| Sets the value of a field when it doesn't\nexist.  \nHVALS| DB.Hash().Exists| Returns all values.  \n  \nThe following hash-related commands are not planned for 1.0:\n\n    \n    \n    HRANDFIELD HSTRLEN\n\n### Sorted sets\n\nSorted sets are collections of unique strings ordered by each string's\nassociated score. Redka aims to support the following sorted set related\ncommands in 1.0:\n\n    \n    \n    ZADD ZCARD ZCOUNT ZINCRBY ZINTERSTORE ZRANGE ZRANK ZREM ZSCORE\n\n### Key management\n\nRedka supports the following key management (generic) commands:\n\nCommand| Go API| Description  \n---|---|---  \nDEL| DB.Key().Delete| Deletes one or more keys.  \nEXISTS| DB.Key().Count| Determines whether one or more keys exist.  \nEXPIRE| DB.Key().Expire| Sets the expiration time of a key (in seconds).  \nEXPIREAT| DB.Key().ExpireAt| Sets the expiration time of a key to a Unix\ntimestamp.  \nKEYS| DB.Key().Keys| Returns all key names that match a pattern.  \nPERSIST| DB.Key().Persist| Removes the expiration time of a key.  \nPEXPIRE| DB.Key().Expire| Sets the expiration time of a key in ms.  \nPEXPIREAT| DB.Key().ExpireAt| Sets the expiration time of a key to a Unix ms\ntimestamp.  \nRANDOMKEY| DB.Key().Random| Returns a random key name from the database.  \nRENAME| DB.Key().Rename| Renames a key and overwrites the destination.  \nRENAMENX| DB.Key().RenameNotExists| Renames a key only when the target key\nname doesn't exist.  \nSCAN| DB.Key().Scanner| Iterates over the key names in the database.  \n  \nThe following generic commands are not planned for 1.0:\n\n    \n    \n    COPY DUMP EXPIRETIME MIGRATE MOVE OBJECT PEXPIRETIME PTTL RESTORE SORT SORT_RO TOUCH TTL TYPE UNLINK WAIT WAITAOF\n\n### Transactions\n\nRedka supports the following transaction commands:\n\nCommand| Go API| Description  \n---|---|---  \nDISCARD| DB.View / DB.Update| Discards a transaction.  \nEXEC| DB.View / DB.Update| Executes all commands in a transaction.  \nMULTI| DB.View / DB.Update| Starts a transaction.  \n  \nUnlike Redis, Redka's transactions are fully ACID, providing automatic\nrollback in case of failure.\n\nThe following transaction commands are not planned for 1.0:\n\n    \n    \n    UNWATCH WATCH\n\n### Server/connection management\n\nRedka supports only a couple of server and connection management commands:\n\nCommand| Go API| Description  \n---|---|---  \nECHO| \u2014| Returns the given string.  \nFLUSHDB| DB.Key().DeleteAll| Remove all keys from the database.  \n  \nThe rest of the server and connection management commands are not planned for\n1.0.\n\n## Installation\n\nRedka can be installed as a standalone Redis-compatible server, or as a Go\nmodule for in-process use.\n\n## Standalone server\n\nRedka server is a single-file binary. Download it from the releases.\n\nLinux (x86 CPU only):\n\n    \n    \n    curl -L -O \"https://github.com/nalgeon/redka/releases/download/v0.2.0/redka_linux_amd64.zip\" unzip redka_linux_amd64.zip chmod +x redka\n\nmacOS (both x86 and ARM/Apple Silicon CPU):\n\n    \n    \n    curl -L -O \"https://github.com/nalgeon/redka/releases/download/v0.2.0/redka_darwin_amd64.zip\" unzip redka_darwin_amd64.zip # remove the build from quarantine # (macOS disables unsigned binaries) xattr -d com.apple.quarantine redka chmod +x redka\n\nOr pull with Docker as follows (x86/ARM):\n\n    \n    \n    docker pull nalgeon/redka\n\nOr build from source (requires Go 1.22 and GCC):\n\n    \n    \n    git clone https://github.com/nalgeon/redka.git cd redka make setup build # the path to the binary after the build # will be ./build/redka\n\n## Go module\n\nInstall the module as follows:\n\n    \n    \n    go get github.com/nalgeon/redka\n\nYou'll also need an SQLite driver. Use github.com/mattn/go-sqlite3 if you\ndon't mind CGO. Otherwise use a pure Go driver modernc.org/sqlite. Install\neither with go get like this:\n\n    \n    \n    go get github.com/mattn/go-sqlite3\n\n## Usage\n\nRedka can be used as a standalone Redis-compatible server, or as an embeddable\nin-process server with Go API.\n\n### Standalone server\n\nRedka server is a single-file binary. After downloading and unpacking the\nrelease asset, run it as follows:\n\n    \n    \n    redka [-h host] [-p port] [db-path]\n\nFor example:\n\n    \n    \n    ./redka ./redka data.db ./redka -h 0.0.0.0 -p 6379 data.db\n\nServer defaults are host localhost, port 6379 and empty DB path.\n\nRunning without a DB path creates an in-memory database. The data is not\npersisted in this case, and will be gone when the server is stopped.\n\nYou can also run Redka with Docker as follows:\n\n    \n    \n    # database inside the container # will be lost when the container stops docker run --rm -p 6379:6379 nalgeon/redka # persistent database # using the /path/to/data host directory docker run --rm -p 6379:6379 -v /path/to/data:/data nalgeon/redka # in-memory database, custom post docker run --rm -p 6380:6380 nalgeon/redka redka -h 0.0.0.0 -p 6380\n\nServer defaults in Docker are host 0.0.0.0, port 6379 and DB path\n/data/redka.db.\n\nOnce the server is running, connect to it using redis-cli or an API client\nlike redis-py or go-redis \u2014 just as you would with Redis.\n\n    \n    \n    redis-cli -h localhost -p 6379\n    \n    \n    127.0.0.1:6379> echo hello \"hello\" 127.0.0.1:6379> set name alice OK 127.0.0.1:6379> get name \"alice\"\n\n### In-process server\n\nThe primary object in Redka is the DB. To open or create your database, use\nthe redka.Open() function:\n\n    \n    \n    package main import ( \"log\" _ \"github.com/mattn/go-sqlite3\" \"github.com/nalgeon/redka\" ) func main() { // Open or create the data.db file. db, err := redka.Open(\"data.db\", nil) if err != nil { log.Fatal(err) } // Always close the database when you are finished. defer db.Close() // ... }\n\nDon't forget to import the driver (here I use github.com/mattn/go-sqlite3).\nUsing modernc.org/sqlite is slightly different, see example/modernc/main.go\nfor details.\n\nTo open an in-memory database that doesn't persist to disk, use the following\npath:\n\n    \n    \n    // All data is lost when the database is closed. redka.Open(\"file:redka?mode=memory&cache=shared\")\n\nAfter opening the database, call redka.DB methods to run individual commands:\n\n    \n    \n    db.Str().Set(\"name\", \"alice\") db.Str().Set(\"age\", 25) count, err := db.Key().Count(\"name\", \"age\", \"city\") slog.Info(\"count\", \"count\", count, \"err\", err) name, err := db.Str().Get(\"name\") slog.Info(\"get\", \"name\", name, \"err\", err)\n    \n    \n    count count=2 err=<nil> get name=\"alice\" err=<nil>\n\nSee the full example in example/simple/main.go.\n\nUse transactions to batch commands. There are View (read-only transaction) and\nUpdate (writable transaction) methods for this:\n\n    \n    \n    updCount := 0 err := db.Update(func(tx *redka.Tx) error { err := tx.Str().Set(\"name\", \"bob\") if err != nil { return err } updCount++ err = tx.Str().Set(\"age\", 50) if err != nil { return err } updCount++ return nil }) slog.Info(\"updated\", \"count\", updCount, \"err\", err)\n    \n    \n    updated count=2 err=<nil>\n\nSee the full example in example/tx/main.go.\n\nSee the package documentation for API reference.\n\n## Persistence\n\nRedka stores data in a SQLite database using the following tables:\n\n    \n    \n    rkey --- id integer primary key key text not null type integer not null -- 1 string, 2 list, 3 set, 4 hash, 5 sorted set version integer not null -- incremented when the key value is updated etime integer -- expiration timestamp in unix milliseconds mtime integer not null -- modification timestamp in unix milliseconds rstring --- key_id integer not null -- FK -> rkey.id value blob not null rhash --- key_id integer not null -- FK -> rkey.id field text not null value blob not null\n\nTo access the data with SQL, use views instead of tables:\n\n    \n    \n    select * from vstring;\n    \n    \n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 key_id \u2502 key \u2502 value \u2502 etime \u2502 mtime \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 1 \u2502 name \u2502 alice \u2502 \u2502 2024-04-03 16:58:14 \u2502 \u2502 2 \u2502 age \u2502 50 \u2502 \u2502 2024-04-03 16:34:52 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\netime and mtime are in UTC.\n\nThere is a separate view for every data type:\n\n    \n    \n    vstring vhash\n\n## Performance\n\nI've compared Redka with Redis using redis-benchmark with the following\nparameters:\n\n  * 10 parallel connections\n  * 1000000 requests\n  * 10000 randomized keys\n  * GET/SET commands\n\nSQLite settings:\n\n    \n    \n    pragma journal_mode = wal; pragma synchronous = normal; pragma temp_store = memory; pragma mmap_size = 268435456; pragma foreign_keys = on;\n\nHardware: Apple M1 8-core CPU, 16GB RAM\n\nResults:\n\n    \n    \n    redis-server --appendonly no redis-benchmark -p 6379 -q -c 10 -n 1000000 -r 10000 -t get,set SET: 133262.25 requests per second, p50=0.055 msec GET: 139217.59 requests per second, p50=0.055 msec\n    \n    \n    ./redka -p 6380 data.db redis-benchmark -p 6380 -q -c 10 -n 1000000 -r 10000 -t get,set SET: 22551.47 requests per second, p50=0.255 msec GET: 56802.05 requests per second, p50=0.119 msec\n\nSo while Redka is 2-6 times slower than Redis (not surprising, since we are\ncomparing a relational database to a key-value data store), it can still do\n23K writes/sec and 57K reads/sec, which is pretty good if you ask me.\n\nNote that running in a container may result in poorer performance.\n\n## Roadmap\n\nThe project is on its way to 1.0.\n\nThe 1.0 release will include the following features from Redis 2.x (which I\nconsider the \"golden age\" of the Redis API):\n\n  * \u2705 Strings.\n  * \u2b1c Lists.\n  * \u2b1c Sets.\n  * \u2705 Hashes.\n  * \u23f3 Sorted sets.\n  * \u2705 Key management.\n  * \u2705 Transactions.\n\n\u2705 = done, \u23f3 = in progress, \u2b1c = next in line\n\nFuture versions may include additional data types (such as streams,\nHyperLogLog or geo), features like publish/subscribe, and more commands for\nexisting types.\n\nFeatures I'd rather not implement even in future versions:\n\n  * Lua scripting.\n  * Authentication and ACLs.\n  * Multiple databases.\n  * Watch/unwatch.\n\nFeatures I definitely don't want to implement:\n\n  * Cluster.\n  * Sentinel.\n\n## More information\n\n### Contributing\n\nContributions are welcome. For anything other than bugfixes, please first open\nan issue to discuss what you want to change.\n\nBe sure to add or update tests as appropriate.\n\n### Acknowledgements\n\nRedka would not be possible without these great projects and their creators:\n\n  * Redis (Salvatore Sanfilippo). It's such an amazing idea to go beyond the get-set paradigm and provide a convenient API for more complex data structures.\n  * SQLite (D. Richard Hipp). The in-process database powering the world.\n  * Redcon (Josh Baker). A very clean and convenient implementation of a RESP server.\n\nLogo font by Ek Type.\n\n### License\n\nCopyright 2024 Anton Zhiyanov.\n\nThe software is available under the BSD-3-Clause license.\n\n### Stay tuned\n\n\u2605 Subscribe to stay on top of new features.\n\n## About\n\nRedis re-implemented with SQLite\n\n### Topics\n\nredis database key-value sqlite\n\n### Resources\n\nReadme\n\n### License\n\nBSD-3-Clause license\n\nActivity\n\n### Stars\n\n20 stars\n\n### Watchers\n\n2 watching\n\n### Forks\n\n0 forks\n\nReport repository\n\n## Releases 2\n\nv0.2.0 Latest\n\nApr 14, 2024\n\n\\+ 1 release\n\n## Languages\n\n  * Go 99.5%\n  * Other 0.5%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": true}
