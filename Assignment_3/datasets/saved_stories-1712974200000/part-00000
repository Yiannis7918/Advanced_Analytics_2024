{"aid": "40017116", "title": "Writing an OS in Rust", "url": "https://os.phil-opp.com/", "domain": "phil-opp.com", "votes": 1, "user": "Arteiii", "posted_at": "2024-04-12 20:09:19", "comments": 0, "source_title": "Writing an OS in Rust", "source_text": "Writing an OS in Rust\n\n## Writing an OS in Rust\n\nPhilipp Oppermann's blog\n\n# Writing an OS in Rust\n\nThis blog series creates a small operating system in the Rust programming\nlanguage. Each post is a small tutorial and includes all needed code, so you\ncan follow along if you like. The source code is also available in the\ncorresponding Github repository.\n\nLatest post: Async/Await\n\nBare Bones\n\n## A Freestanding Rust Binary\n\nThe first step in creating our own operating system kernel is to create a Rust\nexecutable that does not link the standard library. This makes it possible to\nrun Rust code on the bare metal without an underlying operating system.\n\nread more \u00bb\n\n## A Minimal Rust Kernel\n\nIn this post, we create a minimal 64-bit Rust kernel for the x86 architecture.\nWe build upon the freestanding Rust binary from the previous post to create a\nbootable disk image that prints something to the screen.\n\nread more \u00bb\n\n## VGA Text Mode\n\nThe VGA text mode is a simple way to print text to the screen. In this post,\nwe create an interface that makes its usage safe and simple by encapsulating\nall unsafety in a separate module. We also implement support for Rust\u2019s\nformatting macros.\n\nread more \u00bb\n\n## Testing\n\nThis post explores unit and integration testing in no_std executables. We will\nuse Rust\u2019s support for custom test frameworks to execute test functions inside\nour kernel. To report the results out of QEMU, we will use different features\nof QEMU and the bootimage tool.\n\nread more \u00bb\n\nInterrupts\n\n## CPU Exceptions\n\nCPU exceptions occur in various erroneous situations, for example, when\naccessing an invalid memory address or when dividing by zero. To react to\nthem, we have to set up an interrupt descriptor table that provides handler\nfunctions. At the end of this post, our kernel will be able to catch\nbreakpoint exceptions and resume normal execution afterward.\n\nread more \u00bb\n\n## Double Faults\n\nThis post explores the double fault exception in detail, which occurs when the\nCPU fails to invoke an exception handler. By handling this exception, we avoid\nfatal triple faults that cause a system reset. To prevent triple faults in all\ncases, we also set up an Interrupt Stack Table to catch double faults on a\nseparate kernel stack.\n\nread more \u00bb\n\n## Hardware Interrupts\n\nIn this post, we set up the programmable interrupt controller to correctly\nforward hardware interrupts to the CPU. To handle these interrupts, we add new\nentries to our interrupt descriptor table, just like we did for our exception\nhandlers. We will learn how to get periodic timer interrupts and how to get\ninput from the keyboard.\n\nread more \u00bb\n\nMemory Management\n\n## Introduction to Paging\n\nThis post introduces paging, a very common memory management scheme that we\nwill also use for our operating system. It explains why memory isolation is\nneeded, how segmentation works, what virtual memory is, and how paging solves\nmemory fragmentation issues. It also explores the layout of multilevel page\ntables on the x86_64 architecture.\n\nread more \u00bb\n\n## Paging Implementation\n\nThis post shows how to implement paging support in our kernel. It first\nexplores different techniques to make the physical page table frames\naccessible to the kernel and discusses their respective advantages and\ndrawbacks. It then implements an address translation function and a function\nto create a new mapping.\n\nread more \u00bb\n\n## Heap Allocation\n\nThis post adds support for heap allocation to our kernel. First, it gives an\nintroduction to dynamic memory and shows how the borrow checker prevents\ncommon allocation errors. It then implements the basic allocation interface of\nRust, creates a heap memory region, and sets up an allocator crate. At the end\nof this post, all the allocation and collection types of the built-in alloc\ncrate will be available to our kernel.\n\nread more \u00bb\n\n## Allocator Designs\n\nThis post explains how to implement heap allocators from scratch. It presents\nand discusses different allocator designs, including bump allocation, linked\nlist allocation, and fixed-size block allocation. For each of the three\ndesigns, we will create a basic implementation that can be used for our\nkernel.\n\nread more \u00bb\n\nMultitasking\n\n## Async/Await\n\nIn this post, we explore cooperative multitasking and the async/await feature\nof Rust. We take a detailed look at how async/await works in Rust, including\nthe design of the Future trait, the state machine transformation, and pinning.\nWe then add basic support for async/await to our kernel by creating an\nasynchronous keyboard task and a basic executor.\n\nread more \u00bb\n\n## Subscribe\n\nReceive notifications about new posts and other major changes! You can either:\n\n  * Subscribe to our RSS/Atom Feed,\n  * Subscribe to this GitHub issue, or\n  * Subscribe to our email newsletter.\n\n## Status Updates\n\nThese posts give a regular overview of the most important changes to the blog\nand the tools and libraries behind the scenes.\n\n  * This Month in Rust OSDev (March 2024)\n  * This Month in Rust OSDev (February 2024)\n  * This Month in Rust OSDev (January 2024)\n  * This Month in Rust OSDev (December 2023)\n  * This Month in Rust OSDev (November 2023)\n  * view all \u00bb\n\n## First Edition\n\nYou are currently viewing the second edition of \u201cWriting an OS in Rust\u201d. The\nfirst edition is very different in many aspects, for example it builds upon\nthe GRUB bootloader instead of using the `bootloader` crate. In case you're\ninterested in it, it is still available. Note that the first edition is no\nlonger updated and might contain outdated information. read the first edition\n\u00bb\n\n## Support Me\n\nCreating and maintaining this blog and the associated libraries is a lot of\nwork, but I really enjoy doing it. By supporting me, you allow me to invest\nmore time in new content, new features, and continuous maintenance. The best\nway to support me is to sponsor me on GitHub. Thank you!\n\n## Other Languages\n\n  * Chinese (simplified)\n  * Chinese (traditional)\n  * French\n  * Japanese\n  * Persian\n  * Russian\n  * Korean\n\n## Recent Updates\n\nNo notable updates recently.\n\n## Repository\n\nphil-opp/blog_os\n\nWriting an OS in Rust\n\n13.9k 999 Sponsor\n\n\u00a9 2022. All rights reserved. License Contact\n\n", "frontpage": false}
