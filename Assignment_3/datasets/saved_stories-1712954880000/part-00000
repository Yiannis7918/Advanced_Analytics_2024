{"aid": "40013522", "title": "React, Solid, Htmx", "url": "https://bobaekang.com/blog/react-solid-htmx/", "domain": "bobaekang.com", "votes": 9, "user": "bnewton", "posted_at": "2024-04-12 14:45:58", "comments": 0, "source_title": "React, Solid, htmx", "source_text": "React, Solid, htmx | bobae kang\n\n\u2190 Blog\n\nFeb 12, 2024\n\n# React, Solid, htmx\n\n#Reactjs #Solidjs #htmx #web\n\n## React: how far can components go?\n\nIt seems that not a single day passes without someone on Twitter wondering\nwhat RSC is really about. I have made my own attempt at cracking it (\u201cRSC is\nReact Server + Component\u201d), arguing that RSC is best understood in the context\nof the new React architecture, not in isolation. What we have here is not some\nnew magic kind of Components, but a server-client architecture that speaks\nReact on both ends and grants Components, if placed on the \u201cserver\u201d side,\ndirect access to new computing environments and their resources.\n\nAfter another month of closely following the RSC discourse, I still stand by\nit. And personally, I think React might be making mistakes by picking RSC as\nan umbrella term for everything this new architecture brings. Nonetheless, I\nappreciate the new React architecture as a unified model for UI development\nthat brings both ends under a single, coherent paradigm. A true \u201cone app\u201d\narchitecture. This is a significant departure from most JS-centric web\nframeworks, including those built on top of React, that provide various server\nside features (e.g. Next\u2019s getServerSideProps and API routes, Remix\u2019s loader\nand action, etc.) that are doubtless useful but fundamentally external to the\ncore UI application placed squarely on the client side.\n\nIn practice, the new React architecture isn\u2019t without pitfalls. Without\ncareful planning, React Components with access to server resources (i.e. RSCs)\nstill suffer from the same \u201cwaterfall\u201d issues even though they\u2019re now hidden\nfrom the network tab on the browser devtools. Unlocking this new architecture\nalso comes at the cost of increased bundle size and RSC support in tooling is\nstill at an early stage.\n\nThat said, I believe they are more growing pains than critical difficiencies\ninherent to the new architecture. If React can successfully address those pain\npoints via improved tooling and messaging, 2024 shall be the year when\neverything finally clicks for the mainstream audience. As I noted in an\nearlier blog post \u201cReact vs the world\u201d, React has a proud history of\nchallenging the contemporary norms and conventions of UI development,\nincluding the ones it helped to popularize, and winning over the world.\nDespite all the noise and confusion in the ongoing RSC discourse, React\nappears confident that it can repeat the history again. \u201cRelax, it\u2019s React.\u201d\n\n## Solid: how far can primitives go?\n\nIf anyone asked me, I\u2019d say Solid won the JS frontend in 2023. Not because it\novertook React in usage (not even close!), but because its idea won. Pretty\nmuch every framework but React implemented Signals in some form, and even\nReact adopted the language of reactivity to describe its optimizing compiler\nunder development (\u201cA better way to understand React Forget is as an automatic\nreactivity compiler\u201d). But this begs a question: what\u2019s next for Solid? Will\nthe success of fine-grained reactivity lead to the fall of Solid, which can no\nlonger stand out from the crowd?\n\nSolid\u2019s answer is no. In 2024, Solid will reach 2.0 with a renewed reactivity\nimplementation and Solid Start, the official Solid web framework, will reach\n1.0. As I follow the ongoing development, it\u2019s getting clearer to me that I,\nlike many others, have been missing the point of Solid. The point of Solid is\nnot Signals or fine-grained reactivity. That\u2019s more a happy accident. The real\npoint is about primitives over abstractions, explicit over implicit, and\nsimplicity over ease of use. And that\u2019s how Solid remains a stand-out in the\ncrowded JS framework space where others often seek to attract developers with\neasy-to-use abstractions that \u201cfeel magical.\u201d\n\nAnd Solid, too, is eyeing on solving the server side of the equation with a\nnew set of primitives albeit from a different angle. Instead of creating its\nown version of \u201cserver component,\u201d Solid is betting on streamlined support for\nserver function. Solid\u2019s server function looks similar to React\u2019s Server\nAction; they\u2019re both marked with the \"use server\" directive and with bundler\u2019s\nhelp, gets turned into RPC calls.^1 When combined with Solid\u2019s official router\nand its Data API (action, cache, createAsync, and more), Solid\u2019s server\nfunction can offer pretty much everything you want from data fetching/server\nstate management solutions: direct access to server resources via flexible RPC\ninterface with caching and route-level parallel fetching. The best of Relay,\nTanstack Query, tRPC and Remix all in a single package!\n\nAlso, recall that a Solid component is more like a \u201csetup\u201d function that runs\nonce to wire up the reactivity graph than a \u201crender\u201d function that continually\nre-runs to produce the latest UI. This means that the potential gain from\nmoving components to server is much smaller for Solid than for React. Plus,\nSolid already has a minimal bundle size and its hydration cost is relatively\ncheap. So it\u2019s understandable why Solid doesn\u2019t consider \u201cserver component\u201d to\nbe a critical piece of its take on the \u201cone app\u201d architecture.^2^3\n\nNotably, Solid\u2019s approach does not require any radical shift in mental model.\nIt still feels very much client centric, but with additional primitives that\ncan be combined to bring server closer. It\u2019s modular, incremental, familiar,\nand practical\u2014potentially a winning combination.\n\n## htmx: How far can hypermedia go?\n\n2023 saw an unexpected entrant to the JS framework war. htmx, a simple library\nconsisting only of a single JS file, came to the scene seemingly out of\nnowhere and took the web developer community by storm. Adding 15.6K new GitHub\nstarts, htmx earned the second place in 2023 JavaScript Rising Stars for the\n\u201cFront-end Framework\u201d category. (The first place was React with 16.8K stars.)\nWhile htmx is not a new library (htmx 1.0 came out in late 2020 and its\npredecessor by the same author, intercooler.js, reached 1.0 in 2016), its\nincreased awareness and adoption means that 2024 will be the first year for\nhtmx to really shine\u2014and also its robustness be tested.\n\nhtmx presents an approach that is fundamentally at odds with what has been the\nmainstream for over a decade, i.e. a Single Page Application entirely\ncontrolled by a React-like JS framework, directly manipulating DOM and\nexchanging data with (mostly) JSON APIs. Instead, htmx extends HTML as\nhypermedia. With htmx, we can encode sophisticated behaviors directly in HTML\nas attributes\u2014this is an exact opposite of JSX, \u201can XML-like syntax extension\u201d\nto JS for templating purposes. An htmx app is server centric like the Web 1.0\ndays, but is able to match most SPA apps in its ability to support advanced\ninteractivity and modern UX\u2014all with little to no client side scripting.^4\n\nWhat\u2019s particularly intriguing to me is that htmx shows us a different route\nto the \u201cone app\u201d architecture by the way of killing the client-side.^5 It\u2019s\nimportant to note that htmx is not a 100% solution\u2014it shouldn\u2019t be\ncontroversial to state that the interactivity ceiling is much lower for htmx\nthan, say, React or Solid. However, it can get you 80% there with radically\nless complexity. No extra dependencies, no build step, no advanced tooling\n(now re-written in Rust!), no complicated state management, no \u201cdouble data\u201d\nproblem, no hydration mismatch... Just write your HTTP server and return HTML!\n\nIn a way, htmx is not a solution, but a question: what are you really\nbuilding\u2014does it really need more than htmx?\n\n## Which way to cross?\n\nThough most (all?) web frameworks aim to bridge the \u201cnetwork chasm,\u201d I\u2019m\nlearning that this chasm cannot be closed, it can only be crossed. So which\nway to cross it? React, Solid, and htmx all present distinct answers here.\nWith React, we see an attempt to cover the full spectrum at once within the\nsame Component model. With Solid, we see a focus on the client side with new\nprimitives to bring server close to it. With htmx, we see a good old server\ncentric approach but with a twist that is supercharged hypermedia.\n\nIt may be too early to predict which way will win out. Or maybe such a\nprediction is a mere nonsense\u2014there is no silver bullet, remember? Different\napproaches with different trade-offs will benefit different use cases\ndifferently. Nonetheless, I believe that React, Solid, and htmx all point to\nwhat might be the next step in the evolution of web development and UI\nengineering. If and when they succeed, perhaps crossing the network gap will\nfinally feel as though the gap\u2019s closed.\n\n## Footnotes\n\n  1. An earlier iteration of Solid\u2019s server function API was server$(). Solid later made a pragmatic choice to stay aligned with React and adopted \"use server\"\u2014just like it did with JSX early on. You can find the rationale for this decision in this release note. \u21a9\n\n  2. In fact, Solid did run an experiment on \u201cserver component\u201d with its \u201cIslands router\u201d in 2023. Examples of this experiment can be found under /archived_examples directory of the https://github.com/solidjs/solid-start repo, including this \u201cMovies\u201d app. The Islands router approach was later (temporarily?) dropped as Solid switched its focus to server function with new router Data API. \u21a9\n\n  3. To be fair, Solid\u2019s approach cannot fully match React\u2019s new architecture and falls short in solving the \u201cdouble data\u201d problem where the same data appears twice, once in pre-rendered HTML during SSR and once again in <script> as a JSON blob to be used during hydration. \u21a9\n\n  4. A full explanation on how htmx achieves this is clearly out of the scope of the current blog post. But if you, dear reader, are interested in learning more, I strongly, strongly recommend Hypermedia Systems, a book-length treatment of the topic co-written by the author of htmx. If you\u2019re short on time, the official htmx.org website also has many good essays. \u21a9\n\n  5. This is not to say that htmx fully eliminates any need for client-side scripting. However, htmx demands that such scripting must be in the service of hypermedia, rather than replacing or competing against it. \u21a9\n\nRSC is React Server + Component\n\n\u00a9 2024 Bobae Kang. All rights reserved.\n\n", "frontpage": true}
