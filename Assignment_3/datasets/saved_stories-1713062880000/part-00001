{"aid": "40025935", "title": "Careful with That Lock, Eugene", "url": "https://kaveland.no/careful-with-that-lock-eugene.html", "domain": "kaveland.no", "votes": 1, "user": "ingve", "posted_at": "2024-04-13 20:46:26", "comments": 0, "source_title": "Careful with That Lock, Eugene", "source_text": "Robin's blog \u2013 Careful with That Lock, Eugene\n\n# Robin K\u00e5veland\n\nSoftware engineer\n\n# Careful with That Lock, Eugene\n\nPosted on 2024-04-12 in postgres\n\nIt is rewarding to work on software that people care about and use all around\nthe clock. This constant usage means we can't simply take the system offline\nfor maintenance without upsetting users. Therefore, techniques that allow us\nto update the software seamlessly without downtime or compromising service\nquality are incredibly valuable.\n\nMost projects I've worked on use a relational database for persistence, and\nhave some sort of migration tool like flyway or liquibase to make changes to\nthe database schema. This post is about a particular kind of migration\nsituation that, in my experience, most developers who work on such projects\nwill encounter at some point in their career. They will want to apply a\nsimple, and seemingly innocent migration, like adding a column to a table and\nit'll cause some number of requests to fail, or maybe even a small outage.\nThere are some tricks we can use here to reduce risk and automatically detect\nsome patterns that cause this problem.\n\n## Scenario 1\n\nWe'll use postgres to describe the setup and scenario, with the following\nsimple schema:\n\n    \n    \n    CREATE TABLE documents(id serial PRIMARY KEY, document text);\n\nThis scenario has 2 transactions in it:\n\n  * A is a transaction that wants to complete 2 statements, one fast and one slow, both modifications to the database.\n  * B is a transaction that only wants to read a single document.\n\nI will start these in different psql shells and we'll take a look at what\nhappens.\n\n### A adds a column to documents\n\n    \n    \n    postgres=# BEGIN; BEGIN postgres=*# ALTER TABLE documents ADD COLUMN is_indexed bool; ALTER TABLE\n\nA is now holding an AccessExclusiveLock on documents, and all subsequent\ntransactions that attempt to do anything with that table must wait:\n\n    \n    \n    postgres=# SELECT l.relation::regclass AS object_name, l.mode, locktype, granted FROM pg_locks l JOIN pg_class c ON c.oid = l.relation JOIN pg_namespace n ON n.oid = c.relnamespace AND n.nspname != 'pg_catalog'; object_name | mode | locktype | granted -------------+---------------------+----------+--------- documents | AccessExclusiveLock | relation | t (1 row)\n\n### A starts a slow statement\n\nLet's say, then that A starts a slow statement, like filling in all the\nmissing values for the new column (suppose that documents is a big table):\n\n    \n    \n    postgres=*# UPDATE documents SET is_indexed = true;\n\n### B attempts to read a single document\n\n    \n    \n    postgres=# BEGIN; BEGIN postgres=*# SELECT document FROM documents WHERE id = 3;\n\nB is now blocked and must wait for A to finish:\n\n    \n    \n    # SELECT l.relation::regclass AS object_name, l.mode, locktype, granted FROM pg_locks l JOIN pg_class c ON c.oid = l.relation JOIN pg_namespace n ON n.oid = c.relnamespace AND n.nspname != 'pg_catalog'; object_name | mode | locktype | granted ----------------+---------------------+----------+--------- documents_pkey | RowExclusiveLock | relation | t documents | RowExclusiveLock | relation | t documents | AccessExclusiveLock | relation | t documents | AccessShareLock | relation | f (4 rows)\n\nOnce A commits successfully, B immediately executes. In this scenario, if B is\na very frequent transaction type and A is very slow, this can seem like a\npartial outage that can impact users on the live system.\n\nThis scenario is essentially identical to one in which there's a single\nmigration statement that requires an AccessExclusiveLock and performs a table\nrewrite, such as adding a NOT NULL column with a DEFAULT value.\n\nBut at least if A is fast, nothing bad can happen, right? Well...\n\n## Scenario 2\n\nThis scenario has 3 transactions in it:\n\n  * A is a slow transaction. It reads documents and puts all the documents somewhere, possibly a search engine or something. The search engine is having a particularly bad day today or perhaps A is just reading more data than it should.\n  * B is our migration. It wants to add a column to documents, so that the job that runs A can see which documents that have already been sent to the search engine.\n  * C represents one of many fast transactions, needle-in-the-haystack kind of transactions. For example users that have clicked a link from the search engine and want to retrieve the entire document to read it, instead of the summary from the search engine.\n\nThere's a particular interleaving of these that could cause a lot of C\ntransactions to block, leading to time outs or hanging web pages and\nfrustrated users.\n\n### A reads documents\n\n    \n    \n    postgres=*# SELECT document FROM documents; document ------------- Imagine a bunch of interesting documents (6 rows)\n\nAt this point, A starts doing a bunch of indexing into a search engine, and\nit's going to take a long time.\n\n### B attempts to take an AccessExclusiveLock\n\n    \n    \n    postgres=# BEGIN; BEGIN postgres=*# ALTER TABLE documents ADD COLUMN is_indexed boolean;\n\nThis transaction is blocked because A has some locks that are in conflict with\nthe AccessExclusiveLock on documents that B is trying to take. We can check\npg_locks to see what the status is right now:\n\n    \n    \n    postgres=# SELECT l.relation::regclass AS object_name, l.mode, locktype, granted FROM pg_locks l JOIN pg_class c ON c.oid = l.relation JOIN pg_namespace n ON n.oid = c.relnamespace AND n.nspname != 'pg_catalog'; object_name | mode | locktype | granted ----------------+---------------------+----------+--------- documents_pkey | AccessShareLock | relation | t documents | AccessShareLock | relation | t documents | AccessExclusiveLock | relation | f\n\nThe two AccessShareLocks are held by A, which is slow and B is waiting for the\nAccessExclusiveLock.\n\n### C attempts to read one row from documents\n\n    \n    \n    postgres=# BEGIN; BEGIN postgres=*# SELECT document FROM documents where id = 3;\n\nC is now blocked, waiting to acquire an AccessShareLock:\n\n    \n    \n    postgres=# SELECT l.relation::regclass AS object_name, l.mode, locktype, granted FROM pg_locks l JOIN pg_class c ON c.oid = l.relation JOIN pg_namespace n ON n.oid = c.relnamespace AND n.nspname != 'pg_catalog'; object_name | mode | locktype | granted ----------------+---------------------+----------+--------- documents_pkey | AccessShareLock | relation | t documents | AccessShareLock | relation | t documents | AccessExclusiveLock | relation | f documents | AccessShareLock | relation | f (4 rows)\n\nAt this point, B can't proceed because of A and C can't proceed because of B.\nIf B aborts and rolls back, all instances of C will be able to proceed. If A\nis fast enough, it might be that nobody notices anything, if it's also true\nthat B is fast. If A is slow enough, some people might start getting alerts\nand start an investigation before A commits.\n\n## Mitigations\n\nScenario 1 would be resolved if we made A from that scenario into 2\nmigrations; the SELECT document FROM documents WHERE id = 3 transaction does\nnot conflict with the locks that UPDATE documents SET is_indexed = true takes.\n\nFor the common example of wanting to add a NOT NULL-column, we can add the\ncolumn without the NOT NULL constraint, but with the default value in a\nmigration. This is pretty much instant. Then we can issue a second migration\nto populate the value (it's safer still if we can do this in small batches to\navoid long-running transactions), then a third migration to add the NOT NULL\nconstraint.\n\nScenario 2 needs a different strategy. Maybe we can design the job so we can\nsolve the problem by adding a new documents_index_status table that has a\nforeign key to documents?\n\nOnce you know these patterns, it's easy to test how possible mitigations would\nwork out by practicing with concurrent sessions and see what works and what\nblocks. What would be very nice however, would be to have some tooling that\ntold you that you were about to do something potentially dangerous.\n\n## Detection in CI/CD\n\nRecently I learned from a colleague that flyway has a very cool callback\nfeature that will let you run queries in the same transaction as your\nmigrations, and I'm realizing that there is a lot of potential to build nice\ntooling with this feature. I have taken a stab at detecting migrations that\ntake AccessExclusiveLocks on tables that aren't new. I do this in three steps.\n\n### Snapshot pg_class before migration\n\nWhen flyway gives my callback the BEFORE_EACH_MIGRATE event, I take a snapshot\nof pg_class to temporarily store which relations that existed before the\nmigration ran:\n\n    \n    \n    CREATE TABLE pg_class_before_migrate as SELECT * FROM pg_class;\n\nThe reason we do this is that we don't want to yell wolf when migrations\ncreate new tables or indexes, since the locks only matter if other\ntransactions try to use the relations concurrently with the migration.\n\n### Find relation level AccessExclusiveLocks\n\nOn the AFTER_EACH_MIGRATE event, I retrieve all relation level locks that my\ntransaction has taken on database objects that existed before the migration\nran. If the migration has issued a SET ROLE we may need to change role back to\nthe one that created the pg_class_before_migrate-table.\n\n    \n    \n    SELECT n.nspname::text AS schema_name, l.relation::regclass::text AS object_name FROM pg_locks l JOIN public.pg_class_before_migrate c ON c.oid = l.relation JOIN pg_namespace n ON n.oid = c.relnamespace WHERE l.locktype = 'relation' AND l.mode = 'AccessExclusiveLock' AND l.pid = pg_backend_pid(); -- Locks held by current transaction\n\n### Clean up\n\nWe probably shouldn't leave that snapshot of pg_class hanging around forever:\n\n    \n    \n    DROP TABLE pg_class_before_migrate;\n\nAt this point, you can choose to have the CI/CD comment on the pull request\nthat the migration will lock documents and therefore you should check what\ntypes of transactions that may try to use that table concurrently with the\nmigration. Possibly have some LLM generate a helpful text about what could go\nwrong with the migration script? Maybe match the locks against a list of\ntables that are acceptable to lock, or a list of tables that are known to be\ndangerous to lock?\n\n## Future work\n\nNote that there are lots of corner cases still here, I'm very enthusiastic\nabout lots of ideas in this space and definitely want to write and share some\nmore code once I know more about what's possible.\n\nTaking a snapshot of pg_class potentially also gives us another few things we\ncan detect. If we can run these migrations against something like an\nanonymized copy of the production database, we may be able to issue ANALYZE\nbefore and after the migration to detect some table rewrites -- such an\noperation should change the relationship between reltuples and relpages in\npg_class, by increasing the size of the tuples. That might also allow us to\nflag migrations that rewrite large tables. We can also snapshot other tables\nfrom information_schema, or tables like pg_attribute to build a pretty good\ndata structure describing the effect of the migration in terms of both schema\nand content.\n\n\u00a9\n\nBuilt with Pelican using Flex theme\n\n", "frontpage": false}
