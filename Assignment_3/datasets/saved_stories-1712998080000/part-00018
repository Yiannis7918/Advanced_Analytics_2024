{"aid": "40017875", "title": "Reading jsonb from SQLite three times faster", "url": "https://github.com/lovasoa/serde-sqlite-jsonb", "domain": "github.com/lovasoa", "votes": 2, "user": "lovasoa", "posted_at": "2024-04-12 21:28:20", "comments": 0, "source_title": "GitHub - lovasoa/serde-sqlite-jsonb: Rust Serde Serializer and Deserializer for SQLite jsonb data format", "source_text": "GitHub - lovasoa/serde-sqlite-jsonb: Rust Serde Serializer and Deserializer\nfor SQLite jsonb data format\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nlovasoa / serde-sqlite-jsonb Public\n\nforked from serde-rs/example-format\n\n  * Notifications\n  * Fork 0\n  * Star 2\n\nRust Serde Serializer and Deserializer for SQLite jsonb data format\n\n### License\n\nApache-2.0 license\n\n2 stars 9 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# lovasoa/serde-sqlite-jsonb\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n2 Tags\n\nThis branch is 48 commits ahead of serde-rs/example-format:master.\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nlovasoav0.1.06088de7 \u00b7\n\n## History\n\n93 Commits  \n  \n### .github/workflows\n\n|\n\n### .github/workflows\n\n| disable testing on old rust  \n  \n### benches\n\n|\n\n### benches\n\n| add benchmark  \n  \n### src\n\n|\n\n### src\n\n| performance improvement  \n  \n### tests\n\n|\n\n### tests\n\n| serialize enum struct variant  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| Serde example format  \n  \n### Cargo.toml\n\n|\n\n### Cargo.toml\n\n| v0.1.0  \n  \n### LICENSE-APACHE\n\n|\n\n### LICENSE-APACHE\n\n| Sync license text with rust-lang repos  \n  \n### LICENSE-MIT\n\n|\n\n### LICENSE-MIT\n\n| MIT copyright line  \n  \n### README.md\n\n|\n\n### README.md\n\n| add benchmark  \n  \n### clippy.toml\n\n|\n\n### clippy.toml\n\n| start serializer  \n  \n### rustfmt.toml\n\n|\n\n### rustfmt.toml\n\n| Format with 80-character lines  \n  \n## Repository files navigation\n\n# serde-sqlite-jsonb\n\nThis crate provides a custom Serde deserializer for SQLite JSONB columns.\n\nIt was initially developed for inclusion in the SQLPage website builder.\n\n## Why\n\nSince version 3.45.0, SQLite supports JSONB columns, which can store JSON data\nin a binary format that is more efficient to manipulate than JSON.\n\nThe problem is that applications that use SQLite currently need to convert the\ndata from JSONB to JSON, and then from JSON to their own data structures to\nuse it. This prevents reading the blob data directly from the database in a\nstreaming fashion using SQLite's blob streaming API, and requires making a SQL\nquery to extract and convert the data to JSON.\n\nThis crate provides a custom Serde serializer and deserializer for JSONB\ndirectly, which allows skipping the JSON conversion step.\n\nThis can lead to significant performance improvements in certain scenarios, as\ndemonstrated in this crate's benchmarks.\n\n### Benchmarks\n\nThese graphs show the time taken:\n\n  * deserializing a JSONB column directly to a struct using this crate\n  * making a SQL query to extract the JSONB column as JSON and then deserializing it to a struct using serde_json.\n\nThe data being deserialized contains a string, the length of which varies from\n50 to 1000 characters, to demonstrate the evolution of the performance with\nthe size of the data.\n\n> Disclaimer: These benchmarks should always be taken with a grain of salt.\n> When performance matters, you should measure the performance inside your own\n> application with your own data. serde_json is very well optimized and can be\n> faster than this crate in some scenarios, especially when the JSON data is\n> small.\n\n## Crate features\n\nThe binary format can contain raw json data, so this crate depends on the\nserde_json crate to parse the JSON data. Since SQLite also supports json5, the\nserde-json5 feature can be used if json5 support is needed.\n\nBy default, the (faster) serde_json feature is enabled and this crate returns\nan error when trying to parse json5 data. To enable json5 support, enable the\nserde-json5 feature (and optionally disable the default features to use the\njson5 parser even for json data):\n\n    \n    \n    [dependencies] serde-sqlite-jsonb = { version = \"0.1\", features = [\"serde-json5\"], default-features = false }\n\n## Usage\n\nThis library does not handle the SQLite connection, so you need to use a crate\nlike rusqlite or sqlx to interact with the database.\n\nOnce you have extracted the JSONB data from the database, either as a Vec<u8>\nor as a std::io::Read object that streams the BLOB data from the database, you\ncan use the serde_sqlite_jsonb crate to deserialize the JSON data, either to\nyour own data structures or to a serde_json::Value.\n\n### Deserialize JSONB from a query result\n\n    \n    \n    let conn = rusqlite::Connection::open_in_memory()?; let blob: Vec<u8> = conn.query_row( r#\"select jsonb('{\"id\": 1, \"name\": \"John Doe\"}')\"#, [], |row| row.get(0), )?; let person: Person = serde_sqlite_jsonb::from_bytes(&blob).unwrap();\n\n### Streaming deserialization from a SQLite BLOB\n\n    \n    \n    let my_blob = conn.blob_open( // returns an object that implements std::io::Read DatabaseName::Main, \"my_table\", // table name \"my_jsonb_column\", // column name 42, // primary key (rowid) true // read-only )?; let parsed: serde_json::Value = // or any other type that implements Deserialize serde_sqlite_jsonb::from_reader(my_blob).unwrap();\n\n## Format\n\nThe format of the JSONB column is described in the SQLite documentation:\nhttps://sqlite.org/draft/jsonb.html\n\nThe data format is a binary format with a header and payload. The header\ncontains information about the type of the element and the size of the\npayload. The payload contains the actual data.\n\nHere's a rough ASCII representation:\n\n    \n    \n    bits: 0 1 2 3 4 5 6 7 8 +-------------+-------------+ | size(4) | type(4) | first header byte +-------------+-------------+ | payload size (0 - 64) | header bytes number 2 to 9 +---------------------------+ | payload data | payload bytes (JSON strings or numbers in text format) +---------------------------+\n\n### Header\n\n#### Payload size\n\nIf the payload data is between 0 and 11 bytes (inclusive), the size is encoded\nin the first 4 bits of the header. Otherwise, the size of the payload is\nencoded in the next bytes, and the first 4 bits indicate the number of bytes\nused to encode the payload size, using the following table:\n\nPayload Data Size Range| Size Encoding| First 4 bits of Header  \n---|---|---  \n0 to 11 bytes| u4 (embedded in first 4 bits)| 0 to 11 (0x0 to 0xB)  \n12 to 2^8 - 1 bytes| u8| 12 (0xC)  \n2^8 to 2^16 - 1 bytes| u16| 13 (0xD)  \n2^16 to 2^32 - 1 bytes| u32| 14 (0xE)  \n2^32 to 2^64 - 1 bytes| u64| 15 (0xF)  \n  \n#### Type\n\nType| Hex Code| Description  \n---|---|---  \nNull| 0x0| The element is a JSON \"null\".  \nTrue| 0x1| The element is a JSON \"true\".  \nFalse| 0x2| The element is a JSON \"false\".  \nInt| 0x3| The element is a JSON integer value in the canonical RFC 8259\nformat.  \nInt5| 0x4| The element is a JSON5 integer, such as 0xABC.  \nFloat| 0x5| The element is a JSON floating-point value in the canonical RFC\n8259 format.  \nFloat5| 0x6| The element is a JSON5 floating-point value that is not in the\ncanonical JSON format.  \nText| 0x7| The element is a JSON string value that does not contain any\nescapes.  \nTextJ| 0x8| The element is a JSON string value that contains RFC 8259\ncharacter escapes.  \nText5| 0x9| The element is a JSON5 string value that contains character\nescapes, including some from JSON5.  \nTextRaw| 0xA| The element is a JSON string value that contains UTF8 characters\nthat need escaping in JSON.  \nArray| 0xB| The element is a JSON array. The header of the first array element\nstarts immediately after the array header.  \nObject| 0xC| The element is a JSON object. Object keys (strings) and values\nare alternated in the payload.  \nReserved13| 0xD| Reserved for future expansion.  \nReserved14| 0xE| Reserved for future expansion.  \nReserved15| 0xF| Reserved for future expansion.  \n  \n#### Example\n\nThe following JSON object:\n\n    \n    \n    {\"a\": false, \"b\":true}\n\nis encoded as the following 7 bytes of binary data:\n\n    \n    \n    6c 17 61 02 17 62 01\n\nbyte| value| description  \n---|---|---  \n0| 0x6c| header: payload size = 6, type = Object (0xC)  \n1| 0x17| header: payload size = 1, type = Text (0x7)  \n2| 0x61| payload: 'a'  \n3| 0x02| header: payload size = 0, type = False (0x2)  \n4| 0x17| header: payload size = 1, type = Text (0x7)  \n5| 0x62| payload: 'b'  \n6| 0x01| header: payload size = 0, type = True (0x1)  \n  \n## MSRV\n\nRequires rust >= 1.63 (debian stable)\n\n## About\n\nRust Serde Serializer and Deserializer for SQLite jsonb data format\n\n### Resources\n\nReadme\n\n### License\n\nApache-2.0 license\n\nActivity\n\n### Stars\n\n2 stars\n\n### Watchers\n\n0 watching\n\n### Forks\n\n0 forks\n\nReport repository\n\n## Releases\n\n2 tags\n\n## Packages 0\n\nNo packages published\n\n## Languages\n\n  * Rust 100.0%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
