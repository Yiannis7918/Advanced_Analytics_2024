{"aid": "39962617", "title": "GNU Autoconf is not replaceable in any practical sense", "url": "https://utcc.utoronto.ca/~cks/space/blog/programming/AutoconfNotReplaceable", "domain": "utcc.utoronto.ca", "votes": 3, "user": "ingve", "posted_at": "2024-04-07 18:20:50", "comments": 0, "source_title": "Chris's Wiki :: blog/programming/AutoconfNotReplaceable", "source_text": "Chris's Wiki :: blog/programming/AutoconfNotReplaceable\n\nChris Siebenmann :: CSpace \u00bb blog \u00bb programming \u00bb AutoconfNotReplaceable\n\nWelcome, guest.\n\n## GNU Autoconf is not replaceable in any practical sense\n\nApril 6, 2024\n\nIn the wake of the XZ Utils backdoor, which involved GNU Autoconf, it's been\nsomewhat popular to call for Autoconf to go away. Over on the Fediverse I said\nsomething about that:\n\n> Hot take: autoconf going away would be a significant net loss to OSS,\n> perhaps as bad as the net loss of the Python 2 to Python 3 transition, and\n> for much the same reason. There are a lot of projects out there that use\n> autoconf/configure today and it works, and they would all have to do a bunch\n> of work to wind up in exactly the same place ('a build system that works and\n> has some switches and we can add our feature checks to').\n>\n> (The build system can never supply all needed tests. Never.)`\n\nAutoconf can certainly be replaced in general, either by one of the existing\nand more modern configuration and build systems, such as CMake, or by\nsomething new. New projects today often opt for one of the existing\nalternative build systems and (I believe) often find them simpler. But what\ncan't be replaced easily is autoconf's use in existing projects, especially\nprojects that use autoconf in non-trivial ways.\n\nYou can probably convert most projects to alternate build systems. However,\nmuch of this work will have to be done by hand, by each project that is\nconverted, and this work (and the time it takes) won't particularly move the\nproject forward. That means you're asking (or demanding) projects to spend\ntheir limited time to merely wind up in the same place, with a working build\nsystem. Further, some projects will still wind up running a substantial amount\nof their own shell code as part of the build system in order to determine and\ndo things that are specific to the project.\n\n(Although it may be an extreme example, you can look at the autoconf pieces\nthat OpenZFS has in its config/ subdirectory. Pretty much all of that work\nwould have to be done in any build system that OpenZFS used, and generally it\nwould have to be significantly transformed to fit.)\n\nThere likely would be incremental security-related improvements even for such\nprojects. For example, I believe many modern build systems don't expect you to\nship their generated files the way that autoconf sort of expects you to ship\nits generated configure script (and the associated infrastructure), which was\none part of what let the XZ backdoor slip files into the generated tarballs\nthat weren't in their repository. But this is not a particularly gigantic\nimprovement, and as mentioned it requires projects to do work to get it,\npossibly a lot of work.\n\nYou also can't simplify autoconf by declaring some standard checks obsolete\nand dropping everything to do with them. It may indeed be the case that few\nautoconf based programs today are actually going to cope with, for example,\nthere being no string.h header file (cf), but that doesn't mean you can remove\nmentioning it from the generated header files and so on, since existing\nprojects require those mentions to work right. The most you could do would be\nto make the generated 'configure' scripts simply assume a standard list of\nfeatures and put them in the output those scripts generate.\n\n(Of course it would be nice if projects using autoconf stopped making\nsuperstitious use of things like 'HAVE_STRING_H' and just assume that standard\nheaders are present. But projects generally have more important things to\nspend limited time on than cleaning up header usage.)\n\nPS: There's an entire additional discussion that we could have about whether\n'supply chain security' issues such as Autoconf and release tarballs that\ncan't be readily reproduced by third parties are even the project's problem in\nthe first place.\n\nWritten on 06 April 2024.\n\n| \u00ab| Solving the hairpin NAT problem with policy based routing and plain NAT  \n---|---  \n  \nThese are my WanderingThoughts (About the blog)\n\nFull index of entries Recent comments\n\nThis is part of CSpace, and is written by ChrisSiebenmann. Mastodon: @cks\nTwitter @thatcks\n\n* * *\n\nCategories: links, linux, programming, python, snark, solaris, spam, sysadmin,\ntech, unix, web Also: (Sub)topics\n\nThis is a DWiki. GettingAround (Help)\n\nPage tools: View Source, Add Comment.\n\nAtom Syndication: Recent Comments.\n\nLast modified: Sat Apr 6 22:50:15 2024 This dinky wiki is brought to you by\nthe Insane Hackers Guild, Python sub-branch.\n\n", "frontpage": false}
