{"aid": "40033378", "title": "Mysterious Moving Pointers", "url": "https://blomqu.ist/posts/2024/move/", "domain": "blomqu.ist", "votes": 10, "user": "camblomquist", "posted_at": "2024-04-14 18:50:28", "comments": 4, "source_title": "Mysterious Moving Pointers", "source_text": "Mysterious Moving Pointers - blomqu.ist\n\nblomqu.ist\n\n# Mysterious Moving Pointers\n\nIn which I pretend to be Raymond Chen\n\n2024-04-12 4 minutes\n\nAt work, we have started the process of modernizing our codebase. We currently\nwork with Visual Studio 2013 and are upgrading to Visual Studio 2022.^1 Like\nany modernization effort, changes in the language are likely to break existing\nsoftware as certain things are deprecated and new features are added. One\npiece of software was built exclusively for Windows and after upgrading the\nproject, an important class consistently caused segmentation faults.\n\n^1\n\nTalk about long overdue!\n\nHere is a minimal example that describes the problem code:\n\n    \n    \n    struct Node { std::vector<Connection> connections; }; struct Connection { Node *from, *to; }; struct Graph { std::vector<std::list<Node>> nodes; };\n\nIn this graph, a node stores its connection to other nodes. When a connection\nis made, the pointer is known to be valid. And the node within a std::list is\nstable, a pointer to it should stay valid as long as the list and the node\nitself exists. But at some point, that pointer is invalidated and attempting\nto access it causes the segmentation fault.\n\nFirst question: Why is this broken?\n\nSecond Question: How did this ever work in the first place?\n\nThe answer to the first question is a classic C++ footgun. When a std::vector\ngrows larger than its capacity, it reallocates its backing store and has to\nput the existing elements into that store. The best way to do this would be to\nmove the elements, which in the best case is effectively a memcpy.\nUnfortunately, std::vector will only move elements if the class has the trait\nis_nothrow_move_constructible which is typically denoted by declaring the move\nconstructor as noexcept.^2 In MSVC, std::list is not marked as such so when\nthe vector reallocates, the list is copied instead of moved. When the list is\ncopied, its elements are copied and our pointers are invalidated.^3\n\n^2\n\nI say typically here because the default move constructor is implicitly\nnoexcept.\n\n^3\n\nOur first hint to this issue was that Node had defined a copy constructor but\nfailed to copy its connections. That was a quick fix, but we never questioned\nwhy the nodes were being copied in the first place.\n\nNow that we know why it's broken, we ask how it was able to work in the first\nplace. How did the pointers stay valid if std::vector couldn't move its\nelements?\n\nWhile MSVC is considered one of the most complete implementations of the\nstandard as of 2022,^4 this wasn't always the case. It wasn't until 2015 that\nMicrosoft had a mostly complete implementation of C++11. C++11 was a huge\nchange to the language; having introduced lambdas, move construction, and\nnoexcept among other things. The MSVC of 2013 had move construction, but not\nnoexcept.^5 Since noexcept didn't exist, the reallocation behavior of\nstd::vector couldn't change depending on the traits of the element type. It\nwould unconditionally use the move constructor of the element.\n\n^4\n\nIgnoring the legacy bits that aren't standard conforming. Or the unicode. Or\nwhatever specific thing has caused you pain.\n\n^5\n\nIt also didn't have thread_local, constexpr, or a fully functional\nimplementation of default member initializers. And the lack of two of those\nspecific things regularly causes me pain.\n\nAnd so the second mystery is solved. Because of Microsoft's partial\nimplementation of the standard pre-2015, we could rely on our nodes staying in\nthe same spot because our vector would move the lists it contained. When we\nupgraded, the \"correct\" behavior broke our code. The simplest solution in our\ncase was to change the std::vector to a std::list which keeps everything\nstable.\n\nPersonally, I found this to be a pretty interesting puzzle. That said, it\nshould not take a detailed understanding of the standard and the history of\nits various implementations to find the source of a bug. Most languages are\ndesigned for writing software. Apparently, C++ was designed for solving\nriddles.\n\n\u00a9 2023 Cameron Blomquist. Powered by Zola\n\n", "frontpage": true}
