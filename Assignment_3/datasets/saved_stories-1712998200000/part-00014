{"aid": "40018398", "title": "How to run MySQL queries on an ESP32 microcontroller", "url": "https://realtimelogic.com/articles/ESP32-and-MySQL-Cloud-Integration-Visualizing-Weather-Data", "domain": "realtimelogic.com", "votes": 1, "user": "willhschmid", "posted_at": "2024-04-12 22:39:10", "comments": 0, "source_title": "ESP32 and MySQL Cloud Integration: Visualizing Weather Data", "source_text": "ESP32 and MySQL Cloud Integration: Visualizing Weather Data\n\n  * NewsNews\n\n    * Tutorials\n    * Newsletter Subscription\n  * Contact Us\n  * Downloads\n  * Products\n\n# ESP32 and MySQL Cloud Integration: Visualizing Weather Data\n\nIn this hands-on tutorial, you will learn how to connect an ESP32 to a MySQL\ncloud instance using the Lua programming language.\n\nIf you do not have an ESP32, you can still follow along and run all of the\nfollowing code on Windows and Linux using the ESP32 simulator. See Running the\nExamples on Windows and Linux for details. However, if you would like to run\nthis on an ESP32, install Xedge32 on your ESP32 microcontroller before\nproceeding.\n\n### What You Will Learn\n\nThis tutorial provides a hands-on practical guide on securely connecting the\nESP32 microcontroller directly to a MySQL database instance. You'll learn how\nto establish and maintain a persistent connection to the database and\ncontinuously insert data directly from the ESP32. Once the data is stored in\nthe online database, it can easily be visualized using Grafana, as detailed in\nthe final section of this tutorial.\n\n### Weather Station\n\nFor those who want to go one step further, the tutorial also shows how to\nsample temperature, humidity, and pressure from a BME 280 sensor and then\ninsert this data continuously into the database.\n\n## Components Used\n\nThe Xedge32 foundation, the Barracuda App Server, includes MySQL and Redis\ndrivers, which can be executed directly on an ESP32 microcontroller. If you're\nexperienced with MySQL installations, you may choose to install your own\ndatabase on your computer and have the ESP32 connect to this database.\nHowever, this tutorial focuses on how to securely connect to a MySQL instance\non the Internet using a free service provided by Aiven.\n\n## Getting Started\n\nBegin by visiting Aiven's website and clicking the \"Get Started\" button. After\nsigning up, follow the wizard to create a free MySQL instance.\n\nOnce signed up, we recommend installing a MySQL tool such as MySQL Workbench.\nRefer to the Connect to Aiven using the MySQL Workbench tutorial for details.\n\n## Installing the MySQL Driver\n\nThe ready-to-use MySQL driver is available for download from GitHub. Follow\nthese steps to download and prepare the driver:\n\n    \n    \n    git clone https://github.com/RealTimeLogic/LSP-Examples.git cd LSP-Examples/MysqlAndRedis/MySQL/ zip -D -q -u -r -9 ../MySQL.zip .\n\nNext, after installing Xedge32 on your ESP32, navigate to the ESP32 IDE:\nhttp://xedge32.local/rtl/, click the three dots in the top right corner, and\nselect \"App upload.\" Drag and drop the MySQL.zip onto the upload form to\ninstall the driver. Choose \"Do not unpack\" when asked whether to unpack the\nZIP file. For more information on this process, see the tutorial Xedge\nApplication Deployment: From Installation to Creation.\n\nYou should now see MySQL in the left pane, marked green, indicating that the\ndriver is in execution mode.\n\n## Creating a DB App\n\nIt is now time to create an app that connects to your Aiven database instance.\nStart by creating a new app, such as MyDbTest. If you're new to Xedge32, refer\nto the tutorial Your First Xedge32 Project, section How to Create an Xedge\nApp. In this app, create a .preload script with the following code:\n\n123456789101112131415161718192021222324252627282930313233343536373839404142|\n\\-- Create a new, unconnected DB instancelocal mysql = require\n\"resty.mysql\"local aivendb, err = mysql:new()if not aivendb\nthentrace(\"mysql:new failed:\", err)returnend\\-- Configuration settings for the\nAiven database connectionlocal cfg = {host = \"rtl-weather-\ndata.a.aivencloud.com\",port = 13031, -- Aiven DB port numberdatabase =\n\"defaultdb\", -- Aiven DB nameuser = \"avnadmin\", -- Database usernamepassword =\n\"AVNS_dadfgkjasdfufld9X_9\", -- Database passwordssl = true -- Important: Aiven\nrequires a secure connection}\\-- Flag to control the running state; remains\ntrue until 'onunload' is executedlocal running = true\\-- Callback function for\nhandling the database connection responselocal function cb(ok, err, errno,\nsqlstate)\\-- Log the connection statustrace(\"Connect\", ok, err, errno,\nsqlstate)\\-- Continue attempting to connect until 'onunload' is calledreturn\nrunningend\\-- Initiates a persistent asynchronous connection to the database\nwith\\-- the provided configuration and callbackaivendb:async(cfg, cb)\\--\n'onunload' function to gracefully shut down the database connectionfunction\nonunload()\\-- Update the running state to false to stop the connection\nattemptsrunning = falseaivendb:close()end\\-- Make it possible for scripts in\nthis app to access the db instanceapp.aivendb = aivendb  \n---|---  \n  \nThe code provided above is detailed in the MySQL and Redis Drivers Readme\nFile. We recommend consulting this readme file to understand how the code\nworks.\n\nImportant: After inserting the above code into your .preload script, you'll\nneed to adjust the database configuration settings to match those provided by\nyour Aiven portal.\n\nSave the .preload script, then open the Application Configuration dialog by\nclicking on the .appcfg file in the left pane. If the app is already running,\nrestart it; otherwise, start the app. Upon successful startup, you should see\nthe following output in the console:\n\n    \n    \n    cb 25: Connect 1 nil nil nil\n\nIf you encounter an error code, stop the application. The connection callback\nis designed to perpetually request a reconnect by returning true as long as\nthe application remains active. Should an error arise, investigate the error\nmessage; common issues include Xedge32's inability to connect to the Internet\nor incorrect database configuration parameters.\n\nNotice that the SQL command executes within a callback function passed to\napp.aivendb:execute(). The 'execute' method ensures the code within is\nexecuted in the MySQL connection's Cosocket. The MySQL and Redis Drivers\nReadme File section, Using the Database Drivers, explains this concept.\n\nOnce the .preload is operational and a persistent database connection has been\nsuccessfully established, proceed to the following section.\n\n## Creating a Database Table\n\nThe next step involves creating a database table directly from the ESP32.\nWithin the MyDbTest app, generate a new file named WeatherData.xlua and\npopulate it with the following code:\n\n123456789101112131415161718| \\-- SQL statement to create the 'weatherdata'\ntablelocal sql = [[CREATE TABLE weatherdata (id BIGINT AUTO_INCREMENT PRIMARY\nKEY,timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE\nCURRENT_TIMESTAMP,temperature DECIMAL(5,2),humidity DECIMAL(5,2),pressure\nDECIMAL(7,2),INDEX idxtimestamp (timestamp)) ENGINE=InnoDB;]]\\-- Access the DB\nobject exported in .preload\\-- Execute the SQL query in a cosocket, allowing\nfor non-blocking I/Oapp.aivendb:execute(function()\\-- Output the result of the\nquerytrace(app.aivendb:query(sql))end)  \n---|---  \n  \nAfter editing, click the \"Save & Run\" button. You should then see a console\noutput similar to the following:\n\n    \n    \n    ? 17: table: 3c21d630\n\nThe question mark signifies the trace function's inability to identify the\nanonymous function's name. The query returns a Lua table, indicating\nsuccessful table creation. Verify the existence of this table using the MySQL\nWorkbench.\n\nAttempting to re-run the script by clicking \"Save & Run\" again will yield the\nfollowing error, as the table weatherdata already exists:\n\n    \n    \n    ? 17: nil Table 'weatherdata' already exists 1050 42S01\n\n## Inserting SQL Data\n\nNow that our 'weatherdata' table is set up, the next step involves populating\nit with simulated data to test the insertion process. Replace the code in\nWeatherData.xlua with the following, discarding the table creation code since\nit's no longer necessary.\n\n1234567891011121314151617181920212223242526272829303132333435363738| \\-- This\nfunction generates random environmental data and inserts it into the\ndatabaselocal function timerFunc()\\-- Generate random temperature, humidity,\nand pressure valueslocal r = ba.rnd -- Shortcut for the random functionlocal\ntemperature = (20 + r(-50, 50) / 10) -- Random temperature between 15.0 and\n25.0 degreeslocal humidity = (50 + r(-150, 200) / 10) -- Random humidity\nbetween 35.0% and 70.0%local pressure = (1013 + r(-500, 500) / 10) -- Random\npressure between 963.0% and 1063.0% hPa\\-- Construct the SQL insert statement\nwith formatted valueslocal sql = string.format(\"%s VALUES (%.2f, %.2f,\n%.2f)\",\"INSERT INTO weatherdata(temperature, humidity, pressure)\",temperature,\nhumidity, pressure)\\-- Execute the SQL query in a cosocket, allowing for non-\nblocking I/Oapp.aivendb:execute(function()trace(sql) -- Output the SQL command\nto the console for debugginglocal res, err, errno, sqlstate =\napp.aivendb:query(sql) -- Execute the query\\-- Check for errors in the insert\noperationif not res thenxedge.elog({ts=true, flush=true},\"Insert failed:\nerr=%s, errno=%s, sqlstate=%s\",tostring(err), tostring(errno),\ntostring(sqlstate))endend)return true -- Return true to keep the timer running\nat regular intervalsend\\-- Set up a timer to call the function every 3\nsecondslocal timer = ba.timer(timerFunc)timer:set(3000) -- Interval set to\n3000 milliseconds\\-- 'onunload' function to stop the timer when the\napplication is stoppedfunction onunload()timer:cancel() -- Stops the timerend  \n---|---  \n  \nAfter clicking the \"Save & Run\" button, you should see a printout similar to\nthe following every 3 seconds.\n\n    \n    \n    ? 18: INSERT INTO weatherdata(temperature, humidity, pressure) VALUES (23.30, 55.40, 1009.00)\n\nThis debug message confirms that data is being continuously inserted into the\nweatherdata database table. The application maintains an active secure TCP\nconnection with the database through the persistent MySQL Cosocket established\nin the .preload script. In the event of a disconnection, the connection\ncallback in the .preload script is invoked, returning true to signal an\nattempt to reconnect, thereby ensuring your data insertion process is\nresilient and uninterrupted.\n\n### Handling Database Operation Failures\n\nNotice the use of the function xedge.elog(), which is particularly useful if a\ndatabase operation does not succeed. This function logs detailed error\ninformation, including the nature of the database error, the error number, and\nthe SQL state. How to use the email function xedge.elog() for logging errors\nis explained in the tutorial Logging for Testing and Production Mode.\n\n### Ensuring Continuous Data Flow\n\nThe design of this application, particularly its use of a persistent\nasynchronous database connection and intelligent error handling, exemplifies\nhow to build resilient IoT applications capable of continuous data collection\nand storage. By leveraging the persistent connection feature of the MySQL\nCosocket, the application is designed to automatically recover from connection\ndisruptions, ensuring that environmental data collection proceeds without\nmanual intervention.\n\n## Creating a Weather Station\n\nWith the foundational knowledge and setup complete, it's time to transform\nyour project into a fully operational weather station. The weatherdata table\nwe've established in the MySQL database is ready to receive and store data\nfrom a BME280 sensor, which measures temperature, humidity, and atmospheric\npressure. To proceed, you must purchase a BME280 sensor and integrate it with\nyour ESP32.\n\n### Wiring and Testing the BME280 Sensor\n\nOnce you have your BME280 sensor, the next step is to connect it to your\nESP32. This connection can be achieved through direct soldering or using a\nbreadboard for a non-permanent setup, which might be preferable for those\nexperimenting or looking to reuse components for future projects.\n\nThe ready-to-run bme280.xlua test program is wired according to the following:\n\nBME280| ESP32  \n---|---  \nVin| 3.3V  \nGND| GND  \nSCL| GPIO 22  \nSDA| GPIO 21  \n  \nWire the ESP32 and the BME280 as above, or use alternative GPIO pins. However,\nchange the GPIO settings in bme280.xlua accordingly if you use alternative\nGPIO pins.\n\nCopy the Lua code in bme280.xlua and replace the code in your WeatherData.xlua\nusing the Xedge IDE. After replacing the code, click the \"Save & Run\" button.\nYou should see a printout similar to the following if everything is working:\n\n    \n    \n    Temperature: 24.50, Humidity: 48.01, Pressure: 1003.86\n\n### Final Integration: Weather Data Collection\n\nAfter verifying the BME280 sensor's functionality, it's time to implement the\nfinal code version in WeatherData.xlua. This code will continuously read data\nfrom the BME280 sensor and insert it into your MySQL database based on\nspecified conditions. Replace the code in WeatherData.xlua with the following:\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970|\n\\-- GPIO pins for I2C communication with the BME280 sensorlocal SDA_GPIO\n<const> = 21local SCL_GPIO <const> = 22\\-- I2C address for the BME280\nsensorlocal BME280_I2C_ADDR <const> = 0x76local bme -- Placeholder for the\nbme280 instance, set in saveMetrics\\-- Coroutine timer function to send\nweather data to the MySQL databaselocal function saveMetrics()local err\\--\nInitialize the BME280 sensorbme, err = require \"bme280\".create(0,\nBME280_I2C_ADDR, SDA_GPIO, SCL_GPIO, settings)if not bme thentrace(\"Cannot\ncreate bme280 instance:\", err)returnendlocal toint = math.tointeger --\nShortcut for integer conversion\\-- Initialize measurements to trigger the\nfirst savelocal temperature, humidity, pressure = 1, 1, 1while true do --\nInfinite loop, but stops when the timer is cancelledlocal t, h, p = bme:read()\n-- Read sensor valuesif t then\\-- Convert readings to integers with one\ndecimal point precisiont, h, p = toint(t * 10), toint(h * 10), toint(p)\\--\nCheck for significant changes before saving datalocal tc, hc, pc =\nmath.abs(temperature - t) > 1, math.abs(humidity - h) > 4, math.abs(pressure -\np) > 30if tc or hc or pc then -- Save data if there's a notable\nchangetemperature, humidity, pressure = t, h, p -- Update the stored values\\--\nFormat and execute the SQL insert statementlocal sql = string.format(\"INSERT\nINTO weatherdata (temperature, humidity, pressure) VALUES (%.2f, %.2f,\n%.2f)\",temperature / 10, humidity / 10, pressure /\n100)app.aivendb:execute(function()trace(sql) -- Debug: print SQL commandlocal\nres, err, errno, sqlstate = app.aivendb:query(sql)\\-- Log insert operation\nerrorsif not res thenxedge.elog({ts = true, flush = true}, \"Insert failed:\nerr=%s, errno=%s, sqlstate=%s\",tostring(err), tostring(errno),\ntostring(sqlstate))endend)endelse\\-- Log sensor reading\nerrorsxedge.elog({flush = true, ts = true}, \"BME280 reading failed: %s\",\ntostring(h))\\-- Attempt to reinitialize the sensorbme:close()bme, err =\nrequire \"bme280\".create(0, BME280_I2C_ADDR, SDA_GPIO, SCL_GPIO, settings)if\nnot bme thenxedge.elog({flush = true, ts = true}, \"Cannot recreate bme280\ninstance: %s\", tostring(err))return -- Exit if reinitialization\nfailsendendcoroutine.yield(true) -- Pause until the next timer tickendend\\--\nSet up and start the timer to save metrics every 3 secondslocal metricsTimer =\nba.timer(saveMetrics)metricsTimer:set(3000)\\-- Cleanup function called when\nthe application is closedfunction onunload()metricsTimer:cancel() -- Stop the\nmetrics timerif bme then bme:close() end -- Close the BME280 sensor\ninstanceend  \n---|---  \n  \n### Understanding the Final Code\n\n  * Sensor Initialization: At the start, the BME280 sensor is initialized using the specified GPIO pins and I2C address. This step creates an instance of the sensor for reading data.\n  * Continuous Data Monitoring: The saveMetrics function enters an infinite loop, periodically reading temperature, humidity, and pressure from the sensor. It compares these readings with the previous values to detect significant changes.\n  * Data Insertion: When a notable change is detected, the new readings are formatted into an SQL INSERT command and sent to the MySQL database. This approach reduces unnecessary data storage and network traffic by ensuring that only meaningful changes in environmental conditions trigger database updates.\n\n## Grafan Weather Station Visualization Dashboard\n\nGrafana makes it easy to visualize the weather data. This section will guide\nyou through setting up a Grafana dashboard designed for this tutorial. Follow\nthese steps to download and set up the custom Grafana Weather Station\nVisualization Dashboard.\n\n### Step 1: Download the Custom Dashboard\n\nBegin by downloading the ready-to-use Grafana Weather Station Visualization\nDashboard designed for this tutorial. This dashboard connects with your MySQL\ndatabase and seamlessly visualizes temperature, humidity, and pressure data.\n\n  1. Download the Dashboard: Download the Grafan Weather Station Visualization Dashboard. Save this file to your computer; you'll need it to import the dashboard into Grafana.\n\n### Step 2: Connect Grafana to Your Aiven MySQL Database\n\nGrafana needs to retrieve the weather data from your MySQL database to\nvisualize the weather data. Let's set up Grafana to connect to your Aiven-\nhosted MySQL instance.\n\n  1. Log Into Grafana: Open your Grafana instance in a web browser and sign in.\n  2. Add a New Data Source: Navigate to Configuration > Data Sources from the side menu, and click on Add data source. Select MySQL as the type of data source to add.\n  3. Configure the Data Source:\n\n  * Host: Enter your Aiven MySQL database host and port.\n  * Database: Specify the name of your database.\n  * User and Password: Input your database user and password.\n  * Ensure you select SSL Mode\n  * Save & Test: After filling in the connection details, click Save & Test to ensure Grafana can successfully connect to your MySQL database.\n\n### Step 3: Import the Dashboard into Grafana\n\nYou're now ready to import the custom dashboard with the data source\nconfigured.\n\n  1. Open the Import Interface: In Grafana, go to the side menu, click the + icon, and select Import .\n  2. Import the Dashboard: Click on Upload JSON file and select the dashboard JSON file you downloaded in Step 1. Grafana will prompt you to select the data source you've just configured. Choose the MySQL data source connected to your Aiven database.\n  3. Complete the Import: Follow the import wizard's instructions to finish importing the dashboard. Once imported, the dashboard will be ready to use and to display your weather data.\n\n### Step 4: Visualize Your Data\n\nNavigate to your new Weather Station Visualization Dashboard in Grafana to see\nyour ESP32-collected weather data come to life. As new data is inserted into\nyour MySQL database, the dashboard will update, providing real-time insights\ninto temperature, humidity, and pressure conditions.\n\n## MySQL Security Considerations\n\nIn this tutorial, we have used a user with full database access, which is OK\nfor a DIY project. However, tighter security is paramount for a professional\nproduct interfacing with MySQL. MySQL enables us to restrict user access\neffectively. A prudent step is creating a user with permissions limited to\nonly inserting and fetching data from the weatherdata table. This approach\nminimizes risks and ensures our database operations are secure and efficient.\nHere's a conceptual guide to setting this up:\n\n  1. Creating a New User: Use the MySQL CREATE USER command to create a user with a password.\n  2. Granting Permissions: Use the GRANT statement to grant this user specific permissions. For inserting data and fetching data from the weatherdata table, you would grant INSERT and SELECT permissions. This ensures the user (the ESP32) can add new entries into the table and read from the table (Grafana) but cannot modify or delete existing data or access other parts of the database.\n\n## Stuck on a Design Detail? Let's Solve It Together:\n\nDive deep into our treasure trove of embedded web server and IoT tutorials\ndesigned for enthusiasts like you. Yet, if deadlines loom or challenges arise,\nremember our experts are on standby. With Real Time Logic, you have the\nfreedom to learn and the assurance of expert support when you need it. Let's\nbring your project to fruition your way.\n\nIoT Toolkit\n\n### Barracuda App Server\n\nExpedite your IoT and edge computing development with the \"Barracuda App\nServer Network Library\", a compact client/server multi-protocol stack and IoT\ntoolkit with an efficient integrated scripting engine. Includes Industrial\nProtocols, MQTT client, SMQ broker, WebSocket client & server, REST, AJAX,\nXML, and more. The Barracuda App Server is a programmable, secure, and\nintelligent IoT toolkit that fits a wide range of hardware options.\n\nTLS Client & Server\n\n### TLS Stack & IoT Protocols\n\nSharkSSL is the smallest, fastest, and best performing embedded TLS stack with\noptimized ciphers made by Real Time Logic. SharkSSL includes many secure IoT\nprotocols.\n\nSMQ IoT Protocol\n\n### IoT Device Control\n\nSMQ lets developers quickly and inexpensively deliver world-class management\nfunctionality for their products. SMQ is an enterprise ready IoT protocol that\nenables easier control and management of products on a massive scale.\n\nSecure MQTT\n\n### Secure MQTT Client\n\nSharkMQTT is a super small secure MQTT client with integrated TLS stack.\nSharkMQTT easily fits in tiny microcontrollers.\n\nOPC-UA\n\n### OPC-UA Client & Server\n\nAn easy to use OPC UA stack that enables bridging of OPC-UA enabled industrial\nproducts with cloud services, IT, and HTML5 user interfaces.\n\nEdge Controller\n\n### Edge Controller\n\nUse our user programmable Edge-Controller as a tool to accelerate development\nof the next generation industrial edge products and to facilitate rapid IoT\nand IIoT development.\n\nOn-Premises IoT\n\n### On-Premises IoT Platform\n\nLearn how to use the Barracuda App Server as your On-Premises IoT Foundation.\n\nEmbedded Web Server\n\n### Barracuda Embedded Web Server\n\nThe compact Web Server C library is included in the Barracuda App Server\nprotocol suite but can also be used standalone.\n\nWebSocket Server\n\n### Microcontroller Friendly\n\nThe tiny Minnow Server enables modern web server user interfaces to be used as\nthe graphical front end for tiny microcontrollers. Make sure to check out the\nreference design and the Minnow Server design guide.\n\nWebDAV Server\n\n### Network File System\n\nWhy use FTP when you can use your device as a secure network drive.\n\nHTTP Client\n\n### Secure HTTP Client Library\n\nPikeHTTP is a compact and secure HTTP client C library that greatly simplifies\nthe design of HTTP/REST style apps in C or C++.\n\nWebSocket Client\n\n### Microcontroller Friendly\n\nThe embedded WebSocket C library lets developers design tiny and secure IoT\napplications based on the WebSocket protocol.\n\nSMTP Client\n\n### Secure Embedded SMTP Library\n\nSend alarms and other notifications from any microcontroller powered product.\n\nCrypto Library\n\n### RayCrypto C Library\n\nThe RayCrypto engine is an extremely small and fast embedded crypto library\ndesigned specifically for embedded resource-constrained devices.\n\nEmbedded PKI Service\n\n### Automatic SSL Certificate Management for Devices\n\nReal Time Logic's SharkTrustTM service is an automatic Public Key\nInfrastructure (PKI) solution for products containing an Embedded Web Server.\n\nModbus\n\n### Modbus TCP client\n\nThe Modbus client enables bridging of Modbus enabled industrial products with\nmodern IoT devices and HTML5 powered HMIs.\n\nPosted in Xedge32\n\nReal Time Logic \u00a9 2024\n\nContact Us\n\n", "frontpage": false}
