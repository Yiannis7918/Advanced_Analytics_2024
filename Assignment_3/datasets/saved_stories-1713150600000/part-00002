{"aid": "40034496", "title": "Life Before Demos \u2014 or, Hobbyist Programming in the 1980s (1996)", "url": "http://www.oldskool.org/shrines/lbd", "domain": "oldskool.org", "votes": 1, "user": "Lammy", "posted_at": "2024-04-14 21:08:53", "comments": 0, "source_title": "Life Before Demos", "source_text": "Life Before Demos\n\n## (or, Hobbyist Programming in the 1980's)\n\n### by Trixter\n\nThis document recounts the early days of fun computer stuff on the IBM PC, so\nwhenever I refer to \"the computer\" or a similar generic term, I'm talking\nabout an IBM. If I mention the \"Tandy sound chip\", I'm referring to the sound\nchip that was present in both the IBM PC Jr. and the Tandy clones (it's the\nsame chip).\n\n## Introduction\n\nMany demosceners go through changes in life that affect them profoundly--\nchanges that either bring them into or force them out of the demo scene. I\nfind myself in the latter, which saddens me a bit, as I have not yet given\nback fully to the scene that has given me so much. I also welcome the change,\nas it is time for me to pass the baton onward to the newer generation of\npeople who will redefine what demos are. I look forward to what tomorrow's\nenterprising youth with a love of computers can bring to the demo scene.\n\nBut the new blood probably has no idea what was interesting before demos came\naround in 1990. Sure, everyone can download GR8 / Future Crew and have a laugh\nor two, but that's the tail end of what I call \"the golden age of PC fun.\" How\ndid anything become interesting or cool on the PC--a machine with no dedicated\ngraphics or music hardware? What held our attention before demos came along?\n\nGood question. Well, this article will attempt to describe the changes in my\nlife that brought me into the scene--what was interesting to me as I grew up\nwith a PC, starting out in 1984 with a new 4.77 MHz processor and ending in\n1990, the proper birth of the PC scene. It will be fascinating to some, and\nonly mildly interesting to others, but it needs to be remembered in the sea of\nPentium Pros, Windows 95, and accelerated hardware. Trust me, it used to be\nnothing like it is now. :-)\n\nAlso, I will try to cover some of the more eclectic technical information\nunless I don't remember it clearly, so if you want more info on how something\nwas done, email me and there's a good chance I can find it somewhere. Hope you\ncan parse BASIC code. :-)\n\nSo, if you've ever wondered what was interesting or \"demo-like\" on the PC\nbefore demos came around, this article will probably explain it. Let's journey\nbackward, shall we?\n\n## The Wonderful World of Games\n\nLet's start briefly with something that held my fascination long before demos\nexisted (and probably what contributed to their birth): Games. It's not too\nsurprising that the most impressive stuff on any home computer is a game.\nGames are, in fact, some of the hardest things in the world to program, and in\nthe early days, nothing was more true.\n\nThink about it: You had to do many or all of the following: Accept input,\ndisplay graphics (quickly), play sound effects, process artificial\nintelligence and other game elements, and do it all quickly enough so that the\nuser didn't feel cheated out of a decent gaming experience. Of course, there\nwas a multitude of problems in doing this on the original PC:\n\n  * The CPU, an Intel 8088, was a 16-bit processor (8-bit bus) running at 4.77 MHz.\n  * The sound hardware was a single-voice tone generator with no volume control.\n  * The stock graphics hardware (CGA) was limited to 4 colors, and had an interlaced memory organization (not nice and linear like Mode 13h).\n  * The bus was so slow that video memory and port writes were time-consuming; simply reading the joystick port took up to 15% of the CPU's time.\n\nSo it's obvious that a well-written game that was fast and fun to play was\nincredibly impressive, since things just simply weren't fast on the PC. I will\nmention games liberally in my musings. Just thought you'd like to know. ;-)\n\n## Teaching An Old PC New Tricks\n\nHow do you make a bland, boring \"business\" computer do something impressive?\nGood question. While newer (1984) versions of the PC (IBM's PCjr, and Radio\nShack's clone, the Tandy 1000) had more sound and graphics capabilities, the\nolder PC did not, and that was what had the largest installed user base. So,\nyou had a couple of areas to improve on: Sound, Graphics, and anything that\nwould speed up the system. Since a program's first impression was usually how\nit looked, many chose to improve the CGA graphics.\n\nCGA (Computer Graphics Adapter) always struck me as finicky. The video memory\nlayout was interlaced, which means that the first 8K was every even-numbered\nscanline and the last 8K was every odd-numbered scanline. Plus, there were 192\nbytes unused at the end of both 8K sections, so that became annoying to skip\nas well. Finally, you had one of two fixed palettes of nasty, ugly colors\n(cyan, magenta, and white; or red, green, and yellow) to choose from. While\nsome of the best artists could deal with four colors adequately, the crappy\ncolor set usually disgusted the user.\n\nWell, I quickly found out that by fiddling with the video registers, I could\nget an unadvertised (to my manuals, anyway) color palette that seemed to\ncombine the two palettes. The resulting 4-color palette had black, white,\ncyan, and red--much nicer. I'm sure this palette was advertised somewhere\nbecause some game I had used it, which is what got me sending random bytes to\nthe video ports in the first place.\n\nSending random bytes to the video registers, by the way, was extremely\ndangerous! If I had known that then, I wouldn't have even tried at all; I was\nlucky I didn't break anything. The monitors back then (1987 and earlier) were\nfixed frequency monitors, and ran at low frequencies. If you told the video\ncard to do something outside of those frequencies, you stood an excellent\nchance of damaging the monitor. A friend of mine was trying to get the rumored\nCGA 16-color mode to work (more on this later) and destroyed his Compaq's\nbuilt-in monitor, a small monochrome monitor that emulated color with\ndifferent shades of gray. He went to the nearest Compaq dealership to get it\nreplaced, and when they refused to fix it, he answered with something like,\n\"Well, I could demonstrate how easy it is to break the monitor to your\ncustomers by typing in a three-line BASIC program on, oh... this machine over\nhere,\" and pointed to their top-of-the-line machine that some customers were\nhuddled around. They quickly replaced his monitor to shut him up. :-)\n\nLet's face it: CGA was crap. The C64 blew it away in terms of speed, and even\nan Apple ][+ had more colors to choose from. Anything you could do above what\nit was normally used for, quickly or differently, was neat. So, a bit of\nexperimentation exposed that you could change the background color, usually\nblack, to one of the 16 text colors. This allowed for a quick flash (possibly\nfor an explosion in a game), which was slightly impressive since nothing about\nCGA was quick. This trick was also commonly used to change the black\nbackground to blue, which made it easier to draw bright and colorful pictures\nif you didn't need the color black. This same technique could be used to\nchange the foreground and background color of the monochrome graphics in CGA's\n640x200 2-color mode. (Love that 640x200 2.6:1 aspect ratio--NOT!) This wasn't\nuseful for games, but was used to make black-and-white pictures look less...\nugly.\n\nOther palette fun could be had by changing the border color, which was largely\nan overscan hack. It was cute to have the border change colors and not\neverything else. I didn't even know the border could be a different color for\na while--nothing bothered to change it. Another cute hack was to write to the\nports to change from 320x200x4 to 640x200x2 on the fly without erasing video\nmemory. This way, you essentially faked a color-to-mono toggle switch.\n\nThe only game I ever ran that used some of the above tricks to do some\nprimitive copper effects was California Games (1987). Its video selection menu\nhad the normal CGA 4-color mode, but it also had a mysterious CGA \"more-color\"\nmode. The \"more-color\" mode was only used in two places: The title screen and\nthe hackeysack portion. Why? Because those screens had a clear horizontal\ndivision of a graphic on the top half of the screen and one on the bottom\nhalf. The \"more-color\" mode would switch palettes at a certain scanline to\ndisplay one set of colors on the top graphic, and a different set of colors on\nthe bottom. As you can imagine, this was unnervingly time-critical, and self-\nprogramming vertical-retrace interrupts took too long (hey, you needed all the\nspeed you could get) on a 4.77MHz machine, so this trick only worked on the\none machine that they could hard-code the values into: The original IBM with\nan original CGA. I always used to think that this mode didn't do anything\nuntil I brought it over to my friend's house and saw it work. It worked pretty\nwell, oddly enough. Maybe I was just easy to impress. :-)\n\nHere's a bit of trivia: Checking for Vertical Retrace has been the same\nprocedure since CGA on up--you simply monitor port 3dah. Until I discovered\nthat port, I always wondered why delaying 13 or 14 ms before updating the\nscreen made it nice and smooth, but that's because 1000 ms / 70 Hz (the screen\nrefresh rate) is about 14.2 ms. ;-) Nobody ever bothered to monitor the\nvertical retrace port unless they were trying to avoid snow on CGA screens.\n\nSnow, you ask? What, you don't know about snow? CGA boards, for a reason I\ncan't remember, displayed \"snow\" in text mode whenever you wrote to the screen\nmemory directly (the BIOS writes avoided snow, but were terribly slow). Since\nI'm typing this article on a CGA PC right now (I'm not kidding--my word\nprocessor runs in 384k! ;-), I'll describe what it looks like: Every time\nvideo memory is touched, small horizontal white lines one character cell wide\nappear and disappear all over the screen. It can get really annoying after a\nwhile, so many people waited for vertical retrace before writing to the\nscreen. This was much slower, but reduced snow a great deal, and was still\nfaster than using the BIOS to output text.\n\nph@nocom.se had the following extra information to offer:\n\n> \"If my memory serves me right, the snow on the CGA was because when the CPU\n> and the video card both tried to access the one-ported video memory, the CPU\n> would lock out the video cards access until the read was completed.\"\n\nCyberTaco clarified this a bit:\n\n> \"I believe you were wondering what causes CGA snow (wow, it's been a long\n> time!)? It goes like this:\n>\n> \"The ram in the standard IBM CGA card was what was called single-ported,\n> meaning that it could not be written to and read from at the same time. If\n> you were writing to the ram, it simply ignored read requests and you got a\n> random result from it instead. Single-port ram was used because at the time\n> both because it was cheaper than dual-port ram (can read and write at the\n> same time, like we're all used to), and because IBM was (is?) staffed by a\n> bunch of idiots. :-)\n>\n> \"End result: When scrolling the screen up a line, every single piece of\n> character memory has to be written to the memory area corresponding to one\n> line above where it was. While this is happening (sloooooly), every time the\n> physical picture-generating hardware goes to read the ram to figure out what\n> dot to put where on the monitor, it keeps getting random results over and\n> over because the ram is being written to during the scroll. The end result?\n> Random dots all over the screen instead of text, resembling static, or....\n> snow. :-)\"\n\n## Low Resolution equals More Color\n\n16 colors in graphics mode with a stock CGA board? Believe it or not, there\nwas not one but two legitimate ways to get more than 4 colors on a CGA card:\nAn undocumented \"low res\" mode (which I'll talk about later), and CGA's\nComposite Color mode. Both had drawbacks, unfortunately:\n\n  * Since you only had 16K of video memory, your effective resolution went down to accommodate the extra colors--160x200 in Composite mode, and 160x100 in \"lowres\" mode.\n  * Not all PC's had a CGA card with a composite color jack on the back of their CGA card. The few PC owners that did have one most likely didn't know how to turn it on if it needed special activation before the program ran.\n  * Computer owners that had real monitors had little reason to keep a TV close to the computer to hook it up for the extra video mode provided by Composite Color.\n\nBut many game companies wanted to have every edge they could over the\ncompetition, so many decided to use it. (Starflight from Electronic Arts was\nthe first mainstream game I can remember (1986) that used it well.) The only\ndrawback, with any sort of compatibility back then, was speed--if all your\ngraphics were in 16 colors, then you had two problems on your hands: You\neither had to convert the 16-color pictures down to 4 on the fly, which was\nslow, or you had to provide both sets of converted pictures on the disk, which\ntook up too much room and cost more money. (Remember that back in the first\nhalf of 1980, disks were still fairly expensive--I remember the best price I\ncould get on a 360K floppy in 1984 was a dollar a disk.)\n\nStill, some companies saw the light and did it, and the result was colorful\ngraphics on almost any system. Besides, you could use a lookup table to\nquickly plot the low-res sprites, because a word (two bytes) plotted 8 pixels\nin CGA or 4 pixels in EGA/Tandy (16 colors). (Plus, this gave Tandy/PCjr\nowners some extra speed because they had a native 160x200 mode, so they got\nmore color without slowing down.) California Games from Epyx supported\nprobably the most graphic options of any game in 1987 using this technique,\nincluding CGA, EGA, CGA \"more-color\" (see above copper trick), CGA Composite\ncolor, Hercules Mono, MCGA/VGA 16-color, and Tandy/PCjr. All the graphics and\nsprites (except for the font) were in 160x200. Mindscape also did the same\nthing with Bop'n'Wrestle, Uridium, and Bad Street Brawler (hi Lord Blix!).\n\nMany companies used the 160x200 trick even if they didn't have 16 colors to\nstore, simply because the sprites took up half the space. All the \"Maxx Out\"\ngames from Epyx like Rad Warrior used this even though the graphics were\nmostly 4 colors.\n\nFinally, some adventure game companies found a unique way to store over 200 or\nmore full-screen pictures on a single 360K disk: Vectors. (By \"Vectors\", I'm\nreferring to a series of points that define the beginning and end of a line,\noutline of a polygon, etc.) Regardless of how large or complex the picture\nwas, you could usually fit a decent-looking scene into about 2K, because all\nyou were storing were polygon outlines/definitions. A blue circle with a\nradius of 100 pixels located at (100,130) could take up over 10K as a raw\nsprite/bitmap, but it only took up enough bytes to describe \"circle, at\n(100,130), radius 100, color blue\" when you stored it as its vector\ndefinition. The previous example could take up as little as 7 bytes, if you\ndid it haphazardly:\n\nData| Size  \n---|---  \nDraw Element| byte  \nX Coordinate| word  \nY Coordinate| word  \nRadius| byte  \nFill Color/Pattern| byte  \n  \nCome to think of it, I'm sure the game programmers were much more frugal than\nthat; this was when games had to fit on a single 360K disk. The previous\nstructure would've probably been optimized even further:\n\nData| Size| Comments  \n---|---|---  \nDraw Element| first 3 bits of first byte| Holds 8 different types: Square,\nCircle, Line, Pixel, Fill Point, etc.  \nFill Color/Pattern| last 5 bits of first byte| Allows for 32 different colors\nor patterns  \nX Coordinate| word| Must be a word, since the maximum (320) wouldn't fit in a\nbyte (255)  \nY Coordinate| byte| Could be a byte, since the maximum (200) fits into a byte\n(255)  \nRadius| byte  \n  \nSo, even though 7 of the 16 bits in the xcoordinate word are wasted and could\nbe used for even more things, we're down to five bytes for the information\nrequired to draw a large circle on the screen. You can pack this down even\nfurther, which I'm sure they did, but I included the above merely as an\nexample into the thought process involved.\n\nAnother nice advantage to this system was that you could compose your pictures\nwith 16 colors and let the drawing algorithm pick the closest color or dither\npattern when it drew the vector objects on the screen at runtime. But, as with\nall computer programs, there was the classic speed vs. size tradeoff: Drawing\nthe polygons took a lot of time, sometimes as much as six seconds for the\npicture to assemble, which looked sloppy. There were other drawbacks to this\nsystem as well; the artist was forced to use an uncommon vector-editing\nprogram, which usually had to be developed in-house, and the nature of the\nwhole vector format procedure made it hard to produce pictures with a lot of\nfine detail. Still, Sierra used it in King's Quest I (1983), and the classic\ntext/graphics adventure Transylvania (1983) from Polarware used it as well.\n(In fact, when Polarware was still called Penguin Software, they marketed a\nvector drawing package specifically built for making small graphics for games\ncalled The Graphics Magician.)\n\n## Graphics Forged From Text Mode\n\nAh, now the fun part: 16 color graphics on a standard CGA card. IBM actually\nannounced this mode in January of 1982, when the second version of the IBM PC\ncame out; it's mentioned in their technical documentation, but they evidently\nsaw no need to provide any real documentation for it unless asked. I guess\nnobody asked. :-) By the time I finally figured out how to program the mode,\nit was 1990 and I had a VGA card, so I never had a chance to use it in\nanything. Some games did use it, though, including a good shareware\nshoot-'em'up called Round 42 and two commercial adventure games, one from Sir\nTech (remember Wizardry?) and another from Macrocom called ICON (1984). Here's\nhow you program the mode:\n\nThe 160x100 \"graphics\" mode was actually a text mode. The video registers were\nchanged so that normal 80x25 color text mode squeezed four times as many rows\nof text characters onto the screen to produce an 80x100 text screen with the\nbottom 75% of the text characters chopped off. Then, the screen was filled\nwith ASCII 221, which is the left vertical bar. Each character on the screen\nwas used for a pair of two horizontally adjacent pixels by adjusting the\nforeground and background color of that character. The \"blink\" option on the\nvideo board had to be turned off so that pixels didn't blink when the right-\nhalf pixels (which use the text background color) had a color value greater\nthan 7. (Text characters normally blink if the background color is in the\n8...15 range, but who uses blinking any more?)\n\nOkay, cute trick. You could make it work in today's world by modifing it for\nEGA and VGA boards as well; on VGA boards, the text character height is\nnormally 16, so it would be changed to 4. EGA boards, however, normally use a\ntext height of 14 pixels. There is no way to change the text height to exactly\none quarter of 14 pixels, so a text height of 3 would have to be used, which\nis slightly too small, but that's what you get for using EGA after 1990. :-)\n\nTechnical details: Blink is suppressed on CGA boards by setting bit 5 of port\n3d8 hex to 0. On EGA and VGA cards, blink is suppressed by using subfunction\n3h, function 10h of interrupt 10h and setting BL to 0. Trivia: The 160x100\nmode uses 16000 bytes at b800:0000 hex to store 16000 4-bit pixels, which is\ntwice the amount of memory that would be required in a normal graphics mode--\nso each even byte of video memory is wasted to store the ASCII character 221.\nMoving blocks of video memory around was both fast and annoying, since only\nthe odd bytes (storing the text foreground and background colors) had to be\nmodified.\n\nWell, that's enough about CGA's 16-color \"graphics\" mode. I was just so happy\nwhen I figured it out that just had to spew somewhere. :-) And ICON? They\nadded even more depth by using the entire ASCII character set--or, at least,\nthe top four scanlines of the entire ASCII character set. (The bat's wings\nwere the top four scanlines of ASCII #2, which was the smiley!) Some of the\nresults were fantastic, but that's ANSI from hell that I don't think anyone\nwould want to ever attempt again.\n\n## If You Want Something Done, You Have To Do It Yourself\n\nDemosceners are familiar with speeding up graphics with cute math and hardware\ntricks. But what do you do when the machine is simply too slow? Speed up your\nhardware. It sounds silly, but there were actually several ways to make the\nmachine run faster--via software--by modifying certain bits of hardware. For\nexample, the CPU spent time refreshing early DRAM so that the RAM wouldn't\nlose its contents. This refresh rate was adjustable and usually done way too\noften, so you could usually lower it a bit and gain more speed for your\nprograms. Speed increases of 5% to 10% were not uncommon; I got a 15% increase\nby lowering the DRAM refresh rate gradually until the computer locked up. :-)\nI then used the last setting that didn't lock up the computer. Handy thing to\nhave in your autoexec.bat, that.\n\nBut probably the most common method that game programmers used to speed up the\ncomputer was to go for the guts and bypass the operating system in a big way--\nby creating self-booting programs. This solved several problems at the same\ntime:\n\n  * Disk access and loading times were much faster. If you wanted data and knew where you put it, you seek directly to the track and load the entire track to somewhere in memory. If you were a real hotshot, you could trackload \"manually\" by not using the BIOS and instead using DMA. Very quick.\n  * You had more RAM. The operating system took up at least 32K of ram, which your program could have used. (Hey, PCs came with only 128K of RAM until around 1985, so you really needed to save RAM.) So, make your entire program fit into 64K and write a little 446-byte bootloader and you gain that RAM back.\n  * The machine was empty. There was no operating system to get in your way, so you could reprogram timers, write obscene self-modifying code, store data in unused portions of the BIOS (or vector table--ACK!), whatever you wanted to do. If the computer were a parking lot, it would be an empty parking lot--you could drive like a maniac for hours and not hit a thing.\n\nOf course, you had to be a damn fine coder to do this. Being merely proficient\nin assembler programming wasn't enough--remember all those friendly DOS\nservices you use? Gone. So, you'd better be prepared to write your own mini-\nDOS when you needed one.\n\nSometimes self-booting programs were mandatory; it was the only way to have\nany decent form of copy-protection. Stuff like that was really hard to crack.\nIn fact, I don't think anyone in today's world would have the stomach to\nattempt it. Not only does the game boot (hel-LO!), but it then proceeds to\nstomp all over memory, usually obliterating the debugger. Your only chance is\nto dump the boot sector and attempt to disassemble it manually. (While the\ngame programmers were tough back then, so were the crackers, so it got done\nsomehow.) The most common programs that come to mind are the early Accolade\nand Electronic Arts games; Pinball Construction Set and Music Construction Set\n(forever classics), for example. Of course, the classic Wizardry did this as\nwell, although it took them two tries to get it right: The first version of\nWizardry was not very friendly to non-perfect-100% IBM compatibles, so the\nmore you played the game, the less successful the disk reads were. Odd... The\nsecond version played just fine, however. They even took the time to improve\nthe graphics.\n\n## Don't Copy That Floppy\n\nLet's sidetrack for a minute or so on copy-protection schemes. Although they\nhad nothing to do with graphics or sound explicitly, I still found them\nabsolutely fascinating, since they were also very hardware-intensive.\n\nCopy-protection, for those too young to remember, was a method of doing\nsomething to the diskette the game came on that made writing a perfect\nduplicate impossible, which in turn prevented you from copying the disk and\ngiving it to all your friends, robbing the software company of potential\nsales. A typical method of checking went something like this: When the game\nstarted, it checked to see if it was running on the original diskette by\nlooking for a specific piece of data stored in an extra sector hidden in a\nspecially formatted track. If it didn't find that data, it aborted. This way,\nyou could only make the program run by running it off of its original\ndiskette. (Nowadays, \"copy-protection\" is usually as simple as the program\nasking you to look up a word on a certain page in your software manual and\ntype it in, or for CDROM games, checking to see if it is running on the CDROM\ndevice.)\n\nCopy-protection used to be included on everything, from games to business\nsoftware, simply because software was extremely expensive back then, and a\ncouple hundred copies of a program could actually make or break a software\ncompany (no, I'm not kidding). People just didn't buy software all the time\nbecause a typical game (for example) was $50. That's normal in 1996, but very\nexpensive for 1984. (Think about it: $50 in 1984 is like $95 today due to\ninflation. I don't know about you, but I'm not willing to pay $95 for a\ncomputer game.)\n\nI wasn't any good at cracking back in 1984 (I barely knew general programming,\nlet alone assembler), so I had to become good at figuring out the copy\nprotection scheme instead if I wanted to duplicate the program. While many\ncrackers learned DEBUG inside and out, I learned protection schemes and how to\nduplicate diskettes. Here's some of the more interesting methods that\nprogrammers used to prevent you from copying that floppy with DOS's standard\nDISKCOPY:\n\n  * Simple trickery. Format a diskette as single-sided, but then store the secret copy-protection information on a track formatted on the second side. DISKCOPY would read the boot sector, determine that the disk was single-sided, and only bother copying the first side.\n  * User stupidity. The program would simply try writing a dummy file to the disk. Since most commercial software came on write-protected disks, the write would fail, and the program would continue. But if you'd just made a copy, chances were high that you'd forget to write-protect the disk when you were finished, and the write would succeed, which then aborted the program.\n  * Secret hardware information. Most disk drives could actually seek beyond track 40; usually to 41. Some software companies formatted that extra track (DISKCOPY didn't go that high) and stored secret info in it for the program to check.\n  * Wacko disk formats. This is when you go slightly beyond the obvious, like formatting a normal 9-sector track with 10 or 11 sectors (or less, like 4 or 5), or by writing an incorrect track ID (track 20 says its track 30, etc.), or something similar. DISKCOPY didn't know how to handle stuff outside the norm like this, so you usually needed a special program like CopyIIPC or CopyWrite to analyze the diskette thoroughly, then attempt to duplicate the format. This was about 66% successful; the other 33% you had to do yourself, usually (I personally used the Ultra Utilities). Electronic Arts had one of the best schemes in the early 80's; I couldn't figure it out until about 1985. They formatted track 15 with over 90 sectors! :-D\n  * Weak Bits. Some bits on the disk were recorded as halfway between 1 and 0, which made the disk difficult to copy. This wasn't used too often because it was unreliable, even on the original disk!\n  * Damage. The most expensive method of copy protection was also the most effective: Physically damage the disk. Using a laser, it was possible to burn a small hole in the disk surface, and then all the program had to do was check to see if there was a read error in that particular sector, and if so, continue running the program. If you turned the disk surface manually by grabbing the inside ring, you could actually see a tiny hole in the disk surface!\n\nIf it was so easy (relatively speaking) to figure out these formats, then why\ndidn't everybody just write bitcopy or nibbler programs to analyze the\ndiskette and make perfect copies of everything (except the laser hole, of\ncourse)? It wasn't quite that easy: While the IBM floppy controller could read\nall of these formats, it did not have the ability to write all of them. A\nthird-party company (usually the diskette duplication facility itself)\nspecially prepared the diskettes using custom floppy controllers. To this day\nI don't know if the read-all-but-not-write-all phenomenon was a decision made\non purpose by IBM's engineers or just a hardware glitch that software\ncompanies took advantage of. (Probably a hardware glitch.) Either way, I\neventually broke down in 1987 and bought a Copy ][ PC Option Board, which went\nbetween the floppy drive and controller, allowing me to write those special\nformats. Trivia: To this day, there is only one diskette I have never been\nable to duplicate, even with the help of my Option Board: A Cops Copylock ][\ndemo diskette that I sent away for (Cops was a third-party copy-protection\nlibrary you could purchase to copy-protect your own programs). I never found\nany programs that actually used Cops as the copy protection scheme, which was\nfortunate, since I couldn't copy it. :-(\n\n## Your Computer Is Too Damn Loud\n\nAh, music. Certainly one of the most interesting things done with computers\ntoday in the demoscene; in fact, at least twenty times more MOD/S3M/IT/XM\nmusic is being put out per year than demos, and that figure is steadily\nincreasing. Until Sami came out with Scream Tracker in 1990, there was no\nnative digital/multi-channel composition program. Heck, until 1986, there\nwasn't even any sound hardware you could hook up to your PC. Sure, the PCjr\nand Tandy had their own 3-voice sound chip built in, but I didn't have a Tandy\nor PCjr.\n\nThat didn't stop me. :-) Or anyone else, for that matter. People did the best\nwith what they had, with surprising results for the time and hardware. Ladies\nand Gentlemen, I present to you the evolution of composed/tracked personal\ncomputer music hardware and techniques, from the point of a fledgling\ndemoscener (which means I'll conveniently ignore MIDI):\n\n1981-1982\n\n    \n\nThe PC speaker, driven by a chip that could only produce a simple tone at a\nfixed volume, was the only thing that kept us company. If it weren't for\nBASICA, we'd live in silence. BASICA had a PLAY statement that took real notes\nand octaves; you could bang out a melody relatively quickly, although it was\nloud and harsh. You could fake a chord by quickly alternating between\ndifferent notes at the same time (an arpeggio), but this sounded artificial\nand bubbly. (If you didn't have a love for computer music, it would quickly\ndrive you crazy.) Pianoman by Neil J. Rubenking was a music composition\nprogram that did this; you could compose each voice separately, and then\ncombine them into an arpeggio. A gentler trick was to adjust the pitch up and\ndown very finely, simulating vibrato. One voice, but at least it wasn't so\nharsh.\n\n1983\n\n    \n\nThe PCjr is released, and Tandy follows suit a year later with the Tandy 1000,\nwhich was a clone of the PCjr. One of the enhancements in the PCjr was the\naddition of a 3-voice sound chip that gave multiple channels, noise\ngeneration, tone envelopes, and volume control to the built-in speaker. Now we\nhad something to play with. The BASICA that came with the PCjr and Tandy\nsupported a 3-voice PLAY statement, which, if you played your cards right,\ncould produce some fairly nice sound. One thing I discovered was that the\nTandy chip had a hidden strength in low chord layering.\n\n1984\n\n    \n\nMusic Construction Set, programmed by Will Harvey, came out for the PC in 1984\nfrom Electronic Arts. It had a real staff, with treble and bass clefs, and had\na neato \"construction set\" motif--you could drag'n'drop notes onto the staff\nbefore \"drag'n'drop\" was a common catch phrase. Best of all, not only did it\nsupport the native sound chip of the PCjr/Tandy, but it could play four voices\nthrough the normal built-in speaker! (Granted, it was difficult to discern\nbetween the voices, but it was possible to hear the overall chord you were\ngoing for.) You could even print out the staff on your printer, although it\nwas one long staff down the side of the page, and not nicely formatted sheet\nmusic. :-)\n\n1986\n\n    \n\nMindscape publishes Bank Street Music Writer, the first program I ever bought\nthat came with its own hardware if you didn't own a Tandy or PCjr. The\n\"Mindscape Music Board\" was a 6 voice sound card which turned out to be a sine\nor square wave generator with simple attack, sustain, and delay parameters.\nNot exactly FastTracker 2 envelopes, but it was a start. :-) Plus, it\nattempted to print out real sheet music, and you could follow your voices on-\nscreen as they played. I went nuts with this board, sometimes spending hours\narranging the tunes my school choir was practicing. Although it was very good\nat producing solid chords (it was a tone generator, right?), it never took\noff, because the price was a bit high ($110) and it did sound a bit...\n\"plinky\". (Come to think of it, Music Construction Set for the Apple supported\na similar board called the Mockingboard, but that never took off either.)\n\n    \n\nI'm fairly certain that I saw the Covox Speech Thing around this time as well.\nThe Speech Thing was a simple digital-to-analog converter that you could\nconnect to your parallel port to hear digitized sound. It sold for about $70,\neven though the parts cost about $15--including the speaker. :-)\n\n1987\n\n    \n\nAdlib. :-) This famous board used a chip from Yamaha that produced Frequency-\nModulated (FM) sound synthesis through 2 operators and a variety of\nparameters. You could utilize 9 melodic voices, or 6 melodic and 5 percussion.\nArmed with the odd Visual Composer, you could compose on a piano roll instead\nof a musical staff. It wasn't bad at all; in fact, it sounded pretty damn\ngood. If programmed correctly, it could layer voices well, produce decent\nbass, and fairly full sounds. I still believe that the Adlib was (and still\nis) underused by the majority of people who composed for it.\n\n    \n\nWhile I didn't purchase my Adlib until 1989, the board was actually selling in\n1987, and games started supporting it in 1988. Taito's arcade conversions done\nby Banana Development supported it passably, but it wasn't until 1990 that I\nheard simply beautiful music through it from a game called Continuum from\nInfogramme. The game consisted of jumping from platform to platform to reach a\ncertain object, but the music was so good that I booted it up just for the\nmusic. (It also supported the Tandy sound chip, but since the music was\ncomposed for the Adlib, it was nowhere near the same quality.)\n\n    \n\nThe great former C64 demogroup Vibrants also did some excellent music composed\nspecifically for the Adlib board, but this wasn't until much later, in 1993,\nwhen they composed music for a few games. Their composition program, Edlib, is\nstill freely available. Ever hear techno on an Adlib? :-) (Their true strength\nwas jazz, which is what they usually composed.)\n\n    \n\nIBM Music Feature Card. This board was released from IBM in 1987 in an effort\nto draw MIDI musicians and game programmers over to the IBM. It cost about\n$250, and played 8 FM voices. The quality of the FM was much better than the\nAdlib, presumably since it used a 4-operator FM chip (also from Yamaha)\ninstead of Adlib's 2-operator chip, and had over 100 built-in instrument\nparameters. It also had a MIDI port, of course. Trivia: You could put two of\nthese boards in your PC at the same time to get a total of 16 simultaneous\nvoices.\n\n1988\n\n    \n\nCreative Music Systems (the name they had before they changed it to Creative\nLabs) came out with the Game Blaster around this time, and it offered 12\nchannels, with each channel producing either a single sine wave of a given\nfrequency and magnitude (in stereo), or noise. The sound quality was obviously\nworse than the Adlib--the board simply couldn't do much of anything. You can\nstill purchase CMS chips to put inside your Sound Blaster 1.x and 2.0, but\nit's really not worth it. The only game I know of that supported the CMS Game\nBlaster with decent music was was Times of Lore by Origin.\n\n    \n\nDigitized sound! Around this time, game companies had finally started to use\ndigitized sound for music. (It had been used on the PC for sound effects as\nearly as 1983, in Castle Wolfenstein/Beyond Castle Wolfenstein, and in 1987,\nin the PC version of Dark Castle.) While I had speculated that you could\nrecord bits of music and then rearrange them cleverly, a French game company\ncalled Loriciels beat me to it, with the excellent games Mach 3 (1987) and\nSpace Racer (1988) (they also did a then-popular Pong/Breakout/Arkanoid clone\ncalled PopCorn). These games had a really cool (for a PC at the time) musical\nintro at the beginning, which was pieced together from small sound snippets\nthat were arranged on the fly to form a longer piece of music. (You can think\nof this as a .MOD file with only one channel and all instruments/samples\nplayed at C#3.) And it played through the PC speaker! Coming from a PC that\nhad a simple tone generator as a sound device, this just blew me away. Crazy\nCars by Titus also had a snippet of digitized sound at the beginning, but this\nwas just a 64K sample that looped once. The same went for Wizball by\nMindscape. (Wizball was a fabulous game, IMHO.) Finally, games like\nBop'n'Wrestle used it for the counts and body-slamming noises.\n\n1989\n\n    \n\nThe Sound Blaster hits the scene, and game companies start supporting it. It's\nessentially an Adlib clone, but it has the ability to record and playback\ndigitized sound, allowing for speech and decent sound effects. (This\ninformation was essentially provided for people who don't know what a Sound\nBlaster is. I probably shouldn't have even written this paragraph, since the\n(in)famous Sound Blaster doesn't need mentioning, but I've done it already,\nso... whatever. :-)\n\n1990\n\n    True Mixing. While many remember TrakBlaster being the first program to play MOD files on the PC, a couple of people were mixing before then, most notably PSI / Future Crew. He had created and marketed Scream Tracker in 1990 as shareware, and it could mix and play up to four voices in real-time on an 8MHz (or faster) computer. The early versions of Scream Tracker supported a mode of operation similar to the old SoundTracker on Amiga--you could save the song data and instruments separately. This allowed you to compose over 20 songs and fit them on the same disk, because you use the same set of instruments with each song. EGA Megademo / SpacePigs did this--they had four different songs that used the same instruments, so the whole thing fit onto a single 360K disk.\n\n## A Brief Early History of Demos\n\nThis has been covered many times before, so I won't rehash The Beginning Of\nDemos excessively; however, a few tangible examples would probably serve to\nhelp you picture the transition.\n\nPirating games led to the birth of the demo scene. It's time everyone who is\nin deep denial about this fact comes out and accepts it. You can see this in\nthe early loaders for pirated games; as early as 1988 you can see some demo-\nlike effects in small loaders. The loader for Bad Street Brawler is a perfect\nexample of this: The screen starts as static; then, like a TV pirate\nintercepting a TV channel, the screen flickers with the title graphic, until\nfinally the title graphic is fully displayed. The entire program was only 128\nbytes, and was tacked onto the front of a CGA screen dump.\n\nThis \"loader mentality\" took a while to grow, but it eventually did. Many\nearly intros were simply one effect, but to be impressive, it had to be an\neffect never before seen on the PC. \"Never before seen\" meant one of two\nthings, actually:\n\n  * The effect was an Amiga or C64 effect that was translated to the PC (common), or\n  * The effect was an entirely new effect (rare).\n\nMany of the early Brain Slayer intros were good examples of the Amiga-effect-\nto-PC trend, and until .MOD playing on the PC became popular, most early\nintros had no sound at all.\n\n## Rose-colored Glasses\n\nWell, our look back has ended, and not a moment too soon, since I've taken up\nvaluable time that you could've used to write the newest demos. All I ask is\nthat the next time you take a look at the demos today that contain incredibly\ncomplex 3D objects, particle systems, and multi-channel digital music, or the\nnext time you compose music with 64 digital channels in Inertia Tracker, you\nthink about what it used to be like in the old days. Who knows... Maybe some\nof you will be as innovative as us old-timers needed to be in dealing with\nsuch limited, slow hardware.\n\nThen again, the driving force behind demos is that the hardware is only as\nlimited as you think it is. ;-)\n\n## Epilogue\n\nIt just wouldn't be fair for me to end this article without a list of old\ndemos that you should check out if you want to see the best of the best back\nin the old days (from 1990 to 1992). Keep in mind that these demos run at the\nfull framerate on a 386 running at 16 MHz:\n\nDemo| Group| Video| Sound Support  \n---|---|---|---  \nChronologia| Cascada| VGA| Sound Blaster, Internal speaker, LPT DAC  \nDragnet| DCE| VGA| Sound Blaster  \nPutre Faction| Skull| VGA| Sound Blaster  \nUnreal vers. 1.1| Future Crew| VGA| Sound Blaster, Gravis Ultrasound, LPT DAC  \nVectdemo| Ultraforce| VGA| Sound Blaster  \nColdcut| Ultraforce| EGA| Sound Blaster  \nEGA Megademo| SpacePigs| EGA| Internal speaker, LPT DAC  \n  \nAnd, as always, if you're interested about demos in general, please feel free\nto free to check out PC Demos Explained or download the PC Demos FAQ list.\n\nWritten by Jim Leonard. Completed September 25th, 1996. Special thanks to\nGeoffrey Silverton for some low-level \"lowres\" information.\n\nThis file was last modified on .\n\n", "frontpage": false}
