{"aid": "40022246", "title": "Day 6 of Advent of Code in Hurl", "url": "https://blog.flowblok.id.au/2024-04/advent-of-code-2023-day-6.html", "domain": "flowblok.id.au", "votes": 2, "user": "ntietz", "posted_at": "2024-04-13 11:12:18", "comments": 0, "source_title": "Advent of Code 2023: Day 6 \u2014 flowblok\u2019s blog", "source_text": "Advent of Code 2023: Day 6 \u2014 flowblok\u2019s blog\n\n  * flowblok\u2019s blog\n  * Tags\n  * Archives\n\n  * atom feed\n  * mastodon\n  * twitter\n  * instagram\n  * facebook\n  * code\n\n# Advent of Code 2023: Day 6\n\nPublished on April 13 2024\n\nadventofcode aoc2023\n\nHurl is a dynamically-typed programming language that uses exception handling\nas its only form of control flow. Much of the syntax is unsurprising, but the\nforms of exception raising and handling deserve close examination.\n\nHere is the canonical way to do conditional branches in Hurl:\n\n    \n    \n    try { hurl 1 < 2; } catch (true) { println(\"hooray\"); } catch (false) { println(\"what weird machine are you running on this on?\"); };\n\nIn this example, the hurl keyword raises an exception with the value true,\nwhich then is matched by the catch (true) block. There are three forms of the\ncatch block:\n\n  * catch (<expr>) { ... } will match if the exception value evaluates equal to <expr>^1\n  * catch as <identifier> { ... } will match any value and make it available as an <identifier> variable in the catch body\n  * catch into <identifier> will match any value and assign it to an already-declared variable <identifier>\n\nHurl has functions, but since we have exceptions, there is no need for that\npesky return keyword: we can just hurl the value we want to return:\n\n    \n    \n    let add = func(x, y) { hurl x + y; }; try { add(3, 4); } catch as result { println(result); };\n\nThere is a second way to throw exceptions: if you toss a value, it will be\nmatch against the parent catch blocks, but when that block calls return^2\nexecution will resume from after the toss. Crucially, toss can be called\nmultiple times to invoke the parent catch block as many times as desired,\nwhich gives us a tool to build continuations.\n\n## Making Hurl even more exceptional\n\nHurl is an exceptional language, but some parts seem unexceptional to me. For\nexample, we only really need the let <ident> part of let <ident> = <value>,\nsince we can write:\n\n    \n    \n    # Today's Hurl: let add = 0; # Tomorrow's Hurl? #let add; try { hurl func(x, y) { hurl x + y; }; } catch into add;\n\nSince the value part is unnecessary and the language is dynamically-typed, I\nwill restrict myself to only ever assigning the value 0 with let, with the\nhope that this is removed from the language in the future.\n\nAnother unexceptional part of the language is the collection of built-in\nfunctions for I/O and manipulating numbers, strings and lists. Having such a\ncollection is necessary to make the language practical to use, but they\ncurrently evaluate as expressions rather than hurl'ing their results\u2014something\nthat user-defined functions cannot do.\n\nFortunately, it is not too difficult to build a compatibility layer to remove\ntheir special status. Wherever you see FOO_proper, this is a version of the\nbuilt-in function FOO that hurl's the result rather than evaluating to it. For\nexample:\n\n    \n    \n    let read_file_proper = 0; try { hurl func(filename) { hurl read_file(filename); }; } catch into read_file_proper;\n\nFinally, there is no need for builtin comparison operators in the language. We\ncan make these truly exceptional with a three-way comparison operator for\nnumbers:\n\n    \n    \n    let lt = 0; let eq = 0; let gt = 0; let cmp = 0; # Some enums or list unpacking would be neat... try { hurl 0; } catch into lt; try { hurl 1; } catch into eq; try { hurl 2; } catch into gt; # cmp(a, b) hurls lt (if a < b), eq (if a == b) or gt (if a > b). try { hurl func(a, b) { try { hurl a < b; } catch (true) { hurl lt; } catch (false) { try { hurl a > b; } catch (true) { hurl gt; } catch (false) { hurl eq; }; }; }; } catch into cmp;\n\nAnd for strings (which do not support lexicographic comparison in Hurl) we\nneed an explicit equality function:\n\n    \n    \n    let equals = 0; try { hurl func(a, b) { hurl a == b; }; } catch into equals;\n\n## Wait, what was I doing again?\n\nOh, that\u2019s right, we\u2019ve got an Advent of Code problem to solve. Today we have\ndata about some boat races. Each race has a duration: we can use some portion\nof this duration to charge our boat, and then we spend the remainder of the\nduration moving at a speed determined by how long we charged our boat for. If\nwe hold the button for hold of the duration milliseconds, then we will travel\nhold * (duration - hold) millimeters.\n\nIf we wanted to maximise that distance, we'd want the two parts of that\nmultiplication to be as close to each other as possible, so hold would be\neither floor(duration / 2) or ceil(duration / 2). But that's not our problem:\nwe want to know how many different ways we could beat a competitor who\nachieved a certain distance (target).\n\nWe could do maths to find an analytical solution, but that sounds like work,\nso let's not. We could also just evaluate every possible hold value, but it\nseems likely that Part 2 of the problem will make the problem bigger or more\ncomplicated, and maybe that would be too slow (but maybe not?). Or we could\nimplement binary search. That sounds more fun.\n\nIn order to binary search, we make use of the half-way point: we can split our\nproblem into the intervals [0, floor(duration / 2)] and [ceil(duration / 2),\nduration]: hold * (duration - hold) will be strictly increasing for the first\ninterval, and strictly decreasing for the second. So we can binary search the\nfirst interval for the smallest value of hold where hold * (duration - hold) >\ntarget (we start beating the competitor), and the second interval for the\nsmallest value where hold * (duration - hold) <= target (we stop beating the\ncompetitor). The difference between these hold values is the number of ways we\ncan beat them.\n\nSo anyhow, we need an implementation of binary search. Here\u2019s one using the\nloop function from Hurl\u2019s standard library:\n\n    \n    \n    let binary_search = 0; try { hurl func(lower, upper, fn) { try { loop(func(locals) { try { hurl locals.1; } catch as lower { try { hurl locals.2; } catch as length { try { hurl floor(length / 2); } catch as half_length { try { hurl lower + half_length; } catch as mid { try { fn(mid); } catch (true) { toss [lower, half_length]; try { cmp(half_length, 0); } catch (eq) { hurl false; } catch as ne { hurl true; }; } catch (false) { length = length - half_length + 1; toss [mid + 1, length]; try { cmp(length, 0); } catch (eq) { hurl false; } catch as ne { hurl true; }; }; }; }; }; }; }, [lower, upper - lower]); } catch as result { hurl result.1; }; }; } catch into binary_search;\n\nOn each iteration, loop invokes the function in its first argument with the\nparameter locals, which starts as the second argument ([lower, upper -\nlower]). Each time the function is invoked, it should toss a new value which\nwill replace locals for the next invocation, and hurl either true or false to\nindicate if the loop should continue. Finally, loop will hurl locals so the\ncaller can produce a result.\n\nThis example also shows off our three-way comparison operator^3: we catch eq\nexplicitly, but then aggregate lt and gt into a variable (the name doesn\u2019t\nmatter, but ne aids readability). You will also notice a bunch of faces that\nlook like they want to Hurl (}; }; }; }; };). These are from using catch as\nblocks in sequence, to avoid the use of let.\n\nAnyhow, we define a distance function and implement lower and upper as\nfunctions which do the comparisons used by the binary search, find the two\nvalues of hold and subtract them.\n\n    \n    \n    let distance = 0; let ways_to_beat = 0; try { hurl func(hold, duration) { hurl hold * (duration - hold); }; } catch into distance; try { hurl func(duration, target) { try { hurl func(hold) { try { distance(hold, duration); } catch as d { try { cmp(target, d); } catch (lt) { hurl true; } catch as ge { hurl false; }; }; }; } catch as lower { try { hurl func(hold) { try { distance(hold, duration); } catch as d { try { cmp(target, d); } catch (lt) { hurl false; } catch as ge { hurl true; }; }; }; } catch as upper { try { binary_search(0, floor(duration / 2), lower); } catch as l { try { binary_search(ceil(duration / 2), duration + 1, upper); } catch as u { hurl u - l; }; }; }; }; }; } catch into ways_to_beat;\n\nThat\u2019s the core of the problem, but we also need to parse the input and\nmultiply together the results of multiple races. The second part is fairly\nstraightforward, but parsing the input is a little more tricky, since we have\nnumbers with any number of spaces between them:\n\n    \n    \n    Time: 7 15 30 Distance: 9 40 200\n\nThere is a split function in the standard library, but it will turn \"7 15\"\ninto [\"7\", \"\", \"15\"], so we need to be able to remove empty elements. All\nthat\u2019s needed for this is filter(xs, pred) (returns a new list of the items in\nxs for which pred(item) returned true), but I thought I might need map\nlater^5, so implemented map_filter_nil(xs, fn) (returns a new list of fn(item)\nfor each item in xs, skipping items when fn returns nil). Unfortunately, while\nnil is a valid value at runtime, it\u2019s not part of the language syntax, so we\nneed to jump through a hoop to make it accessible:\n\n    \n    \n    let nil = 0; try { try { hurl func() {}; } catch as nil_producer { hurl nil_producer(); }; } catch into nil;\n\nAnd then we can implement map_filter_nil. It might be possible to write this\nbetter using one of the other loop functions in the standard library, but I\ndidn\u2019t immediately see anything which would work.\n\n    \n    \n    let map_filter_nil = 0; try { hurl func(xs, fn) { try { loop(func(locals) { try { at_proper(xs, locals.1); } catch as item { try { try { fn(item); } catch (nil) { hurl locals.2; } catch as value { hurl locals.2 + [value]; }; } catch as new_list { toss [locals.1 + 1, new_list]; try { cmp(locals.1, len(xs)); } catch (lt) { hurl true; } catch as ge { hurl false; }; }; }; }, [1, []]); } catch as rv { hurl rv.2; }; }; } catch into map_filter_nil;\n\nAnd then we can construct a split function that drops empty values:\n\n    \n    \n    let split_ignoring_whitespace = 0; try { hurl func(string, sep) { try { split(string, sep); } catch as rv { map_filter_nil(rv, func(s) { try { equals(s, \"\"); } catch (false) { hurl s; } catch as ne { hurl nil; }; }); }; }; } catch into split_ignoring_whitespace;\n\n## Part 2\n\nMy guess from earlier turned out correct: Part 2 makes the numbers bigger by\ncombining the races into one (in the example above, \"7 15 30\" is read as 71530\nand \"9 40 200\" as 940200). These numbers don\u2019t seem that big though, so I\nsuspect trying every hold value is perfectly viable.\n\nSo there were some minor changes to input parsing, but nothing particularly\ninteresting.\n\nAnyhow, I recommend having a read of Hurl\u2019s documentation, there are a bunch\nof interesting examples that demonstrate the capabilities of exceptional\ncontrol flow. And if you\u2019re the kind of person who thinks this is all very\nsensible, I can also recommend SIGBOVIK, whose 2024 proceedings are how I\ndiscovered this language.\n\nAs usual, a complete code listing is available in the repository.\n\n  1. The documentation says that it merely matches literals, but the implementation handles expressions, which seems intentional. \u21a9\n\n  2. There are some bugs (features?) in the implementation, so I can get this working without doing this. Also, hurl and toss behave slightly differently when invoked from a function within a try block than if inlined in that block. None of this really matters, if you hold the language as intended, it works fine. \u21a9\n\n  3. This example could also be achieved with equals, but you would still need two catch blocks to invert the boolean^4. \u21a9\n\n  4. Or I guess you could use the decidedly unexceptional unary not operator. \u21a9\n\n  5. I didn\u2019t. Oh well. \u21a9\n\n## Comments\n\n\u00a9 Peter Ward\n\n", "frontpage": false}
