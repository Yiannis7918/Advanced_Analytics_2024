{"aid": "40014900", "title": "Mux announces new JavaScript SDK for video", "url": "https://www.mux.com/blog/keeping-up-with-the-node-ish-ecosystem", "domain": "mux.com", "votes": 5, "user": "rattray", "posted_at": "2024-04-12 16:42:11", "comments": 0, "source_title": "Keeping up with the Node-ish ecosystem | Mux", "source_text": "Keeping up with the Node-ish ecosystem | Mux\n\nSkip to content\n\nMux Logo\n\nBack to Blog Home\n\nSign upSign up\n\nGet a demoGet a demoLog inLog in\n\nPublished on April 10, 2024 (2 days ago)\n\n# Keeping up with the Node-ish ecosystem\n\nBy Dylan Jhaveri \u2022 9 min read \u2022 Engineering\n\nHas the JavaScript ecosystem ever been simple? It used to be JavaScript in the\nbrowsers that had wild inconsistencies. We'd have to detect which browser\nwe're in and write custom code. Thankfully, those browser inconsistencies seem\nto mostly be papered over, but the JavaScript server ecosystem is the new\nchallenge. Only a few short years ago \"Node\" was just \"Node\", but now it's\nTypeScript, and a bunch of other runtimes like Cloudflare Workers, Bun, Deno,\nVercel Edge, and Nitro, I call these \u201cNode-ish\u201d environments and there's even\na thing called Web-interoperable Runtimes Community Group to keep track of all\nthese environments.\n\nAt Mux, we have to meet developers where they are. If developers are using\nthese platforms, we have to support them. We have a 6 year old Node SDK for\nmaking server-side API requests to Mux. It was written in JavaScript (not\nTypeScript) and over the years we have added types (by hand) and layered on\ncode as we've tried to keep up with Mux's evolving and advancing platform.\n\nOver the past few years, the Mux-Node SDK hasn't been living up to our\nstandards. It's been difficult to maintain, had TypeScript inconsistencies,\nand lacked support for the new \"Node-ish\" runtimes. It's time we solve this.\n\n## Big breaking changes suck, and you should never do them\n\nThis is basically my stance. I push back very hard on the idea that we should\nintroduce a breaking change into our SDK. Particularly if that breaking change\nis going to require everyone or almost everyone using the SDK to update their\ncode.\n\nSometimes I feel that engineers can be a bit flippant about breaking changes\nin SDKs. They'll say things like \"Well, it's a major version release and we\nfollow SemVer, so it\u2019s no big deal\". Let's just say: I disagree. It IS a big\ndeal. And it should be a big deal. Sure, you have not technically violated\nyour contract with the developers using your SDK. Your agreement is \u2014 if there\nare breaking changes we will do major version bumps. If you, as the developer,\nsee a major version bump, it's your responsibility to do your diligence and\nmake sure you are taking all the steps to upgrade.\n\nBut I think that approach and that mindset lack empathy for the people using\nyour SDK. Let\u2019s all try not to be so casual about breaking changes. Let\u2019s make\nsure that when we introduce breaking changes we\u2019re doing so with care and\ncaution, understanding that we are requiring actual developers using our SDKs\nto go and change code in their codebase, then test that code, put in a pull\nrequest, get someone from their team to review the pull request, merge the\npull request, deploy it, and monitor the new code to make sure nothing is\nbroken. All of this is time they could have spent building their product! If\nyou're doing your job right you should be maximizing the time developers get\nto spend on their product, and minimizing the amount of time they have to be\ninteracting with your SDK, that\u2019s the goal, anyway.\n\nThere is a version of breaking changes that are simple: dropping support for\nlegacy systems and removing some code that is not used by many people and has\npreviously been clearly deprecated. That\u2019s not what I\u2019m talking about here.\nWhat I\u2019m talking about is breaking changes that require a large plurality of\ndevelopers using your SDK to change their application code. These kinds of\nchanges should be considered hostile and only done with great consideration.\n\n## So then why are we doing this really big breaking change?\n\nWell, based on what I just said you can call me a hypocrite. And you wouldn\u2019t\nbe wrong. I had extremely mixed feelings about this, and it was with great\npain and suffering that we pulled the trigger on this change. I promise you it\nwas carefully considered and in this particular case, I believe the benefits\noutweigh the costs (and the costs are enormous). Let\u2019s get into it and you can\ndecide for yourself.\n\n## Iterating on legacy SDKs\n\nThe thing that makes this difficult in our situation is that none of the\nthings that backend Node developers care about today really existed 6 years\nago. It was more or less only \"Node\" and we didn\u2019t have to worry about all\nthese other complexities.\n\nUp until version 8, our major releases contained breaking changes usually in\nthe form of \"dropping support for Node < X\" because it's considered end-of-\nlife and no longer getting security updates. Or at least once when we had to\nrefactor how the package is bundled to support CSM and ESM. In those cases,\nnothing should have broken, but it was impossible to be 100% sure so we erred\non the side of caution and marked it as a major release.\n\nBut the technical debt was adding up. Among many things, what we lacked was:\n\n  * Reliable types for TypeScript users. We were hand-rolling types which means something was always wrong.\n  * Manually maintaining all the code. We have a well-maintained Open API specification. Our API reference docs are automatically generated from this spec, and we have a number of other SDKs that we generate from this spec. There are pros and cons to how we generate those SDKs, but more on code generation later.\n  * Lacking support for new runtimes. Cloudflare workers, Deno, Bun, Vercel Edge, Nitro, etc. All of these were not supported because our SDK took a dependency on node:crypto, which is a Node package that doesn't exist in the newer runtimes. The newer runtimes have Web Crypto APIs, which isn't exactly a drop-in replacement, particularly when it comes to supporting pks-8 v.s pks-1 signatures.\n\n## How we did Mux-Node 8\n\nThe pain we were feeling with Mux-Node before version 8 was getting to the\npoint that we had to re-assess everything. We have been shipping features on\nthe Mux Platform rapidly this year (metrics filtering, auto-generated\ncaptions, and resolution modifiers to name a few). Many of these features\nrequired API-level changes. Updating the OpenAPI spec is part of our normal\nprocess (and the spec updates flow through to the docs). But then we have to\ngo in and manually update the Node SDK, and update the types for the Node SDK.\nThis was starting to be cumbersome and we would always find ourselves lagging\nbehind or making mistakes with the types. It felt natural to say: we have the\nOpenAPI spec, can\u2019t we just use that for the types?\n\nSimilar to how we generate other server-side SDKs with OpenAPI, we looked to\nsee if we could do the same for TypeScript. We found out we could, but we\nweren\u2019t totally happy with the output. It didn\u2019t feel idiomatic, it lacked\ncustom functionality not represented in the spec like signing JWTs or\nverifying webhook signatures and it would overall be a step back from the\ncurrent Node SDK.\n\nOne thing was for certain: if we were going to do a big breaking change, we\nsure as hell were going to make it worth it. We were not willing to lose\nthings like the JWT generation for the sake of auto-generation, that would be\na win for us in terms of maintainability, but it would be a huge loss for our\nusers.\n\nThe only acceptable solution to going down the auto-generation route would be\nif it resulted in an SDK that was much better than our current one. This was a\nhard line we weren\u2019t willing to compromise on.\n\n## Enter Stainless\n\nLucky for us, we got in touch with the folks from Stainless. Based on our\nprevious experience with code generation we were skeptical if it would give us\neverything we needed, but we were willing to give it a shot. The Mux-Node\nversion 8 SDK that you see now is the output of what Stainless generated based\non our Open API spec. And it is MUCH better than what we had before. All the\nsyntax is different, it is a large departure from what we had, but it is so\nmuch better in every way. It gives us:\n\n  * Automatically generated code based on our OpenAPI spec\n  * Utilities that are not represented in the spec, like JWT generation and webhook signature verification\n  * Support for all the non-Node runtimes\n  * Real TypeScript types based on our OpenAPI spec\n  * Idiomatic code. Unlike other attempts at generated SDKs, the code actually looks and feels like something a developer would design\n\nAnd other nice quality-of-life things that we were missing before:\n\n  * Retry configurations for failed requests\n  * Auto pagination with for await\n  * A better pattern for accessing raw responses\n  * Ability to make custom requests to undocumented endpoints (useful against staging or when testing things in beta)\n  * Configuring HTTP proxies\n  * Logging & middleware to customize the fetch client\n\nAnd, to smooth things over there is a migration tool that will perform a\ncodemod to help developers upgrade from 7.x to 8.\n\nbash\n\n    \n    \n    npx @getgrit/launcher apply mux_v8\n\nRunning this on your project will modify all your existing code and update it\nto the version 8 syntax.\n\n## Is the tradeoff worth it?\n\nOverall, we think so. With ~100k downloads per week, Mux-Node is our most\npopular server-side SDK, so we did not take this lightly. But the issues we\nwere experiencing were starting to really cause pain for developers using it.\nAnd we felt like the more we grew, the more we were going to run up against\nthose pains.\n\nNow we feel like we\u2019re in a place where we can scale the usage of this SDK to\n1 million and 10 million weekly downloads.\n\n## Written By\n\n### Dylan Jhaveri \u2013 Director of Self Service\n\nSoftware Engineer and cold water surfer. Previously startup co-founder. Trying\nto find the best cheeseburger in San Francisco.\n\n## Leave your wallet where it is\n\nNo credit card required to get started.\n\nSign upSign up\n\n## Read more like this\n\nPublished on January 31, 2024 \u2022 By Colton Karoses\n\n### AI models on CPUs: accurate audio transcriptions without breaking the bank\n\nPublished on March 8, 2023 \u2022 By Justin Sanford\n\n### Edge Config: first line of defense against script kiddies\n\nPublished on November 1, 2022 \u2022 By Darius Cepulis\n\n### How we made Mux Player\u2019s loading feel great\n\n### Check out our newsletter\n\nA monthly-ish digest of all the best new blog posts and features\n\nMux Logo\n\n## United States\n\n50 Beale Street, Floor 9 San Francisco, CA, 94105 510-402-2257\n\n## United Kingdom\n\n34-37 Liverpool Street London, EC2M 7PP\n\nContact usMux on TwitterMux on LinkedInMux on GitHub\n\n## Platform\n\n### Mux Video\n\nOverviewFeaturesOn-DemandLiveInteractiveEncodingPricing\n\n### Mux Data\n\nOverviewMonitoringPricing\n\n### Mux Player\n\nOverview\n\nBeta features\n\n## Docs and Tools\n\nMux Video docsMux Data docsMux Player docsAPI referenceWebhook referenceOpen\nsource software\n\n### Integrations\n\nNodeRubyPHPPythonElixirGoNext.jsRemix.jsGenerative AI\n\n## Company\n\nTeamJobsBlogCustomersResourcesPartnersSupportDownload Press Kit\n\n## More Video\n\nVideo glossaryLearn about videoSign up for our newsletterDemuxedHowVideo.Works\n\n\u00a9 Mux, Inc. 2024\n\nTerms of serviceSecurityPrivacy policySitemap\n\nStatus:Loading....\n\n", "frontpage": false}
