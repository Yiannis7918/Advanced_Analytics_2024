{"aid": "40033106", "title": "Getting started with sched-ext development", "url": "http://arighi.blogspot.com/2024/04/getting-started-with-sched-ext.html", "domain": "arighi.blogspot.com", "votes": 1, "user": "nomad41", "posted_at": "2024-04-14 18:13:17", "comments": 0, "source_title": "Getting started with sched-ext development", "source_text": "arighi's blog: Getting started with sched-ext development\n\n# arighi's blog\n\nAndrea Righi - Linux Kernel Engineer at Canonical\n\n## Sunday, April 14, 2024\n\n### Getting started with sched-ext development\n\nThe purpose of this article is to support those interested in deepening their\nengagement in scheduling development using sched-ext.\n\nWe are currently working to better integrate all of this in the major Linux\ndistributions, but for now setting up a development environment requires a few\nmanual steps.\n\nIn this post, I\u2019ll describe my personal workflow for conducting experiments\nwith sched-ext without the need to install a custom kernel.\n\nTo test the sched-ext schedulers, we will use virtme-ng, a tool that allows to\nquickly build and test custom kernels without having to deploy them on a bare\nmetal system or a dedicated virtual machine.\n\n## Install virtme-ng\n\nvirtme-ng is available in pretty much all the major Linux distributions, so\nyou should be able to install it via the package manager of your distro.\n\nAlternatively, you can either recompile, or even run directly, from source or\ninstall it via pip:\n\n    \n    \n    $ pip install --break-system-packages virtme-ng\n\n## Dependencies\n\nInstall the following dependencies to be able to compile a sched-ext kernel\nand the user-space scx tools and schedulers:\n\n    \n    \n    $ sudo apt -y install \\ bison busybox-static cargo clang-17 cmake coreutils cpio \\ elfutils file flex gcc git iproute2 jq kbd kmod libcap-dev \\ libelf-dev libunwind-dev libvirt-clients libzstd-dev llvm-17 \\ linux-headers-generic linux-tools-common linux-tools-generic \\ make meson ninja-build pahole pkg-config python3-dev python3-pip \\ python3-requests qemu-kvm rsync rustc udev zstd\n\nThese is the list of required packages if you are using Debian/Ubuntu, other\ndistributions may have similar or equivalent package names.\n\n## Preparing a sched-ext kernel\n\nThe development kernel of sched-ext is based on the latest bpf-next branch.\n\nThe main reason is that we may want to start exploring the new eBPF features\nas soon as possible, being sched-ext strictly connected to eBPF.\n\nTo prepare a minimal sched-ext kernel that can run inside a virtme-ng session\ndo the following:\n\n    \n    \n    $ git clone https://github.com/sched-ext/sched_ext.git linux $ cd linux $ vng -v --build --config ~/.config/virtme-ng/kernel.config.bpf $ make headers $ cd -\n\n## Build the user-space scx tools and schedulers\n\nAll the sched-ext schedulers and tools are provided in a separate scx git\nrepository.\n\nTo compile all the schedulers with the required tools and libraries you can\nrun the following command:\n\n    \n    \n    $ git clone https://github.com/sched-ext/scx.git $ cd scx $ meson setup build -Dkernel_headers=../linux/usr/include $ meson compile -C build --njobs=1\n\nIf you want to recompile only a specific scheduler (i.e., scx_rustland) you\ncan specify just the scheduler name that you want compile via the meson\ncompile command:\n\n    \n    \n    $ meson compile -C build scx_rustland\n\n## Test the scheduler inside virtme-ng\n\nFirst of all let\u2019s define a bash helper that will help us to quickly spawn a\ntmux session with a running sched-ext scheduler and a shell.\n\nAdd the following to your ~/.bashrc:\n\n    \n    \n    # Helper to test scx scheduler scx() { sudo tmux new-session \\; split-window -v \\; send-keys -t 0 \"$*\" Enter }\n\nNow we can run the kernel that we have just recompiled using virtme-ng:\n\n    \n    \n    $ vng -vr ../linux\n\nThen, inside virtme-ng, we can use the following command to run the\nscx_rustland scheduler together with a shell session, that can be used to run\nsome tests or benchmarks:\n\n    \n    \n    $ scx ./build/scheds/rust/scx_rustland/debug/scx_rustland\n\n## Modify a scheduler: scx_rustland\n\nNow, let\u2019s try to modify the scx_rustland scheduler as following:\n\n    \n    \n    diff --git a/scheds/rust/scx_rustland/src/main.rs b/scheds/rust/scx_rustland/src/main.rs index 33cf43b..59891ad 100644 --- a/scheds/rust/scx_rustland/src/main.rs +++ b/scheds/rust/scx_rustland/src/main.rs @@ -506,7 +506,7 @@ impl<'a> Scheduler<'a> { // available. let mut dispatched_task = DispatchedTask::new(&task.qtask); if !self.builtin_idle { - dispatched_task.set_cpu(NO_CPU); + dispatched_task.set_cpu(0); } // Send task to the BPF dispatcher.\n\nThis change will force the scx_rustland scheduler to dispatch all tasks on CPU\n#0.\n\nThis small change is obviously provided mostly for academic purposes, but even\na little change like this can have practical benefits in certain scenarios.\n\n## Result\n\nFor example, let\u2019s test this scheduler on a real system (my laptop) and\ncompare the power consumption of the default Linux scheduler vs the modified\nscx_rustland.\n\nWe can start scx_rustland with the -u option to make sure that all the tasks\nwill be scheduled by the user-space component that we have just modified:\n\n    \n    \n    $ scx ./build/scheds/rust/scx_rustland/debug/scx_rustland -u\n\nThen we can start a CPU-intensive stress test using stress-ng:\n\n    \n    \n    $ stress-ng -c 8 --timeout 30\n\nWhen measuring the average power consumption over a 30-second period using\nturbostat, the results show a notable difference between two schedulers:\n\n    \n    \n    Power usage ------------------------------------ Default Linux scheduler | 7.5W Modified scx_rustland | 3.6W ------------------------------------\n\nThis disparity can obviously be attributed to the different behavior of the\nschedulers. With the modified scx_rustland scheduler, all tasks are directed\nto CPU #0, leaving the other CPUs largely idle. Consequently, the kernel can\nplace these idle CPUs into a low-power state. In contrast, the default Linux\nscheduler evenly distributes the workload across all available CPUs, leading\nto higher power consumption.\n\nAlthough this modification massively impacts on performance, it demonstrates\nthe effectiveness of operating at the kernel scheduler level and how easy it\nis via sched-ext. This experience highlights the tangible benefits of fine-\ntuning kernel scheduler settings in real-world scenarios using sched-ext.\n\nThe reason is that all the tasks are dispatched on CPU #0 with the modified\nscx_rustland, so the other CPUs are basically idle and the kernel can put them\nin a low-power state, while the default Linux scheduler tries to distribute\nthe workload equally across all the available CPUs.\n\nDespite the substantial impact on performance caused by this change, this\nexample demonstrates the effectiveness to operate at the kernel scheduler\nlevel and the ease of implementing (and testing) such modifications using\nsched-ext.\n\nAnd, speaking from personal experience, I have actually used this change while\ntravelling when my laptop was running out of power. With this simple change I\nwas able to almost double the battery life of my laptop and complete my work\nduring the trip. :)\n\n## Conclusion\n\nIn this post I have shared my personal workflow to quickly run experiments\nwith sched-ext without the need to install a custom kernel, highlighting the\nease of conducting such experiments.\n\nI hope this information can help all the potential developers interested in\nimproving their understanding of sched-ext through experimentation.\n\nPosted by\n\narighi at\n\n7:56 PM\n\nEmail ThisBlogThis!Share to TwitterShare to FacebookShare to Pinterest\n\n#### No comments:\n\nPost a Comment\n\nOlder Post Home\n\nSubscribe to: Post Comments (Atom)\n\n## Blog Archive\n\n  * April (1)\n  * March (1)\n  * February (1)\n  * July (1)\n  * August (1)\n  * December (1)\n  * August (1)\n  * May (1)\n  * August (2)\n  * January (2)\n  * September (1)\n  * June (2)\n  * May (2)\n  * April (2)\n  * March (1)\n  * January (2)\n  * December (1)\n  * October (5)\n  * July (1)\n  * May (2)\n  * March (5)\n  * February (1)\n  * January (4)\n  * October (1)\n  * May (4)\n  * April (3)\n  * March (6)\n  * February (2)\n\nAndrea Righi - Kernel Engineer at Canonical. Simple theme. Powered by Blogger.\n\nDiese Website verwendet Cookies von Google, um Dienste anzubieten und Zugriffe\nzu analysieren. Deine IP-Adresse und dein User-Agent werden zusammen mit\nMesswerten zur Leistung und Sicherheit f\u00fcr Google freigegeben. So k\u00f6nnen\nNutzungsstatistiken generiert, Missbrauchsf\u00e4lle erkannt und behoben und die\nQualit\u00e4t des Dienstes gew\u00e4hrleistet werden.Weitere InformationenOk\n\n", "frontpage": false}
