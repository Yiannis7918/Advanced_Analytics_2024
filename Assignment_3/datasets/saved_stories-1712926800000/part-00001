{"aid": "40010058", "title": "Hypermedia APIs vs. Data APIs", "url": "https://htmx.org/essays/hypermedia-apis-vs-data-apis/", "domain": "htmx.org", "votes": 1, "user": "runeks", "posted_at": "2024-04-12 06:59:00", "comments": 0, "source_title": "</> htmx ~ Hypermedia APIs vs. Data APIs", "source_text": "</> htmx ~ Hypermedia APIs vs. Data APIs\n\n</> htmx\n\ndocs\n\nreference\n\nexamples\n\ntalk\n\nessays\n\n# Hypermedia APIs vs. Data APIs\n\nCarson Gross July 17, 2021\n\nA hypermedia API is an API that returns hypermedia, typically HTML over HTTP.\nThis style of API is distinguished from data APIs that do not return a\nhypermedia. The most familiar form of this latter style of API today is the\nubiquitous JSON API.\n\nThese two different types of API have distinctly different design needs and,\ntherefore, should use different design constraints and adopt different goals\nwhen being created.\n\nHypermedia APIs:\n\n  * Will be trivially REST-ful, since they are simply what Roy Fielding was describing.\n  * Should be driven by the needs of the underlying hypermedia application\n  * May change dramatically without versioning information, because hypermedia utilizes self describing messages\n  * Should be passed directly to humans, to maximize the flexibility of the system\n\nData APIs, on the other hand:\n\n  * Will not benefit dramatically from REST-fulness, beyond perhaps Level 2 of the Richardson Maturity Model\n  * Should strive for both regularity and expressiveness due to the arbitrary data needs of consumers\n  * Should be versioned and should be very stable within a particular version of the API\n  * Should be consumed by code, processed and then potentially presented to a human\n\n## #APIs Today\n\nToday, APIs are typically thought of in terms of JSON-over-HTTP. These are\nalmost always data-oriented APIs rather than hypermedia APIs, although\noccasionally hypermedia concepts are incorporated into them (typically to\nlittle benefit of the end users.) There has been a movement away from REST-ful\nAPIs as the industry has begun to recognize the problems with fitting data\nAPIs into the REST-ful model.\n\nThis is a good thing: the industry should question REST-ful ideas in the Data\nAPI world and begin looking at older client-server technologies that did a\nbetter job of servicing that particular network architecture, leaving REST\ninstead to the network architecture that it was coined to describe: hypermedia\nAPIs.\n\n## #Designing a Hypermedia API\n\nTo show how a hypermedia API might be designed differently than a data API,\nlet\u2019s consider the following situation, which came up on the htmx discord\nrecently:\n\n> I want a page with a form and a table on it. The form will add new elements\n> to the table, and the table will also be polling every 30 seconds so that\n> updates from other users are shown.\n\nLet\u2019s consider this UI in terms of a base url, /contacts\n\nThe first thing we will need is an end point to retrieve the form and the\ntable of current contacts. This will live at /contacts, giving:\n\n    \n    \n    GET /contacts -> render the form & contacts table\n\nNext, we want to be able to create contacts. This would be done via a POST to\nthe same URL:\n\n    \n    \n    GET /contacts -> render the form & contacts table POST /contacts -> create the new contact, redirect to GET /contacts\n\nwith HTML that looks something like this:\n\n    \n    \n    <div> <form action='/contacts' method=\"post\"> <!-- form for adding contacts --> </form> <table> <!-- contacts table --> </table> </div>\n\nSo far, so standard web 1.0 application, and thus far the data-API and\nhypermedia API needs haven\u2019t diverged very much, although it is worth noteing\nthat the hypermedia API is self describing and could be modified (say,\nchanging the URL for creating contacts) without breaking the hypermedia\napplication.\n\nNow we get to the part where htmx is needed: polling the server for updates to\nthe table occasionally. To do this we will add a new end point,\n/contacts/table, which renders only the table of contacts:\n\n    \n    \n    GET /contacts -> render the form & contacts table POST /contacts -> create the new contact, redirect to GET /contacts GET /contacts/table -> render the contacts table\n\nand then add a poll trigger to the table:\n\n    \n    \n    <div> <form action='/contacts' method=\"post\"> <!-- form for adding contacts --> </form> <table hx-trigger=\"every 30s\" hx-get=\"/contacts/table\" hx-swap=\"outerHTML\"> <!-- contacts table --> </table> </div>\n\nHere we see the hypermedia API and data API begin to diverge. This new end\npoint is driven entirely by hypermedia needs, not data model needs. This end\npoint can go away if the hypermedia needs of the application change; its form\nmay change dramatically and so on, which is entirely acceptable since the\nsystem is self-describing.\n\nSince we have updated the HTML to use htmx for polling, we may as well make\nthe form use htmx as well for a better UX experience:\n\n    \n    \n    <div> <form action='/contacts' method=\"post\" hx-boost=\"true\"> <!-- form for adding contacts --> </form> <table hx-trigger=\"every 30s\" hx-get=\"/contacts/table\" hx-swap=\"outerHTML\"> <!-- contacts table --> </table> </div>\n\nWe can, if we choose, add additional end points for things like server-side\nvalidation of inputs, dynamic forms and so forth. These end points would be\ndriven by hypermedia needs rather than any sort of data model considerations:\nwe think in terms of what we are trying to achieve with our application.\n\n## #API Churn\n\nThe crux point of this short essay is this: API churn is fine in a hypermedia\nsystem because the messages in a hypermedia system are self-describing. We can\nthrash the API around and the application doesn\u2019t break: human users simply\nsee the new hypermedia (HTML) and select what actions they want to do.\n\nHumans, compared with computers, are good at deciding what to do and are\nreasonably OK with change.\n\nThis is in contrast with data APIs. Data APIs cannot be modified without\nbreaking client code and thus must be much more disciplined in their changes.\nData APIs also face pressure to provide higher levels of expressiveness so\nthat they can satisfy more client needs without modification.\n\nThis latter situation is especially dangerous when these data APIs are\nconsumed in a browser, because any data-api expressiveness available to a\nfront-end developer is also available to a potentially hostile user, who can\nfire up a console and begin hammering away at the API. Apparently, facebook\nuses a whitelist to deal with this.\n\nDo you?\n\n## #Conclusion\n\nWhen designing a hypermedia API, you should use a different design mindset\nthan you use for data APIs. Churn is much less of a concern, and providing the\nend points you need for a good hypermedia experience should be your primary\ngoal.\n\n</>\n\n## haiku\n\njavascript fatigue: longing for a hypertext already in hand\n\ndocs\n\nreference\n\nexamples\n\ntalk\n\nessays\n\n@htmx_org\n\n", "frontpage": false}
