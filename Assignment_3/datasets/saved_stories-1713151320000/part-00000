{"aid": "40034580", "title": "JSON in Postgres Use Case: Saving Drafts", "url": "https://philipschweiger.com/posts/jsonb-drafts/", "domain": "philipschweiger.com", "votes": 2, "user": "djcollier", "posted_at": "2024-04-14 21:19:34", "comments": 0, "source_title": "Anyone Can Code", "source_text": "# Anyone Can Code\n\n## A personal website. Mostly about software.\n\n# Json in Postgres Use Case: Saving Drafts\n\n## January 20, 2019\n\nLet's say we have an application where it generally makes sense to use a\nrelational database. For instance, say we're running a coffee shop and our\nsystem takes care of managing inventory. We put this data to a lot of\ndifferent uses, from customer-facing ones like displaying a menu to business-\nrelated purposes like deciding what what to include in next week's order. A\nrelational database is a nice fit here as it gives us the flexibility to query\non different combinations of attributes.\n\nA coffee cake might have these attributes:\n\n    \n    \n    Name: Can't Resist Coffee Cake Category: Food Sub_Category: Baked Goods Supplier: Pop Up Cafe Supply Co. Cost: 2.00 USD Customer_Price: 3.50 USD Description: One of our best sellers, this perfectly-textured, just-the-right-sweetness coffee cake is the perfect accompaniment to your morning joe!\n\n(Having only ever eaten at bakeries rather than worked at one, I'm sure my\nprices here are off, and that there'd be other attributes such as nutritional\ninformation we'd want to include, but this should work for illustrative\npurposes.)\n\nTranslating this to a database table, we might get a schema like this:\n\n    \n    \n    Table \"goods\" Column | Type ----------------+------------------------+ id | integer | category | integer | sub_cat | integer | supplier | integer | cost_amt | numeric(10,2) | cost_curr | currency | customer_price | numeric(10,2) | customer_curr | currency | name | character varying(128) | description | text | Indexes: \"goods_pkey\" PRIMARY KEY, btree (id) Foreign-key constraints: \"category\" FOREIGN KEY (category) REFERENCES categories(id) \"sub_cat\" FOREIGN KEY (sub_cat) REFERENCES sub_categories(id) \"supplier\" FOREIGN KEY (supplier) REFERENCES suppliers(id)\n\nAnd the entry like this:\n\n    \n    \n    -[ RECORD 1 ]--+---------------------------------------------------------------------------------------------------------------------------------------- id | 1 category | 1 sub_cat | 4 supplier | 42 cost_amt | 2.00 cost_curr | USD customer_price | 3.50 customer_curr | USD name | Can't Resist Coffee Cake description | One of our best sellers, this perfectly-textured just-the-right-sweetness coffee cake is the perfect accompaniment to your morning joe!\n\nEverything seems in order. The current state of our inventory is in an easily\nqueryable, nicely normalized form. Assuming we also have tables to record\norders placed, items sold, and so forth, the past state of our inventory is\nalso accessible.\n\nWhat about that description field, though? As I noted at the start of this\npost, in this example this system not only helps us manage business processes\nlike inventory tracking, it also powers the menu. If we change the description\nin our current approach, that will instantly flow through to the menu as well.\nMaybe that's what we want, but it puts a lot of pressure on whoever is editing\nthat description\u2014don't hit \"save\" until the description is exactly right!\n\nWhat we need is a \"drafts\" table to store data-in-progress that we don't want\nreflected across the rest of our system yet. What should this table look like?\nMaybe we should just copy over the goods table and add a few columns specific\nto tracking drafts:\n\n    \n    \n    Table \"goods_drafts\" Column | Type ----------------+--------------------------+ draft_id | integer | good_id | integer | category | integer | sub_cat | integer | supplier | integer | cost_amt | numeric(10,2) | cost_curr | currency | customer_price | numeric(10,2) | customer_curr | currency | name | character varying(128) | description | text | created | timestamp with time zone | Indexes: \"goods_drafts_pkey\" PRIMARY KEY, btree (id) Foreign-key constraints: goods_drafts_good_id_fkey\" FOREIGN KEY (good_id) REFERENCES goods(id) \"category\" FOREIGN KEY (category) REFERENCES categories(id) \"sub_cat\" FOREIGN KEY (sub_cat) REFERENCES sub_categories(id) \"supplier\" FOREIGN KEY (supplier) REFERENCES suppliers(id)\n\nThis works but feels a bit heavy. Do we really need to duplicate all the\ncolumns from the goods table? We never query on or update those columns when\nworking with drafts. A draft is essentially immutable\u2014we store any changes as\na brand new entry in the table and we only ever read, not modify, previous\nversions.\n\nPut another way, there's nothing especially relational about a draft.\nNormalizing our database schema makes it easier to sort, filter, and\naggregate, but these use cases don't apply here. All we really want to do when\nsaving a draft is to store the state of the record at that point in time, as a\n\"blob\" of data, if you will.\n\nApplying this insight, let's take a different approach. Instead of replicating\nthe goods table in goods_drafts, we can just store the contents of the draft\nas a JSON object:\n\n    \n    \n    Table \"public.goods_drafts\" Column | Type | ----------+-----------------------------+ draft_id | bigint | good_id | integer | draft | jsonb | created | timestamp with time zone | Indexes: \"goods_drafts_pkey\" PRIMARY KEY, btree (draft_id) Foreign-key constraints: \"goods_drafts_good_id_fkey\" FOREIGN KEY (good_id) REFERENCES goods(id)\n\nPostgreSQL actually offers two JSON types: json and jsonb. The json type is\nessentially just a variant on the text type with some additional validation,\nwhereas jsonb internally converts the values of JSON fields to their\nequivalent PostgreSQL data types. This makes for much more efficient storage\nand enable indexing and containment testing. As the documentation puts it, \"In\ngeneral, most applications should prefer to store JSON data as jsonb, unless\nthere are quite specialized needs, such as legacy assumptions about ordering\nof object keys.\"\n\nThis flexibility is a really nice feature of PostgreSQL, allowing us to tailor\nour data storage strategy to different use cases within the same database. We\ncan represent our data as JSON while we're editing it (which our UI layer is\nprobably already doing anyway), then take full advantage of the traditional\nrelational approach once our data is \"live.\" As an added bonus, we've even\naccidentally added support for an \"undo\" feature in the UI\u2014to restore a\nprevious state, simply retrieve the JSON for an earlier version of the draft.\n\nJSON + PostgreSQL: Letting us have our relational cake and eat NoSQL too ;-)\n\nPhilip Schweiger\u2019s web site, built with Gatsby and hosted on Github.\n\nYou can reach me via LinkedIn or at the email on my resume.\n\nLooking for more on this site? Browse all my posts, or maybe just the post\nwhere I talk a bit about myself or explain my user name.\n\n", "frontpage": false}
