{"aid": "39961921", "title": "Rate Limiting", "url": "https://redis.com/glossary/rate-limiting/", "domain": "redis.com", "votes": 1, "user": "mooreds", "posted_at": "2024-04-07 16:43:12", "comments": 0, "source_title": "Rate Limiting", "source_text": "Rate Limiting - What is Rate Limiting? | Redis\n\nTry Redis Cloud Essentials for Only $5/Month!\n\nLearn More\n\n# Rate Limiting\n\nBack to Glossary\n\n## Rate Limiting Defined\n\nRate limiting is a technique used in computer systems to control the rate at\nwhich requests are sent or processed in order to maintain system stability and\nsecurity. In web applications, rate limiting restricts the number of requests\nthat a client can make to a server within a given time period to prevent abuse\nand ensure fair usage of resources among multiple clients.\n\nAs our reliance on web applications and services grows, so does the risk of\ncyber attacks. In 2020, there were over 2 billion cyber attacks, according to\na report by RiskIQ. Rate limiting is an effective tool for protecting against\nsuch attacks. It can help prevent overload by limiting the amount of traffic\nthat can access a website or application within a given time frame. This\ntechnique can keep cyber threats at bay and maintain the stability of the\nsystem.\n\nOverall, rate limiting is an important mechanism that helps ensure the\nsecurity and reliability of computer systems, and it is commonly used in\nvarious applications, including web APIs, web servers, and network\ninfrastructure.\n\n## Why is rate limiting necessary for applications and systems?\n\nRate limiting is an essential component of any security strategy for practical\napplication and system management. It helps prevent a wide range of malicious\nactivities, such as DDoS attacks, brute force attacks, credential stuffing,\ninventory hoarding attacks, and data scraping, by limiting the number of\nrequests or connections that can be made to an application or system.\n\nImplementing rate limiting can help organizations ensure that resources are\navailable to all users and prevent malicious activity from overwhelming the\nsystem. By limiting the number of requests, companies can protect against\nvarious types of attacks, such as:\n\nDDoS attacks: By restricting the number of requests to a reasonable level,\norganizations can prevent DDoS attacks from overloading their system and\nbringing it down.\n\nCredential stuffing: Limiting login attempts from a single IP address or user\ncan prevent credential stuffing attacks, where attackers use automated scripts\nto try different combinations of usernames and passwords until they find a\ngood match.\n\nBrute force attacks: Limiting the number of requests or attempts to access a\nresource can help prevent brute force attacks, where attackers try different\ncombinations of characters to gain access to a system or application.\n\nData scraping: Rate limiting can help prevent data scraping by restricting the\nnumber of requests made by a single user or IP address. Attackers are\nprevented from scraping sensitive data.\n\nInventory hoarding attacks: Limiting the number of requests for a particular\nitem or resource can thwart inventory hoarding attacks, where attackers try to\npurchase all available inventory of a popular item to resell at a higher\nprice.\n\nOverall, rate limiting is a necessary tool for applications and systems to\nensure the security and reliability of resources while protecting against\nmalicious activity. By implementing rate limiting, companies can improve their\nsecurity posture and prevent attacks, ensuring that resources are available to\nall users.\n\n## Types of rate limiting\n\nIP-Based\n\nOne common type of rate limiting is IP-based, which restricts access based on\nthe source IP address of the request. It can help prevent attacks from a small\nnumber of IP addresses, but it can be less effective against distributed\nattacks.\n\nUser-Based\n\nUser-based rate limiting is another method that restricts access based on the\nuser account making the request. It can help prevent credential stuffing\nattacks, but it requires identifying unique users across different sessions,\nwhich can be challenging.\n\nApplication-Based\n\nApplication-based rate limiting restricts access based on the type of\napplication making the request. It can help prevent inventory hoarding and\ndata scraping attacks, but it may not be effective against attacks coming from\nlegitimate applications.\n\nToken Bucket\n\nToken bucket rate limiting is a popular approach that regulates the flow of\nrequests using a token bucket. Each request consumes a token from the bucket,\nand once the bucket is empty, no more requests are allowed until the bucket is\nrefilled.\n\nOrganizations should regularly review and update their rate limiting policies\nto ensure they remain effective against new and emerging threats.\nAdditionally, it\u2019s essential to choose the rate limiting method that best fits\nyour organization\u2019s specific needs and requirements.\n\n## How does rate limiting work?\n\nRate limiting is something like a bouncer at a nightclub. A bouncer assess the\nflow of people into the club and stops entry if things are becoming\novercrowded and unsafe. Similarly, rate limiting controls the number of\nrequests to an application to prevent it from becoming overwhelmed or\ncrashing. Just as the bouncer may limit entry to a certain number of people\nper hour, rate limiting can limit requests to a certain number per second or\nminute. By carefully managing the flow of people or requests, both the bouncer\nand rate limiting help to maintain a safe and reliable environment for\neveryone.\n\nRate limiting normally is based on tracking IP addresses and measures the time\nbetween each request. When a user makes a request, the system tracks it and\ncompares the number of requests made to a predefined threshold. If the number\nof requests exceeds the threshold, rate limiting kicks in and the system will\nnot fulfill the user\u2019s requests for a certain amount of time.\n\n## Algorithms used for rate limiting\n\nRate-limiting algorithms are essential tools that enable organizations to\ncontrol and limit the rate of incoming requests to their applications and\nsystems. Different algorithms can be used depending on the specific needs of\nthe application or system.\n\nFixed-window rate limiting: This is a straightforward algorithm that counts\nthe number of requests received within a fixed time window, such as one\nminute. Once the maximum number of requests is reached, additional requests\nare rejected until the next window begins. This algorithm is easy to implement\nand effective against DDoS attacks but may limit legitimate users.\n\nSliding-window rate limiting: This algorithm tracks the number of requests\nreceived in the recent past using a sliding window that moves over time. This\nalgorithm is more flexible than fixed-window rate limiting and can adjust to\nspikes in traffic, making it a better choice for applications with varying\nusage patterns. However, it may not be as effective against sustained attacks.\n\nToken bucket rate limiting: This maintains a token bucket that is refilled at\na fixed rate. Each request consumes a token, and additional requests are\ndenied once the bucket is empty. Token bucket rate limiting is suitable for\nhandling bursts of traffic, as it can allow a certain number of requests to be\nprocessed simultaneously. However, it may not be as effective against\nsustained traffic.\n\nLeaky bucket rate limiting: Similar to token bucket rate limiting but puts\nrequests into a \u201cbucket\u201d that gradually empties over time, allowing more\nrequests to be processed. This algorithm is effective against bursts of\ntraffic and helps to prevent overload, but it may not be as effective against\nsustained attacks.\n\nChoosing the right rate-limiting algorithm depends on several factors,\nincluding the application\u2019s traffic patterns and the desired level of\nprotection against malicious activity. Organizations must strike a balance\nbetween protecting their systems and providing a good user experience.\nRegularly reviewing and updating rate-limiting policies is also essential to\nensure that they remain effective against new and emerging threats.\n\n## Rate limiting use cases\n\nMany popular websites and applications use rate limiting to prevent malicious\nattacks, improve performance, and ensure fair usage for all users. Here are\nsome real-world use cases for rate limiting:\n\n  1. Google Maps API \u2013 The Google Maps API is a popular tool for developers to integrate maps and location-based services into their applications. However, due to its popularity, the API is a frequent target of malicious traffic, which can overload the service and affect legitimate users. Google Maps API uses rate limiting to protect against these attacks and ensure all users can access the service.\n  2. GitHub API \u2013 GitHub is a code hosting platform millions of developers worldwide use. The GitHub API provides programmatic access to many platform features, such as creating and managing repositories. Excessive API usage can cause performance issues for the platform and affect other users. GitHub uses rate limiting to prevent these issues and ensure all users can access the API fairly.\n  3. Twitter API \u2013 The Twitter API allows developers to build applications that interact with the Twitter platform, such as posting tweets or retrieving user data. Abusive or spammy API usage can harm the platform and other users. Twitter uses rate limiting to prevent these issues and ensure all users can access the API without interruption.\n  4. Cloudflare \u2013 Cloudflare is a popular content delivery network and security service many websites and applications use. Cloudflare uses rate limiting to prevent DDoS attacks and other malicious traffic from overwhelming websites and applications, ensuring their availability and security.\n\nIn all these examples, rate limiting has helped these websites and\napplications protect themselves from attacks and ensure their services remain\navailable to legitimate users.\n\n## Redis Rate Limiting Best Practices\n\nBuilding a rate limiter with Redis is easy because of two commands INCR and\nEXPIRE. The basic concept is that you want to limit requests to a particular\nservice in a given time period. Let\u2019s say we have a service that has users\nidentified by an API key. This service states that it is limited to 20\nrequests in any given minute.\n\nTo achieve this we want to create a Redis key for every minute per API key. To\nmake sure we don\u2019t fill up our entire database with junk, expire that key\nafter one minute as well. Visualize it like this:\n\nUser API Key = zA21X31, Green represents unlimited and red represents limited.\n\nRedis Key| zA21X31:0| zA21X31:1| zA21X31:2| zA21X31:3| zA21X31:4  \n---|---|---|---|---|---  \nValue| 3| 8| 20| >2| 20  \nExpires at| Latest 12:02| Latest 12:03| Latest 12:04| Latest 12:05| Latest\n12:06  \nTime| 12:00| 12:01| 12:02| 12:03| 12:04  \n  \nThe key is derived from the User API key concatenated with the minute number\nby a colon. Since we\u2019re always expiring the keys, we only need to keep track\nof the minute\u2014when the hour rolls around from 59 to 00 we can be certain that\nanother 59 don\u2019t exist (it would have expired 58 minutes prior).\n\nWith pseudocode, let\u2019s see how this would work.\n\n1| >GET [user-api-key]:[current minute number]  \n---|---  \n2| If the result from line 1 is less than 20 (or unset) go to 4 otherwise line\n3  \n3| Show error message and end connection. Exit.  \n4| >MULTIOK > INCR [user-api-key]:[current minute number] QUEUED > EXPIRE\n[user-api-key]:[current minute number] 59 QUEUED >EXECOK  \n5| Do service stuff  \n  \nTwo key points to understand from this routine:\n\n  1. INCR on a non-existent key will always be 1. So, the first call of the minute will be result the value of 1\n  2. EXPIRE is inside a MULTI transaction along with the INCR, which means form a single atomic operation.\n\nThe worse-case failure situation is if, for some very strange and unlikely\nreason, the Redis server dies between the INCR and the EXPIRE. When restoring\neither from an AOF or in-memory replication, the INCR will not be restored\nsince the transaction was not complete.\n\nWith this pattern, it\u2019s possible that anyone one user will have two limiting\nkeys, one that is being currently used and the one that will expire during the\nsame minute window, but it is otherwise very efficient.\n\n  * Products\n  * Cloud\n  * Software\n  * Pricing\n  * Support\n\n  * Company\n  * About Us\n  * Careers\n  * Contact us\n  * Trust Center\n  * Legal Notices\n\nSOCIAL\n\n\u00a9 2024 Redis. Redis and the cube logo are registered trademarks of Redis Ltd.\n\nCookie Preferences\n\nDo Not Sell Or Share My Personal Information\n\n", "frontpage": false}
