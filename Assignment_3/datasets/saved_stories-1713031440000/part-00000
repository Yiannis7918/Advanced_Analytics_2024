{"aid": "40022576", "title": "Demystifying TLS", "url": "https://peelingrage.netlify.app/demystifying-tls/", "domain": "peelingrage.netlify.app", "votes": 1, "user": "gearnode", "posted_at": "2024-04-13 12:03:17", "comments": 0, "source_title": "Demystifying TLS", "source_text": "Demystifying TLS | Peeling Rage\n\n# Peeling Rage\n\n  * About\n  * \ud83c\udf1a\n\n# Demystifying TLS\n\nMay 30, 2021\n\nI recently had to prepare a presentation on TLS as part of the cybersecurity\nclass I was taking. Researching and understanding TLS took quite some effort.\nHowever, I was quite satisfied with the things I had learned. In this blog\npost, I wanted to document the things I understood, as well as try to answer\nsome of the questions I asked myself while preparing my presentation.\n\nBefore reading, I strongly recommend you read a little about\nasymmetric/symmetric encryption, message authentication code (MAC), and\ndigital certificates. I don\u2019t believe you need extensive background in those\ntopics, but exposure will definitely help. I am personally not an expert in\nany of those topics and doubt i\u2019d be able to do a better job than what\u2019s\nalready available out there.\n\n## What\u2019s so special about this article?\n\nNot much. All the information you\u2019ll find here is already available on the\ninternet. However, it\u2019s been a bit challenging for me to compile that\ninformation and connect the dots. For me, this article is simply what I wish I\nfound when I was researching the topic.\n\n## Motivation of TLS\n\nBefore talking about what Transport Layer Security (TLS) is, let\u2019s briefly\nintroduce why it exists in the first place. The overarching objective is to\nset up a secure communication channel over internet which guarantees\nconfidentiality, integrity, and authenticity.\n\nTLS tells us how to set up such a secure channel. It tells us the exact steps\na client/server should follow to set it up. Concepts such as\nasymmetric/symmetric encryption, digital signatures, MACs, etc. are our\nbuilding blocks, and TLS fits them together to achieve its overarching goal.\n\n## Brief Evolution of TLS\n\nI won\u2019t get into much detail here. This is mainly to clear up any confusion\nbetween SSL and TLS. People have developed a tendency to use both\ninterchangeably, but the two have significant technical differences.\n\nFirst, TLS 1.0 (the first version) deprecated SSL 3.0 (the last SSL version).\nBoth protocols actually work towards the same goal, except that multiple\nvulnerabilities were discovered in SSL, which logically led to its\ndeprecation. Actually, even the first two iterations of TLS (TLS 1.0 & TLS\n1.1) are now considered deprecated. Major browsers have announced lately that\nthey don\u2019t plan on supporting them in the future. I found a pretty cool\nillustration from the GlobalSign blog that summarizes the evolution of TLS.\n\n### Relationship with SSL/TLS certificates\n\nThis is also one thing I wish to clear up. If SSL and TLS certificates are two\ndifferent protocols, does that mean that when we acquire an SSL certificate,\nwe have to use SSL and not TLS? Absolutely not. You might (and should) be\nusing TLS, yet certificate registration providers will likely refer to your\ndigital certificate as an SSL certificate. I believe this is just a name that\nstuck around for the longest time. More providers are starting to use the term\nSSL/TLS certificate, but it still a little bit confusing.\n\nThe point is: the certificate does NOT determine the protocol. The way\neverything fits together is that digital certificates are used WITH TLS or\nSSL.\n\nTLS or SSL is the protocol. The certificate is just a means to prove the\nauthenticity of the public key and can be used with both TLS and SSL\nirrespective of what they\u2019re being called by others/certificate registration\nproviders.\n\n### The TLS Protocol\n\nOne of the first descriptions of TLS you\u2019ll come across is: \u201cTLS is a layered\nprotocol\u201d. It is comprised of 2 layers. The first (lower) layer is for the\nRecord Protocol. The second (upper) layer is for one of the following 4\nprotocols: the handshake protocol, the alert protocol, the change cipher spec\nprotocol, the heartbeat protocol and the application data protocol.\n\nThe Record Protocol, by being the lower layer, abstracts some functionality\nfrom the upper layer. It\u2019s quite similar to how IP provides a service (e.g.\nrouting, addressing) for TCP and UDP. In the context of TLS, the Record\nProtocol can fragment, apply a MAC, encrypt, or/and optionally compress data.\nAt the receiving end, it can reassemble, verify, decrypt, or/and optionally\ndecompress data.\n\nThe upper layer protocols are used for different purposes, mainly, negotiating\nencryption algorithms/secrets and providing some error control.\n\nThe layered approach abstracts behavior and provides services to the upper\nlayer. The motivation behind this layered approach is similar to what you\nmight be familiar with in the case of the TCP/IP and OSI models: modularity,\ndecoupling, re-use, etc.\n\n## Terminology\n\nBefore talking more detail, I want to introduce some terminology. I think it\nwill help in our discussion and in case you read other more technical\narticles.\n\nTLS, as a protocol, exchanges messages and in the context of TLS, we usually\ncall those records. Each record contains a specific set of common fields +\nsome other fields depending on what is used in the upper layer. These \u201cother\nfields\u201d depend mainly on the value of the content type field (which is found\nin all TLS records). Below is a representation of a TLS record.\n\nThis diagram is abstract. Can you guess why?\n\nThe reason is because the \u201cPayload\u201d on the above diagram doesn\u2019t really mean\nanything... The payload will depend on what the content type field value is.\nHowever, the key takeaway here is that every TLS record will have at least the\nfields specified above.\n\n## TLS Content Types\n\nAs mentioned previously, there are different values for the content type\nfield. Each conforms to a specific 2nd layer protocol. Our focus will be\nmainly on the first 3, but I thought it would be nice to provide at least a\nshort description for each protocol.\n\n  * Handshake: used to exchange the necessary information required by the client and the server to start encrypting the application data\n  * ChangeCipherSpec: used to change the encryption strategy/algorithm being used by the client and server\n  * Application Data: used to refer to the messages we get from the application layer (e.g. an HTTP request or response). The messages are carried by the Record Protocol and are basically treated as transparent data.\n  * Alert: used to signal an error or a warning\n  * Heartbeat: used to test and keep alive the secure communication\n\nNow, with the background we have acquired, we can go back to the previous TLS\nrecord format, and provide some more detail.\n\nScroll back up and try to compare the two record structures.\n\nNote the absence of the abstract \u201cpayload\u201d. Instead, because this is a\nhandshake record (note the 22 value in the content type field), we have\nadditional fields such as message type and handshake message data length.\n\n## TLS Handshake\n\nThe TLS handshake is the series of TLS records exchanged by a client and a\nserver to establish a secure communication. I enjoyed reading about this topic\nbecause it captures how everything fits together. If you ever asked yourself\nhow a TLS session is established when you navigate to https://google.com, this\nanswers it.\n\nFirst, we\u2019ll briefly talk about the TLS handshake steps, then, at each step,\nwe\u2019ll make use of wireshark so that we can see things in practice.\n\n### Step 1: Client Hello\n\nThe client initiates the handshake by sending a Client Hello message to the\nserver. The TLS record will include, among other things, the supported TLS\nversions and a string of random bytes known as the client random. The client\nrandom is simply a set of random bytes. We\u2019ll see how it is used later. The\nsupported cipher suite is also sent from the client. A cipher suite is just a\nset of cryptographic algorithms that can be used to encrypt the communication\nchannel.\n\nLet\u2019s take a closer look at the cipher suites field\n\nWe\u2019ll take TLS_RSA_WITH_AES_256_CBC_SHA as an example and try to parse it:\n\n  * RSA: Refers to the algorithm used for the key exchange. As we\u2019ll see later, our client will generate a premaster secret and will have to send it to the server. The premaster secret is a sensitive piece of information. In order to guarantee its confidentiality, an encryption algorithm needs to be used. If the server chooses the cipher suite we took as an example, it will use RSA to encrypt the premaster secret.\n  * AES_256_CBC: Refers to the symmetric-key algorithm used to encrypt the session data\n  * SHA: Refers to the MAC algorithm used.\n\n### Step 2: Server Hello\n\nThe server will respond with a Server Hello message. It will include the\nserver\u2019s chosen cipher and TLS version, as well as a server random.\n\n### Step 3: Server Certificates\n\nThe server will send its certificate chain for the client to verify.\n\n### Step 4: Server Hello Done\n\nThe server sends this message to signal the completion of the hello-message\nphase of the handshake. In other words, when a client receives this message,\nit should know that the server is done sending messages. The client should now\nverify the server certificate and move on to the next step.\n\n### Step 5: Client Key Exchange\n\nThis is the beginning of a new phase, the client key exchange phase. The\nclient will generate one more string of random bytes referred to as the\npremaster secret. The public key of the server, which the client should have\nauthenticated by verifying the server certificate, is used to encrypt the\npremaster secret. Only the server should be able to decrypt the premaster\nsecret because only it has the private key.\n\n### Step 6: Key Generation\n\nAt this level, both the client and server have enough information to generate\nsession keys. The server random, client random, and premaster secret will be\nused to generate the session keys.\n\n### Step 7: Change Cipher Spec Message\n\nThis message is sent to instruct the server that subsequent TLS records will\nuse another encryption mode. In this case, we switch from asymmetric to\nsymmetric encryption.\n\nWhy is the CipherSpecMessage part of the CipherSpecProtocol and not a simple\nmessage part of the Handshake Protocol?\n\nThink about it. Can\u2019t we just include a boolean that says either yes or no for\nswitching the encryption mode as part of a some Handshake message?\n\nI think the answer to these questions boils down to a design decision that was\nonce made when defining the TLS Protocol. Actually, I have not mentioned this\npreviously, but many TLS messages can be batched into one TLS Record, as long\nas they belong to the same 2nd layer protocol. This means that one or more TLS\nHandshake messages can be sent as part of one TLS record. The problem is that\nencryption is performed at the record level!\n\nImagine sending a message to the server, saying, \u201chey, please switch to the\nnew encryption mode\u201d, but then, this same message + potentially other messages\nare encrypted using the new encryption mode .. which the server does NOT\nexpect.\n\nThe fact that the ChangeCipherSpec message is part of its own protocol (the\nChangeCipherSpec protocol) breaks this batching. Now implementations are\nforced to start a new TLS Record when new encryption settings are set! This is\nparticularly relevant in the next step because the subsequent TLS message will\nnow be encrypted using the new settings, and the server would expect that\n(because it would have received a ChangeCipherSpec message).\n\n### Step 8: Finished\n\nThe finished message is the first message that is encrypted using the newly\nnegotiated algorithms, keys, and secrets. It should be sent right after the\nChangeCipherSpec message.\n\nThe receiving end must verify that its contents are correct. In fact, this is\nquite a crucial step, because it allows the receiving end to verify that the\nauthentication and key exchange processes were successful and not tampered\nwith. Remember, an active man-in-the-middle should be able to tamper with the\nClient Hello, Server Hello, and other non-encrypted TLS Handshake messages.\nThe Finished message includes a hash over unencrypted handshake messages (e.g.\nClientHello, ServerHello).\n\nWhen a party receives the Finished message, it decrypts it using the session\nkey, then computes a hash over all the previous handshake messages it received\n(all are kept up until this point), then it compares this hash with the hash\nthat was sent as part of the Finished message.\n\n### Step 9 and 10: Change Cipher Spec and Finished Messages\n\nSimilar to steps 7 and 8, except that this is sent from the server to instruct\nthat the messages from the server to the client will use new encryption\nsettings. The Finished message in this case is sent for the client to validate\nthe newly negotiated algorithms, keys, and secrets.\n\nThis is the last step in the Handshake Protocol.\n\n### Step 11: Application Data\n\nNow that the server is authenticated and the encryption algorithm + keys are\nnegotiated, we are ready to start sending and receiving encrypted application-\nlayer data: https in our example.\n\n## Conlusion\n\nI hope this has been somewhat helpful. Truth be told, TLS is a new topic for\nme. I had been exposed to it in the past and have even set up an HTTPS server,\nbut I never really knew the details of how the session key is generated or how\ndigital certificates are sent from the server to the client.\n\nThere is still much to talk about in TLS, but I feel like, for now, this\nanswered most of the questions I had when I first read about the topic. Feel\nfree to zoom in on each part and read more about the various protocols. The\ngoal of this article, from a reader perspective, was to expose you to TLS.\n\nWritten by Zakaria El Asri\n\n\u00a9 2020 \u2022 Built with Gatsby\n\n", "frontpage": false}
