{"aid": "40030981", "title": "Speculations on arenas and custom strings in C++", "url": "https://nullprogram.com/blog/2024/04/14/", "domain": "nullprogram.com", "votes": 1, "user": "ingve", "posted_at": "2024-04-14 13:43:20", "comments": 0, "source_title": "Speculations on arenas and custom strings in C++", "source_text": "Speculations on arenas and custom strings in C++\n\n## Speculations on arenas and custom strings in C++\n\nApril 14, 2024\n\nnullprogram.com/blog/2024/04/14/\n\nMy techniques with arena allocation and strings are oriented around C. I\u2019m\nalways looking for a better way, and lately I\u2019ve been experimenting with\nbuilding them using C++ features. What are the trade-offs? Are the benefits\nworth the costs? In this article I lay out my goals, review implementation\npossibilities, and discuss my findings. Following along will require\nfamiliarity with those previous two articles.\n\nSome of C++ is beyond my intellectual capabilities, and so I cannot wield\nthose parts effectively. Other parts I can wrap my head around, but it\nrequires substantial effort and the inevitable mistakes are difficult to\ndebug. So a general goal is to minimize contact with that complexity, only\ntouching a few higher-value features that I can use confidently.\n\nExisting practice is unimportant. I\u2019ve seen where that goes. Like the C\nstandard library, the C++ standard library offers me little. Its concepts\nregarding ownership and memory management are irreconcilable (move semantics,\nsmart pointers, etc.), so I have to build from scratch anyway. So absolutely\nno including C++ headers. The most valuable features are built right into the\nlanguage, so I won\u2019t need to include library definitions.\n\nNo public or private. Still no const beyond what is required to access certain\nfeatures. This means I can toss out a bunch of keywords like class, friend,\netc. It eliminates noisy, repetitive code and interfaces \u2014 getters, setters,\nseparate const and non-const \u2014 which in my experience means fewer defects.\n\nNo references beyond mandatory cases. References hide addresses being taken \u2014\nor merely implies it, when it\u2019s actually an expensive copy \u2014 which is an\nannoying experience when reading unfamiliar C++. After all, for arenas the\nexplicit address-taking (permanent) or copying (scratch) is a critical part of\ncommunicating the interfaces.\n\nIn theory constexpr could be useful, but it keeps falling short when I try it\nout, so I\u2019m ignoring it. I\u2019ll elaborate in a moment.\n\nMinimal template use. They blow up compile times and code size, they\u2019re noisy,\nand in practice they make debug builds (i.e. -O0) much slower (typically ~10x)\nbecause there\u2019s no optimization to clean up the mess. I\u2019ll only use them for a\nfew foundational purposes, such as allocation. (Though this article is about\nthe fundamental stuff.)\n\nNo methods aside from limited use of operator overloads. I want to keep a C\nstyle, plus methods just look ugly without references: obj->func() vs.\nfunc(obj). (Why are we still writing -> in the 21st century?) Function\noverloading can instead differentiate \u201cmethods.\u201d Overloads are acceptable in\nmoderation, especially because I\u2019m paying for it (symbol decoration) whether\nor not I take advantage.\n\nFinally, no exceptions of course. I assume -fno-exceptions, or the local\nequivalent, is active.\n\n### Allocation\n\nLet\u2019s start with allocation. Since writing that previous article, I\u2019ve\nstreamlined arena allocation in C:\n\n    \n    \n    #define new(a, t, n) (t *)alloc(a, sizeof(t), _Alignof(t), n) typedef struct { byte *beg; byte *end; } arena; static byte *alloc(arena *a, size objsize, size align, size count) { assert(count >= 0); size pad = (uptr)a->end & (align - 1); assert(count < (a->end - a->beg - pad)/objsize); // oom return memset(a->end -= objsize*count + pad, 0, objsize*count); }\n\n(As needed, replace the second assert with whatever out of memory policy is\nappropriate.) Then allocating, say, a 10k-element hash table (i.e. to keep it\noff the stack):\n\n    \n    \n    i16 *seen = new(&scratch, i16, 1<<14);\n\nWith C++, I initially tried placement new with the arena as the \u201cplace\u201d for\nthe allocation:\n\n    \n    \n    void *operator new(size_t, arena *); // avoid this\n\nThen to create a single object:\n\n    \n    \n    object *o = new (&scratch) object{};\n\nThis exposes the constructor, but everything else about it is poor. It relies\non complex, finicky rules governing new overloads, especially for alignment\nhandling. It\u2019s difficult to tell what\u2019s happening, and it\u2019s too easy to make\nmistakes that compile. That doesn\u2019t even count the mess that is array new[].\n\nI soon learned it\u2019s better to replace the new macro with a template, which can\nactually see what it\u2019s doing. I can\u2019t call it new in C++, so I settled on make\ninstead:\n\n    \n    \n    template<typename T> static T *make(arena *a, size count = 1) { assert(count >= 0); size objsize = sizeof(T); size align = alignof(T); size pad = (uptr)a->end & (align - 1); assert(count < (a->end - a->beg - pad)/objsize); // oom a->end -= objsize*count + pad; T *r = (T *)a->end; for (size i = 0; i < count; i++) { new ((void *)&r[i]) T{}; } return r; }\n\nThen allocating that hash table becomes:\n\n    \n    \n    i16 *seen = make<i16>(&scratch, 10000);\n\nOr a single object, relying on the default argument:\n\n    \n    \n    object *o = make<object>(&scratch);\n\nDue to placement new, merely for invoking the constructor, these objects\naren\u2019t just zero-initialized, but value-initialized. It can only construct\nobjects that define an empty initializer, but in exchange unlocks some\ninteresting possibilities:\n\n    \n    \n    struct mat3 { f32 data[9] = { 1, 0, 0, 0, 1, 0, 0, 0, 1, }; }; struct list { node *head = 0; node **tail = &head; };\n\nWhen a zero-initialized state isn\u2019t ideal, objects can still initialize to a\nmore useful state straight out of the arena. The second case is even self-\nreferencing, which is specifically supported through placement new. Otherwise\nyou\u2019d need a special-written copy or move constructor.\n\nmake could accept constructor arguments and perfect forward them to a\nconstructor. However, that\u2019s too far into the dark arts for my comfort, plus\nit requires a correct definition of std::forward. In practice that means\n#include-ing it, and whatever comes in with it. Or ask an expert capable of\nwriting such a definition from scratch, though both are probably too busy.\n\nOne small gotcha: placement new doesn\u2019t work out of the box, and you need to\nprovide a definition. That means including <new> or writing one out.\nFortunately it\u2019s trivial, but the prototype must exactly match, including\nsize_t:\n\n    \n    \n    void *operator new(size_t, void *p) { return p; }\n\nOverall I feel the template is a small improvement over the macro.\n\n### Strings\n\nRecall my basic C string type, with a macro to wrap literals:\n\n    \n    \n    #define countof(a) (size)(sizeof(a) / sizeof(*(a))) #define s8(s) (s8){(u8 *)s, countof(s)-1} typedef struct { u8 *data; size len; } s8;\n\nSince it doesn\u2019t own the underlying buffer \u2014 region-based allocation has\nalready solved the ownership problem \u2014 this is what C++ long-windedly calls a\nstd::string_view. In C++ we won\u2019t need the countof macro for strings, but it\u2019s\nstill generally useful. Converting it to a template, which is theoretically\nmore robust (rejects pointers):\n\n    \n    \n    template<typename T, size N> size countof(T (&)[N]) { return N; }\n\nThe reference \u2014 here a reference to an array \u2014 is unavoidable, so it\u2019s one of\nthe rare cases. The same concept applies as an s8 constructor to replace the\nmacro:\n\n    \n    \n    struct s8 { u8 *data = 0; size len = 0; s8() = default; template<size N> s8(const char (&s)[N]) : data{(u8 *)s}, len{N-1} {} };\n\nI\u2019ve explicitly asked to keep a default zero-initialized (empty) string since\nit\u2019s useful \u2014 and necessary to directly allocate strings using make, e.g. an\narray of strings. const is required because string literals are const in C++,\nbut it\u2019s immediately stripped off for the sake of simplicity. The new\nconstructor allows:\n\n    \n    \n    s8 version = \"1.2.3\";\n\nOr even more usefully:\n\n    \n    \n    void print(bufout *, s8); // ... print(stdout, \"hello world\\n\");\n\nDefine operator== and it\u2019s more useful yet:\n\n    \n    \n    b32 operator==(s8 s) { return len==s.len && (!len || !memcmp(data, s.data, len)); }\n\nNow this works, and it\u2019s cheap and fast even in debug builds:\n\n    \n    \n    s8 key = ...; if (key == \"HOME\") { // ... }\n\nThat\u2019s more ergonomic than the macro and comparison function. operator[] also\nimproves ergonomics, to subscript a string without going through the data\nmember:\n\n    \n    \n    u8 &operator[](size i) { assert(i >= 0); assert(i < len); return data[i]; }\n\nThe reference is again necessary to make subscripts assignable. Since s8span \u2014\nmake a string spanning two pointers \u2014 so often appears in my programs, a\nconstructor seems appropriate, too:\n\n    \n    \n    s8(u8 *beg, u8 *end) { assert(beg <= end); data = beg; len = end - beg; }\n\nBy the way, these assertions I\u2019ve been using are great for catching mistakes\nquickly and early, and they complement fuzz testing.\n\nI\u2019m not sold on it, but an idea for the future: C++23\u2019s multi-index operator[]\nas a slice operator:\n\n    \n    \n    s8 operator[](size beg, size end) { assert(beg >= 0); assert(beg <= end); assert(end <= len); return {data+beg, data+end}; }\n\nThen:\n\n    \n    \n    s8 msg = \"foo bar baz\"; msg = msg[4,7]; // msg = \"bar\"\n\nI could keep going with, say, iterators and such, but each will be more\nspecialized and less useful. (I don\u2019t care about range-based for loops.)\n\n### Downside: static initialization\n\nThe new string stuff is neat, but I hit a wall trying it out: These fancy\nconstructors do not reliably construct at compile time, not even with a\nconstexpr qualifier in two of the three major C++ implementations. A static\nlookup table that contains a string is likely constructed at run time in at\nleast some builds. For example, this table:\n\n    \n    \n    static s8 keys[] = {\"foo\", \"bar\", \"baz\"};\n\nRequires run-time construction in real world cases I care about, requiring C++\nmagic and linking runtime gunk. The constructor is therefore a strict\ndowngrade from the macro, which works perfectly in these lookup tables. Once a\nnon-default constructor is defined, I\u2019ve been unable to find an escape hatch\nback to the original, dumb, reliable behavior.\n\n### Other features\n\nHaving a generic dynamic array would be handy, and more ergonomic than my\ndynamic array macro:\n\n    \n    \n    template<typename T> struct slice { T *data = 0; size len = 0; size cap = 0; slice<T> = default; template<size N> slice<T>(T (&a)[N]) : data{a}, len{N}, cap{N} {} T &operator[](size i) { ... } } template<typename T> slice<T> append(arena *, slice<T>, T);\n\nOn the other hand, hash maps are mostly solved, so I wouldn\u2019t bother with a\ngeneric map.\n\nFunction overloads would simplify naming. For example, this in C:\n\n    \n    \n    prints8(bufout *, s8); printi32(bufout *, i32); printf64(bufout *, f64); printvec3(bufout *, vec3);\n\nWould hide that stuff behind the scenes in the symbol decoration:\n\n    \n    \n    print(bufout *, s8); print(bufout *, i32); print(bufout *, f64); print(bufout *, vec3);\n\nSame goes for a hash() function on different types.\n\n### Ultimately worth it?\n\nThe static data problem is a real bummer, but perhaps it\u2019s worth it for the\nother features. I still need to put it all to the test in a real, sizable\nproject.\n\n  * c\n  * cpp\n\nHave a comment on this article? Start a discussion in my public inbox by\nsending an email to ~skeeto/public-inbox@lists.sr.ht [mailing list etiquette]\n, or see existing discussions.\n\n# null program\n\n## Chris Wellons\n\nwellons@nullprogram.com (PGP)\n\n~skeeto/public-inbox@lists.sr.ht (view)\n\nAll information on this blog, unless otherwise noted, is hereby released into\nthe public domain, with no rights reserved.\n\n", "frontpage": false}
