{"aid": "40020549", "title": "The end of GitHub PATs: You can't leak what you don't have", "url": "https://www.chainguard.dev/unchained/the-end-of-github-pats-you-cant-leak-what-you-dont-have", "domain": "chainguard.dev", "votes": 1, "user": "RyeCombinator", "posted_at": "2024-04-13 04:42:31", "comments": 0, "source_title": "The end of GitHub PATs: You can\u2019t leak what you don\u2019t have", "source_text": "The end of GitHub PATs: You can\u2019t leak what you don\u2019t have\n\nThis website stores cookies on your computer. These cookies are used to\ncollect information about how you interact with our website and allow us to\nremember you. We use this information in order to improve and customize your\nbrowsing experience and for analytics and metrics about our visitors both on\nthis website and other media. To find out more about the cookies we use, see\nour Privacy Policy.\n\nIf you decline, your information won\u2019t be tracked when you visit this website.\nA single cookie will be used in your browser to remember your preference not\nto be tracked.\n\nUnchained\n\nUnchained\n\nProducts\n\nChainguard Images\n\nReduce your attack surface with hardened container images.\n\nSolutions\n\nDeveloper\n\nResources\n\nCompany\n\nSign InContact\n\nBack\n\nContainer Image Security\n\nRun hardened container images.\n\nVulnerability Remediation\n\nEliminate CVEs daily.\n\nOpen Source Software Security\n\nConsume OSS safely.\n\nCompliance & Risk Mitigation\n\nMeet and maintain compliance.\n\nSoftware Supply Chain Security\n\nBuild secure software by default.\n\nBack\n\nDocs\n\nOpen source\n\nBack\n\nUnchained blog\n\nChainguard labs\n\nCustomer stories\n\nEvents\n\nSecurity\n\nEducation\n\nBack\n\nAbout\n\nNewsroom\n\nCareers\n\nChainguard love\n\nBack\n\nAbout\n\nNewsroom\n\nCareers\n\nEngineering\n\n# The end of GitHub PATs: You can\u2019t leak what you don\u2019t have\n\nMatt Moore, CTO and Co-founder\n\nApril 11, 2024\n\ncopied\n\nTLDR: This post outlines how we were able to replace our usage of long-lived\nGitHub Personal Access Tokens (PATs) with short-lived credentials across\nseveral GitHub organizations managed by Chainguard. To eliminate our need for\nthese long-lived credentials, we created Octo STS to act as a \u201cSecurity Token\nService\u201d (STS) for GitHub credentials.\n\nOne of our mantras at Chainguard is: treat your build systems like production\nsystems. Really this sentiment applies not just to your build system, but to\nyour entire development platform, which for a great many people is GitHub.\n\nAt Chainguard, we are continuously exploring ways to improve our security\nposture (e.g. ephemerality, and minimalism). We have A LOT of automation\ninteracting with GitHub. In some places, we leverage GitHub Actions, which\nalready supports short-lived tokens for basic same-repository operations.\nHowever, we also have a large amount of automation that these tokens do not\nwork for, including:\n\n  1. Actions that create Pull Requests (needs a PAT to trigger presubmit GitHub Actions)\n  2. Actions that interact across repositories (unsupported by built-in permissions)\n  3. Actions that interact with the organization\n  4. Automation that is not running on GitHub Actions\n\nFor these use cases, the only viable credentials were long-lived:\n\n  1. Create a dedicated GitHub App (the private key is long-lived)\n  2. Create a \u201cdeploy key\u201d (the private key is long-lived)\n  3. Create a Personal Access Token (PAT)\n\nWe had automation using a mixture of these long-lived credentials across many\nplaces in our codebase. To make matters worse, the toil of producing and\nmanaging the rotation of these long-lived secrets meant that developers would\nstart to reuse existing tokens rather than go through the hassle of creating\nnew ones, which violates the principle of least privilege (and increases the\nblast radius of a leaked token).\n\nCredential leaks are one of the most common ways systems are compromised, and\nlong-lived credentials are at the heart of that. These types of attacks have\nled to breaches at large enterprises like Mercedes and Toyota. At Chainguard,\nwe typically avoid long-lived secrets like the proverbial plague, but with\nGitHub it seemed we were stuck with them.\n\nUntil Octo STS.\n\nTo eliminate our need for these long-lived credentials, we created Octo STS to\nact as a \u201cSecurity Token Service\u201d (STS) for GitHub credentials. The idea of an\nSTS is largely inspired by the cloud providers like Amazon Web Services (AWS)\nand Google Cloud Platform (GCP), but other services have them too, including\nChainguard. An STS exchanges a short-lived third-party token for a short-lived\nfirst-party token, after checking that the caller has permission to make the\nexchange.\n\n(image credit: our Chief Meme Officer, Dan Lorenc)\n\nUsing AWS's STS, you can exchange a GitHub token for an AWS token to deploy\nresources from CI, without granting the workflow long-lived credentials. This\nis precisely what Octo STS does, but for GitHub \u2014 it allows users to federate\nthird-party OpenID Connect (OIDC) tokens for GitHub credentials. As Dino A.\nDai Zovi, Head of Security at Cash App, puts it \u2014 these types of \u201cfederation\n[are] a security super-power,\u201d and we couldn\u2019t agree more.\n\nOcto STS even lets GitHub workflows use OIDC to obtain short-lived credentials\nto authorize GitHub requests, eliminating the need for long-lived PATs.\n\nIn short: GitHub didn\u2019t expose an STS, so we went ahead and built one.\n\n## Establishing trust\n\nThe cornerstone of these types of federation is the trust policy. How does an\nSTS know which third-party identities to hand first-party credentials to? To\nestablish this trust in Octo STS we have users check-in trust policies under\n.github/chainguard/{foo}.sts.yaml in the repository where access is needed. A\nsimple policy for federating a GitHub Action\u2019s identity looks like this:\n\n    \n    \n    # Match these literal values in the respective claims issuer: https://token.actions.githubusercontent.com subject: repo:chainguard-dev/bar:ref:refs/heads/main permissions: contents: read issues: write\n\nThese trust policies can get much more sophisticated, but let us first see how\nwe would leverage our starter policy.\n\n## Federating with Octo STS\n\nAt a very high-level, the way Octo STS works is outlined in this sequence\ndiagram:\n\nNow suppose the policy from the previous section were checked into\ngithub.com/chainguard-dev/foo as .github/chainguard/baz.sts.yaml then in\ngithub.com/chainguard-dev/bar we could author an actions workflow with this:\n\n    \n    \n    permissions: id-token: write # Needed to federate with octo-sts steps: # Federate our workflow's identity token for a token that we can use # to interact with chainguard-dev/foo - uses: octo-sts/action@6177b4481c00308b3839969c3eca88c96a91775f # v1.0.0 id: octo-sts with: scope: chainguard-dev/foo identity: baz # Use the resulting token with the GitHub CLI (for example) - name: Use the token with gh env: GITHUB_TOKEN: ${{ steps.octo-sts.outputs.token }} run: | gh repos list\n\n... and just like that, we have enabled cross-repository access without a PAT.\n\n## But wait, there\u2019s more!\n\nSince Octo STS is built around OIDC federation, we can federate OIDC tokens\nfrom anywhere, not just GitHub Actions. For example, to allow a Google Service\nAccount to federate you might use a trust policy like this:\n\n    \n    \n    # Match these literal values in the respective claims issuer: https://accounts.google.com subject: \"1234567890\" # This is the \"unique id\" of the Google Service Account # (optionally) match the \"email\" version (beware: the values are regular expressions) claim_pattern: email: baz@blah\\.iam\\.gserviceaccount\\.com ...\n\nWith this policy in place, a Google Service Account can POST its token to Octo\nSTS and ask for a token to interact with the GitHub repo, and Octo STS will\ngenerate one.\n\nAnother neat trick: these trust policies can take advantage of claim_pattern\nto restrict which workflows can federate using the workflow_ref claim, which\nis super helpful for pursuing least privilege.\n\n## One more use case\n\nThe last use case mentioned in the beginning that we haven\u2019t yet covered are\nthings that need organization-level or multi-repository access. For these\ncases, we use the .github repository to hold our trust policies (e.g.). Trust\npolicies in this repository can specify an additional field with the list of\nrepositories to which access should be granted:\n\n    \n    \n    # Grant this identity issuer: ... subject: ... # These permissions permissions: ... # On these repositories repositories: - foo - bar\n\n## A note on permissions\n\nOcto STS has to be installed into your organization (possibly scoped to a few\nrepositories) for us to be able to hand out credentials that can access things\nwithin your organization. Due to how permissions for GitHub Apps work, Octo\nSTS has to have a superset of the permissions it is capable of handing out.\nRight now the list is what we (Chainguard) needed to get off of PATs, but this\nwill necessarily expand over time as users want to federate for additional\npermissions (reach out if there is an additional permission we don\u2019t support).\n\nThe App itself uses exactly one permission: contents: read, which it needs to\nfetch trust policies from the repositories as described above. All other\npermissions exist so that users can request them for their federated tokens.\n\n## Wrapping up\n\nOcto STS eliminated our need for an entire class of long-lived credentials,\nthereby eliminating our exposure to this attack vector. Across Chainguard\u2019s\nGitHub organizations, we have been able to effectively eliminate our usage of\nPATs, several \u201cdeploy keys,\u201d and at least one bespoke GitHub App. Wolfi and\nChainguard are now more secure because of it.\n\nThe one long-lived key for Octo STS itself sits safely in a KMS system\naccessible to only the GitHub App for signing (not raw access) without setting\noff alerts.\n\nContinuously hardening Chainguard\u2019s own software supply chain as we become a\npart of many other organizations\u2019 supply chains is critical. We take a\ndefense-in-depth approach to protecting all of our internal controls and\nsystems, conduct bi-annual pen tests with third parties, live and breathe the\nprinciples of minimalism and ephemerality, and leverage automation for\nalerting, detection and response. The only way to fix weak links in the global\nsoftware supply chain is to start with the most secure foundation possible,\nand that\u2019s exactly what Chainguard is committed to being for our users and\ncustomers today and into the future.\n\nTo install our Octo STS app, get started here. To learn how Chainguard can\nhelp your organization\u2019s software supply chain security strategy, reach out to\nour team.\n\nShare on Twitter Share on LinkedIn Share on Email\n\n##### Related articles\n\nEngineering\n\nSubtraction by addition: Leaner images, safer code\n\nMarch 29, 2024\n\nEngineering\n\nBuilding minimal and low CVE images for compiled languages\n\nFebruary 27, 2024\n\nEngineering\n\nReimagining the Linux distro with Wolfi\n\nFebruary 21, 2024\n\n## Ready to lock down your supply chain?\n\nTalk to our customer obsessed, community-driven team.\n\nGet started\n\nProducts\n\nChainguard Images\n\nChainguard Services\n\nSolutions\n\nContainer Image Security\n\nVulnerability Remediation\n\nOpen Source Software Security\n\nCompliance & Risk Mitigation\n\nSoftware Supply Chain Security\n\nDeveloper\n\nOpen source\n\nDocs\n\nResources\n\nUnchained blog\n\nChainguard Labs\n\nCustomer stories\n\nScanners\n\nSecurity\n\nEducation\n\nCompany\n\nAbout\n\nNewsroom\n\nCareers\n\nChainguard love\n\nLegal\n\nContact\n\nFollow\n\nNewsletter\n\nTwitter\n\nGitHub\n\nLinkedIn\n\nTikTok\n\n\u00a9 2024 Chainguard, Inc.\n\nContact\n\nProducts\n\nSolutions\n\nDeveloper\n\nResources\n\nCompany\n\nFollow\n\nContact\n\nBe the first to know\n\nSign up for Chainguard emails to be the first to see product updates, news,\nand events.\n\n", "frontpage": false}
