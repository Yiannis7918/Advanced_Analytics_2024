{"aid": "40076794", "title": "Mig: Lightweight and Composable Servers for Haskell", "url": "https://anton-k.github.io/mig/", "domain": "anton-k.github.io", "votes": 3, "user": "njrc9", "posted_at": "2024-04-18 14:41:39", "comments": 0, "source_title": "Foreword - Mig by example", "source_text": "Foreword - Mig by example\n\n# Mig by example\n\n# Mig by example\n\nMig is a lightweight and easy to use library to build HTTP servers and clients\nin Haskell. It is kind of servant for Simple/Boring Haskell. This book is an\nexample driven guide to the library. The name mig (pronounced as meeg) is a\nrussian word for \"instant moment\".\n\nThe main features of the mig library are:\n\n  * lightweight library\n  * easy to use. It has simple design on purpose\n  * expressive DSL to compose servers\n  * type-safe route handlers, URLs and conversions\n  * handlers are encoded with generic Haskell functions\n  * built on top of WAI and warp server libraries.\n  * provides Swagger to your server with one-line of code\n  * relies on standard classes to compose servers. The server is a monoid\n  * we can build HTTP-clients from the server definition\n\nExample of hello world server:\n\n    \n    \n    {-# Language OverloadedStrings #-} import Mig.Json.IO -- | Starts server on port 8085. main :: IO () main = runServer 8085 server -- | The server definition server :: Server IO server = \"api/v1\" /. [ \"hello\" /. hello , \"bye\" /. bye ] -- | The handler definition as a function hello :: Get (Resp Text) hello = pure $ ok \"Hello World\" -- | The handler with a query parameter to ask for the user name bye :: Query \"user\" Text -> Get (Resp Text) bye (Query name) = pure $ ok (\"Goodbye \" <> name)\n\n## How to start a new project\n\nIf you are a Haskell beginner and interested to try out building servers with\nmig the easiest way to start is to install stack. See the main page of the\nstack docs in the link on how to do it. After the stack is installed we can\ngenerate a new mig project that contains hello world server with command:\n\n    \n    \n    > stack new my-project-name anton-k/hello-mig\n\nIt generates my-project-name directory that contains a code for our server.\nLet's navigate to it, build server code and start the server:\n\n    \n    \n    > cd my-project-name > make build > make run\n\nAfter that we can query the server on port 8085 either by curl or by swagger-\nui. The project contains a basic JSON API server with two routes. The code\nwill be explained in detail in the next chapter of this tutorial.\n\n## How to use mig library in your project\n\nWe can install it from hackage. We need to use the library mig-server\n\nWith cabal we can install it from Hackage:\n\n    \n    \n    cabal install mig-server --lib\n\nWith stack we can link to the repo in extra-deps (put it in your stack.yaml):\n\n    \n    \n    extra-deps: - git: https://github.com/anton-k/mig commit: <some-commit-of-the-mig-libray> subdirs: - mig - mig-extra - mig-client - mig-wai - mig-swagger-ui - mig-server\n\n## Structure of the library\n\nThere are several libraries:\n\n  * mig - core library which defines DSL to build servers with API-schemas and functions to render it to low-level representation.\n  * mig-extra - extra add-ons to the core library\n  * mig-server - mig core with batteries and functions to run servers on top of warp.\n  * mig-client - HTTP-clients from the server code\n  * mig-wai - convert mig servers to WAI-applications\n  * mig-swagger-ui - serve swagger for you app.\n\n## Source code for examples\n\nWe are going to learn how the mig works by examples. You can run the examples\nfrom the tutorial. Here is the code that we are going to study. Look at the\nMakefile for commands on how to build and run the examples.\n\nLet's dive in to the first example.\n\n## Comparing to other libraries\n\nWhy to use mig if there are other cool libraries? To me mig lies in the middle\nground between servant and scotty. It's as simple as scotty and does not go to\nfancy type road as servant. But it is akin to servant in usage of type-safe\nconversions and type-level safety.\n\n### servant\n\nThe mig uses the same ideas of type-safe handlers which are based on generic\nHaskell functions. The main difference is that in servant the whole server is\ndescribed as type. Which leads to type-safety and ability to derive API schema\nfrom the type.\n\nBut downside of it is fancy big types and very advanced concepts that user\nneeds to know in order to use the library. Also one drawback to me is when\nthings go wrong and you get several pages long error messages. If your server\nis really big it can be very hard to spot the origin of the error as type\nmismatch is going to be with the whole type which describes the full server.\n\nThe mig borrows idea of type-safe functions to represent route handlers. But\ntypes represent only individual handlers. It does not describe the full\nserver. But we have type safety on the level of the single route. And error\nmessages are going to be localised and dedicated to a single route.\n\nUsing type-level description of the routes provide the same benefits as in\nservant case:\n\n  * safe type check of the conversions of low level request and response elements\n  * usage of generic Haskell functions as handlers\n  * declarative design of the servers\n  * composition of servers from small sub-servers\n\nIn the mig API is a value that is derived from the server at run-time. It\nallows us to build clients and OpenApi swagger too.\n\nTo me servant is more demanding and complicated solution. I'd like to use\nsomething more simple.\n\n### scotty\n\nThe scotty is also in domain of simple, easy to use solutions. So why did I\nwrote mig and haven't used the scotty instead? Scotty features more imperative\napproach where you write handlers as expression for Scotty library monad. But\nit does not looks so well as in servant's case to me. It is harder to assemble\nservers from parts. And I really like the idea of type-safe conversions of\nvarious parts of request and response.\n\nSo the scotty is simple enough but for me it lacks some servant features such\nas composability of the servers (nice tree structure of the API) and type-safe\nconversions of various parts of request and response.\n\n", "frontpage": false}
