{"aid": "40020895", "title": "How to use Git reflog to find lost commits", "url": "https://blog.kusho.ai/how-to-use-git-reflog-to-find-lost-commits/", "domain": "kusho.ai", "votes": 3, "user": "thunderbong", "posted_at": "2024-04-13 06:09:41", "comments": 0, "source_title": "How to use Git reflog to find lost commits", "source_text": "How to use Git reflog to find lost commits\n\nApr 12, 2024 3 min read\n\n# How to use Git reflog to find lost commits\n\nConsider this scenario (this may or may not have happened to me \ud83d\udc40) - You check\nout a tag to do a prod release. The release is done and all looks good on\nprod. Now, you start working on a bug fix that\u2019s been bothering your team for\na while. After 4 hours and 200 LOC \u2013 it\u2019s finally fixed. You commit your\nchanges. Then you switch to a different branch to work on another feature. Git\nthrows some warning, but that's just git being git \ud83e\udd37, so you just ignore it. 2\nhours later you want to create a pull request for the bug fix but can\u2019t find\nthe commit anywhere. Cue panic!\n\n### What happened here?\n\nWhen you checkout a tag, you\u2019re in a detached HEAD state.\n\n    \n    \n    You are in a 'detached HEAD' state. You can look around, make experimental changes, commit them, and you can discard any commits you make in this state without impacting any branches by switching back to a branch. If you want to create a new branch to retain the commits you create, you may do so (now or later) by using -c with the switch command. Example: git switch -c <new-branch-name> Or undo this operation with: git switch -\n\nHEAD is a reference to your current position in the repo. When HEAD points to\na branch, you\u2019re in an attached HEAD state.\n\nWhen HEAD points directly to a commit, you\u2019re in a detached HEAD state.\n\nWhen you commit in this state, your commits don\u2019t belong to any branch. When\nyou switch away from this detached head state, Git shows a warning asking you\nto create a branch to retain your commits.\n\n    \n    \n    Warning: you are leaving 1 commit behind, not connected to any of your branches: 9f45edc dummy commit If you want to keep it by creating a new branch, this may be a good time to do so with: git branch <new-branch-name> 9f45edc\n\nIf you don\u2019t do that, your commits will not be part of any branch.\n\nThere are many ways to end up in a similar situation where you made some\ncommits and you can\u2019t find them at some later point. E.g. you made commits in\na detached HEAD state and then forgot to create a branch, you did a git reset\n\u2013 hard origin/<branch_name> and then realized that there were some commits\nthat you wanted to keep, etc.\n\nSo are these commits lost forever? Nope. git reflog to the rescue.\n\n### What is Git reflog?\n\nFrom the official docs:\n\n> Reference logs, or \"reflogs\", record when the tips of branches and other\n> references were updated in the local repository.\n\nYou can think of Git reflog as an audit log of everything that you do (to the\nHEAD reference) in Git like commit changes, switch branches, etc. You can\nrecover almost anything you do in git using reflog with some caveats.\n\n  * Reflog is periodically trimmed so you might not be able to recover very old commits\n  * Reflog is local only so you\u2019ll not be able to recover someone else\u2019s commits from the origin\n\n### Now let\u2019s take a look at how to recover lost commits using reflog\n\n  * Find the commit using the git reflog command. Copy the commit hash from here once you\u2019ve identified the commit you want to recover.\n\n  * Cherry-pick that commit and add it to a branch using git cherry-pick <commit_hash>\n\nAnd just like that, you've recovered your lost work and saved hours that you\nwould've spent redoing it!\n\n### Published by:\n\n### Member discussion\n\nKushoAI \u00a9 2024\n\nPowered by Ghost\n\n", "frontpage": false}
