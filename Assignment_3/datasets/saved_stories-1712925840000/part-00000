{"aid": "40009979", "title": "Improve performance of you Rust functions by const currying", "url": "https://blog.cocl2.com/posts/const-currying-rs/", "domain": "cocl2.com", "votes": 2, "user": "signa11", "posted_at": "2024-04-12 06:42:11", "comments": 0, "source_title": "Improve performance of you Rust functions by const currying", "source_text": "Improve performance of you Rust functions by const currying - COCl2's blog\nhome\n\nCOCl2's blog home\n\n# Improve performance of you Rust functions by const currying\n\nApr 6, 2024\n\nCurrying is a functional programming technique that allows you to partially\napply a function\u2019s arguments and return a new function that takes the\nremaining arguments. This is widely used in functional programming languages\nlike Haskell, as a fundamental tool for many design patterns. However, today\nwe use the technique in Rust to improve the performance of our functions.\n\nTL;DR: You can also take a look to the proc macro const-currying directly.\n\n## Const generics\n\nConst generics is a feature that allows you to use constant values as type\nparameters. A function with const generics will be monomorphized at compile\ntime for each constant values passed in, allowing for more compiler\noptimizations.\n\nWe can take a simple example to demonstrate how const generics work:\n\n    \n    \n    #[inline(never)] pub fn f<const B: bool>(x: i32) -> i32 { if B { x + 1 } else { -x + 1 } } pub fn g(x: i32, y: i32) -> (i32, i32) { let x = f::<true>(x); let y = f::<false>(y); (x, y) }\n\nWe add the #[inline(never)] attribute to prevent the compiler from inlining\nthe function f. Here the function is simple enough to inline, but in a real-\nworld scenario, the function might be more complex and not inlined.\n\nHere is the generated assembly code under -C opt-level=3 option:\n\n    \n    \n    example::f::hc5481d4b82c18b89: mov eax, 1 sub eax, edi ret example::f::heed6faf69bf7a990: lea eax, [rdi + 1] ret example::g::h7afc5ee1582b3b49: push rbp push rbx push rax mov ebx, esi call example::f::heed6faf69bf7a990 mov ebp, eax mov edi, ebx call example::f::hc5481d4b82c18b89 mov edx, eax mov eax, ebp add rsp, 8 pop rbx pop rbp ret\n\nThere are two symbols generated for the function f, one for f::<true> and one\nfor f::<false>. Both are the most optimized version under the given constant\nvalue. As a comparison, if we remove the const generics and use a runtime\nparameter to control the branch, the generated assembly code will be:\n\n    \n    \n    #[inline(never)] pub fn f(B: bool, x: i32) -> i32 { if B { x + 1 } else { -x + 1 } } pub fn g(x: i32, y: i32) -> (i32, i32) { let x = f(true, x); let y = f(false, y); (x, y) }\n    \n    \n    example::f::h3cb1252c09b7e367: mov eax, esi neg eax test edi, edi cmovne eax, esi inc eax ret example::g::h7afc5ee1582b3b49: push rbp push r14 push rbx mov ebx, esi mov esi, edi mov r14, qword ptr [rip + example::f::h3cb1252c09b7e367@GOTPCREL] mov edi, 1 call r14 mov ebp, eax xor edi, edi mov esi, ebx call r14 mov edx, eax mov eax, ebp pop rbx pop r14 pop rbp ret\n\nThe function f::h3cb1252c09b7e367 has much more instructions than the two\nfunctions generated by const generics.\n\nIn current Rust version, only primitive types like numbers/bool/char can be\nused as constant parameters until a new feature called adt_const_params is\nstabilized.\n\n## Runtime parameter\n\nUnfortunately, in real-world scenarios, we may always make the arguments\nconfigurable at runtime, which makes it impossible to utilize the performance\nbenefits of const generics. There are usually two cases we want to optimize:\n\n  1. A part of the function calls is with constant values, and the other part is with runtime values.\n  2. The function is always called with a runtime configurable value, which is likely a given default value. A typical example is a LIKE expression in SQL, which accepts an optional escape character likely be \\\\.\n\nIn the first case, we can expect the compiler to inline the calls with\nconstant values and generate optimized code. However, if the function is too\ncomplex to inline, the performance benefits can\u2019t be achieved. In the second\ncase, things are even worse, the compiler know nothing about the runtime\ndefault value, and is impossible to optimize for it.\n\n## Const currying by hand\n\nWe can manually create two versions of the function, one with the const\nparameters and the other accept runtime parameters.\n\n    \n    \n    fn like_ct<const ESCAPE: char>(s: &str, p: &str) -> bool { /* complex logic */ } fn like_rt(s: &str, p: &str, escape: char) -> bool { /* complex logic */ }\n\nNote: like_ct::<'\\\\\\'> is a curried version of like_rt with a given escape\ncharacter \\, which is why I call it const currying.\n\nWe can also create a dispatch function for a highly biased calling pattern:\n\n    \n    \n    #[inline(always)] fn like(s: &str, p: &str: escape: char) -> bool { if escape == '\\\\' { like_ct::<'\\\\'>(s, p) } else { like_rt(s, p, escape) } }\n\nIn most cases, the function like is more efficient than like_rt. And the\nfunction should be marked as #[inline(always)], which tells the compiler to\nalways inline the function. There are several cases:\n\n  1. If a constant value \\ is passed in, the branch is optimized away, and the function like_ct::<'\\\\\\'> is called directly.\n  2. If a runtime value \\ is passed in, the function like_ct::<'\\\\\\'> is called with a simple branch overhead.\n  3. If other runtime values are passed in (unlikely), the function like_rt is called, and produce a correct result by an unoptimized path.\n\n## const-currying-rs\n\nIn the previous section, we have to duplicate the complex logic in two\nfunctions, which is error-prone and hard to maintain. Things would be even\nworse if we have more than one constant parameter, such as like_ct::<'\\\\\\',\ntrue> to represent a case-sensitive LIKE expression with \\ escape character,\nand different currying may be used in different places, which will produces at\nmost 2n functions to maintain, where n is the number of constant parameters.\n\nTo solve this problem, I created the proc macro const-currying to generate the\ncodes for you.\n\nFor a simple example:\n\n    \n    \n    use const_currying::const_currying; #[const_currying] fn f1( #[maybe_const(dispatch = x, consts = [0, 1])] x: i32, #[maybe_const(dispatch = y, consts = [true, false])] y: bool, z: &str, ) -> (i32, String) { if y { (x, z.to_string()) } else { (-x, z.chars().rev().collect()) } }\n\nThe following codes will be generated:\n\n    \n    \n    #[inline(always)] fn f1(x: i32, y: bool, z: &str) -> (i32, String) { match (x, y) { (1, false) => f1_x_y::<1, false>(z), (1, true) => f1_x_y::<1, true>(z), (0, false) => f1_x_y::<0, false>(z), (0, true) => f1_x_y::<0, true>(z), (x, false) => f1_y::<false>(x, z), (x, true) => f1_y::<true>(x, z), (1, y) => f1_x::<1>(y, z), (0, y) => f1_x::<0>(y, z), (x, y) => f1_orig(x, y, z), } } #[allow(warnings)] fn f1_orig(x: i32, y: bool, z: &str) -> (i32, String) { if y { (x, z.to_string()) } else { (-x, z.chars().rev().collect()) } } #[allow(warnings)] fn f1_x<const x: i32>(y: bool, z: &str) -> (i32, String) { if y { (x, z.to_string()) } else { (-x, z.chars().rev().collect()) } } #[allow(warnings)] fn f1_y<const y: bool>(x: i32, z: &str) -> (i32, String) { if y { (x, z.to_string()) } else { (-x, z.chars().rev().collect()) } } #[allow(warnings)] fn f1_x_y<const x: i32, const y: bool>(z: &str) -> (i32, String) { if y { (x, z.to_string()) } else { (-x, z.chars().rev().collect()) } }\n\n## Peformance benifits\n\n\u201cNo silver bullet\u201d is a well-known principle in software engineering. The\nmacro is not a silver bullet, and it\u2019s not always the best choice to use it.\nAt least, it may heavily increase you binary size, and likely no great\nperformance improvement if there are not many branches or allocations to\neliminate. You should always profile your code before and after using the\nmacro, and make sure the performance is improved.\n\nIn a benchmark of LIKE expression with two const parameters, calling the\ngenerated dispatch function can achieve about 5% performance improvement\ncompared to the original function with runtime default parameters, which is\nnot very exciting, but still worth trying in a critical path.\n\n    \n    \n    use const_currying::const_currying; #[const_currying] fn like( s: &str, p: &str, #[maybe_const(consts = [b'\\\\'])] escape: u8, #[maybe_const(consts = [true, false])] case_sensitive: bool, ) -> bool { // complex logic }\n\n## Keyword generics?\n\nKeyword generics is a new feature proposed by the Rust team, which allows you\nto use keywords like const as type parameters. Although the feature doesn\u2019t\nmention the argument position constness, it\u2019s still possible to imagine a\nsyntax like:\n\n    \n    \n    fn like( s: &str, p: &str, const? escape: u8, const? case_sensitive: bool, ) -> bool { // complex logic }\n\nThe compiler should guarantee that a version of the function is generated for\neach tuples of constant values passed in if the arguments are marked as\nconst?. If compiler can do this automatically by analyze the calling sites,\nmany unused branches and codes can be eliminated.\n\n## Optimized automatically by a JIT runtime\n\nI\u2019m not a compiler expert, but I guess the optimization is already done by\nsome programming languages with JIT support like V8. JIT runtime can analyze\nthe hot paths and generate optimized codes, there is no obvious difference\nbetween optimizing by a runtime type or a runtime value, it\u2019s easy to achieve\nby a JIT runtime. I guess the optimization can also be done by an AOT compiler\nwith a profile-guided optimization.\n\n## Conclusion\n\nThe const-currying macro can help you to generate codes optimized for\nspecified values, which is useful in critical scenarios. Generally, the crate\nis more like a workaround or hint to the current Rust compiler. I hope the\ncrate can be deprecated in the future version by some ease-of-use builtin\nfeatures in compiler.\n\n\u00a9 2024 COCl2's blog home\n\nPowered by Hugo\ufe0f\ufe0f\ufe0f \u270e Paper\n\n", "frontpage": false}
