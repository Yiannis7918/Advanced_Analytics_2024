{"aid": "40020594", "title": "Modern CSS Patterns in Campfire", "url": "https://dev.37signals.com/modern-css-patterns-and-techniques-in-campfire/", "domain": "37signals.com", "votes": 1, "user": "marban", "posted_at": "2024-04-13 04:53:52", "comments": 0, "source_title": "Modern CSS patterns in Campfire", "source_text": "37signals Dev \u2014 Modern CSS patterns in Campfire\n\nDev\n\n    Modern CSS patterns in Campfire\n\nApril 4, 2024\n\n# Modern CSS patterns in Campfire\n\nAn in-depth look at how 37signals built ONCE/Campfire using modern features,\nvanilla CSS, and no frameworks or preprocessors.\n\nJason Zimdars\n\n    Principal Product Designer, Web\n\nRecently, customers who have purchased a copy of ONCE/Campfire were invited to\nparticipate in a live walk through the app\u2019s CSS code. Campfire was built with\nvanilla CSS, fully #nobuild without compiling or preprocessors, and uses the\nlatest web platform features available in evergreen browsers\u2014CSS nesting,\n:has(), :is(), and :where(); wide-gamut colors, View Transitions and more.\n\nIn this post we\u2019ll take a look at how we\u2019re using some of these features and\nshare some helpful patterns discovered along the way.\n\n## Colors\n\nCampfire uses oklch() to define colors in CSS. oklch() offers access to wider\ncolor spaces (like Display-P3) and greatly improves developer ergonomics when\nworking with colors. For example, let\u2019s take a look at these greys used in\nCampfire\u2019s UI.\n\n    \n    \n    :root { --lch-gray: 96% 0.005 96; --lch-gray-dark: 92% 0.005 96; --lch-gray-darker: 75% 0.005 96; }\n\nAt first glance they may seem unfamiliar but they\u2019re actually more readable\nand quite easy to use once you get acquainted.\n\nLCH stands for:\n\n  * Lightness: perceptual lightness ranging from 0%\u2014100%;\n  * Chroma: the amount of color from pure grey to full saturation, 0\u20130.5;\n  * Hue: the color\u2019s angle on the color wheel, 0\u2013360deg.\n\nWith that in mind, we can read the colors without much effort. We can see that\nthey all share the same hue and chroma, only the lightness differs. It\u2019s\napparent just from reading the code that --lch-gray and --lch-gray-dark are\nrelatively close in lightness, but --lch-gray-darker is significantly darker.\nIt\u2019s also simple to adjust them programmatically or manually tweak them\nwithout using a color picker and without inadvertently shifting the hue. If\nyou\u2019ve ever tried to do that with RGB colors you know how tricky that can be.\n\nWe started by defining the pure color values above but we wrap them in the\noklch() color function and define a set of abstract custom properties that\nconsume the values for use in our other stylesheets.\n\n    \n    \n    --color-border: oklch(var(--lch-gray)); --color-border-dark: oklch(var(--lch-gray-dark)); --color-border-darker: oklch(var(--lch-gray-darker));\n\nSure, you might be thinking, grey is easy but what about other colors? Here\u2019s\na set based on blue for links and selections.\n\n    \n    \n    --lch-blue: 54% 0.23 255; --lch-blue-light: 95% 0.03 255; --lch-blue-dark: 80% 0.08 255; --color-link: oklch(var(--lch-blue)); --color-selected: oklch(var(--lch-blue-light)); --color-selected-dark: oklch(var(--lch-blue-dark));\n\nA quick read of these values reveals that all three are in the same color\nfamily, indicated by the same hue angle (255o). Further we can observe that\nlinks are medium lightness and saturation. The light variant has a much higher\nlightness value and much lower saturation making it more grey, while the dark\nvariant is not quite as light or desaturated. We generally use the darker\nvariants for borders around the lighter values.\n\nAnd even better, oklch() makes it trivial to add variants that use alpha\ntransparency, too.\n\n    \n    \n    --color-link-50: oklch(var(--lch-blue) / 0.5);\n\n## Custom Properties\n\nVariables in CSS are certainly not new but we\u2019ve developed some general usage\npatterns that make working with them a pleasure. Let\u2019s look at some styles\nfrom Campfire\u2019s buttons.css to demonstrate.\n\n### Declared vs. Fallback values\n\nOften when using custom properties in the past, we\u2019d set something up like\nthis in which you declare all the custom properties at the top of the rule (or\nin :root) and then use them immediately below. Something like this:\n\n    \n    \n    .btn { --btn-background: var(--color-text-reversed); --btn-border-color: var(--color-border); --btn-border-radius: 2em; --btn-border-size: 1px; --btn-color: var(--color-text); --btn-padding: 0.5em 1.1em; align-items: center; background-color: var(--btn-background); border-radius: var(--btn-border-radius); border: var(--btn-border-size) solid var(--btn-border-color); color: var(--btn-color); display: inline-flex; gap: 0.5em; justify-content: center; padding: var(--btn-padding); }\n\nAnd that works fine but it feels like a lot of boilerplate and it\u2019s a little\ndefensive in that you may never use those variables again. That\u2019s where\nfallback values come in handy. Instead of a litany of properties at the top of\nthe rule, we can set the default values inline but expose a custom property\nthat will accept another value when present. It looks like this:\n\n    \n    \n    color: var(--btn-color, var(--color-text));\n\nHere --btn-color is optional. If it\u2019s set, the rule will use that value; if\nnot, it will fall back to --color-text. The fallback value can be a straight\nvalue or another variable. Now we can re-write the rule above like this:\n\n    \n    \n    .btn { align-items: center; background-color: var(--btn-background, var(--color-text-reversed)); border-radius: var(--btn-border-radius); border: var(--btn-border-size, 2em) solid var(--btn-border-color, var(--color-border)); color: var(--btn-color, var(--color-text)); display: inline-flex; gap: 0.5em; justify-content: center; padding: var(--btn-padding, 0.5em 1.1em); }\n\nThis is tighter and all the default values plus exposed variables are\ntogether, inline.\n\nBut how do we decide where to use custom properties? There are really two\ncases: 1) whenever we need to use the same value in more than one place (DRY)\nand 2) when we know a value is going to be changed.\n\nA good example of the first case is the --btn-size variable. Almost all of\nCampfire\u2019s buttons are circles with an icon inside. To make sure they line up\nnicely with input fields we set their block-size using this variable.\n\nBecause that size is exposed at the :root level we can use it for buttons and\ninput elements. And even better, we can use that value to calculate the height\nof the chat footer in our layout. No magic numbers in sight!\n\n    \n    \n    :root { --btn-size: 2.65em; } body { --footer-height: calc((var(--block-space)) + var(--btn-size) + var(--block-space)); grid-template-rows: 1fr var(--footer-height); }\n\nThe footer\u2019s height consists of the button\u2019s height plus padding above and\nbelow using the global --block-space variable.\n\nThe other case for custom properties is when we know that we\u2019ll want to change\nsome values to create variants of an element. We think of it like a mini API\nfor our CSS classes. Going back to our button class, we can declare variants\nsimply by changing the value of custom properties instead of redefining a\nproperty.\n\n    \n    \n    /* Variants */ .btn--reversed { --btn-background: var(--color-text); } .btn--negative { --btn-background: var(--color-negative); } :is(.btn--reversed, .btn--negative) { --btn-color: var(--color-text-reversed); } .btn--borderless { --btn-border-color: transparent; } .btn--success { animation: success 1s ease-out; img { animation: zoom-fade 300ms ease-out; } }\n\nThis makes it very clear what\u2019s changed by these variants. Even better, as in\nthe case of .btn--success, it makes on obvious distinction between changing a\ndefault property value and adding a new property (the animation property in\nthis case).\n\n## CSS :has()\n\nWe started using :has() in the early stages of Campfire\u2019s development because\nit offers a number of conveniences and opportunities to do with CSS what we\npreviously had to do in server side code. We were so bullish on :has() that we\nliterally shipped the first beta version of Campfire a week before Firefox\nshipped its release with support for :has()\u2014the last of the major browsers to\ndo so.\n\nYou can think of :has() as a way to query an element about what\u2019s inside it.\n\nThis makes our button class very flexible. You can throw about any combination\nof things inside it, and it will adjust accordingly. Text only, image and\ntext, image only, inputs (like radio buttons), or multiple images with text.\n\nFor example, when our .btn class finds an image inside of it (that\u2019s not an\navatar photo), it can apply sizing and make sure it gets inverted in dark\nmode\u2014without needing any kind of special classes.\n\n    \n    \n    .btn { ... img { -webkit-touch-callout: none; user-select: none; } &:where(:has(img):not(.avatar)) { text-align: start; img { filter: invert(0); inline-size: 1.3em; max-inline-size: unset; @media (prefers-color-scheme: dark) { filter: invert(100%); } } }\n\nMost of the buttons in Campfire contain an icon image plus a hidden text\nelement for screen readers.\n\n    \n    \n    <%= form.button class: \"btn btn--reversed center\", type: \"submit\" do %> <%= image_tag \"check.svg\", aria: { hidden: \"true\" }, size: 20 %> <span class=\"for-screen-reader\">Save changes</span> <% end %>\n\nWith :has() our button class can know if these elements are present and turn\nit into a circle icon button with the image centered inside it. Notice that\nwe\u2019re using our --btn-size variable from earlier.\n\n    \n    \n    &:where(:has(.for-screen-reader):has(img)) { --btn-border-radius: 50%; --btn-padding: 0; aspect-ratio: 1; block-size: var(--btn-size); display: grid; inline-size: var(--btn-size); place-items: center; > * { grid-area: 1/1; } }\n\nJust dump whatever you want into .btn and it\u2019ll take care of the rest.\n\nThat\u2019s really satisfying to use as a developer but you could do this without a\nlot of extra effort using utility classes like .btn--circle-icon or .btn--\nicon-and-text. What really opened our eyes was when we were able to replace\nRuby on Rails code with just CSS.\n\nTake, for example, the menu button that toggles the sidebar when using\nCampfire with a narrow viewport.\n\nBecause the sidebar (which lists all of your chat rooms) is hidden when closed\nwe wanted to display a small dot on the menu button to indicate that you have\nrooms with new, unread messages in them. Normally we\u2019d have to write some Ruby\non Rails code to handle that condition something like this:\n\n    \n    \n    <% if @room.memberships.unread.any? %> // render the dot <% end %>\n\nBut with :has() we can do it with pure CSS alone!\n\n    \n    \n    #sidebar:where(:not([open]):has(.unread)) & { &::after { --size: 1em; aspect-ratio: 1; background-color: var(--color-negative); block-size: var(--size); border-radius: calc(var(--size) * 2); content: \"\"; flex-shrink: 0; inline-size: var(--size); inset-block-start: calc(var(--size) / -4); inset-inline-end: calc(var(--size) / -4); position: absolute; } }\n\nHere the we\u2019re querying the sidebar element to 1) make sure it isn\u2019t open\n(because you don\u2019t need to see the dot if you\u2019re already looking at the rooms\nlist) and 2) to see if it has any elements inside it that have the .unread\nclass. If those are true, draw the dot and position it. Notice that we\u2019re\nusing a custom property (--size) here for both the dimensions of the dot and\nto calculate its border radius and position. It\u2019s harmonious and avoids magic\nnumbers.\n\nElsewhere, on Campfire\u2019s account profile screen we used :has() to solve a\nproblem that was nearly impossible to do even with server side code. The\nscreen features a list of all the chat rooms you\u2019re in and a button to toggle\nthe state of each room. If you\u2019ve made the room invisible in your sidebar we\nalso wanted to be able to grey out the row to visually reinforce this critical\nstatus.\n\nThe problem is that toggle button is a completely separate element using a\ndifferent controller, rendered in a Turbo Frame. It\u2019s the same toggle we show\nin the room, itself. That means the code that renders the row has no idea what\nstatus of the button is, nor does it know when the status changes.\n\n    \n    \n    <li class=\"flex align-center gap margin-none min-width membership-item\"> <%= link_to room_path(membership.room), class: \"overflow-ellipsis fill-shade txt-primary txt-undecorated\" do %> <strong><%= room_display_name(membership.room) %></strong> <% end %> <hr class=\"separator\" aria-hidden=\"true\"> <span class=\"txt-small\"> <%= turbo_frame_tag dom_id(membership.room, :involvement) do %> <%= button_to_change_involvement(membership.room, membership.involvement) %> <% end %> </span> </li>\n\nNow we could, of course, use Javascript to get the state, observe changes, and\nupdate the view. Or we could re-write this code to re-render the entire row\nwhen the notification state changes, but then we\u2019d be writing a duplicate\ntoggle that is only slightly different than the one used elsewhere.\n\nA third option is to write a single CSS rule!\n\n    \n    \n    .membership-item:has(.btn.invisible) { opacity: 0.5; }\n\nIf the row has a button in toggled to the .invisible class, dim it.\n\nAdvances in CSS have been slowing replacing Javascript code over the last few\nyears, now it\u2019s coming for server side code!\n\n### One more?\n\nCampfire\u2019s direct message feature, which we call Pings, displays all of your\nactive conversations across the top of the sidebar. Depending on how many\npeople are involved, Campfire displays one, two, three, or four avatars to\nrepresent the chat.\n\nNormally our view template would need to count the number of participants and\nconditionally apply a class to the element so the CSS knows how to render each\nlayout group. But with :has() we can effectively count the number of elements\nand adjust the display accordingly.\n\n    \n    \n    /* Four avatars */ .avatar__group { --avatar-size: 2.5ch; block-size: 5ch; display: grid; gap: 1px; grid-template-columns: 1fr 1fr; grid-template-rows: min-content; inline-size: 5ch; place-content: center; .avatar { margin: auto; } /* Two avatars */ &:where(:has(> :last-child:nth-child(2))) { --avatar-size: 3.5ch; > :first-child { margin-block-end: 1.5ch; margin-inline-end: -0.75ch; } > :last-child { margin-block-start: 1.5ch; margin-inline-start: -0.75ch; } } /* Three avatars */ &:where(:has(> :last-child:nth-child(3))) { > :last-child { margin-inline: 1.25ch -1.25ch; } } }\n\nMagic \ud83e\ude84\n\n## Responsive design\n\nIn this last section, we\u2019ll take a look at Campfire\u2019s approach to responsive\ndesign. The first thing to know is that Campfire has zero/none/nada viewport\nbased @media queries. There are no attempts to assert that viewports narrower\nthan x are mobile devices. Campfire\u2019s layout fully adapts to whichever device\nyou\u2019re using in whichever configuration or orientation, without attempting to\ndeclare any state as \u201cmobile\u201d. Here\u2019s how.\n\n### Layout\n\nCampfire has a single @media breakpoint\u2014one value, used in a number of places.\n\n    \n    \n    @media (max-width: 100ch) { ... }\n\nThis breakpoint largely determines how the CSS grid layout must adjust when\nthe viewport is too narrow to display the sidebar alongside the chat\ntranscript. When the document is narrower than 100 characters, it\u2019s not\npractical to render them side-by-side, so instead Campfire hides the sidebar\nand reveals a menu button to toggle it.\n\nUsing characters as the unit of measure ensures that we get the right behavior\nno matter which device you\u2019re using and in a number of other scenarios such as\nmultitasking on iPad or even if you simply enlarge the font size past a\ncertain point. Type is the heart of web pages so it makes sense for the layout\nto respond to it.\n\n### Feature enhancements\n\nThe other place we use media queries is to respond to the kind of input device\nthe user has. It\u2019s never been fair to assume a device with a narrow viewport\nhas a touch screen, nor that a device with an enormous viewport does not. This\nblurry line is not getting clearer. But thanks to @media queries we can\nactually get useful information about a device\u2019s capabilities. First up, any-\nhover.\n\n    \n    \n    @media (any-hover: hover) { &:where(:not(:active):hover) { /* hover effect */ } }\n\nThis queries the user\u2019s device to see if it has any input mechanism that is\ncapable of hovering (probably a mouse). It won\u2019t match on touch screen devices\nand will opt out of Mobile Safari\u2019s annoying behavior that makes you double-\ntap things that have a hover effect. Not bad.\n\nBut let\u2019s look at something a little more impressive. Every message line in a\nCampfire chat has a \u2022\u2022\u2022 button that reveals a menu of extra actions (edit,\nBoost, copy, share) that you can do.\n\nOn devices with a mouse or trackpad the ideal is to only reveal the menu when\nyou hover over the message but that would make it inaccessible on touch\ndevices. No problem. We can use any-hover along with the pointer query to get\nthe behavior we want on each kind of device.\n\n    \n    \n    @media (any-hover: hover) and (pointer: fine) { /* Reveal the button only on hover */ } @media (any-hover: none) and (pointer: coarse) { /* Show the button all the time */ }\n\nThis is especially magical with a device like the iPad Pro. Which can match\nboth queries under certain conditions, and change on-the-fly. When it\u2019s docked\non the Magic Keyboard with built-in trackpad, it matches the first query and\nthe \u2022\u2022\u2022 buttons are hidden until you hover. Lift it off the Magic Keyboard and\nit becomes a purely touch device\u2014the \u2022\u2022\u2022 buttons magically appear. It\u2019s very\ncool.\n\n## What\u2019s next?\n\nCampfire 1.0 shipped in January 2024 and by March we had already started to\nwork on the next ONCE product. While Campfire supported bleeding edge features\nwhen was released the web platform is rapidly changing and we\u2019re already\nexploring new features that have gained browser support since then. It\u2019s a\nfantastic time to be working on the web.\n\nIf you haven\u2019t tried Campfire yet, it\u2019s available now at once.com, the first\nof a family of products that you buy once, own forever (including source\ncode), and can do what you want with.\n\n## Questions?\n\nHave a question, comment or idea? Want to see more posts like this? Get in\ntouch at jz@37signals.com or x.com/jasonzimdars\n\nSign up to get posts via email, or grab the RSS feed.\n\n", "frontpage": false}
