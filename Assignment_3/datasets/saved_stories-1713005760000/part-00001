{"aid": "40020598", "title": "Never redefine an inherited default parameter value", "url": "http://www.cpptips.com/redef_dflt_parm", "domain": "cpptips.com", "votes": 1, "user": "Tomte", "posted_at": "2024-04-13 04:54:58", "comments": 0, "source_title": null, "source_text": "\n    TITLE: Never redefine an inherited default parameter value (This example taken from \"Effective C++\" by Scott Meyers, p. 132-134.) Let's simplify this discussion right from the start. A default parameter can exist only as a part of a function declaration, and you can inherit only two kinds of functions: virtual functions and nonvirtual functions. Therefore, the only way to redefine a default parameter value is to redefine an inherited function. ...virtual functions are dynamically bound, but default parameter values are statically bound. What's that? You say you're not up on the latest object-oriented lingo or perhaps the difference between static and dynamic binding has slipped your already overburdened mind? Let's review then. An object's static type is the type you declare it to have in the program text. Consider this class heirarchy: enum ShapeColor { RED, GREEN, BLUE }; // a class for geometric shapes class Shape { public: // all shapes must offer a function to draw them virtual void draw (ShapeColor color = RED) const = 0; ... }; class Rectangle : public Shape { public: // notice the different default parameter value - bad! virtual void draw (ShapeColor color = GREEN) const; ... }; class Circle : public Shape { public: virtual void draw (ShapeColor color) const; ... }; Now consider these pointers: Shape *ps1; // static type = Shape * Shape *ps2 = new Circle; // static type = Shape * Shape *ps3 = new Rectangle; // static type = Shape * In this example, ps1, ps2, and ps3 are all declared to be of type pointer- to-Shape, so they all have that as their static type. Notice that is makes absolutely no difference what they're really pointing to -- their static type is Shape* regardless. An object's dynamic type is the type of the object it currently refers to. That is, its dynamic type indicates how it will behave. In the example above, ps2's dynamic type is Circle*... As for ps1, it doesn't really have a dynamic type, because it doesn't refer to any object (yet). ... Virtual functions are dynamically bound, meaning that the particular function called is determined by the dynamic type of the object... ps2->draw (RED); // calls Circle::draw(RED) ps3->draw (RED); // calls Rectangle::draw(RED) This is all old hat... The twist comes in when you consider virtual functions with default parameter values... You might end up invoking a virtual function defined in a derived class but using a default parameter value from a base class: ps3->draw (); // calls Rectangle::draw(RED) ! In this case, ps3's dynamic type is Rectangle, so the Rectangle virtual function is called, just as you would expect. In Rectangle::draw, the default parameter value is GREEN. Because ps3's static type Shape, however, the default parameter value for this function call is taken from the Shape class, not the Rectangle class! ... Why does C++ insist on acting in this perverse manner? The answer has to do with runtime efficiency. If default parameter values were dynamically bound, compilers would have to come up with a way of determining the appropriate default value(s) for parameters of virtual functions at runtime, which woiuld be slower and more complicated than the current mechanism of determining them during compilation. The decision was made to err on the side of speed and simplicity of implementation, and the result is that you now enjoy execution behavior that is efficient, but confusing.\n\n", "frontpage": false}
