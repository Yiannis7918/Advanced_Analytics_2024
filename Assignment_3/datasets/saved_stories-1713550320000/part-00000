{"aid": "40085787", "title": "__super__ considered a case for dependency injection", "url": "https://programming-engineer.nl/blog/__super__-considered-a-case-for-dependency-injection/", "domain": "programming-engineer.nl", "votes": 1, "user": "hayertjez", "posted_at": "2024-04-19 12:10:26", "comments": 0, "source_title": "__super()__ considered a case for dependency injection - Programming Engineer", "source_text": "__super()__ considered a case for dependency injection - Programming Engineer\n\nSkip to content\n\n# super() considered a case for dependency injection\n\nIn following of python super() considered harmfull and __super()__ considered\n__super()__ by Raymond Hettinger Blog Video I came to the idea to use it for\ndependency injection.\n\n# __super()__\n\nIf you haven't seen and used __super()__ before, see the video from Hettinger\nor the docs.python . In short returns a object that delegates method calls to\na parent or sibling of the same type.\n\n# Dependency Injection\n\nFor those unaware of the term Dependency Injection or DI for short. It is a\npattern to to decouple dependencies (it can be a database, file, class or\nfunction) from a certain implementation. So it makes it easier to test or to\nchange later on.\n\n# Reason to use __super()__\n\nFor a small project (<150 hrs) I was working on, I wanted to achieve the\nfollowing - Write production code (obviously) - Write Tests (Unit and\nIntegration) - Unit Tests should be independent from production - Writing\ntests should be easy - No clunky adjustment to production code in order to\nmake the testing easy ^1 - Unittest should be fast - Tests should be\nindependent of production data\n\n## Motivation of Reason\n\n### No adjustment to production in order to make it testable\n\nAn insight I got from reading a book about testing^2. Is that code is a\nliability. I want to minimize production code. (Not in a strict sense that\nfewer lines are better) But the more code the more possibilities in can fail.\n\n### Tests should be independent of production data and production system\n\nProduction Data This one speaks for itself, I think. As production can change\nover time you cannot make assumptions about the data and you will continuously\nask yourself questions is the test wrong or has production data changed\n\nProduction system For the production system it is a little bit different. In\nthis case there is a database. So I could use it to write my tests against it.\nBut I certainly want to avoid the possibility that my tests drops a database\ntable and my production data is gone. (Although would be good lesson to make\nbackups. ) Or modifies existing records.\n\n### Unittest should be fast\n\nWhen adding functionality I sometimes work test-driven and the tests lead me\nto bugs in the program. So I run the unittests very frequently. The amount of\ntests I run are something in the range of 10-100 times per issue for a single\ntest of class of tests and around 1-5 times for the entire test suite again\nthis is also per issue.\n\nAdding a 5 second during test could lead to a possible increase of 5 minutes\nof waiting time per issue (5 secs per issue * 60 runs = 300 sec = 5 minutes).\nBenchmark 26 tests in 3.4 seconds for the current project.\n\n#### Fast \u2248 local\n\nFast tests are almost equal to local test. You could create a online database\nidentical to the production database but this can lead to longer running times\nfor tests as a connection has to be made. In my case I had only two tests when\nran it took about 2 seconds. (They could be run in parallel)\n\n# Design choices\n\n## Design choices 1\n\nHave a local database for the majority of the tests. In order to keep te tests\nfast. This could have been a local PostgreSQL in a docker environment but a\nfull PostgreSQL was not needed for this test setup. But this makes the testing\nenvironment unnecessarily complex. Besides that I am not proficient with\ndocker ecosystem.\n\n## Design choice 2\n\nWith native support in the standard library for SQLite included in the python\nlanguage, I chose that one. It is fast, easily run locally.\n\n## Design choice 3\n\nI was already considering a ORM but having multiple databases strengthened the\nchoice for the ORM SQLAlchemy in this case.\n\n# Code-ing\n\nLets look at the steps taken from idea to code and a couple of refactors and\nconsiderations. The development stack involved was: - Python - FastAPI -\nPostgreSQL - SQLAlchemy\n\n# Bad design\n\n## Database connected to the class\n\n    \n    \n    class Records: engine = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\") def get_database_record(self): with Session(self.engine) as session: stmt = select(OnlyProdDB.item) items = session.scalar(stmt) return items\n\nNow the implementation of the class is connected to the database. How would we\nreuse the methods of the Records class or test it? Overriding the engine\nperhaps?\n\n    \n    \n    import unittest from sqlalchemy import create_engine from super_dependency_injection.prod import Records class TestProd(unittest.TestCase): def test_get_record(self): test_record = Records() test_record.engine = create_engine(\"localtestengine\") # Overriding engine\n\nWhich conforms to the design decision to conform that tests should be\nindependent of production code. But the engine is now connected to the class\nwhich we don't want as the engine is not reusable and the Records class as a\nwhole.\n\n## Database defined within a method\n\nLets have the engine defined somewhere else and import it\n\n    \n    \n    def engine(): return \"postgresql+psycopg://scott:tiger@localhost/test\" class Records: engine = create_engine(engine()) def get_database_record(self): with Session(self.engine) as session: stmt = select(OnlyProdDB.item) items = session.scalar(stmt) return items\n\nMuch better and we can still override it during test, like in the previous\nexample.\n\n## Database defined in the constructor / __init__ method\n\nThe first example where dependency injection comes in. We supply the engine as\na parameter during initialisation of a Record class.\n\n    \n    \n    def engine(): return \"postgresql+psycopg://scott:tiger@localhost/test\" class Records: def __init__(self, engine) -> None: self.engine = create_engine(engine) def get_database_record(self): with Session(self.engine) as session: stmt = select(OnlyProdDB.item) items = session.scalar(stmt) return items\n\nWhen testing we can supply our own engine\n\n    \n    \n    def test_engine(): return \"localtestengine\" class TestProd(unittest.TestCase): def test_get_record(self): test_record = Records(engine=test_engine) test_record.engine # localtestengine\n\n## Database defined through Inheritance\n\n    \n    \n    class Database: engine = create_engine(\"postgresql+psycopg://scott:tiger@localhost/test\") class Records(Database): def get_database_record(self): with Session(self.engine) as session: stmt = select(OnlyProdDB.item) items = session.scalar(stmt) return items class Tables(Database): def get_database_table(self): with Session(self.engine) as session: pass\n\nNow multiple classes can inherit from Database and reuse the defined behaviour\nin the superclass Database But for testing we need to override the engine\nproperty like in the first two examples. But it does not have to and this is\nwhere Multiple Cooperative Inheritance comes in.\n\n## Database defined through inheritance and testing through multiple\ncooperative inheritance\n\nWe can keep the code in production the same as defined in the previous example\nand reuse the same Database for another class Tables.\n\n    \n    \n    class Database: engine = create_engine(\"postgresql+psycopg://scott:tiger@localhost/test\") class Records(Database): def get_database_record(self): with Session(self.engine) as session: stmt = select(OnlyProdDB.item) items = session.scalar(stmt) return items class Tables(Database): def get_database_table(self): with Session(self.engine) as session: pass\n\nBut we can test it using\n\n    \n    \n    import unittest from sqlalchemy import create_engine from super_dependency_injection.prod import Database, Records class TestDatabase(Database): engine = create_engine(\"localtestengine\") class TestRecords(Records, TestDatabase): pass class TestProd(unittest.TestCase): def test_get_record(self): test_record = TestRecords() test_record.engine # localtestengine\n\nDefining TestRecords it inherited from two classes Records and TestDatabase.\nWhen calling the enginge property on test_record it dit not yield\n\"postgresql+psycopg://scott:tiger@localhost/test\" but localtestengine as it\nwas the next in line.\n\nwhen engine property is called onTestRecord first Records is checked, then\nTestDatabase (and then Database through Records`) I found this quite a neat\nuse of Multiple Inheritance.\n\n# Hindsight\n\nAfter setting up the project, I had missed a design pattern available in\nFastAPI (seeing ArjanCodes)^3 the usage of depends was new to me.\n\n## Example with fastapi.Depends\n\n    \n    \n    \"\"\"prod_v5.py\"\"\" from fastapi import Depends, FastAPI from sqlalchemy import String, create_engine, select from sqlalchemy.orm import DeclarativeBase, Mapped, Session, mapped_column, sessionmaker app = FastAPI() def get_db(): engine = create_engine(\"postgresql+psycopg://scott:tiger@localhost/test\") session = sessionmaker(engine) database = session() try: yield database finally: database.close() @app.get(\"/record\") def get_record(session: Session = Depends(get_db)): db_record = get_database_record(session) return db_record class Base(DeclarativeBase): pass class OnlyProdDB(Base): __tablename__ = \"only_prod_db\" id: Mapped[int] = mapped_column(primary_key=True) item: Mapped[str] = mapped_column(String) def get_database_record(session): db_item = session.query(OnlyProdDB.item) return db_item\n    \n    \n    import unittest from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker from super_dependency_injection.prod_v5 import get_database_record engine = create_engine(\"localtestengine\") session = sessionmaker(engine) database = session() class TestProd(unittest.TestCase): def test_get_record(self): test_record = get_database_record(database) test_record\n\nThis pattern is allows for more functional style programming as it does not\nneed the creation of classes See the previous example ofRecords inheriting\nfrom Database Another benefit I see is that querying is more neat as I don't\nneed to set up a context manager (with Session() as session: ) it is less text\nand more readable. So I will definitely try to make use of this pattern when\nusing FastAPI in another project.\n\nSources\n\n  1. Good explanation of DI can be found at ArjanCodes blog \u21a9\n\n  2. In the spirit of Vladimir Khorikov Unit Testing Principles, Practices, and Patterns Remember, all code, including test code, is a liability. I want to minimize code and especially production. Avoid that production fails because of an adjustment made so I can test it. \u21a9\n\n  3. ArjanCodes discussing FastAPI YouTube \u21a9\n\nMade with Material for MkDocs\n\n", "frontpage": false}
