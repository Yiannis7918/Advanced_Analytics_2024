{"aid": "40026077", "title": "Greatest common divisor, the extended Euclidean algorithm, and speed", "url": "https://lemire.me/blog/2024/04/13/greatest-common-divisor-the-extended-euclidean-algorithm-and-speed/", "domain": "lemire.me", "votes": 2, "user": "chmaynard", "posted_at": "2024-04-13 21:01:16", "comments": 0, "source_title": "Greatest common divisor, the extended Euclidean algorithm, and speed!", "source_text": "Greatest common divisor, the extended Euclidean algorithm, and speed! \u2013 Daniel\nLemire's blog\n\nSkip to content\n\nDaniel Lemire's blog\n\nDaniel Lemire is a computer science professor at the Data Science Laboratory\nof the Universit\u00e9 du Qu\u00e9bec (T\u00c9LUQ) in Montreal. His research is focused on\nsoftware performance.\n\n## Support my work!\n\nI do not accept any advertisement. However, you can you can sponsor my open-\nsource work on GitHub.\n\nJoin over 12,500 email subscribers:\n\nYou can follow this blog on telegram. You can find me on twitter as @lemire or\non Mastodon.\n\n## Recent Posts\n\n## Recent Comments\n\n## Pages\n\n## Archives\n\n## Boring stuff\n\n# Greatest common divisor, the extended Euclidean algorithm, and speed!\n\nWe sometimes need to find the greatest common divisor between two integers in\nsoftware. The fastest way to compute the greatest common divisor might be the\nbinary Euclidean algorithm. In C++20, it can be implemented generically as\nfollows:\n\n    \n    \n    template <typename int_type> int_type binary_gcd(int_type u, int_type v) { if (u == 0) { return v; } if (v == 0) { return u; } auto shift = std::countr_zero(u | v); u >>= std::countr_zero(u); do { v >>= std::countr_zero(v); if (u > v) { std::swap(u, v); } v = v - u; } while (v != 0); return u << shift; }\n\nThe std::countr_zero function computes the \u201cnumber of trailing zeroes\u201d in an\ninteger. A key insight is that this function often translates into a single\ninstruction on modern hardware.\n\nThe binary Euclidean algorithm is typically faster than the textbook Euclidean\nalgorithm which has to do divisions (a slow operation), although the resulting\ncode is pleasantly short:\n\n    \n    \n    template <typename int_type> int_type naive_gcd(int_type u, int_type v) { return (u % v) == 0 ? v : naive_gcd(v, u % v); }\n\nI found interesting that there is a now a std::gcd function in the C++\nstandard library so you may not want to implement your own greatest-common-\ndivisor if you are programming in modern C++.\n\nFor the mathematically inclined, there is also an extended Euclidean\nalgorithm. It also computes the greatest common divisor, but also the B\u00e9zout\ncoefficients. That is, given two integers a and b, it finds integers x and y\nsuch that x * a + y + b = gcd(a,b). I must admit that I never had any need for\nthe extended Euclidean algorithm. Wikipedia says that it is useful to find\nmultiplicative inverses in a module space, but the only multiplicative\ninverses I ever needed were computed with a fast Newton algorithm.\nNevertheless, we might implement it as follows:\n\n    \n    \n    template <typename int_type> struct bezout { int_type gcd; int_type x; int_type y; }; // computes the greatest common divisor between a and b, // as well as the B\u00e9zout coefficients x and y such as // a*x + b*y = gcd(a,b) template <typename int_type> bezout<int_type> extended_gcd(int_type u, int_type v) { std::pair<int_type, int_type> r = {u, v}; std::pair<int_type, int_type> s = {1, 0}; std::pair<int_type, int_type> t = {0, 1}; while (r.second != 0) { auto quotient = r.first / r.second; r = {r.second, r.first - quotient * r.second}; s = {s.second, s.first - quotient * s.second}; t = {t.second, t.first - quotient * t.second}; } return {r.first, s.first, t.first}; }\n\nThere is also a binary version of the extended Euclidean algorithm although it\nis quite a bit more involved and it is not clear that it is can be implemented\nat high speed, leveraging fast instructions, when working on integers that fit\nin general-purpose registers. It is may beneficial when working with big\nintegers. I am not going to reproduce my implementation, but it is available\nin my software repository.\n\nTo compare these functions, I decided to benchmark them over random 64-bit\nintegers. I found interesting that the majority of pairs of random integers\n(about two thirds) were coprime, meaning that their greatest common divisor is\n1. Mathematically, we would expect the ratio to be 6/pi^2 which is about right\nempirically. At least some had non-trivial greatest common divisors (e.g.,\n42954).\n\nComputing the greatest common divisor takes hundreds of instructions and\nhundreds of CPU cycle. If you somehow need to do it often, it could be a\nbottleneck.\n\nI find that the std::gcd implementation which is part of the GCC C++ library\nunder Linux is about as fast as the binary Euclidean function I presented. I\nhave not looked at the implementation, but I assume that it might be well\ndesigned. The version that is present on the C++ library present on macOS\n(libc++) appears to be the naive implementation. Thus there is an opportunity\nto improve the lib++ implementation.\n\nThe extended Euclidean-algorithm implementation runs at about the same speed\nas a naive regular Euclidean-algorithm implementation, which is what you would\nexpect. My implementation of the binary extended Euclidean algorithm is quite\na bit slower and not recommended. I expect that it should be possible to\noptimize it further.\n\nfunction| GCC 12 + Intel Ice Lake| Apple LLVM + M2  \n---|---|---  \nstd::gcd| 7.2 million/s| 7.8 million/s  \nbinary| 7.7 million/s| 12 million/s  \nextended| 2.9 million/s| 7.8 million/s  \nbinary ext.| 0.7 million/s| 2.9 million/s  \n  \nMy source code is available.\n\nAs part of the preparation of this blog post, I had initialized tried writing\na C++ module. It worked quite well on my MacBook. However, it fell part under\nLinux with GCC, so I reverted it back.\n\nCredit: Thanks to Harold Aptroot for a remark about the probability of two\nrandom integers being prime.\n\n## Published by\n\n### Daniel Lemire\n\nA computer science professor at the University of Quebec (TELUQ). View all\nposts by Daniel Lemire\n\nPosted on April 13, 2024April 13, 2024Author Daniel LemireCategories\n\n### Leave a Reply Cancel reply\n\nYou may subscribe to this blog by email.\n\nTerms of use Proudly powered by WordPress\n\n", "frontpage": false}
