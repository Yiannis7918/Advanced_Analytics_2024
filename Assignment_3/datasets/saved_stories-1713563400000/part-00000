{"aid": "40088298", "title": "A Combinatory Rosetta Stone", "url": "https://blog.zdsmith.com/posts/a-combinatory-rosetta-stone.html", "domain": "zdsmith.com", "votes": 1, "user": "crux", "posted_at": "2024-04-19 15:48:26", "comments": 0, "source_title": "Subset Park: A Combinatory Rosetta Stone", "source_text": "Subset Park: A Combinatory Rosetta Stone\n\n  * Subset Park\n  * Posts\n  * Notes\n  * About\n  * Illustrated Whist\n  * Combinatory Programming\n  * Culture-Games\n\nPart of the series: Combinatory Programming\n\n# A Combinatory Rosetta Stone\n\n2024-04-14\n\nIn Combinatory Programming, we attempt to provide motivating examples for the\nvarious combinators identified as useful to everyday programmers.\n\nThe aim of that piece was to extract the basic concept of combinators from as\nmuch its context as possible, and present certain particularly useful\ncombinators as higher-order functions callable inside of nearly any\nprogramming language, applicable to most styles of programming. In practice,\nof course, tacit forms\u2014the style of programming that we can use combinator\nfunctions to achieve\u2014are more at home in certain languages and certain\ncontexts than others, and compose most nicely with other features of a\nprogramming environment: plentiful pure, first-class functions; partial\napplication; and terse combinator syntax, among others.\n\nIn this supplement, we can dig deeper into some of those examples; where\nuseful, expressing the same logic in multiple styles, and at times commenting\non features of different styles or languages and the effects they produce.\n\n## identity\n\n    \n    \n    const maybeAbs = n => shouldNormalizeNegatives ? Math.abs(n) : n return nums.map(maybeAbs)\n\nHere, maybeAbs is a function which either calls Math.abs on n or returns it\ndirectly, depending on the value of shouldNormalizeNegatives. This is the most\nexplicit, referring directly to n by name three times, but also the easiest to\nread.\n\n    \n    \n    const maybeAbs = shouldNormalizeNegatives ? Math.abs : identity\n    \n    \n    (def maybe-abs (if should-normalize-negatives math/abs identity)) (map mayb-abs nums)\n\nThe JavaScript and Janet versions behave the same: we bind either the\nabsolute-value function or identity to our new symbol depending on the value\nof the conditional. In later examples, we\u2019ll see less trivial usages of\nidentity.\n\n### A Conditional Combinator\n\n    \n    \n    is_between_negative_3_and_0 =: (<&0)*.(>&_4) maybe_abs =: [`| @. is_between_negative_3_and_0 maybe_abs _5 _4 _3 _2 _1 0 1 2 3 _5 _4 3 2 1 0 1 2 3\n\nThough we haven\u2019t put it into our personal library of combinators, we can\nimagine a function agenda that behaves like this:\n\n    \n    \n    function agenda(p, f, g) { return x => { if (p(x)) { return f(x) } else { return g(x) } }\n\nIn other words, we can imagine a simple combinator that lets us express\nconditional logic tacitly. J\u2019s Agenda @. is such a function. In the slightly\nsilly J example above, we are able to reproduce behaviour closer to the\nJavaScript example: rather than using a conditional to choose a function f or\ng, which is then applied to some values, our J code takes a verb\nbetween_negative_3_and_0, which is then called on every element of the\nargument to maybe_abs. Thus we can use both f and g within a single call. In\nthis example, identity is spelled [.\n\n## compose\n\n    \n    \n    const cleanData = datum => removeUndefineds(coalesceNaNs(datum)) const cleanedData = dirtyData.map(cleanData)\n\nIn the case of composed functions (as opposed to the minimal identity example\nabove), explicit code rarely has many advantages over tacit code. We have to\nrefer to datum twice, so:\n\n  * We have to introduce a name;\n  * It\u2019s not very short.\n\nBut in addition to that, the explicit version is structurally complex. Nested\nfunction calls are difficult to read.\n\n    \n    \n    const cleanData = compose(removeUndefineds, coalesceNaNs)\n    \n    \n    (def clean-data (comp remove-undefineds coalesce-nans))\n\nIn both tacit versions, we avoid an unnecessary name in addition to obtaining\na simpler structure, with less nesting.\n\n    \n    \n    clean_data =: remove_undefineds @ coalesce_nans\n\nIn J, function composition is an infix operator.\n\n### Absolute Difference\n\n    \n    \n    const absoluteDifference = (x, y) => Math.abs(x - y) return absoluteDifference(9, 13) // => 4\n    \n    \n    const absoluteDifference = compose(Math.abs, _.subtract)\n\nIn this case, the explicit code requires us to bind to both x and y; in a case\nlike subtraction, which is so intuitively transparent, this seems particularly\nunnecessary.\n\n    \n    \n    (def absolute-difference (comp math/abs -)) (absolute-difference 11 24) # => 13\n\nThe Janet code also takes advantage of the fact that - is a normal function,\nand not an infix operator, while the JavaScript has to rely on Lodash\u2019s\nsubtract to get a first-class function that does subtraction.\n\n    \n    \n    absolute_difference =: |@:-\n\nThe J code is another straightforward application of function composition. In\nthis case, however, the composition of subtraction with absolute value is\nspelled |@:-, which is shorter than the variable name absolute_difference.\n\nArray language practitioners will contend that this obviates the need for\nbinding the verb to a name at all; why assign it to a variable name when it\nwould require more characters than simply re-spelling it out each time?\n\nOne possible answer: it\u2019s more straightforward to understand the semantics of\nabsolute_difference than of |@:-. I\u2019m not a very experienced J programmer, so\nI can\u2019t argue one way or the other.\n\n### Pipes\n\nIt\u2019s worth calling out that function composition is traditionally written \u201cto\nthe left\u201d; that is, the innermost function is the last argument and the last\nfunction to be applied is the first in the argument list. This maps cleanly to\ntraditional function call syntax\u2014f(g(x)) has f and g in the same order as\n(compose f g)\u2014but ends up being harder to read, as the order of application\nisn\u2019t the same as the order of the syntax.\n\nMany newer languages have syntax, or standard library functions, to\neffectively perform function composition in reverse, so that the call to the\n\u201ccombinator\u201d (such as it is) can be read in the same order as function\napplication.\n\nFor instance, in Janet we could natively write\n\n    \n    \n    (-> dirty-data (coalesce-nans) (remove-undefineds))\n\nThis is not properly a combinator, because it\u2019s not a higher-order function.\nIt\u2019s syntax for a particular tacit form of control flow; it represents the\nactual application of those two functions to dirty-data.\n\nNevertheless we can imagine a so-called pipe that behaves just like compose\nbut in reverse order, which might feel more comfortable to those programmers\nwho have grown used to the conveniences of -> and its cousins.\n\n## apply\n\n    \n    \n    const basesAndExponents = [[0, 1], [1, 2], [3, 5], [8, 13]] return basesAndExponents.map(([base, exponent]) => base ** exponent) // => [ 0, 1, 243, 549755813888 ]\n\nAbsent apply, we explicitly destructure the two elements of the argument value\nand then pass them back to Math.pow. This is relatively verbose, though still\nreadable. If we couldn\u2019t avail ourselves of destructuring either, we\u2019d be\nforced to write\n\n    \n    \n    args => { const base = args[0] const exponent = args[1] return base ** exponent }\n\nWhich begins to feel quite clumsy indeed.\n\n    \n    \n    return basesAndExponents.map(apply(Math.pow))\n    \n    \n    (def bases-and-exponents [[0 1] [1 2] [3 5] [8 13]]) (map (apply math/pow) bases-and-exponents)\n\nIn the explicit example, we availed ourselves of JavaScript\u2019s infix exponent\noperator, **. In the tacit examples, we use their respective languages\u2019\nstandard library pow function in order to be able to pass a first-class\nargument to the apply combinator.\n\n    \n    \n    exponentsAndBases: (0 1;1 2;3 5;8 13) pow: */# pow .' exponentsAndBases 1 2 125 815730721\n\nThe K language isn\u2019t really designed with tacit programming in mind, but, as a\nmember of the array family, it nevertheless has some features that make\ncertain tacit forms the most idiomatic way to write programs. One of them is\nthat apply is spelled .. Here .' means \u201capply each\u201d, that is, it applies pow\nto each pair in the list of pairs exponentsAndBases^1.\n\nWe have used the flipped form exponentsAndBases here, because the tacit form\npow, without being flipped itself, expects the exponent first.\n\n*/# is itself an example of compose; as a function of two arguments, it applies # to them, creating an exponent-length array of bases, and then reduces * over them. In K, unlike J, function composition is not an infix operator; it\u2019s accomplished simply by juxtaposing the two verbs # and */.\n\nIn JavaScript and Janet, juxtaposition is not very meaningful. On the other\nhand, we will see later on that J relies heavily on juxtaposition, but assigns\nthe semantics of combinators more complex than compose to that syntax.\n\n## flip\n\n    \n    \n    const exponentsAndBases = [[0, 1], [1, 2], [3, 5], [8, 13]] return exponentsAndBases.map(([exponent, base]) => base ** exponent) // => [ 1, 2, 125, 815730721 ]\n    \n    \n    return exponentsAndBases.map(apply(flip(Math.pow))) // => [ 1, 2, 125, 815730721 ]\n    \n    \n    (def exponents-and-bases [[0 1] [1 2] [3 5] [8 13]]) (map (apply (flip math/pow)) exponents-and-bases)\n\n### Flipping Without apply\n\nThe minimal example for flip includes usage of apply, because that\u2019s the most\nnatural way to imagine dealing with data consisting of multiple ordered\nvalues, where the order must be changed.\n\nHowever, we can also imagine cases where our combinator accepts a variadic\nfunction such that ordering comes into play. For instance:\n\n    \n    \n    function explicit(x, y) { return [x ** y, y / x] } return explicit(2, 3) // => [ 8, 1.5 ]\n    \n    \n    const tacit = recombine(Array.of, Math.pow, flip(_.divide))\n\nIn this slightly artificial example, we want to both take some x to the y, as\nwell as divide y by x. In a case where the g and h of a recombine call expect\nthe same arguments, but in different orders, we can use flip with one of them.\n\n### Flipping Under Partial Application\n\nUp until now we\u2019ve excluded from consideration the topic of partial functions;\nin practice, the easy availability of partial application makes more tacit\nprogramming convenient.\n\n    \n    \n    (def double (partial * 2))\n\nIn Janet, with a built-in partial function, we can trivially use partial\napplication to define double; we bind the first argument and produce a new\nfunction that takes a single argument and multiplies it by 2.\n\n    \n    \n    (defn square [n] (math/pow n 2))\n\nIf we would like to define square in terms of math/pow, the same technique\nisn\u2019t naively applicable: in this case, the argument we want to bind is the\nsecond one.\n\n    \n    \n    (def square (partial (flip math/pow) 2))\n\nIn this case, we can work in a tacit style by employing flip; now the argument\nwe want to bind is the first argument to the function, so we can pass that\nflipped function directly to partial.\n\n### Flipping Under Partial Application (2)\n\nAnother example, from a refactor of bagatto into tacit style. To be refactored\nis a higher-order function which takes some attribute name and returns a\nfunction that calls sort by getting that attribute.\n\n    \n    \n    (defn attr-sorter [key &opt descending?] (defn by [x y] ((if descending? > <) (x key) (y key))) (fn [items] (sort items by)))\n\nIn tacit style, this becomes:\n\n    \n    \n    (defn attr-sorter ... (partial (flip sort) by))\n\nBy calling flip on sort, we obtain a function which can easily have our new by\napplied as the first argument.\n\n## recombine\n\n    \n    \n    const mean = xs => _.sum(xs) / xs.length return mean([0, 1, 1, 2, 3, 5, 8, 13]) // => 4.125\n    \n    \n    const mean = recombine(_.divide, _.sum, _.size)\n    \n    \n    (def mean (recombine / sum length))\n    \n    \n    mean =: +/ % #\n\nIn the case of J we see perhaps the starkest example of that language\u2019s\norientation towards tacit programming. J combines a few syntactic\ncharacteristics such that simple juxtaposition of verbs, that is, placing\nsyntactic verbs directly next to each other with no operator, triggers the\nbehaviour of application combinators. In the case of mean, we see that\ncreating a so-called 3-train of 3 verbs, f g h, creates a new verb whose\nbehaviour is analogous to recombine(g, f, h), called a fork in J.\n\n### Min-max\n\n    \n    \n    const minMax = xs => [_.min(xs), _.max(xs)] return minMax([1, 1, 2, 3, 5, 8, 13]) // => [ 1, 13 ]\n    \n    \n    const minMax = recombine(Array.of, _.min, _.max)\n    \n    \n    (def min-max (recombine array min-of max-of))\n    \n    \n    min_max =: <./ , >./ min_max 0 1 1 2 3 5 8 13 0 13\n\n### Plus or Minus\n\n    \n    \n    const plusOrMinus = (x, y) => [x + y, x - y] return plusOrMinus(13, 8) // => [ 21, 5 ]\n    \n    \n    const plusOrMinus = recombine(Array.of, _.add, _.subtract)\n\nAs in Absolute Difference above, we see that functions of two arguments, when\ntreated explicitly, result in quite a bit of noise. Explicit plusOrMinus takes\ntwo arguments, neither of which has a particularly meaningful name (judging\nfrom the Lodash docs, under addition they should be named augend and addend;\nunder subtraction, minuend and subtrahend\u2014but what would we call them when\nboth operations come into play?), each of which then has to be referred to\ntwice.\n\n    \n    \n    (def plus-or-minus (recombine array + -)) (plus-or-minus 13 8)\n    \n    \n    plus_minus =: - , + 1 plus_minus 2 _1 3\n\nIt\u2019s worth noting that in both our JavaScript and Janet examples, the\ndistinction between a unary recombined function, like minMax, and a variadic\none, like plusOrMinus, is purely semantic: the syntax of application doesn\u2019t\nchange when the number of arguments expected by g and h do.\n\nIn the J example, on the other hand, our application syntax is by default\ninfix; so while our min_max is written before its argument, our plus_minus is\nwritten in between its two arguments, syntactically identical to its\nconstituent g and h.\n\n### item-getter\n\nAnother example from bagatto shows a real-world refactoring using recombine,\nas well as a non-trivial usage of constant.\n\nitem-getter is a function which takes a path of keywords and should return a\nfunction that, given two arguments, will retrieve the attribute at that path\nin the second argument.\n\nA brief test to demonstrate the expected behaviour:\n\n    \n    \n    (deftest item-getter (let [item {:foo {:bar :baz}} getter (bagatto/item-getter [:foo :bar])] (is (== :baz (getter {} item)))))\n\nThe explicit version:\n\n    \n    \n    (defn item-getter [path] (fn [site item] (get-in item path)))\n\nTacit:\n\n    \n    \n    (defn item-getter [path] (recombine get-in right (constant path)))\n\nThe tacit version, at least with all of the names spelled out, is not shorter.\nAnd if we\u2019re still trying to remember what recombine does, it\u2019s no easier to\nread.\n\nBut once we have internalized the behaviour of recombine a little bit, the\ntacit example has the advantage of not having to introduce any additional\nnames at all. We can read that it returns a function that calls get-in on its\nsecond argument and path.\n\n### Population Standard Deviation\n\n    \n    \n    function sum(xs) { return xs.reduce((n, m) => n + m) } function std(xs) { const mean = sum(xs) / xs.length const squaredDifferences = xs.map((x - mean) ** 2) const meanSquares = sum(squaredDifferences) / xs.length return Math.sqrt(meanSquares) } return std([0, 1, 1, 2, 3, 5, 8, 13]) // => 4.136348026943574\n    \n    \n    pow: {*/y#x} mean: %/ (+/;#:) @\\: std: % mean @ pow[;2]' -/ 1 mean\\\n\nIn this example, we showcase the effectiveness of partial functions towards\nprogramming in a tacit style.\n\nIn the first place, it\u2019s important to note that in our K code we\u2019ve defined\npow differently from the apply example: here we\u2019ve opted for an explicit\ndefinition so that the arguments to pow are base, exponent, which is arguably\nthe more natural ordering.\n\nWe have also defined mean using the K translation of recombine: where our J\ncode in that example took advantage of juxtaposition to create a so-called\n3-train, which J defines to behave as recombine, K has no such built-in\nsupport. The only effect of juxtaposition is composition, as we saw in the\nexample of */#. Instead we\u2019ve used the phrase @\\:, which means \u201capply each of\nthe functions on the left\u201d, with an array containing sum and length, and\ncomposed %/ to its left, reducing the array containing the results of both\noperations with division.\n\nOur final definition, std, is a tacit expression describing the composition of\nall the operations performed iteratively in the JavaScript code. In particular\nI want to highlight the spelling pow[;2]. This is a so-called projection, and\nits semantics are to produce a function which fixes 2 as the second argument\nto the function pow.^2 K\u2019s primitive and flexible syntax for projections makes\nit extremely convenient to describe partial function application; whereas in\nour partial example above, we needed to include flip in order to bind 2 to the\nsecond argument of pow: K\u2019s projection syntax allows partial application in\nany argument positions.\n\nThe resulting function is a juxtaposition of the following functions\n\n  * 1 mean\\: produce an array containing x and the mean of x.\n  * -/: join those two values with -. Implicit in this step is the map that\u2019s explicit in the JavaScript; as an array language, K \u201cdoes the right thing\u201d when subtracing a single value from an array of values.\n  * pow[;2]': square the differences.\n  * mean @: take the mean.\n  * %: take the square root.\n\nIn all cases besides the explicit @, the juxtaposition of two verbs is\nsyntactically treated as function composition, producing a single composed\nfunction.\n\n### Each Value is Unique\n\n    \n    \n    const eachValueIsUnique = xs => xs === _.uniq(xs) return eachValueIsUnique([0, 1, 1, 2, 3, 5, 8, 13]) // => false return eachValueIsUnique([0, 1, 2, 3, 5, 8, 13]) // => true\n    \n    \n    const eachValueIsUnique = recombine(_.isEqual, identity, _.uniq)\n    \n    \n    (def each-value-is-unique (recombine deep= identity distinct)) (each-value-is-unique [0 1 2 3 5 8 13])\n    \n    \n    each_value_is_unique =: -: ~. each_value_is_unique 0 1 1 2 3 5 8 13 0 each_value_is_unique 0 1 2 3 5 8 13 1\n\nJ boasts yet another specialization for tacit programming; whereas we\u2019ve seen\nthe 3-train create a fork, a 2-train (which we express in terms of recombine\nby passing in identity as either g or h) has its own combinatorial meaning: it\ncreates a hook, such that f g behaves like x => f(x, g(x)).\n\n    \n    \n    eachValueIsUnique: ~/ 1 ?:\\ eachValueIsUnique 0 1 1 2 3 5 8 13 0 eachValueIsUnique 0 1 2 3 5 8 13 1\n\nOther members of the array family tend to reserve 2-trains for simple function\ncomposition, as we have seen in other K examples. In K, the specialized hook\nbehaviour can be achieved with n-dos, where 1 g\\ x produces an array of (x;g\nx), which we can then fold some f over. If f needed to be passed g(x), x, then\nwe could reverse the array before folding.\n\nEquivalently, we could use eachleft in the same way we did to write mean:\n\n    \n    \n    ~/ (?:;::) @\\: 0 1 1 2 3 5 8 13 0 ~/ (?:;::) @\\: 0 1 2 3 5 8 13 1\n\nHere, the second of the two functions we apply is ::, the identity function.\n\n## under\n\n    \n    \n    const isAnagram = (x, y) => _.sortBy(x) === _.sortBy(y) return isAnagram(\"live\", \"evil\")\n    \n    \n    const isAnagram = under(_.isEqual, _.sortBy)\n    \n    \n    (def is-anagram (under deep= sort)) (is-anagram @\"live\" @\"evil\")\n    \n    \n    sort =: /:~ is_anagram =: -:&:sort is_anagram =: -:&:sort 'evil' is_anagram 'live' 1\n\nIn J, dyadic under is spelled Appose, &:.\n\nIt\u2019s worth noting that with only one argument, under behaves just like\ncompose: x => _.isEqual(_.sortBy(x)). (Thus, monadic Appose &: is equivalent\nto At @:, which we\u2019ve seen above!)\n\nThe noteworthy difference, then, is how we want to wield the innermost\nfunction when given two or more arguments. Within compose(f, g), all those\narguments are passed to a single application of g, and the result is passed to\nf. Within under, g is treated as a single-argument function and each argument\nto the composition has g called on it individually.\n\n  1. A technical detail here: unlike our apply combinator, K\u2019s . doesn\u2019t return a higher-order function; it eagerly applies its left operand to its right.\n\nIn practice, this is a distinction without a difference. If we look at Janet\u2019s\nnative apply, which behaves similarly, we see that its eager nature poses a\nproblem for using in a combinatory style:\n\n    \n        repl:1:> (def bases-and-exponents [[0 1] [1 2] [3 5] [8 13]]) ((0 1) (1 2) (3 5) (8 13)) repl:2:> (map (apply math/pow) bases-and-exponents) error: arity mismatch, expected 2, got 0 in math/pow [src/core/math.c] on line 306 in apply pc=11 in _thunk [repl] (tailcall) on line 2, column 6\n\nThat\u2019s because Janet, like many languages, won\u2019t do implicit partial\napplication (\u201ccurrying\u201d) of the apply function. On the other hand, K will\nautomatically curry any function that hasn\u2019t been given all of its arguments.\nHere we see two ways to apply pow to .', both of which result in a new\nfunction rather than an arity mismatch.\n\n    \n        pow: */# pow .' (*/#).' .'[pow;] (*/#).'\n\n\u21a9\n\n  2. We\u2019ve made our job a little more complex here by specifying a spelling of pow that goes base, exponent. In fact, this is also a case that lends some credence to the argument that it\u2019s better to simply spell out a verb in full than to give that verb a name. The tacit version described in apply, which takes the exponent first, is not only terser, but in our example, we precisely want to partially apply the exponent before specifying the base. Thus we could equivalently spell std:\n    \n        std: % mean @ (*/#)[2;]' -/ 1 mean\\\n\n\u21a9\n\n## Recent Posts\n\n2024-04-14| A Combinatory Rosetta Stone  \n---|---  \n2024-04-06| Combinatory Programming  \n2023-09-03| An Algebraic Sketch of Poetic Form  \n2023-01-15| 2023: The Year of Ulti  \n2022-12-27| What Makes a Good Culture-Game?  \n  \nBuilt with Bagatto.\n\n", "frontpage": false}
