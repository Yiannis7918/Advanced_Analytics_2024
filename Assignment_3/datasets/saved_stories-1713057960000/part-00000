{"aid": "40025330", "title": "Go performance from version 1.0 to 1.22", "url": "https://benhoyt.com/writings/go-version-performance-2024/", "domain": "benhoyt.com", "votes": 5, "user": "ingve", "posted_at": "2024-04-13 19:23:03", "comments": 0, "source_title": "Go performance from version 1.0 to 1.22", "source_text": "Go performance from version 1.0 to 1.22\n\nBen Hoyt\n\n  * Home\n  * Resume/CV\n  * Projects\n  * Tech Writing\n  * Non-Tech\n  * Email\n\n  * benhoyt.com\n  * benhoyt@gmail.com\n\n# Go performance from version 1.0 to 1.22\n\nApril 2024\n\nTwo years ago I compared two different benchmarks of my GoAWK interpreter on\nall the versions of Go from 1.2 through 1.18.\n\nIn this article I re-run those benchmarks, adding the missing Go versions (1.0\nand 1.1) as well as the new versions (1.19 through 1.22). I also include\nresults with profile-guided optimisation (PGO), which was added in Go 1.20.\nI\u2019ll quote a fair bit from my original article so you don\u2019t have to re-read\nthe old one to understand the setup.\n\nThere are many ways programs written in Go have gotten faster: the Go team and\nexternal contributors have improved the compiler and have optimized the\nruntime, garbage collector, and standard library. Here we compare GoAWK\u2019s\nperformance when compiled using each released version of Go from 1.0 through\n1.22 \u2013 the latest at the time of writing.\n\nI tested this by running GoAWK on two AWK programs which represent different\nextremes of what you can do with AWK: I/O with string processing, and number\ncrunching.\n\nFirst we have countwords, a string processing task that counts the frequencies\nof words in the input and prints out the words with their counts. This is the\nkind of thing that\u2019s typical for an AWK script. The input is a 10x\nconcatenated version of the King James Bible (which I\u2019ve used before for\nperformance comparisons). Here\u2019s the code:\n\n    \n    \n    { for (i=1; i<=NF; i++) counts[tolower($i)]++ } END { for (k in counts) print k, counts[k] }\n\nThe second program is sumloop, a tight loop that adds the loop counter to a\nvariable a bunch of times. This one\u2019s not really a typical use of AWK, but\nmakes for a good test of the GoAWK bytecode interpreter loop:\n\n    \n    \n    BEGIN { for (i=0; i<10000000; i++) sum += i+i+i+i+i }\n\nI had to tweak GoAWK\u2019s code slightly to get it to compile on older Go\nversions. In particular for Go 1.0, because it doesn\u2019t have bufio.Scanner, and\nGoAWK uses that heavily. I used the Go 1.1 implementation of bufio.Scanner for\n1.0.\n\nThe timing numbers in the chart are the time in seconds on my x86-64 Linux\nlaptop (best of three runs). The blue line is countwords and the red line is\nsumloop (incidentally, I had mis-labelled the results last time). Note that\nthe Y axis is logarithmic this time, in an effort to see the more subtle\nimprovements in recent versions more clearly.\n\nAlso included on the chart are the GoAWK binary sizes for each Go version \u2013\nthat\u2019s the light grey line.\n\nOnce again, I used a Python script to run them all and measure the timings.\nHere is the chart (or as a table if you prefer):\n\nThe biggest improvements come in versions 1.3, 1.5, 1.7, and 1.12. After that,\nit\u2019s very gradual speedups \u2013 all the low-hanging fruit has long since been\npicked.\n\nThis time there was a strange bump for countwords in Go 1.2: it went from 7.5s\nin 1.1 to 25.5s in 1.2 (!), and then down to 2.8s in 1.3. This is almost\ncertainly caused by the stack \u201chot split\u201d issue which was fixed in 1.3 due to\nthe Go team changing \u201cthe implementation of goroutine stacks away from the\nold, \u2018segmented\u2019 model to a contiguous model.\u201d\n\nI figured out the cause of the 1.2 anomaly by profiling, and noticing that\nruntime stack operations made up a huge percentage of the running time. Here\u2019s\nthe first few lines of the pprof output:\n\n    \n    \n    $ go tool pprof --text ./goawk_1.2 go12.prof Total: 1830 samples 332 18.1% 18.1% 332 18.1% runtime.newstack 296 16.2% 34.3% 296 16.2% runtime.memclr 281 15.4% 49.7% 281 15.4% runtime.oldstack 222 12.1% 61.8% 619 33.8% github.com/benhoyt/goawk/interp.(*interp).execute 91 5.0% 66.8% 91 5.0% runtime.lessstack 75 4.1% 70.9% 133 7.3% github.com/benhoyt/goawk/interp.(*interp).callBuiltin 57 3.1% 74.0% 57 3.1% runtime.stackfree 53 2.9% 76.9% 81 4.4% strings.FieldsFunc ...\n\nPGO improves the performance by only a few percent, about 2% for countwords\nand 7% for sumloop using Go 1.22. I compile the released GoAWK binaries with\nPGO.\n\nBinary size has remained fairly stable over the years, apart from the large\nbump in 1.2. Even with PGO enabled, binaries are only about 5% bigger, so I\nthink it\u2019s normally worth it.\n\nOverall, countwords is now about 8x as fast as it would have been with Go 1.0,\nand sumloop is 24x as fast. Thanks, Go team, for all your hard work over the\nyears!\n\nI\u2019d love it if you sponsored me on GitHub \u2013 it will motivate me to work on my\nopen source projects and write more good content. Thanks!\n\n", "frontpage": true}
