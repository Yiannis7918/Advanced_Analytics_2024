{"aid": "40011738", "title": "Chrysalisp: Parallel OS with GUI, Terminal, OO Assembler, C-Script and Lisp", "url": "https://github.com/vygr/ChrysaLisp", "domain": "github.com/vygr", "votes": 2, "user": "nateb2022", "posted_at": "2024-04-12 12:20:13", "comments": 0, "source_title": "GitHub - vygr/ChrysaLisp: Parallel OS, with GUI, Terminal, OO Assembler, Class libraries, C-Script compiler, Lisp interpreter and more...", "source_text": "GitHub - vygr/ChrysaLisp: Parallel OS, with GUI, Terminal, OO Assembler, Class\nlibraries, C-Script compiler, Lisp interpreter and more...\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nvygr / ChrysaLisp Public\n\n  * Notifications\n  * Fork 94\n  * Star 1.6k\n\nParallel OS, with GUI, Terminal, OO Assembler, Class libraries, C-Script\ncompiler, Lisp interpreter and more...\n\n### License\n\nGPL-2.0 license\n\n1.6k stars 94 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# vygr/ChrysaLisp\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n57 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nvygrUpdate STATUS.md0d0f931 \u00b7\n\n## History\n\n8,859 Commits  \n  \n### apps\n\n|\n\n### apps\n\n| avoid repeat cursor positions  \n  \n### class\n\n|\n\n### class\n\n| remove array-map-args  \n  \n### cmd\n\n|\n\n### cmd\n\n| add support for \\q  \n  \n### docs\n\n|\n\n### docs\n\n| add support for \\q  \n  \n### fonts\n\n|\n\n### fonts\n\n| add OpenSans Bold from CTFonts repo.  \n  \n### gui\n\n|\n\n### gui\n\n| add action-top and action-bottom  \n  \n### lib\n\n|\n\n### lib\n\n| Update charclass.inc  \n  \n### src/host\n\n|\n\n### src/host\n\n| hold on pii_flush call.  \n  \n### sys\n\n|\n\n### sys\n\n| use a few pseudo ops  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| Save Terminal state.  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| Basic cut/copy/paste functionality and clipboard service (#201)  \n  \n### Makefile\n\n|\n\n### Makefile\n\n| no CNTRL-C on install  \n  \n### README.md\n\n|\n\n### README.md\n\n| fixes for intro docs (#283)  \n  \n### STATUS.md\n\n|\n\n### STATUS.md\n\n| Update STATUS.md  \n  \n### funcs.ps1\n\n|\n\n### funcs.ps1\n\n| Fix typos in tui powershell commands (#284)  \n  \n### funcs.sh\n\n|\n\n### funcs.sh\n\n| no CNTRL-C on install  \n  \n### install.bat\n\n|\n\n### install.bat\n\n| prep for RISCV64 port :)  \n  \n### run.bat\n\n|\n\n### run.bat\n\n| upgrade Windows script files  \n  \n### run.ps1\n\n|\n\n### run.ps1\n\n| upgrade Windows script files  \n  \n### run.sh\n\n|\n\n### run.sh\n\n| simplify  \n  \n### run_cube.ps1\n\n|\n\n### run_cube.ps1\n\n| upgrade Windows script files  \n  \n### run_cube.sh\n\n|\n\n### run_cube.sh\n\n| simplify  \n  \n### run_mesh.bat\n\n|\n\n### run_mesh.bat\n\n| prep for RISCV64 port :)  \n  \n### run_mesh.ps1\n\n|\n\n### run_mesh.ps1\n\n| upgrade Windows script files  \n  \n### run_mesh.sh\n\n|\n\n### run_mesh.sh\n\n| simplify  \n  \n### run_ring.ps1\n\n|\n\n### run_ring.ps1\n\n| upgrade Windows script files  \n  \n### run_ring.sh\n\n|\n\n### run_ring.sh\n\n| simplify  \n  \n### run_star.ps1\n\n|\n\n### run_star.ps1\n\n| upgrade Windows script files  \n  \n### run_star.sh\n\n|\n\n### run_star.sh\n\n| simplify  \n  \n### run_tree.ps1\n\n|\n\n### run_tree.ps1\n\n| upgrade Windows script files  \n  \n### run_tree.sh\n\n|\n\n### run_tree.sh\n\n| simplify  \n  \n### run_tui.bat\n\n|\n\n### run_tui.bat\n\n| upgrade Windows script files  \n  \n### run_tui.ps1\n\n|\n\n### run_tui.ps1\n\n| Fix typos in tui powershell commands (#284)  \n  \n### run_tui.sh\n\n|\n\n### run_tui.sh\n\n| simplify  \n  \n### screen_shot_1.png\n\n|\n\n### screen_shot_1.png\n\n| refresh screen shots  \n  \n### screen_shot_2.png\n\n|\n\n### screen_shot_2.png\n\n| refresh screen shots  \n  \n### screen_shot_3.png\n\n|\n\n### screen_shot_3.png\n\n| refresh screen shots  \n  \n### screen_shot_4.png\n\n|\n\n### screen_shot_4.png\n\n| refresh screen shots  \n  \n### screen_shot_5.png\n\n|\n\n### screen_shot_5.png\n\n| refresh screen shots  \n  \n### screen_shot_6.png\n\n|\n\n### screen_shot_6.png\n\n| refresh screen shots  \n  \n### screen_shot_7.png\n\n|\n\n### screen_shot_7.png\n\n| current GUI screenshot  \n  \n### screen_shot_8.png\n\n|\n\n### screen_shot_8.png\n\n| Update screen_shot_8.png  \n  \n### screen_shot_9.png\n\n|\n\n### screen_shot_9.png\n\n| latest screen shot.  \n  \n### snapshot.zip\n\n|\n\n### snapshot.zip\n\n| argument reorderings...  \n  \n### stop.bat\n\n|\n\n### stop.bat\n\n| split make in tui and gui options  \n  \n### stop.ps1\n\n|\n\n### stop.ps1\n\n| latest Windows launch scripts from Mr Blyss  \n  \n### stop.sh\n\n|\n\n### stop.sh\n\n| -f mode auto stop  \n  \n## Repository files navigation\n\n# ChrysaLisp\n\nChrysaLisp is a 64-bit, MIMD, multi-CPU, multi-threaded, multi-core, multi-\nuser parallel operating system with features such as a GUI, terminal, OO\nAssembler, class libraries, C-Script compiler, Lisp interpreter, debugger,\nprofiler, vector font engine, and more. It supports MacOS, Windows, and Linux\nfor x64, Riscv64 and Arm64 and eventually will move to bare metal. It also\nallows the modeling of various network topologies and the use of ChrysaLib\nhub_nodes to join heterogeneous host networks. It has a virtual CPU\ninstruction set and a powerful object and class system for the assembler and\nhigh-level languages. It has function-level dynamic binding and loading and a\ncommand terminal with a familiar interface for pipe-style command line\napplications. A Common Lisp-like interpreter is also provided.\n\nJoin us at #ChrysaLisp-OS:matrix.org for banter. element.io room recommended.\n\nChrysaLisp can be used on MacOS, Windows and Linux. Supports x64, arm64 and\nriscv64 CPUs. It also supports a VP64 software CPU emulator used for the\ninstall process, but this can be used, with the -e option, on platforms where\nno native CPU support currently exits, as the runtime system. It runs on a\nhosted environment while experimentation is being done, but eventually it will\nbe transitioned to run on bare metal. In the future, I plan to create a VM\nboot image for UniKernel appliances and a WebAssembly target for use within\nweb browsers.\n\nChrysaLisp allows for the simulation of various network topologies utilizing\npoint-to-point links. Each CPU in the network is represented as a separate\nhost process, and point-to-point links utilize shared memory to simulate CPU-\nto-CPU, bidirectional connections. The design intentionally does not include\nglobal bus-based networking.\n\nThe ChrysaLib project, https://github.com/vygr/ChrysaLib, enables the use of\nIP and USB3/USB2 Prolific chip \"copy\" cables to create heterogeneous host\nnetworks. This allows users to connect their MacBooks, Linux, Windows machines\nand PI4's to create their own development LAN or WAN networks, which is pretty\ncool.\n\nChrysaLisp uses a virtual CPU instruction set to eliminate the use of x64,\nARM64, RISCV64, or VP64 native instructions. Currently, it compiles directly\nto native code, but it has the capability to also be translated to byte code\nform and use runtime translation.\n\nTo avoid the need for register juggling for parameter passing, all functions\ndefine their register interface, and parameter sources and destinations are\nautomatically mapped using a topological sort. If non-DAG mappings are\ndetected, the user can address them with a temporary. The software also\nincludes operators to make it easy to bind parameters to dynamic bound\nfunctions, relative addresses, auto-defined string pools, references, and\nlocal stack frame values. Output parameters that are not used can be ignored\nwith an underscore.\n\nChrysaLisp has a powerful object and class system that is not limited to just\nthe assembler but is quite as capable as a high level language. It allows for\nthe definition of static classes or virtual classes with inline, virtual,\nfinal, static, and override methods. The GUI and Lisp are built using this\nclass system.\n\nIt has function-level dynamic binding and loading. Functions are loaded and\nbound on demand as tasks are created and distributed. Currently, functions are\nloaded from the CPU file system where the task is located, but in the future,\nthey will come from the server object that the task was created with and will\nbe transported across the network as needed. Functions are shared among all\ntasks that use the same server object, so only one copy of a function is\nloaded, regardless of how many tasks use it.\n\nThe system functions are accessed through a set of static classes, which makes\nit easy to use and eliminates the need to remember static function locations,\nand also decouples the source from changes at the system level. The interface\ndefinitions for these functions can be found in the sys/xxx.inc files.\n\nA command terminal with a familiar interface for pipe style command line\napplications is provided with args vector, stdin, stdout, stderr etc. Classes\nfor easy construction of pipe masters and slaves, with arbitrary nesting of\ncommand line pipes. While this isn't the best way to create parallel\napplications it is very useful for the composition of tools and hides all the\nmessage passing behind a familiar streams based API.\n\nA Common Lisp like interpreter is provided. This is available from the command\nline, via the command lisp. To build the entire system type (make), calculates\nminimum compile workload, or (make-all) to do everything regardless, at the\nLisp command prompt. This Lisp has a C-Script 'snippets' capability to allow\nmixing of C-Script compiled expressions within assignment and function calling\ncode. An elementary optimize pass exists for these expressions. Both the\nvirtual assembler and C-Script compiler are written in Lisp, look in the\nlib/asm/code.inc, lib/asm/xxx.inc, lib/asm/func.inc, lib/trans/x86_64.inc,\nlib/trans/arm64.inc and lib/asm/vp.inc for how this is done. Some of the Lisp\nprimitives are constructed via a boot script that each instance of a Lisp\nclass runs on construction, see class/lisp/root.inc for details. The\ncompilation and make environment, along with all the compile and make commands\nare created via the Lisp command line tool in lib/asm/asm.inc, again this auto\nruns for each instance of the lisp command run from the terminal. You can\nextend this with any number of additional files, just place them after the\nlisp command and they will execute after the lib/asm/asm.inc file and before\nprocessing of stdin.\n\nDon't get the idea that due to being coded in interpreted Lisp the assembler\nand compiler will be slow. A fully cleaned system build from source, including\ncreation of a full recursive pre-bound boot image file, takes on the order of\n2 seconds on a 2014 MacBook Pro ! Dev cycle (make) and (remake) under 0.5\nseconds. It ain't slow !\n\nNetwork link routing tables are created on booting a link, and the process is\ndistributed in nature, each link starts a flood fill that eventually reaches\nall the CPU's and along the way has marked all the routes from one CPU to\nanother. All shortest routes are found, messages going off CPU are assigned to\na link as the link becomes free and multiple links can and do route messages\nover parallel routes simultaneously. Large messages are broken into smaller\nfragments on sending and reconstructed at the destination to maximize use of\navailable routes.\n\nThe -run command line option launches tasks on booting that CPU, such as the\nexperimental GUI (a work in progress, -run gui/gui/gui.lisp). You can change\nthe network launch script to run more than one GUI session if you want, try\nlaunching the GUI on more than CPU 0, look in funcs.sh at the boot_cpu_gui\nfunction ! :)\n\nThe -l command line option creates a link, currently up to 1000 CPU's are\nallowed but that's easy to adjust. The shared memory link files are created in\nthe tmp folder /tmp, so for example /tmp/000-001 would be the link file for\nthe link between CPU 000 and 001.\n\nAn example network viewed with ps looks like this for a 4x4 mesh network:\n\n    \n    \n    ./main_gui -l 011-015 -l 003-015 -l 014-015 -l 012-015 ./main_gui -l 010-014 -l 002-014 -l 013-014 -l 014-015 ./main_gui -l 009-013 -l 001-013 -l 012-013 -l 013-014 ./main_gui -l 008-012 -l 000-012 -l 012-015 -l 012-013 ./main_gui -l 007-011 -l 011-015 -l 010-011 -l 008-011 ./main_gui -l 006-010 -l 010-014 -l 009-010 -l 010-011 ./main_gui -l 005-009 -l 009-013 -l 008-009 -l 009-010 ./main_gui -l 004-008 -l 008-012 -l 008-011 -l 008-009 ./main_gui -l 003-007 -l 007-011 -l 006-007 -l 004-007 ./main_gui -l 002-006 -l 006-010 -l 005-006 -l 006-007 ./main_gui -l 001-005 -l 005-009 -l 004-005 -l 005-006 ./main_gui -l 000-004 -l 004-008 -l 004-007 -l 004-005 ./main_gui -l 003-015 -l 003-007 -l 002-003 -l 000-003 ./main_gui -l 002-014 -l 002-006 -l 001-002 -l 002-003 ./main_gui -l 001-013 -l 001-005 -l 000-001 -l 001-002 ./main_gui -l 000-012 -l 000-004 -l 000-003 -l 000-001 -run gui/gui\n\n## Getting Started\n\nTake a look at the docs/intro.md for instructions to get started on all the\nsupported platforms.\n\nThe experimental GUI requires the SDL2 library to be installed.\n\nGet them via your package manager, on Linux with:\n\n    \n    \n    sudo apt-get install libsdl2-dev\n\nOr on Mac via Homebrew.\n\n    \n    \n    brew install sdl2\n\n## Make/Run/Stop\n\nTake a look at the docs/intro/intro.md for platform specific instructions. The\nfollowing is for OSX and Linux systems. Windows has a pre-built main.exe\nprovided, or you can configure Visual Studio to compile things yourself if you\nwish.\n\n### Installing\n\nThe first time you download ChrysaLisp you will only have the vp64 emulator\nboot image. You must create the native boot images the first time round. This\nis a little slower than subsequent boots and system compiles but allows us to\nkeep the snapshot.zip file as small as possible.\n\nIf on Linux or Mac via Homebrew:\n\n    \n    \n    make install\n\nOr on Windows\n\n    \n    \n    install.bat\n\n### Make\n\n    \n    \n    make\n\n### Run\n\n    \n    \n    ./run_tui.sh [-n num_cpus] [-e] [-b base_cpu]\n\nText user interface based fully connected network. Each CPU has links to every\nother CPU. Careful with this as you can end up with a very large number of\nlink files and shared memory regions. CPU 0 launches a terminal to the host\nsystem.\n\n    \n    \n    ./run.sh [-n num_cpus] [-e] [-b base_cpu]\n\nFully connected network. Each CPU has links to every other CPU. Careful with\nthis as you can end up with a very large number of link files and shared\nmemory regions. CPU 0 launches a GUI.\n\n    \n    \n    ./run_star.sh [-n num_cpus] [-e] [-b base_cpu]\n\nStar connected network. Each CPU has a link to the first CPU. CPU 0 launches a\nGUI.\n\n    \n    \n    ./run_ring.sh [-n num_cpus] [-e] [-b base_cpu]\n\nRing connected network. Each CPU has links to the next and previous CPU's. CPU\n0 launches a GUI.\n\n    \n    \n    ./run_tree.sh [-n num_cpus] [-e] [-b base_cpu]\n\nTree connected network. Each CPU has links to its parent CPU and up to two\nchild CPU's. CPU 0 launches a GUI.\n\n    \n    \n    ./run_mesh.sh [-n num_cpus on a side] [-e] [-b base_cpu]\n\nMesh connected network. Each CPU has links to 4 adjacent CPU's. This is\nsimilar to Transputer meshes. CPU 0 launches a GUI.\n\n    \n    \n    ./run_cube.sh [-n num_cpus on a side] [-e] [-b base_cpu]\n\nCube connected network. Each CPU has links to 6 adjacent CPU's. This is\nsimilar to TMS320C40 meshes. CPU 0 launches a GUI.\n\n### Stop\n\nStop with:\n\n    \n    \n    ./stop.sh\n\n### Snapshot\n\nSnapshot with:\n\n    \n    \n    make snapshot\n\nThis will create a snapshot.zip file of the obj/ directory containing only the\nhost directory structures, the pre-compiled Windows main_gui.exe and\nmain_tui.exe plus the VP64 boot_image files !\n\nUsed to create the more compact snapshot.zip that goes up on Github. This must\ncome after creation of (make-all-platforms) boot_image set !\n\n    \n    \n    obj/vp64/VP64/sys/boot_image obj/x86_64/WIN64/Windows/main_gui.exe obj/x86_64/WIN64/Windows/main_tui.exe\n\n### Clean\n\nClean with:\n\n    \n    \n    make clean\n\n## About\n\nParallel OS, with GUI, Terminal, OO Assembler, Class libraries, C-Script\ncompiler, Lisp interpreter and more...\n\n### Topics\n\nlinux gui vm lisp osx assembly x86-64 os aarch64 raspberry-pi-3\n\n### Resources\n\nReadme\n\n### License\n\nGPL-2.0 license\n\nActivity\n\n### Stars\n\n1.6k stars\n\n### Watchers\n\n73 watching\n\n### Forks\n\n94 forks\n\nReport repository\n\n## Releases 54\n\nWood Dragon Latest\n\nFeb 9, 2024\n\n\\+ 53 releases\n\n## Packages 0\n\nNo packages published\n\n## Contributors 12\n\n## Languages\n\n  * C++ 51.9%\n  * Common Lisp 20.0%\n  * Assembly 8.5%\n  * NASL 3.9%\n  * SourcePawn 3.5%\n  * C 3.4%\n  * Other 8.8%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
