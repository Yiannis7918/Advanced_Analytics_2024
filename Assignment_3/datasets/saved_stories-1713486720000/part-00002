{"aid": "40079260", "title": "Qwik vs. Next.js: Which framework is right for your next web project?", "url": "https://outshift.cisco.com/blog/qwik-vs-nextjs", "domain": "cisco.com", "votes": 1, "user": "riledhel", "posted_at": "2024-04-18 18:30:40", "comments": 0, "source_title": "Outshift | Qwik vs. Next.js: Which framework is right for your next web project?", "source_text": "Outshift | Qwik vs. Next.js: Which framework is right for your next web project?\n\n###### Insights\n\n###### Inside Outshift\n\n###### Collaborations\n\n###### Product\n\n##### Search Blog\n\nINSIGHTS\n\n16 min read\n\nShare\n\n#### by Samuel Mendenhall\n\n##### Published on 03/14/2024\n\n##### Last updated on 03/14/2024\n\n##### Published on 03/14/2024\n\n##### Last updated on 03/14/2024\n\n# Qwik vs. Next.js: Which framework is right for your next web project?\n\nShare\n\nSubscribe to\n\nthe Shift!\n\n##### Get emerging insights on emerging technology straight to your inbox.\n\nQwik is my go-to framework for web development projects over Next.js. In this\narticle, I\u2019ll explore the differences, pros, and cons of Qwik and Next.js.\nHowever, I believe Qwik, created by Builder.io, has the potential to be the\nfuture of web development.\n\n## Why Qwik is my go-to framework\n\nI ultimately chose Qwik over Next.js for a variety of reasons, including\ndeveloper experience, signals, level of control, the ability to use the\nbroader React ecosystem, and the forward-looking features of the Qwik\nframework., Next.js is a phenomenal framework and I would not hesitate to\nrecommend it. However, Qwik provides such a compelling developer experience\nand novel design that I get excited every time I get to code with it!\n\n## Background: From jQuery to the Qwik framework\n\nI've been in software engineering as a fullstack engineer for close to 20\nyears. My frontend journey started about 15 years ago. I began with plain\nJavaScript and jQuery, then moved to KnockoutJS, AngularJS, and GWT. When\nReact came on the scene in 2013, I was a very early adopter and fell in love.\nReact has been my go-to library for close to 10 years now. I've also used a\nvariety of other frameworks and libraries along the way but React has been my\nde facto frontend library until I discovered Qwik this year.\n\n## What is Qwik?\n\nLet's look at how the Qwik docs define itself: \"Qwik is a new kind of\nframework that is resumable (no eager JS execution and no hydration), built\nfor the edge and familiar to React developers.\" What does that mean though?\nLet's break it down.\n\nQwik leverages JSX, so it feels like React, but one of the defining features\nis its resumability. \"Resumability is about pausing execution on the server\nand resuming execution on the client without having to replay and download all\nof the application logic.\" In other words, render, pause, resume, render,\npause, resume, etc.\n\nFor the most part, this is all transparent to the developer without needing to\nadd complexity. This is a fundamental difference between Qwik and other\nframeworks. For example, In React, the page is rendered on the server, then\nhydrated on the client, then the page is interactive once all necessary\nJavaScript is downloaded. The exception here would be if dynamic imports were\nused, but this is still different than resumeability.\n\nQwik is designed so that the client/server boundary is mostly a non-issue. By\ndefault, everything renders on the server unless you specifically use a\nfunction, like useVisibleTask$ combined with isBrowser, to enforce rendering\non the client only. Otherwise, all server rendering universally works with few\nexceptions.\n\nThis is only the tip of the iceberg though. I encourage you to read through\nthe Concepts page of the Qwik docs, linked below, as Qwik is a truly unique\nframework for solving problems that other frameworks continue to have to\nmitigate.\n\n  * Think Qwik\n  * Resumable\n  * Progressive\n  * Reactivity\n\nQwik is quite new; it's only a few years old. It\u2019s had little exposure by\ndevelopers so far. I only recently discovered it at the All Things Open\nConference. If this is your first exposure to the Qwik framework, please take\nthe time to read through the docs. It's worth it.\n\n## What is Next.js?\n\nThere is much written about Next.js so I'll keep this short and sweet. Next.js\nis the prominent framework that wraps the React Library. It's the current go-\nto framework for React. To quote from the docs, \"Next.js is a React framework\nfor building full-stack web applications. You use React Components to build\nuser interfaces, and Next.js for additional features and optimizations. Under\nthe hood, Next.js also abstracts and automatically configures tooling needed\nfor React, like bundling, compiling, and more. This allows you to focus on\nbuilding your application instead of spending time with configuration.\"\n\n## Comparing Qwik vs Next.js\n\nThere are seven key areas I evaluated in my comparison of Qwik vs Next.js. For\neach, I name a winner so you can evaluate each feature based on what is most\nimportant to you.\n\n### Server vs. client\n\nNext.js forces a very clear distinction between Server and Client Components,\nwhereas Qwik, for the most part, completely makes this a non-issue. Everything\nis essentially server rendered by default, which I would consider a good thing\noverall.\n\nWinner: The edge goes to Qwik\n\nHere is an example from the Next.js docs:\n\n    \n    \n    // Next.js code below // SearchBar is a Client Component import SearchBar from './searchbar' // Logo is a Server Component import Logo from './logo' // Layout is a Server Component by default export default function Layout({ children }: { children: React.ReactNode }) { return ( <> <nav> <Logo /> <SearchBar /> </nav> <main>{children}</main> </> ) } // --- 'use client' export default function SearchBar({ children }: { children: React.ReactNode }) { return ( <> <main>Search!</main> </> ) } // --- 'use client' export default function Logo({ children }: { children: React.ReactNode }) { return ( <> <main>Logo!</main> </> ) }\n\nIn Qwik there is no need to define 'use client':\n\n    \n    \n    // Qwik code below import { component$ } from '@builder.io/qwik'; import SearchBar from './searchbar' import Logo from './logo' export default component$(() => { return ( <> <nav> <Logo /> <SearchBar /> </nav> <slot /> </> ) }); // --- // SearchBar.tsx export default component$(() => { return ( <> <main>Search!</main> </> ) }); // --- // Logo.tsx import { component$ } from '@builder.io/qwik'; export default component$(() => { return ( <> <main>Logo!</main> </> ) });\n\nThe code looks quite similar, and that's expected\u2014it's JSX. The major point\nhere is that in Qwik there\u2019s no need to define 'use client' or 'use server' as\neverything is server rendered by default. This dramatically simplifies and\nimproves the developer experience. While the above is a trivial example, if\nyou've ever worked with Next.js you know that working between server and\nclient components is a constant design choice and implementation\nconsideration.\n\n### Caching\n\nNext.js gives significantly more control over caching. Qwik has caching and\nyou can control the duration but cannot directly control invalidation. Whether\nthat is a deal breaker or not has yet to be seen. In practice, it hasn\u2019t been\na significant issue, but I could foresee it becoming a pain point.\n\nWinner: Next.js\n\nNext.js lets you invalidate cache like so:\n\n    \n    \n    // Next.js code below export default async function Page() { const res = await fetch('https://...', { next: { tags: ['collection'] } }) const data = await res.json() // ... } 'use server' import { revalidateTag } from 'next/cache' export default async function action() { revalidateTag('collection') }\n\nThis is nice and a huge missing feature from Qwik. Qwik's approach is to re-\nrun all routeLoader$s (fetch calls in the current page hierarchy) when a\nserver action happens that may cause a mutation. It works, but fine grain\ncontrol is missing.\n\n### React ecosystem\n\nNext.js naturally has native integration with the full React ecosystem. Qwik\nhas access to the broader React ecosystem through the qwikify$ function, which\nthe Qwik docs say should be considered as a migration strategy. This is\nbecause any React components wrapped in qwikify$ are rendered and hydrated\nisolated from one another, which can affect performance. The counterpoint\nhere, however, is that Qwik also gives a lot of flexibility when this\nhydration happens. For example, you can tell Qwik to wait to hydrate the React\ncomponent(s) until the browser becomes idle. There are many other control\nmechanisms besides idle.\n\nThe other nice feature Qwik has is that it won't even pull down the React libs\nuntil the page is rendered containing the component. If you have a qwikified\nReact component on page B, the React libs will never be loaded until both page\nB is hit in the Browser and various conditions are met, like if it's visible\non the page (think of a modal that isn't yet visible). Qwik gives a lot more\ncontrol than Next.js gives. While qwikify$ is considered a migration strategy,\nit works well, and you have various means to mitigate any potential\nperformance issues.\n\nWinner: Edge goes to Qwik\n\n    \n    \n    // Next.js code below 'use client' import { Carousel } from 'acme-carousel' export default Carousel // --- import Carousel from './carousel' export default function Page() { return ( <div> <p>View pictures</p> {/* Works, since Carousel is a Client Component */} <Carousel /> </div> ) }\n\nYou'll notice with Next.js you can't natively use a client component in a\nserver component, so you still have to wrap the third-party component in\nanother component that has 'use client.'\n\nThe story is similar with Qwik, however the level of control is greater. What\nI really like about Qwik's approach is the control over hydration. Next.js has\nno or little control here whereas Qwik allows you to control hydration on\nload, idle, hover, etc.\n\n    \n    \n    // Qwik code below /** @jsxImportSource react */ import { qwikify$ } from '@builder.io/qwik-react'; import { Carousel } from 'acme-carousel' export default qwikify$(Carousel, { eagerness: 'hover' }) // --- // SomeComponent.tsx import { component$ } from '@builder.io/qwik'; import Carousel from './carousel' export default component$(() => { return ( <div> <p>View pictures</p> <Carousel /> </div> ) });\n\n### Charting\n\nQwik has no native charting library at the time of this writing. In React, you\nhave access to numerous libraries, almost too many choices. That said,\nsomething like Chart.js would be trivial to integrate into Qwik, though it\nwould still be client side rendered only. To leverage the full power of Qwik,\na charting library needs to be created that can be server side rendered. Until\nthen, integration is easy with any Charting library, but they'd all be client\nrendered only. The user experience is fine but not having the option to have\nnative server side rendered is still missing. As a side note, you could\npotentially use a svg charting library or manual svg to render server side,\nbut there isn't a formal Qwik charting library that I've seen do this yet.\n\nWinner: Next.js due to native charting libraries in the React ecosystem\n\n### State management\n\nQwik natively has signals. And if you've used Signals compared to React\nuseState, there is simply no comparison. Signals win hands down. There is an\nopen issue to get Signals in Next.js, but the conclusion is this needs to be\ndone in the React library itself. There are some users who have reported\nsuccess in monkey patching Preact signals into Next.js but the results seem\nmixed.\n\nWinner: Qwik\n\n    \n    \n    // Next.js code below 'use client' function HomePage() { // ... const [likes, setLikes] = React.useState(0); function handleClick() { setLikes(likes + 1); } return ( <div> {/* ... */} <button onClick={handleClick}>Likes ({likes})</button> </div> ); } // Qwik code below export default component$(() => { // ... const likes = useSignal(0); return ( <div> {/* ... */} <button onClick={() => likes += 1}>Likes ({likes})</button> </div> ); })\n\nYou can also pass Signals as props to child components and mutate them there\nas well This is not directly possible in React without callback functions.\n\n    \n    \n    // Qwik code below // Parent.tsx export default component$(() => { // ... const likes = useSignal(0); return ( <div> <Child likes={likes} /> </div> ); }) // Child.tsx type Props = { likes: Signal<number>; }; export default component$<Props>((props) => { return ( <div> <button onClick={() => props.likes += 1}>Likes ({props.likes})</button> </div> ); })\n\n### Dev server\n\nQwik uses Vite and Vite is becoming one of those main stays as a dev server\nfrontend works. Vite has some incredible features, such as a built-in reverse-\nproxy and very efficient handling of modules and hot module reloading. See Why\nVite for more information. Next.js is still very fast to build with SWC and\ndev with Turbo but Vite has the edge here.\n\nWinner: Edge to Qwik\n\n### Server-side rendering\n\nWhile I covered this in the Server vs. Client section, I want to dive deeper\ninto the Server-Side Rendering here.\n\nWhen thinking about rendering server components and when the browser receives\nits first HTML from the framework, the story gets complicated very quickly.\nNext.js and Qwik accomplish the same task, albeit in a different manner. The\nresult is effectively the same at face value, but there are framework specific\ncontrol mechanisms that provide a different developer experience. If you read\nNext.js's loading-ui-and-streaming doc, you can leverage React Suspense to\nhave \u2018instant\u2019 loading then progressive resolution of the UI. This is very\nnice and there is no immediate analog to this in Qwik, but you can still\naccomplish the same thing.\n\nAccording to Next.js, \u201cNavigation is immediate, even with server-centric\nrouting.\u201d Let me describe the core issue here a bit more in depth. With\nserver-side rendering the component first loads a list of products, for\nexample, from some external source (most likely). Next, the framework renders\nthe component and produces HTML, and you won't see the rendered page until the\nbackend fully loads the products and renders the HTML. Therefore, with no\ncache and a slow external API, let\u2019s say five seconds, the user won\u2019t see any\nHTML for the products page rendered for a full five seconds. We can agree that\nthis is a bad user experience. The browser appears to be doing nothing or to\nbe unresponsive.\n\nHow Next.js handles this is by telling you to use a loading.js to leverage\nReact Suspense. Suspense allows you to render a fallback component while the\ndata is loading. Then, when the data is loaded, the fallback component is\nreplaced with the actual component. This is a really nice feature and makes\nfor a great developer experience.\n\nQwik handles this differently. Qwik has a function called a routeLoader$,\nwhich is run exclusively on the server. The Promise must be resolved before\nthe page is rendered. So, in the case of the products component, the\nrouteLoader$ would be called, the Promise would be resolved after five\nseconds, then the page would be rendered. There is no concept such as Suspense\nin Qwik, but you can still accomplish the same thing with server$ streaming.\nThe difference here is that you must manage the data loading yourself, however\nyou have more control over the data loading. For example, you could load the\nfirst 10 products, then render the page, then load the rest of the products.\nThis is a contrived example, but it illustrates the point. There is an\ninteresting GitHub issue for Qwik demonstrating an example of loading data\nwith streaming. You\u2019ll notice the significant complexity of doing this in\nQwik. This is where Next.js wins with its simplicity.\n\nWinner: Next.js due to the developer experience with React Suspense. Qwik,\nhowever, potentially has more fine-grained control and can accomplish the same\nthing, just not as seamlessly.\n\n## Why I chose Qwik\n\n  * Qwik is ultimately easier to develop in as it has a better developer experience\u2014 you don\u2019t have to manage the server vs. client components for the most part. It\u2019s not even that Qwik goes out of its way to abstract that, it\u2019s a fundamental design of Qwik where everything is rendered server side initially unless you specifically go out of your way to make it client side rendered. No marking \u2018use client\u2019 or \u2018use server\u2019, it just works, and you don\u2019t think about it.\n  * While the Qwik ecosystem is in its early stages, you still have access to the broader React Ecosystem. Yes, there is a penalty for hydration, which in practice is typically negligible, but that hydration penalty exists regardless with no alternative in Next.js. The silver lining in Qwik is that you both have control over when hydration happens, and you can eventually rewrite/refactor the React component to be Qwik native.\n  * Signals are superior to React useState, I don\u2019t think there will be much disagreement on this point. If anything, some might argue for RxJS over Signals, but that\u2019s a different discussion.\n  * I believe the Qwik way of resumability represents a possible cornerstone of frameworks going forward. Even React Server Components do something similar with serializing data to the client after rendering. However, with RSCs, \u201cAll code written for Server Components must be serializable, which means you can\u2019t use lifecycle hooks, such as useEffect() or state,\u201d whereas Qwik doesn\u2019t have this limitation. I believe Qwik\u2019s approach is currently superior, though RSCs are a step in the right direction. That doesn\u2019t mean that Qwik itself will necessarily be the defacto framework in the future, but it\u2019s future and forward looking, and its approach solves many problems that other frameworks (like Next.js) must mitigate.\n  * By default, in Next.js (or any React framework) the more third-party components you add the larger the bundle size will be to the browser. There is a linear relationship here. In Qwik, however, there is a lot more control and not a direct linear relationship. No JavaScript is delivered to the browser by default unless specifically needed. You can have a component that contains a charting library, for example, and even if the library is imported on the page, you can control when that library is loaded. That means if you have a charting library that is only used on a modal, you can tell Qwik to only load that library when the modal is opened. This is a huge win for Qwik. In Next.js you can do this with dynamic imports, but it\u2019s not as straight forward as Qwik. Qwik also has a lot more control features than the scenario I just mentioned.\n  * Qwik allows streaming server responses from an async generator in an onClick from the client. This is some magic sauce right here if you look at this example. It\u2019s not impossible something could be hacked together to mimic this in Next.js/React with React Server Components, but it wouldn\u2019t be exactly how Qwik is doing this as it is a fundamental design of Qwik that supports this.\n  * useTask is like React useEffect except since Qwik uses Signals, the usage is significantly straighter forward than useEffect + useState in React. It\u2019s much less boilerplate code and the logic makes more sense.\n\n## Conclusion: The Qwik framework takes the win\n\nYou can\u2019t go wrong with either Next.js or Qwik. Both have great documentation,\nboth have momentum, and both are used in production. While I presented many\ntechnical areas that I believe Qwik excels at, what I really get excited about\nis the intangible feel of developing in the framework. Not every framework or\nlanguage has that intangible feel to it. Qwik has it, and it feels great every\ntime I get to code with it.\n\nSign up for the Shift newsletter for more of the latest insights on emerging\ntechnology.\n\nSubscribe to\n\nthe Shift!\n\nGet emerging insights on emerging technology straight to your inbox.\n\n### Unlocking Multi-Cloud Security: Panoptica's Graph-Based Approach\n\nDiscover why security teams rely on Panoptica's graph-based technology to\nnavigate and prioritize risks across multi-cloud landscapes, enhancing\naccuracy and resilience in safeguarding diverse ecosystems.\n\nDownload\n\nI\n\n# Related articles\n\n###### Inside Outshift\n\n### KubeCon + CloudNativeCon Europe 2024 wrap up: Two key themes and special\neditions of Cloud Unfiltered\n\nEvent Cloud Native\n\n###### Insights\n\n### Why integrating AI with graph-based technology is the future of cloud\nsecurity\n\nCloud Native Panoptica\n\n###### Insights\n\n### Better secret management with Bank-Vaults Secret Sync\n\nCloud Native\n\nSubscribe to\n\nthe Shift\n\n!\n\nGet\n\nemerging insights\n\non emerging technology straight to your inbox.\n\nThe Shift keeps you at the forefront of cloud native modern applications,\napplication security, generative AI, quantum computing, and other\ngroundbreaking innovations that are shaping the future of technology.\n\n## WHAT WE DO\n\n  * Products\n  * Events\n  * Research by Cisco\n  * Open Source\n\nExplore Cisco\n\n## WHO WE ARE\n\n  * About Us\n  * Our Team\n  * Careers\n  * Industry Expertise\n\n## OUR WORK\n\n  * Panoptica\n  * Outshift AI\n  * Recon.Cloud\n\n## BLOG\n\nExplore Cisco\n\nHelp\n\nTerms & Conditions\n\nStatement\n\nCookies\n\nTrademarks\n\n\u00a9 2023 Outshift by Cisco Systems, Inc\n\nCookies allow us to optimise your use of our website. We also use third-party\ncookies for advertising and analytics. Please read our Privacy Statement and\nCookie Notice for more information.\n\n## Consent Manager\n\n  * ### Your Privacy\n\n  * ### Strictly Necessary Cookies\n\n  * ### Performance Cookies\n\n  * ### Targeting Cookies\n\n  * ### Functional Cookies\n\n#### Your Privacy\n\nWhen you visit any website, it may store or retrieve information on your\nbrowser, mostly in the form of cookies. This information might be about you,\nyour preferences or your device and is mostly used to make the site work as\nyou expect it to. The information does not usually directly identify you, but\nit can give you a more personalized web experience. Because we respect your\nright to privacy, you can choose not to allow some types of cookies. Click on\nthe different category headings to find out more and change our default\nsettings. However, blocking some types of cookies may impact your experience\nof the site and the services we are able to offer. Privacy Statement\n\n#### Strictly Necessary Cookies\n\nAlways Active\n\nThese cookies are necessary for the website to function and cannot be switched\noff in our systems. They are usually only set in response to actions made by\nyou which amount to a request for services, such as setting your privacy\npreferences, logging in or filling in forms. You can set your browser to block\nor alert you about these cookies, but some parts of the site will not then\nwork. These cookies do not store any personally identifiable information.\n\n#### Performance Cookies\n\nThese cookies provide metrics related to the performance and usability of our\nsite. They are primarily focused on gathering information about how you\ninteract with our site, including: page load times, response times, error\nmessages, and allowing a replay of a visitor\u2019s interactions with our site,\nwhich enables us to review and analyze visitor behavior, helping to improve\nsite usability and functionality. These cookies also allow us to count visits\nand traffic sources so we can measure and improve the performance of our site.\nThey help us to know which pages are the most and least popular and see how\nvisitors move around the site. If you do not allow these cookies we will not\nknow when you have visited our site and will not be able to monitor its\nperformance.\n\n#### Targeting Cookies\n\nThese cookies may be set through our site by our advertising partners. They\nmay be used by those companies to build a profile of your interests and show\nyou relevant adverts on other sites. They do not store directly personal\ninformation, but are based on uniquely identifying your browser and internet\ndevice. If you do not allow these cookies, you will experience less targeted\nadvertising.\n\n#### Functional Cookies\n\nThese cookies enable the website to provide enhanced functionality and\npersonalisation. They may be set by us or by third party providers whose\nservices we have added to our pages. If you do not allow these cookies then\nsome or all of these services may not function properly.\n\n### Cookie List\n\nConsent Leg.Interest\n\nlabel\n\nlabel\n\nlabel\n\nlabel\n\n", "frontpage": false}
