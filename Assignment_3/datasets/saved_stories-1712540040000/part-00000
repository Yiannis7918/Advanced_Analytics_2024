{"aid": "39963135", "title": "The Case Against [unowned self]", "url": "https://jacobbartlett.substack.com/p/the-case-against-unowned-self", "domain": "jacobbartlett.substack.com", "votes": 1, "user": "jakey_bakey", "posted_at": "2024-04-07 19:31:42", "comments": 0, "source_title": "The Case Against [unowned self]", "source_text": "The Case Against [unowned self] - by Jacob Bartlett\n\n# Jacob\u2019s Tech Tavern\n\nShare this post\n\n#### The Case Against [unowned self]\n\njacobbartlett.substack.com\n\n#### Discover more from Jacob\u2019s Tech Tavern\n\nI'm a Lead iOS Engineer working in London startups. Every 2 weeks, I'll send\nyou ludicrously in-depth articles about iOS, Swift, and indie projects.\n\nOver 1,000 subscribers\n\nContinue reading\n\nSign in\n\n# The Case Against [unowned self]\n\n### Why you shouldn\u2019t ever use this keyword (and when you should)\n\nJacob Bartlett\n\nJan 08, 2024\n\n4\n\nShare this post\n\n#### The Case Against [unowned self]\n\njacobbartlett.substack.com\n\nShare\n\nAbstract representation of \u201cthe heap\u201d \u2014 photo by Rick Mason on Unsplash\n\nEvery time you use a class, closure, or actor, Swift is storing information on\nthe heap. The variable you\u2019re passing around is really a pointer to this\naddress in memory (a.k.a. a reference).\n\nBack in the olden days, Mac and iOS developers would need to manage this\nmemory manually through functions like alloc() to create a block of memory on\nthe heap, retain() to add another reference, and release() to free up the\nmemory.\n\nIn 2011, Apple introduced ARC \u2014 automatic reference counting \u2014 which made the\ncompiler write this boilerplate memory management code itself, saving untold\ncenturies of cumulative dev-time.\n\nARC introduced the concept of different types of reference.\n\nThanks for reading Jacob\u2019s Tech Tavern! Subscribe for free to receive new\nposts and support my work.\n\n##\n\nStrong references\n\nThis is the default reference; a pointer which makes sure the memory it points\nat remains alive while the pointer is in use.\n\nCreating a strong reference increments a heap object\u2019s reference count (a.k.a.\nrefCount), and the object is deallocated, freeing up the memory in the heap,\nwhen refCount hits zero.\n\n##\n\nWeak references\n\nweak references allow heap objects to point at each other without making a\nretain cycle. Developers can hence create references to classes in closures\nand delegates without keeping them alive unnecessarily.\n\nweak references point at the heap object in memory without incrementing\nrefCount. If refCount dips to zero, the object is deallocated and the weak\nreference becomes nil\u2014 this prevents memory leaks in closures.\n\nTo handle this modus operani, weak references always come wrapped in an\noptional.\n\n    \n    \n    // StoreViewModel.swift func loadStorefront() { api.fetchInventory() { [weak self] inventory in self?.inventory = inventory } }\n\nIn this example, inventory is fetched over the network, and the closure\ncallback runs when data arrives. self is weakly captured, meaning that the\nproperties on StoreViewModel can be updated in the closure. If the user leaves\nthe screen, and the view model\u2019s strong refCount becomes zero, then the\nruntime can deinitialize the view model \u2014 it won\u2019t be kept alive in memory\nwhile waiting for the callback, and so nothing happens when inventory is\nreturned.\n\n##\n\nUnowned references\n\nA third type of reference was introduced with Swift to help prevent retain\ncycles: unowned. This behaves similarly to a weak reference, except it assumes\nthat the memory of the referenced object will always outlive the unowned\npointer referencing it.\n\n    \n    \n    // StoreSingleton.swift static let sharedInstance = StoreSingleton() private init() {} func configureStorefront() { api.fetchInventory() { [unowned self] inventory in self.inventory = inventory } }\n\nHere, we have a \u201ctrue singleton\u201d (with a private init), so we can be sure the\nlifetime of the object will outlive any closures. The [unowned self] in the\nclosure capture list prevents a retain cycle from being created (though, for a\nsingleton, we don\u2019t actually need to worry about retain cycles).\n\nThe closure is a little bit simpler, and unowned comes with a few performance\nbenefits compared to weak references:\n\n  * There is no need to use optional chaining or unwrapping operations.\n\n  * unowned references store less metadata as they don\u2019t create a side table on the heap object.\n\n  * Accessing the memory pointed at by weak references involves one extra jump, or layer of indirection, between pointers.\n\nThis performance comes with a catch though: if you get the lifetimes wrong,\nand the closure or property outlives the unowned reference, your app will\ncrash.\n\n> There is actually also a 4th type, the unowned(unsafe) reference, which\n> disables runtime safety checks. Instead of crashing if the referenced object\n> is deallocated, the program will happily accessing the memory address\n> anyway. If crashes are the second-worst thing you do to your users,\n> corrupting user data is #1.\n\n#\n\nIs unowned worth it?\n\nObviously, crashes are pretty bad. And premature optimisation, as Knuth is\nfrequently misquoted, is a temptation about which we should be mindful. So we\nshouldn\u2019t use unowned references willy-nilly just to get a little bit more\nperformance.\n\nIf you\u2019re reading my blog, you probably know what you are doing when it comes\nto Swift. But can you be certain this is true for everybody on your team?\n\nCan you be sure every code review you perform at 5pm on a Friday is judicious\nabout understanding the many-branching code paths that lead to object\ndeinstantiation, every time you spot the unowned keyword?\n\nUltimately, unowned isn\u2019t a programming problem. It\u2019s a human problem.\n\n#\n\nPerformance costs of weak references\n\nWe understand the risks of unowned. Let\u2019s talk about the benefits compared to\nweak references.\n\nIt\u2019s all about performance.\n\nI\u2019m not going to pretend the handful of CPU instructions involved in optional\nunwrapping the weak reference is important. Optionals are secretly enums;\nvalue types which live on the stack. Overhead from manipulating these is\nnegligible, as they eschew the need for thread-safe, locked access to the\nheap.\n\nLet\u2019s talk about memory. weakly referencing a heap object for the first time\ncreates a side table, a lightweight piece of metadata stored outside the heap\nobject\u2019s memory layout. Side tables contain a pointer back to the heap object,\nthe weak reference count; and refCounts for any integer-overflowed strong &\nunowned references. unowned references do not themselves require a side table.\n\nIf this sounds like a tiny handful of bits, you\u2019d be right. It\u2019s an extremely\nsmall amount of additional memory. So small in fact, that the runtime doesn\u2019t\nrequire extra work on deinit to pre-emptively nil-out weak references. Until\nthe weak reference is discarded, the lightweight side table remains in memory\nand checks the lifecycle state of the heap object to return either nil or the\nobject.\n\nThere is some overhead here. weak references point at this side table, which\nin turn points to the actual heap object. This indirection adds a tiny bit\nmore overhead to weak references, and runs a small risk of expensive CPU cache\nmisses.\n\nunowned references, in contrast, point directly to the heap object in memory.\nThere is less indirection, however the runtime still needs to check the heap\nobject\u2019s lifecycle state \u2014 so it knows whether to return the object or crash\nout with swift_abortRetainUnowned.\n\n> If you found this section terribly interesting, take a look at the Swift\n> runtime source code. Much of this information is explained in the comments\n> on runtime/HeapObject.cpp and shims/RefCount.h.\n>\n> In the Swift source code, I actaully bumped into my old friend,\n> isUniquelyReferenced \u2014 check out COW2LLVM for a serious deep-dive, where we\n> end up deep down in of the bit-level memory layout of RefCount and side\n> tables.\n\n#\n\nWhen it makes sense to use unowned\n\nFrom looking at the Swift source and understanding the implementation of weak\nand unowned references, it is clear that the benefits of using unowned are\nslim, and the risk of causing a fatal error is often not worth this\nperformance benefit.\n\nBut, everything in computer science is about trade-offs, and there are some\ninstances where this trade-off makes sense.\n\n  * When you have a large number of references, and runtime performance becomes your critical bottleneck, for example this developer making a game engine with many on-screen objects.\n\n  * When you have a vast number of references, and memory is so constrained that saving a handful of bytes becomes a relevant concen \u2014 perhaps if you want to optimise some part of the code to fit into an L1 CPU cache.\n\n  * When you\u2019re an indie developer not relying on any other contributors, you know exactly what you\u2019re doing, and have your eyes open about eating the cost of crashes in production.\n\nI hope you\u2019ll agree, however, that using [unowned self] in a single closure\ncallback is an pretty poor trade-off for a few clock cycles and, at worst, a\nfew nanoseconds of cache miss.\n\n#\n\nConclusion\n\nunowned references help you to prevent retain cycles in ARC. They offer a\nFaustian bargain: a sliver of runtime performance in exchange for the risk of\ncrashing if you get it wrong.\n\nThere are some instances, such as with huge numbers of references in\ncritically bottlenecked systems, in which they make sense to use. But [unowned\nself] in a single closure capture list is not one of them.\n\nI recommend you just stick with [weak self] and treat unowned as an\nexceptional case \u2014 that is, a case with which you\u2019re willing to swallow an\nexception if you get it wrong.\n\nLong story short \u2014 if you\u2019re confident enough to use unowned in your code,\njust use unowned(unsafe), you coward*. It\u2019s marginally more performant.\n\n> *Don\u2019t do this.\n\nThanks for reading Jacob\u2019s Tech Tavern! Subscribe for free to receive new\nposts and support my work.\n\n4 Likes\n\n4\n\nShare this post\n\n#### The Case Against [unowned self]\n\njacobbartlett.substack.com\n\nShare\n\nComments\n\nMy Toddler Loves Planes, So I Built Her A Radar\n\nAn adorable side project featuring SwiftUI, MapKit, and open-source APIs\n\nNov 27, 2023 \u2022\n\nJacob Bartlett\n\n73\n\nShare this post\n\n#### My Toddler Loves Planes, So I Built Her A Radar\n\njacobbartlett.substack.com\n\n44\n\nMy Toddler Still Loves Planes, So I Upgraded Her Radar\n\nAn adorable set of release notes\n\nJan 22 \u2022\n\nJacob Bartlett\n\n17\n\nShare this post\n\n#### My Toddler Still Loves Planes, So I Upgraded Her Radar\n\njacobbartlett.substack.com\n\n3\n\nOh Sh*t, My App is Successful and I Didn\u2019t Think About Accessibility\n\nSpeedrunning a11y in SwiftUI\n\nMar 18 \u2022\n\nJacob Bartlett\n\n15\n\nShare this post\n\n#### Oh Sh*t, My App is Successful and I Didn\u2019t Think About Accessibility\n\njacobbartlett.substack.com\n\n5\n\nReady for more?\n\n\u00a9 2024 Jacob Bartlett\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great writing\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": false}
