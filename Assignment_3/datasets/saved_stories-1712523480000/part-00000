{"aid": "39961186", "title": "Making ClickHouse ch-go client more user-friendly", "url": "https://vaniasin.com/chh-making-clickhouse-ch-go-user-friendly/", "domain": "vaniasin.com", "votes": 1, "user": "nikitos_vv", "posted_at": "2024-04-07 14:56:19", "comments": 0, "source_title": "Making ClickHouse ch-go client more user-friendly", "source_text": "Making ClickHouse ch-go client more user-friendly | Nikita Vaniasin, Software Engineer\n\n# Making ClickHouse ch-go client more user-friendly\n\nNikita Vaniasin | Apr 2, 2024 | 5 min read\n\nClickHouse is a fast open-source column-oriented database management system\nthat allows generating analytical data reports using SQL queries.\n\nWe were using it for some time in our Golang application with the most popular\nclickhouse-go/v2 driver package which served nice and allowed writing queries\nin fast and clean way.\n\nRecently I came across the benchmarks for different ClickHouse go drivers\ncomparing the performance for simple select: https://github.com/ClickHouse/ch-\nbench#benchmarks. I was surprised at the difference between clickhouse-go/v2\nand ch-go packages and decided to do a bit of research, especially since I\nwanted to optimize response times for some of our requests.\n\nThe better performance of ch-go comes from its low-level design: it works with\ncolumns (as the native ClickHouse protocol), not rows like clickhouse-go/v2\ndriver. Actually clickhouse-go/v2 is using ch-go under the hood. After\ninspecting more of our code, it struck me that we are using the column-\noriented database as a traditional relational DB:\n\n  * We are reading / unpacking data from ClickHouse using clickhouse-go/v2. Internally it uses ch-go, so it is done in column-by-column way. Then clickhouse-go/v2 parses set of columns into a slice of entries (rows).\n  * Next, we marshal the results into JSON for HTTP response.\n  * On the frontend, we are using code like let clicks = data.map(({ clicks }) => clicks) to unpack values again into a list of values!\n\nSo why not just unpack data from ClickHouse result-set into frontend-friendly\nformat and send columns to frontend directly? This is definitely not a new\nidea.\n\nI started to investigate how I can introduce ch-go into our project and it\nturned out that official documentation for ch-go is not detailed enough and\nthere were no proper examples how to use it even for simple SELECTs. Most of\nthe test code was checking the validity by selecting just one row, but this is\nprobably not so important use-case. After some googling, I found these two\nposts which helped me to understand the package API:\n\n  * https://clarktrimble.online/blog/funhouse/\n  * https://clarktrimble.online/blog/generic-golang/\n\nUnfortunately, it seems quite stinky funky. Firstly, let\u2019s see old code (row-\nbased approach):\n\n    \n    \n    type PerformanceResult struct { Date time.Time `json:\"date\" ch:\"date\"` Clicks uint64 `json:\"clicks\" ch:\"clicks\"` Impressions uint64 `json:\"impressions\" ch:\"impressions\"` CTR float64 `json:\"ctr\" ch:\"ctr\"` Position float64 `json:\"position\" ch:\"avgPosition\"` Visibility float64 `json:\"visibility\" ch:\"visibility\"` } // ... results := make([]PerformanceResult, 0) if err := s.ch.Select(ctx, &results, getPerformanceChartQuery(c)); err != nil { return nil, err }\n\nYou probably have similar code for other databases like MySQL or Postgres. One\nthing to note here is that clickhouse-go/v2 binds values from query results\ninto provided struct using ch struct tag notation.\n\nNew (column-oriented) approach using ch-go:\n\n    \n    \n    type colsPerformanceResult struct { Date []time.Time `json:\"date\"` Clicks []uint64 `json:\"clicks\"` Impressions []uint64 `json:\"impressions\"` CTR []float64 `json:\"ctr\"` Position []float64 `json:\"position\"` Visibility []float64 `json:\"visibility\"` } // ... var ( dateCol = &proto.ColDate{} clicksCol = &proto.ColUInt64{} impressionsCol = &proto.ColUInt64{} ctrCol = &proto.ColFloat64{} avgPositionCol = &proto.ColFloat64{} visibilityCol = &proto.ColFloat64{} ) results := proto.Results{ {Name: \"date\", Data: dateCol}, {Name: \"clicks\", Data: clicksCol}, {Name: \"impressions\", Data: impressionsCol}, {Name: \"ctr\", Data: ctrCol}, {Name: \"avgPosition\", Data: avgPositionCol}, {Name: \"visibility\", Data: visibilityCol}, } ret := &colsPerformanceResult{} if err := conn.Do(ctx, ch.Query{ Body: getPerformanceChartQueryBody(c), Parameters: []proto.Parameter{p1, p2, p3}, Result: results.Auto(), OnResult: func(ctx context.Context, block proto.Block) error { for _, col := range results { switch col.Name { case \"date\": Append(&ret.Date, dateCol) case \"clicks\": Append(&ret.Clicks, clicksCol) case \"impressions\": Append(&ret.Impressions, impressionsCol) case \"ctr\": Append(&ret.CTR, ctrCol) case \"visibility\": Append(&ret.Visibility, visibilityCol) case \"avgPosition\": Append(&ret.Position, avgPositionCol) } col.Data.Reset() } return nil }, }); err != nil { return nil, err } // ... where Append is func Append[T any](slice *[]T, col proto.ColumnOf[T]) { for i := 0; i < col.Rows(); i++ { *slice = append(*slice, col.Row(i)) } }\n\nNow imagine there are thirty more queries should be adjusted...\n\nAs you can see, writing column-oriented code is cumbersome. I\u2019ve tried to\nfigure out a shorter way to implement that. There are some types in proto\npackage available which could help to minimize the code, but I wasn\u2019t able to\nbring pieces together. That probably wasn\u2019t a goal for ch-go developers and we\ncan\u2019t blame them.\n\nBut we still can make it a bit user-friendly while not losing performance\ngains. I\u2019ve composed a small package to do just that: ClickHouse Helper (chh)\nhttps://github.com/nikita-vanyasin/chh\n\nUsing this package, we can shorten the code above into:\n\n    \n    \n    type colsPerformanceResult struct { Date []time.Time `json:\"date\"` Clicks []uint64 `json:\"clicks\"` Impressions []uint64 `json:\"impressions\"` CTR []float64 `json:\"ctr\"` Position []float64 `json:\"position\"` Visibility []float64 `json:\"visibility\"` } // ... ret := &colsPerformanceResult{} results := &chh.ColResults{} chh.BindDate(results, \"date\", &ret.Date) chh.BindUInt64(results, \"clicks\", &ret.Clicks) chh.BindUInt64(results, \"impressions\", &ret.Impressions) chh.BindFloat64(results, \"ctr\", &ret.CTR) chh.BindFloat64(results, \"avgPosition\", &ret.Position) chh.BindFloat64(results, \"visibility\", &ret.Visibility) if err := chh.Select(ctx, conn, results, getPerformanceChartQuery(c)); err != nil { return nil, err }\n\nAnd for selecting just one row from the result-set (e.g., calculating totals),\njust use .SelectRow instead:\n\n    \n    \n    totals := &Totals{} results := &chh.ColResults{} results.BindUInt64(\"count\", &totals.Count) results.BindUInt64(\"sumClicks\", &totals.Clicks) results.BindUInt64(\"sumImpressions\", &totals.Impressions) results.BindFloat64(\"avgCTR\", &totals.CTR) results.BindFloat64(\"avgPosition\", &totals.Position) if err := chh.SelectRow(ctx, conn, results, getQueriesTotalQuery(c)); err != nil { return nil, err }\n\nThat seems to be a bit cleaner way to work with ClickHouse without employing\nheavy-weight clickhouse-go/v2 package. After moving our backend to column-\nbased approach, we achieved the reduction of average response time up-to\n50-60% for some queries. Frontend code also became simpler because we are\nfeeding column data into 3d-party libraries anyway.\n\nThere is still a room for improvements and I\u2019m planning to add more \u201csugar\u201d\ninto chh:\n\n  * If we want to return results directly to the HTTP client, we probably don\u2019t need to define a new type for result struct \u2014 we can just add some json Marshal interface support into chh.\n  * It is probably hard to come up with a solution for INSERTs which can be universal for everyone. But I think it is possible to introduce some helper functions to simplify code for composing batches.\n\nPlease give a try to the github.com/nikita-vanyasin/chh package and let me\nknow what you think \ud83d\ude09\n\nIs there a cleaner way to get same results without adding wrappers for ch-go?\n\n##### Tags\n\n  * ClickHouse\n  * golang\n  * projects\n\n##### Social\n\nRecent Posts\n\n##### Making ClickHouse ch-go client more user-friendly\n\nApr 2, 2024 Read\n\n\u00a9 2024 All rights reserved\n\nMade with Hugo Profile\n\n", "frontpage": false}
