{"aid": "40030786", "title": "Trying to Understand Copilot's Type Spaghetti", "url": "https://rtpg.co/2024/03/07/parsing-copilots-type-spaghetti/", "domain": "rtpg.co", "votes": 1, "user": "mooreds", "posted_at": "2024-04-14 13:01:10", "comments": 0, "source_title": "Trying To Understand Copilot's Type Spaghetti", "source_text": "Trying To Understand Copilot's Type Spaghetti\n\n  * Home\n  * About\n  * Subscribe (RSS/Email)\n\n# Trying To Understand Copilot's Type Spaghetti\n\n2024-03-07\n\nThe other day this snippet of Typescript generated by Github copilot was\nfloating around:\n\n    \n    \n    type MappedParameterTypes<T extends Parameter[]> = { // Check if the parameter has an 'enum' defined [P in T[number] as P[\"name\"]]: P extends {enum: Array<infer E> } ? E extends string // Ensure the enum values are strings ? P[\"required\"] extends false // Check if the parameter is optional ? E | undefined // If so, include 'undefined' in the type : E // Othewise use the enum type directly : never // This case should not occur since 'enum' implies string values : // Handle parameters defined as 'object' with specified attributes P extends {type: \"object\"; attributes: infer Attributes } ? Attributes extends Parameter[] ? MappedParameterTypes<Attributes> // Recursively map the attributes of the object : never // If 'attributes' is not an array of Parameters, this is invalid : // Handle parameters defined as 'object[]' without specified attributes P extends { type: \"object[]\"; attributes?: never } ? any[] // Default to 'any[]' for arrays of objects without specific attributes : P extends {type: \"object[]\"; attributes: infer Attributes } ? Attributes extends Parameter[] ? MappedParameterTypes<Attributes>[] // Recursively map each object in the array : any[] // Default to 'any[]' if attributes are not properly defined : // Handle all other parameter types P[\"required\"] extends false ? // Include 'undefined' for optional parameters TypeMap[P[\"type\"] extends keyof TypeMap ? P[\"type\"] : \"string\"] | undefined : // Use the direct mapping from 'TypeMap' for the parameter's type TypeMap[P[\"type\"] extends keyof TypeMap ? P[\"type\"] : \"string\"]; };\n\nThis is some type-level programming that can transform an array of field\ndefinitions into a type. The above is the original code, and I was able to\nfill in the blanks for TypeMap and Parameter with the following:\n\n    \n    \n    interface Parameter { name: string, required?: false, type?: keyof TypeMap } interface TypeMap { number: number, boolean: boolean, string: string, }\n\nThe first question is how do you use something like MappedParameterTypes? I've\ndefinitely seen this code in many projects, especially those with bespoke\nORMs. The basic idea is to map an object configuration to some type.\n\n    \n    \n    const parameters = [ { name: \"foo\", type: \"number\" } as const, { name: \"bar\", required: false, type: \"string\" } as const, { name: \"baz\", enum: [\"b\", \"c\"] as const } as const, ]; const mappedObjs: MappedParameterTypes<typeof parameters>[] = [ { foo: 1, bar: \"hi\", baz: \"b\" }, { foo: 2, bar: undefined, baz: \"c\" } ]\n\nI have an object definition, with foo being a number, bar being a string, and\nbaz being an enum. I have added const everywhere to \"make sure\" that\nTypescript doesn't lose track of the object literals in parameters (a constant\nthing to take care of in type-level programming in Typescript).\n\nBut the end result here is that mappedObjs is of the \"type\" {foo: number, bar: string, baz: \"b\" | \"c\"}[]. We were able to take our parameter structure and transform that into a type.\n\nThis is a very common task in Typescript, and can catch a lot of bugs! If I\ndidn't include foo or bar in the objects, then there would be an error. But\nthe code as-written still can be fragile.\n\nFor example, in the above, I can set baz to \"a\" or \"d\" and won't get an error, despite me having created baz as an enum type! I can't set a string, but at some point in the type unification process, Typescript decided that [\"b\", \"c\"] as const is not (\"b\" | \"c\")[] but instead is just string[].\n\nHowever, if I had written:\n\n    \n    \n    { name: \"baz\", enum: [\"b\", \"c\"] as (\"b\" | \"c\")[] }\n\nthen this problem disappears. Type programming is a fidget-y process in\ngeneral.\n\n## Is there a cleaner version of this code?\n\nThis current type is, quite honestly, not the worst kind of type-level\nprogramming out there. There's comments, and the indentation is being used to\nfollow the ternary flow relatvely well. But errors are a bit illegible because\neverything is object literals.\n\nThe simplest thing you can do is factor out some of the type logic into its\nown intermediate types.\n\n    \n    \n    interface EnumParameter<E> extends Parameter { enum: Array<E> } type EnumParameterValue<P extends EnumParameter<E>, E> = E extends string // Ensure the enum values are strings ? P[\"required\"] extends false // Check if the parameter is optional ? E | undefined // If so, include 'undefined' in the type : E // Othewise use the enum type directly : never // This case should not occur since 'enum' implies string values type MappedParameterTypes<T extends Parameter[]> = { // Check if the parameter has an 'enum' defined [P in T[number] as P[\"name\"]]: P extends EnumParameter<infer E> ? EnumParameterValue<P, E> : // Handle parameters defined as 'object' with specified attributes ... }\n\nhere I factored out the enum parameter shape, as well as the logic to extract\nthe array.\n\nAnother option would involve factoring out the \"required\" check, and actually\nincluding the string check higher up directly, avoiding the need for never.\n\n    \n    \n    interface EnumParameter<E extends string> extends Parameter { enum: Array<E> } type MaybeRequired<V, P extends Parameter> = P[\"required\"] extends false ? V | undefined : V type MappedParameterTypes<T extends Parameter[]> = { // Check if the parameter has an 'enum' defined [P in T[number] as P[\"name\"]]: P extends EnumParameter<infer E> ? MaybeRequired<E, P> : ... }\n\nThe nice thing with this kind of code is that later on, when you're writing\nyour parameter values, you could make sure you're not making a mistake by\nactually annotating the types. Instead of seeing errors on the mapped types,\nyou'll see the errors (correctly) shown on the parametesr.\n\n    \n    \n    const ep: EnumParameter<\"b\" | \"c\"> = { name: \"bar\", enum: [\"b\", \"c\"] }\n\nThis might seem silly on smaller constants like this, but is invaluable when\ncomposing code, to keep track of where you're at.\n\nUltimately this sort of thing is like any one-liner, extremely subjective in\nterms of readability. I was able to walk through the thing and understand how\nit works. But when building these sorts of one-liners and not factoring things\nout you can easily miss the forest for the trees.\n\nFor example:\n\n    \n    \n    P extends {type: \"object[]\"; attributes: infer Attributes } ? Attributes extends Parameter[] ? MappedParameterTypes<Attributes> // Recursively map each object in the array : any[] // Default to 'any[]' if attributes are not properly defined\n\nWhy go through the trouble of writing a type mapping system, only for your\ncode to be able to introduce any[] because one of your attributes was slightly\nmistyped? This sort of code will lead to type errors being reported in\nunexpected places (or not at all), instead of where the error actually came\nfrom.\n\nI similary find that the P[\"requires\"] extends false check being placed\nsomewhat haphazardly leads to weird usability issues. I can make an enum or a\nstring or number field optional, but I can't make an object field optional?\n\n## Losing Information In Type-Level Programming\n\nI lied a bit above. EnumParameter< \"b\" | \"c\"> causes problems downstream, because by annotating the object, we lose whether the element is required or not. We also lose the name of the parameter.\n\nTypescript is powerful enough that you can get away with a lot by just\nannotating a lot of constant dictionary maps. But really the pedantic way to\ndo this ends up being things like the following:\n\n    \n    \n    interface EnumParameter< E extends string, Name extends string, Required extends boolean > extends Parameter<Name,Required> { ... }\n\nIf you want to access information about a type, generally speaking you will\nwant it to be present somewhere in your generic signature. Otherwise, type\nannotations will affect your results. Best case, you \"merely\" have some\nambiguous type errors. But worst case, you end up with some implicit anys\nfloating around.\n\nThe beauty of the original one liner, is that the spaghetti-code is ammenable\nto good UX in Typescript! The world is a cruel place, where annotating and\ntrying to make things explicit can make your life harder. Beauty might not be\na word ammenable to Copilot's \"quantum superposition of a million code\nrepositories\". But it somehow works well enough in many circumstances.\n\nBut if you want something that is easy to maintain, that unfortunately often\nrequires a lot of pedantic work and putting things into generic types.\n\nA core takeaway with type-level programming, at least in Typescript: If you\nwant certain information to be used, having it be available in a generic type\nsignature will avoid code that \"accidentally\" works thanks to the type\ninference system.\n\n## Change The Shape Of Your Problem If You Can\n\nIf you're intent on doing this sort of type-level thing, laaning into what is\neasy can save you a lot of time. Instead of using arrays of parameters, maps\nof parameters would reduce the cost of a pedantic type.\n\n    \n    \n    const parameters = { \"foo\": stringParam, \"bar\": optionalNumberParam, \"baz\": myEnumParam }\n\nWhen you have this sort of structure, you can more easily re-use constants\ndefined elsewhere. This means that if you do end up with pedantic signatures,\nyou're not paying a huge cost for them. And if you have pedantic type\nsignatures, your errors might also be pedantic, but they are more likely to be\nwhere the problem is, and not downstream.\n\nIt's very easy to get asymptotically close to something that works. But often\ntimes, you might be one slight transformation from something that is much more\nstraightforward. For example, here, decoupling the naming and the requiredness\nfrom the type development might lead to more lines of codes, but that are\neasier to grok.\n\nBut I have to be honest: I tried a couple \"easy win\" refactors, and often\nwould hit some other problem. Sometimes the clean answer requires some good\ninspiration.\n\nIf you are curious about diving deeper into this sort of type-level\nprogramming, I highly recommend Execute Program's Advanced Typescript Course.\nIt offers a very detailed look into how you can accomplish very powerful\nthings, with more detail than you'll find simply looking at the Typescript\nHandbook.\n\nPreviously:\n\n  * Property Testing Stateful Code in Rust\n  * Finding And Debugging A Nushell Performance Issue\n  * Feature Flags In Depth\n\nLater:\n\n  * Type Unions Don't Always Compose Well\n  * DB Indexes Do Not Magically Compose\n\nSubcribe to get an e-mail when I post something new:\n\n", "frontpage": false}
