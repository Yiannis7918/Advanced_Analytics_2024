{"aid": "39963598", "title": "What Autoconf Got Right", "url": "https://leahneukirchen.org/blog/archive/2024/04/what-autoconf-got-right.html", "domain": "leahneukirchen.org", "votes": 3, "user": "JNRowe", "posted_at": "2024-04-07 20:26:48", "comments": 0, "source_title": "leah blogs: What autoconf got right", "source_text": "leah blogs: What autoconf got right\n\n# leah blogs\n\n\u00ab Definitions with shared hidden variables in Gerbil Scheme April 2024\n\n## 06apr2024 \u00b7 What autoconf got right\n\nThanks to the xz backdoor, many people are now talking about the state of\nLinux packaging tools, and in particular build systems. As a maintainer of\nVoid Linux and packager of many things, I have my five cents to add, so today\nI\u2019ll be the contrarian and argue what autoconf got right. This is not an\napology for GNU autotools; we are all well familiar with the issues they\nbring\u2014yet some prospective replacements manage to be worse in certain aspects.\n\n## It provides a standardized interface.\n\nThis is of course the hardest point to tackle for any new contestor that has\nnot reached a critical mass.\n\nIn Void Linux, the GNU configure build style is the most popular; roughly 2250\nof about 14300 package template use it, and an additional 120 use the generic\nconfigure build style, which works similarily.\n\nAs a packager, the worst thing is to find a custom made build system that\nbehaves totally different from what we know\u2014if you decide to write your own\n./configure scripts, please stick to the conventions! We packagers really have\nbetter things to do than figure out yet another homebrew build system that\u2019s\nused exactly once.\n\nThese conventions are standardized as part of the GNU Coding Standards and\nthey specify many features that packagers expect, but developers without own\npackaging experience are likely to miss. One example is support for staged\ninstallation, i.e. DESTDIR. This is essential for building packages that only\ncontain the files that package actually ships. And no, support for --prefix is\nnot enough to make up for this (if you wonder why, please read up the\nstandards).\n\n## It is based on checking features.\n\nPeople who have been staring at ./configure output for too long may want to\ndisagree, but let me make my point: check-based configuration is the only way\nto write software that will continue to work properly in the future. If you\ninstead keep a table of broken systems and workarounds, it a) will not be\nupdated for future systems, b) doesn\u2019t detect if the system was actually fixed\n(either by patching a bug, or adding a missing feature). It\u2019s also very\nunlikely the software builds on an system unknown to the build system, even if\nit\u2019s standards-compliant otherwise.\n\nOf course, the checks should be reasonable (and in practice, often are\nexcessive). If your code assumes a C99 environment, you don\u2019t need to check\nwhether all C99 functions you use are available. Likewise, if you don\u2019t need\nmacros for certain sizeof values, you don\u2019t need to check for them, either.\nAnd you never need to check if sizeof char is actually 1\u2014it literally can\u2019t be\nanything else. Also, checking for functions can be done incorrectly.\n\n## Overrides are possible.\n\nWhile checks are good, sometimes they are broken or a certain configuration\nneeds special override, because a feature can\u2019t be checked (for example, when\ncross-compiling). In this case, autoconf scripts provide options to override\nchecks with a predetermined result; usually you can set an environment\nvariable like gt_cv_func_printf_posix=yes.\n\nLikewise, if a library is installed at a special location, it\u2019s also easy to\ntell configure to use it.\n\n## The config.log tells what happened.\n\nMany other systems do checks, but only tell that something has failed.\nDebugging this can be difficult. Autoconf writes what it does into a\nconfig.log file, which is sometimes helpful to debug a check.\n\n## There is support for cross-compiling and for host/target separation.\n\nCross-compilation is a build system feature that is often put in second place,\nbut as a maintainer of a system that heavily makes use of it, I have a fair\nshare of experience and can say that autotools are one of the best systems to\nsupport cross-compilation. Especially custom-made build systems are often very\nlacking. Cross-compilation of C programs is not particularly hard in\nprinciple, but your build system needs to know which code is going to run on\nthe target, and that programs which need to run during compilation (e.g. to\nprecompute tables or something) need to be compiled for the host (with\ndifferent CFLAGS and so on).\n\n## It has few runtime dependencies.\n\nThis is also a defining feature of autoconf, as usually a basic POSIX shell\nenvironment (or, say, something busybox) is enough to run the configure\nscripts. This is in particular important for packages needed for\nbootstrapping. If your build system needs Python, well, then you need to\ncompile Python first; but to compile Python, you need to compile all of its\ndependencies, which hopefully don\u2019t need Python then themselves to build...\n\nHowever, for packages not directly relevant to bootstrapping a system this is\nnot such an essential feature.\n\nNP: Policy of 3\u2014Let It Build\n\nCopyright \u00a9 2004\u20132022 Leah Neukirchen\n\n", "frontpage": false}
