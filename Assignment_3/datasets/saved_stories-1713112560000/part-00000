{"aid": "40030150", "title": "Zero-downtime schema migrations in Postgres using views (2021)", "url": "https://fabianlindfors.se/blog/schema-migrations-in-postgres/", "domain": "fabianlindfors.se", "votes": 1, "user": "thunderbong", "posted_at": "2024-04-14 10:33:06", "comments": 0, "source_title": "Fabian Lindfors", "source_text": "Zero-downtime schema migrations in Postgres using views \u2013 Fabian Lindfors\n\n## Fabian Lindfors\n\n# Zero-downtime schema migrations in Postgres using views\n\n\u2190 All posts \u00b7 13 Jun 2021\n\nSchema migrations are tricky, especially when planned downtime is not an\noption. Changes need to be carefully designed to stay backwards compatible so\nthat both the new and old schema are available simultaneously. They must also\nbe designed to not interfere with any other queries, for example by locking up\ntables. Plenty has been written on how to this right but one pattern I haven\u2019t\nseen mentioned often is using views.\n\nThe idea is to encapsulate the data in the database. Clients will not query\nthe actual tables storing data, but instead query views that map directly to\nthe underlying table. Each version of the schema will have a set of views that\nnever change. This way we can perform changes to the underlying table whilst\nmaintaing a stable schema for clients.\n\nThe reason this technique isn\u2019t commonly referenced might just be that it\u2019s\ndumb, but that shouldn\u2019t stop us from exploring it!\n\n## Renaming a column\n\nLet\u2019s test this pattern out with a deceptively simple migration: renaming a\ncolumn. Say we have a non-nilable column named id which we want to rename to\nuser_id. The recommended way of achieving this without downtime is to:\n\n  1. Add a new nillable column called user_id\n  2. Add triggers that transfer any saved data from user_id to id and vice versa\n  3. Backfill the new column with values from the old one\n  4. Set user_id to be non-nilable\n  5. Once no clients use the old id column, remove it\n\nPhew, that\u2019s quite the process! How can views and encapsulation help us here?\nWe start by setting up our table and inserting some data. Remember that this\ntable will never be queried directly.\n\n    \n    \n    CREATE TABLE users ( id SERIAL PRIMARY KEY, email TEXT, name TEXT ); INSERT INTO users (email, name) VALUES ('jerry.seinfeld@aol.com', 'Jerry Seinfeld'), ('george.constanza@aol.com', 'George Costanza');\n\nNow we need some views so that we can actually retrieve this data. A nice\ntrick is to use Postgres schemas to hold our views. Every version of our\nschema will get its own Postgres schema and they will contain one view for\neach underlying table. If we call our starting schema \u201cA\u201d, we can set it up\nlike:\n\n    \n    \n    CREATE SCHEMA A; CREATE VIEW A.users AS SELECT id, email, name FROM public.users -- public is the default schema where the table was created\n\nNow all the clients have to do is specify which version of the schema they\nwant during queries. To keep the application code agnostic of migrations, we\ncan set the search path when connecting:\n\n    \n    \n    SET search_path TO A; -- users will now refer to A.users SELECT id, email, name FROM users; -- Results: -- +----+-------------------------+-----------------+ -- | id | email | name | -- +----+-------------------------+-----------------+ -- | 1 | jerry.seinfeld@aol.com | Jerry Seinfeld | -- | 2 | george.costanza@aol.com | George Costanza | -- +----+-------------------------+-----------------+\n\nNow for the grand finale, how do we rename the id column? If we perform a\nregular rename, Postgres will update the existing A.users view to reference\nthe new name while still calling it id, keeping the change backwards\ncompatible. We also need to introduce a new version of our schema which uses\nthe new user_id name, let\u2019s call it \u201cB\u201d:\n\n    \n    \n    ALTER TABLE public.users RENAME COLUMN id TO user_id; CREATE SCHEMA B; CREATE VIEW B.users AS SELECT user_id, email, name FROM public.users;\n\nThe rename is done! No downtime, no extra column, no triggers, no backfill.\nJust good old encapsulation.\n\n    \n    \n    -- Older clients can still access the old column name SET search_path TO A; SELECT id, email, name FROM users; -- Results: -- +----+-------------------------+-----------------+ -- | id | email | name | -- +----+-------------------------+-----------------+ -- | 1 | jerry.seinfeld@aol.com | Jerry Seinfeld | -- | 2 | george.costanza@aol.com | George Costanza | -- +----+-------------------------+-----------------+ -- New clients just have to update their search path SET search_path TO B; SELECT user_id, email, name FROM users; -- Results: -- +---------+-------------------------+-----------------+ -- | user_id | email | name | -- +---------+-------------------------+-----------------+ -- | 1 | jerry.seinfeld@aol.com | Jerry Seinfeld | -- | 2 | george.costanza@aol.com | George Costanza | -- +---------+-------------------------+-----------------+\n\n## Wrapping things up\n\nRenaming a column is admittedly the simplest possible migration and throwing\nin things like foreign keys and indices will invariably complicate things.\nHopefully this view-encapsulation technique will be helpful in more complex\nscenarios as well. Setting up a clear, versioned interface to the database can\nhelp keep application code simpler by keeping out migration-specific\nimplementation details.\n\nI\u2019m currently working on a tool that aims to make zero-downtime schema\nmigrations effortless for developers. If you think this sounds interesting,\nthen please shoot me an email! If you\u2019d like to discuss this article or just\nhave a chat, then feel free to reach out as well.\n\n", "frontpage": false}
