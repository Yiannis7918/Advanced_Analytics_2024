{"aid": "39964801", "title": "The Blessing of the Strings", "url": "https://bkardell.com/blog/blessing-strings.html", "domain": "bkardell.com", "votes": 1, "user": "zdw", "posted_at": "2024-04-07 23:20:01", "comments": 0, "source_title": "The Blessing of the Strings", "source_text": "The Blessing of the Strings\n\n## Author Information\n\nBrian Kardell\n\nBetterifying the Web\n\n  * Developer Advocate at Igalia\n  * Original Co-author/Co-signer of The Extensible Web Manifesto\n  * Co-Founder/Chair, W3C Extensible Web CG\n  * Member, W3C (OpenJS Foundation)\n  * Co-author of HitchJS\n  * Blogger\n  * Art, Science & History Lover\n  * Standards Geek\n\nFollow Me On...\n\nPosted on 04/03/2024\n\n# The Blessing of the Strings\n\nTrusted Types have been a proposal by Google for quite some time at this\npoint, but it's currently getting a lot of attention and work in all browsers\n(Igalia is working on implementations in WebKit and Gecko, sponsored by\nSalesforce and Google, respectively). I've been looking at it a lot and\nthought it's probably something worth writing about.\n\nThe Trusted Types proposal rides atop Content Security Policy (CSP) and allows\nwebsite maintainers to say \"require trusted-types\". Once required, lots of the\nWeb Platform's dangerous API surfaces (\"sinks\") which currently require a\nstring will now require... well, a different type.\n\nmyElement.innerHTML (and a whole lot of other APIs) for example, would now\nrequire a TrustedHTML object instead of just a string.\n\nYou can think of TrustedHTML as an interface indicating that a string has been\nsomehow specially \"blessed\" as safe... Sanitized.\n\nAnd Saint Attila raised the string up on high, saying, 'O Lord, bless this thy\nstring, that with it we may trust that it is free of XSS...' [ref].\n\n## Granting Blessings\n\nThe interesting thing about this is how one goes about blessing strings, and\nhow this changes the dynamics of development and safety.\n\nTo start with, there is a new global trustedTypes object (available in both\nwindow and workers) with a method called .createPolicy which can be used to\ncreate \"policies\" for blessing various kinds of input (createHTML,\ncreateScript, and createScriptURL). Trusted Types comes with the concept of a\ndefault policy, and the ability for you to register a specially named\n\"default\"...\n\n    \n    \n    //returns a policy, but you // don't really need to do anything // with the default one trustedTypes.createPolicy( \"default\", { createHTML: s => { return DOMPurify.sanitize(s) } } );\n\nAnd now, the practical upshot is that all attempts to set HTML will be\nsanitized... So if there's some code that tries to do:\n\n    \n    \n    // if str contains // `&lt;img src=\"no\" onerror=\"<em>dangerous code</em>\" &gt;`; target.innerHTML = str;\n\nThen the onerror attribute will be automatically stripped (sanitized) before\n.innerHTML gets it.\n\nHey that's pretty cool!\n\nIt's almost like you just put defenses around all that stuff and can just peer\nover the wall at would be attackers and make faces at them....\n\nBut wait... can't someone come along then and just create a more lenient\npolicy called default?\n\nNo! That will throw an exception!\n\nAlso, you don't have to create a default. If you don't, and someone tries to\nuse one of those methods to assign a string, it will throw.\n\nThe only thing this enforcement cares about is that it is one of these\n\"blessed\" types. Website administrators can also provide (in the header) the\nname of 1 or more policies which should be created.\n\nAny attempts to define a policy not in that list will throw (it's a bit more\ncomplicated than that, see Name your Policy below). Let's imagine that in the\nheader we specified that a policy named \"sanitize\" is allowed to be created.\n\nMaybe you can see some of why that starts to get really interesting. In order\nto use any of those APIs (at all), you'd need access to a policy in order to\nbless the string. But because the policy which can do that blessing is a\nhandle, it's up to you what code you give it to...\n\n    \n    \n    { const sanitizerPolicy = trustedTypes.createPolicy( \"sanitize\", { createHTML: s => { return DOMPurify.sanitize(s) } ); // give someOtherModule access to a sanitization policy someOtherModule.init(sanitizerPolicy) // yetAnotherModule can't even sanitize, any use of those // APIs will throw yetAnotherModule.foo() } // Anything out here also doesn't have // access to a sanitization policy\n\nWhat's interesting about this is that the thing doing the trusting on the\nclient, is actually on the client as well - but the pattern ensures that this\nbecomes a considerably more finite problem. It is much easier to audit whether\nthe \"trust\" is warranted. That is, we can look at the above to see that there\nis only one policy and it only supports creating HTML. We can see that the\ntrust there is placed in DOMPurify, and even that amount of trust is only\nprovided to select modules.\n\nFinally, most importantly: It is a pattern that is machine enforceable.\nAnything that tries to use any of those APIs without a blessed string (a\nTrusted Type) will fail... Unless you ask it not to.\n\n## Don't Throw, Just Help?\n\nShutting down all of those APIs after the fact is hard because all of those\ndangerous APIs are also really useful and therefore widely used. As I said\nearlier, auditing to find and understand all uses of them all is pretty\ndifficult. Chances are pretty good that there might just be a lot more unsafe\nstuff floating around in your site than you expected.\n\nInstead of Content-Security-Policy CSP headers, you can send Content-Security-\nPolicy-Report-Only and include a directive that includes report-to /csp-\nviolation-report-endpoint/ where /csp-violation-report-endpoint/ is an\nendpoint path (on the same origin). If set, whenever violations occur,\nbrowsers should send a request to report a violation to that endpoint (JSON\nformatted with lots of data).\n\nThe general idea is that it is then pretty easy to turn this on and monitor\nyour site to discover where you might have some problems, and begin to work\nthrough them. This should be especially good for your QA environment. Just\nkeep in mind that the report doesn't actually prevent the potentially bad\nthings from happening, it just lets you know they exist.\n\n## Shouldn't there just be a standard santizer too?\n\nYes!! That is also a thing that is being worked on.\n\n## Name Your Policy\n\nI'm not going to lie, I found CSP/headers to be both a little confusing to\nread and to figure out their relationships. You might see a header set up to\nreport only....\n\nContent-Security-Policy-Report-Only: report-uri /csp-violation-report-\nendpoint; default-src 'self'; require-trusted-types-for 'script'; trusted-\ntypes one two;\n\nBelieve it or not that's a fairly simple one. Basically though, you split it\nup on semi-colons and each of those is a directive. The directive has a name\nlike \"report-uri\" followed by whitespace and then a list of values\n(potentially containing only 1) which are whitespace separated. There are also\nkeyword values which are quoted.\n\nSo, the last two parts of this are about Trusted Types. The first, require-\ntrusted-types-for is about what gets some kind of enforcement and really the\nonly thing you can put there currently is the keyword 'script'. The second,\ntrusted-types is about what policies can be created.\n\nNote that I said \"some kind of enforcement\" because the above is \"report only\"\nwhich means those things will report, but not actually throw, while if we just\nchange the name of the header from Content-Security-Policy-Report-Only to\nContent-Security-Policy lots of things might start throwing - which didn't\ngreatly help my exploration. So, here's a little table that might help..\n\nIf the directives are...| then...  \n---|---  \n(missing)| You can create whatever policies you want (except duplicates), but\nthey aren't enforced in any way.  \nrequire-trusted-types-for 'script';| You can create whatever policies you want\n(except duplicates), and they are enforced. All attempts to assign strings to\nthose sinks will throw. This means if you create a policy named default, it\nwill 'bless' strings through that automatically, but it also means anyone can\ncreate any policy to 'bless' strings too.  \ntrusted-types| You cannot create any policies whatsoever. Attempts to will\nthrow.  \ntrusted-types 'none'| Same as with no value.  \ntrusted-types a b| You can call createPolicy with names 'a' and 'b' exactly\nonce. Attempts to call with other names (including 'default'), or repeatedly\nwill throw.  \ntrusted-types default| You can call createPolicy with names 'default' exactly\nonce. Attempts to call with other names, or repeatedly will throw.  \nrequire-trusted-types-for 'script'; trusted-types a| You can call createPolicy\nwith names 'a' exactly once. Attempts to call with other names (including\ndefault), or repeatedly will throw. All attempts to assign strings to those\nsinks will throw unless they are 'blessed' from a function in a policy named\n'a'\n\n", "frontpage": false}
