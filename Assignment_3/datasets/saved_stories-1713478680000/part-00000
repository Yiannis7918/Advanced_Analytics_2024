{"aid": "40077750", "title": "Show HN: Open-source Code Interpreter Alternative that works with LLM", "url": "https://github.com/Jonathan-Adly/AgentRun", "domain": "github.com/jonathan-adly", "votes": 1, "user": "jonathan-adly", "posted_at": "2024-04-18 16:16:09", "comments": 0, "source_title": "GitHub - Jonathan-Adly/AgentRun: The easiest, and fastest way to run AI-generated Python code safely", "source_text": "GitHub - Jonathan-Adly/AgentRun: The easiest, and fastest way to run AI-\ngenerated Python code safely\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nJonathan-Adly / AgentRun Public\n\n  * Notifications\n  * Fork 0\n  * Star 17\n\nThe easiest, and fastest way to run AI-generated Python code safely\n\n### License\n\nApache-2.0 license\n\n17 stars 0 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# Jonathan-Adly/AgentRun\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n3 Branches\n\n6 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nJonathan-AdlyversionApr 17, 20240592287 \u00b7 Apr 17, 2024Apr 17, 2024\n\n## History\n\n33 Commits  \n  \n### .github/workflows\n\n|\n\n### .github/workflows\n\n| more code coverage| Apr 17, 2024  \n  \n### agentrun-api\n\n|\n\n### agentrun-api\n\n| cached dep skeleton - needs testing| Apr 16, 2024  \n  \n### agentrun\n\n|\n\n### agentrun\n\n| docs v0| Apr 16, 2024  \n  \n### docs\n\n|\n\n### docs\n\n| wrong docs url| Apr 17, 2024  \n  \n### tests\n\n|\n\n### tests\n\n| requests is flaky with gh-actions| Apr 17, 2024  \n  \n### .coverage\n\n|\n\n### .coverage\n\n| complete| Apr 16, 2024  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| codecov| Apr 17, 2024  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| docs + example| Apr 12, 2024  \n  \n### README.md\n\n|\n\n### README.md\n\n| wrong docs url| Apr 17, 2024  \n  \n### manage_docs.sh\n\n|\n\n### manage_docs.sh\n\n| docs v0| Apr 16, 2024  \n  \n### mkdocs.yml\n\n|\n\n### mkdocs.yml\n\n| correct repo| Apr 16, 2024  \n  \n### pyproject.toml\n\n|\n\n### pyproject.toml\n\n| version| Apr 17, 2024  \n  \n## Repository files navigation\n\n# AgentRun: Run AI Generated Code Safely\n\nAgentRun is a Python library that makes it easy to run Python code safely from\nlarge language models (LLMs) with a single line of code. Built on top of the\nDocker Python SDK and RestrictedPython, it provides a simple, transparent, and\nuser-friendly API to manage isolated code execution.\n\nAgentRun automatically installs and uninstalls dependencies with optional\ncaching, limits resource consumption, checks code safety, and sets execution\ntimeouts. It has 97% test coverage with full static typing and only two\ndependencies.\n\n  * Documentation\n\n  * Get started in minutes\n\n## Why?\n\nGiving code execution ability to LLMs is a massive upgrade. Consider the\nfollowing user query: what is 12345 * 54321? or even something more ambitious\nlike what is the average daily move of Apple stock during the last week?? With\ncode execution it is possible for LLMs to answer both accurately by executing\ncode.\n\nHowever, executing untrusted code is dangerous and full of potential footguns.\nFor instance, without proper safeguards, an LLM might generate harmful code\nlike this:\n\n    \n    \n    import os # deletes all files and directories os.system('rm -rf /')\n\nThis package gives code execution ability to any LLM in a single line of code,\nwhile preventing and guarding against dangerous code.\n\n## Key Features\n\n  * Safe code execution: AgentRun checks the generated code for dangerous elements before execution\n  * Isolated Environment: Code is executed in a fully isolated docker container\n  * Configurable Resource Management: You can set how much compute resources the code can consume, with sane defaults\n  * Timeouts: Set time limits on how long a script can take to run\n  * Dependency Management: Complete control on what dependencies are allowed to install\n  * Dependency Caching: AgentRun gives you the ability to cache any dependency in advance in the docker container to optimize performance.\n  * Automatic Cleanups: AgentRun cleans any artifacts created by the generated code.\n  * Comes with a REST API: Hate setting up docker? AgentRun comes with already configured docker setup for self-hosting.\n  * Transparent Exception Handling: AgentRun returns the same exact output as running Python in your system - exceptions and tracebacks included. No cryptic docker messages.\n\nIf you want to use your own Docker configuration, install this package with\npip and simply initialize AgentRun with a running Docker container.\nAdditionally, you can use an already configured Docker Compose setup and API\nthat is ready for self-hosting by cloning this repo.\n\nUnless you are comfortable with Docker, we highly recommend using the REST API\nwith the already configured Docker as a standalone service.\n\n## Getting Started\n\nThere are two ways to use AgentRun, depending on your needs: with pip for your\nown Docker setup, or directly as a REST API as a standalone service\n(recommended).\n\n### REST API\n\nClone the github repository and start immediately with a standalone REST API.\n\n    \n    \n    git clone https://github.com/Jonathan-Adly/agentrun cd agentrun/agentrun-api cp .env.example .env.dev docker-compose up -d --build\n\nThen - you have a fully up and running code execution API. Code in --> output\nout\n\n    \n    \n    fetch('http://localhost:8000/v1/run/', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ code: \"print('hello, world!')\" }) }) .then(response => response.json()) .then(data => console.log(data)) .catch(error => console.error('Error:', error));\n\nOr if you prefer the terminal.\n\ncurl -X POST http://localhost:8000/v1/run/ -H \"Content-Type: application/json\"\n-d '{\"code\": \"print(\\'hello, world!\\')\"}'\n\n### pip install\n\nInstall AgentRun with a single command via pip (you will need to configure\nyour own Docker setup):\n\n    \n    \n    pip install agentrun\n\nHere is a simple example:\n\n    \n    \n    from agentrun import AgentRun runner = AgentRun(container_name=\"my_container\") # container should be running code_from_llm = get_code_from_llm(prompt) # \"print('hello, world!')\" result = runner.execute_code_in_container(code_from_llm) print(result) #> \"Hello, world!\"\n\nDifference| Python Package| REST API  \n---|---|---  \nDocker setup| You set it up| Already setup for you  \nInstallation| Pip| Git clone  \nEase of use| Easy| Super Easy  \nRequirements| A running docker container| Docker installed  \nCustomize| Fully| Partially  \n  \n## Usage\n\nNow, let's see AgentRun in action with something more complicated. We will\ntake advantage of function calling and AgentRun, to have LLMs write and\nexecute code on the fly to solve arbitrary tasks. You can find the full code\nunder docs/examples/\n\nFirst, we will install the needed packages. We are using mixtral here via groq\nto keep things fast and with minimal depenencies, but AgentRun works with any\nLLM out of the box. All what's required is for the LLM to return a code\nsnippet.\n\n> FYI: OpenAI assistant tool code_interpreter can execute code. AgentRun is a\n> transparent, open-source version that can work with any LLM.\n    \n    \n    !pip install groq !pip install requests\n\nNext, we will setup a function that executed the code and returns an output.\nWe are using the API here, so make sure to have it running before trying this.\n\nHere is the steps to run the API:\n\n    \n    \n    git clone https://github.com/Jonathan-Adly/agentrun cd agentrun/agentrun-api cp .env.example .env.dev docker-compose up -d --build\n    \n    \n    def execute_python_code(code: str) -> str: response = requests.post(\"http://localhost:8000/v1/run/\", json={\"code\": code}) output = response.json()[\"output\"] return output\n\nNext, we will setup our LLM function calling skeleton code. We need:\n\n  1. An LLM client such Groq or OpenAI or Anthropic (alternatively, you can use litellm as wrapper)\n  2. The model you will use\n  3. Our code execution tool - that encourages the LLM model to send us python code to execute reliably\n\n    \n    \n    from groq import Groq import json client = Groq(api_key =\"Your API Key\") MODEL = 'mixtral-8x7b-32768' tools = [ { \"type\": \"function\", \"function\": { \"name\": \"execute_python_code\", \"description\": \"Sends a python code snippet to the code execution environment and returns the output. The code execution environment can automatically import any library or package by importing.\", \"parameters\": { \"type\": \"object\", \"properties\": { \"code\": { \"type\": \"string\", \"description\": \"The code snippet to execute. Must be a valid python code. Must use print() to output the result.\", }, }, \"required\": [\"code\"], }, }, }, ]\n\nNext, we will setup a function to call our LLM of choice.\n\n    \n    \n    def chat_completion_request(messages, tools=None, tool_choice=None, model=GPT_MODEL): try: response = client.chat.completions.create( model=model, messages=messages, tools=tools, tool_choice=tool_choice, ) return response except Exception as e: print(\"Unable to generate ChatCompletion response\") print(f\"Exception: {e}\") return e\n\nFinally, we will set up a function that takes the user query and returns an\nanswer. Using AgentRun to execute code when the LLM determines code execution\nis necesary to answer the question\n\n    \n    \n    def get_answer(query): messages = [] messages.append( { \"role\": \"system\", \"content\": \"\"\"Don't make assumptions about what values to plug into functions. Ask for clarification if a user request is ambiguous.\\n Use the execute_python_code tool to run code if a question is better solved with code. You can use any package in the code snippet by simply importing. Like `import requests` would work fine.\\n \"\"\", } ) messages.append({\"role\": \"user\", \"content\": query}) chat_response = chat_completion_request(messages, tools=tools) message = chat_response.choices[0].message # tool call versus content if message.tool_calls: tool_call = message.tool_calls[0] arg = json.loads(tool_call.function.arguments)[\"code\"] print(f\"Executing code: {arg}\") answer = execute_python_code(arg) # Optional: call an LLM again to turn the answer to a human friendly response query = \"Help translate the code output to a human friendly response. This was the user query: \" + query + \" The code output is: \" + answer answer = get_answer(query) else: answer = message.content return answer\n\nNow let's try it! get_answer(\"what's the average daily move of Apple stock in\nthe last 3 days?\") \"The average daily movement of Apple's stock in the last 3\ndays is approximately $2.60.\"\n\nHow did get this answer?\n\nFirst, the LLM generated the code to call the Yahoo stock API (via yf) as\nsuch:\n\n    \n    \n    #AI generated import yfinance as yf # Setting the ticker and period for the last 3 days apple = yf.Ticker('AAPL') hist = apple.history(period=\"3d\") # Calculating daily moves (close - open) and their average moves = hist['Close'] - hist['Open'] average_move = moves.mean() print(f'{average_move:.2f}')\n\nThat code was sent to AgentRun, which outputted:\n'\\r[*********************100%%**********************] 1 of 1 completed\\n2.39'\n\nLastly, the output was sent to the LLM again to make human friendly. Giving us\nthe final answer: $2.39\n\n## Customize\n\nAgentRun has sane defaults, but totally customizable. You can change:\n\n  1. dependencies_whitelist - by default any thing that can be pip installed is allowable.\n  2. cached_dependencies - these are dependencies that are installed on the image on initialization, and stay there until the image is brought down. [] by default.\n\n> It will take longer to initialize the image with cached_dependencies,\n> however subsequent runs using those dependencies would be a lot faster.\n\n  3. cpu_quota - the default is 50000. Here is GPT-4 explaining what does that mean.\n\n> In Docker SDK, the cpu_quota parameter is used to limit CPU usage for a\n> container. The value of cpu_quota specifies the amount of CPU time that the\n> container is allowed to use in microseconds per scheduling period. The\n> default scheduling period for Docker is 100 milliseconds (100,000\n> microseconds).\n>\n> If you set cpu_quota to 50000, this means that the container is allowed to\n> use 50,000 microseconds of CPU time every 100 milliseconds. Essentially,\n> this limits the container to 50% CPU usage of a single CPU core during each\n> scheduling period. If your system has multiple cores, the container could\n> still potentially use more total CPU resources by spreading the load across\n> multiple cores.\n\n  3. default_timeout - how long is scripts allowed to run for. Default is 20 seconds.\n  4. memory_limit - how much memory can execution take. Default is 100mb\n  5. memswap_limit - the default is 512mb. Again, here is GPT-4 explaing what memory_mit and memswap do.\n\n> In Docker SDK, the memswap_limit parameter is used to control the memory and\n> swap usage of a container. This setting specifies the maximum amount of\n> combined memory and swap space that the container can use. The value is\n> given in bytes.\n>\n> Here\u2019s how it works:\n\n>   * Memory (RAM): This is the actual physical memory that the container can\n> use.\n>   * Swap: This is a portion of the hard drive that is used when the RAM is\n> fully utilized. Using swap allows the system to handle more memory\n> allocation than the physical memory available, but accessing swap is\n> significantly slower than accessing RAM.\n>\n\nYou can change any of the defauts when you initalize AgentRun as below.\n\n    \n    \n    from agentrun import AgentRun # container should be running runner = AgentRun( container_name=\"my_container\", # only allowed to pip install requests dependencies_whitelist = [\"requests\"], # [] = no dependencies cached_dependencies = [\"requests\"], # 3 minutes timeout default_timeout = 3 * 60, # how much RAM can the script use memory_limit = \"512mb\" # how much total memory the script can use, using a portion of the hard drive that is used when the RAM is fully utilize memswap_limit= \"1gb\" ) code_from_llm = get_code_from_llm(prompt) # \"print('hello, world!')\" result = runner.execute_code_in_container(code_from_llm) print(result) #> \"Hello, world!\"\n\n## Benchmarks\n\nAgentRun Median execution time is <200ms without dependencies. Dependency\ninstalling is usually the bottleneck and depends on the size of package and if\nthe package has many dependencies as well as caching.\n\n## Development\n\nTo contribute to this library, first checkout the code. Then create a new\nvirtual environment:\n\n    \n    \n    cd agentrun python -m venv venv source venv/bin/activate\n\nNow install the dependencies and test dependencies:\n\n    \n    \n    pip install -e '.[test]'\n\nTo run the tests:\n\n    \n    \n    pytest\n\nTo run the test with coverage\n\n    \n    \n    pytest --cov=agentrun tests/\n\n## About\n\nThe easiest, and fastest way to run AI-generated Python code safely\n\n### Resources\n\nReadme\n\n### License\n\nApache-2.0 license\n\nActivity\n\n### Stars\n\n17 stars\n\n### Watchers\n\n2 watching\n\n### Forks\n\n0 forks\n\nReport repository\n\n## Releases 6\n\n0.2.2 Latest\n\nApr 17, 2024\n\n\\+ 5 releases\n\n## Packages 0\n\nNo packages published\n\n## Languages\n\n  * Python 96.2%\n  * Dockerfile 2.3%\n  * Shell 1.5%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
