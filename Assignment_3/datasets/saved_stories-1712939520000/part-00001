{"aid": "40011087", "title": "Go is an object-oriented language", "url": "https://blog.gypsydave5.com/posts/2024/4/12/go-is-an-object-oriented-programming-language/", "domain": "gypsydave5.com", "votes": 2, "user": "quii", "posted_at": "2024-04-12 10:31:34", "comments": 0, "source_title": "Go Is An Object Oriented Programming Language", "source_text": "Go Is An Object Oriented Programming Language\n\n# gypsydave5\n\nThe blog of David Wickes, software developer\n\n  * about\n  * posts\n\n# Go Is An Object Oriented Programming Language\n\nApr 12, 2024\n\nI get into this argument every three months or so, so I\u2019m just going to write\nit all down here to remind me of the key points to why Go is an object-\noriented programming language.\n\n## What even is an Object-Oriented Programming Language?\n\nFirst up, the idea of a language \u201cbeing\u201d object-oriented or \u2018functional\u2019 or\nwhatever isn\u2019t really useful. Essentialist nonsense. Go, and all languages,\nhave features. They are designed, the designers made decisions about what\nsorts of features the language would have.\n\nI could write Object-Oriented code in Haskell, or OCaml, or Clojure or Racket\nor whatever - I could. How successful I would be down to how the features of\nthe language supported writing object-oriented code. More precisely, how they\nsupported an object-oriented design.\n\nSo stop asking essentialist crap about whether they are object-oriented - take\na functionalist approach and ask if they let you do OO easily.\n\n## Like, what even is object-oriented programming, man?\n\nI don\u2019t want to get into the tall weeds with this one, as there\u2019s lots of\nwriting out there. Go read Alan Kay or something:\n\n> OOP to me means only messaging, local retention and protection and hiding of\n> state-process, and extreme late-binding of all things. It can be done in\n> Smalltalk and in LISP. There are possibly other systems in which this is\n> possible, but I\u2019m not aware of them.\n\nwhich I guess means there are no OO languages, so we\u2019ll have to loosen up from\nAlan\u2019s description. Page-Jones once wrote a long feature set:\n\n  * Encapsulation\n  * Information/implentation hiding\n  * State retention\n  * Object identity\n  * Messages\n  * Classes\n  * Inheritance\n  * Polymorphism\n  * Genericity\n\nWhich I think goes too far.\n\nSo here\u2019s what I think object-oriented programming is about.\n\nObjects.\n\nAnd as we all know, Go doesn\u2019t have objects, so it can\u2019t be OO. Case closed.\n\nBut wait... what are these struct things?\n\nLook like objects.\n\nSmell like objects.\n\nTaste like objects.\n\nYeah, they\u2019re objects. Why are they called structs then? Go ask Rob Pike, I\ndon\u2019t know. I guess it was a canny marketing move to distinguish Go from Java.\nRemember, OO isn\u2019t cool anymore, it\u2019s boomer coding. So these structs, they\u2019re\njust data right. We\u2019re safe. Functions working on data. Great. We\u2019ll call it\ndata-oriented programming or something, and we can sell some books and a few\nworkshops. Just data.\n\nWell...\n\nThey would be if someone hadn\u2019t gone and ruddy put methods on them.\n\nI mean,\n\n<picard-come-on.gif>\n\nYou\u2019ve now got enough there to get message passing off the ground. At least as\nmuch as Java gives you, right? And you\u2019re not going to say that Java isn\u2019t\ngood for writing OO? (Well, Alan Kay would).\n\n## But encapsulations...\n\nIt\u2019s fine, though, because all the data and methods on an ~object~ struct is\ncompletely public. There\u2019s no encapsulation going on here right?\n\nWell, yes and...\n\nIf you don\u2019t export an identifier from a package, it\u2019s essentially hidden from\nthe calling code. And struct fields and methods, well they\u2019re identifiers...\nso.\n\nYeah, we\u2019ve got encapsulation in Go.\n\n## Ahhhh but Classes and Inheritance\n\n<batman-slap.gif>\n\nClasses aren\u2019t an object-oriented programming feature. They\u2019re a code reuse\nfeature. Class is just a function for making an object (and they also happen\nto be objects too in all the beaauuuuuutiful OO languages like Ruby and\nSmalltalk and even JavaScript, but that doesn\u2019t matter right now.)\n\nWell, if I want a function in Go that makes me a struct... I can just write\none instead of constructing the struct from nothing like some barbarian.\n\nOh look, I\u2019ve got a ~class constructor~ struct maker function.\n\nInheritance? INHERITANCE?\n\n<BIGGER-BATMAN-SLAP.gif>\n\nInheritance is a code-reuse technique, with a bit of type-system pokery on the\nside if you have a static type thing going on with your language. And, I hate\nto break it to you all, but object-oriented programmers have been actively\ntrying to avoid inheritance for the last THIRTY YEARS since the Gang of Four\ntold you to\n\n> Favor object composition over class inheritance.\n\nIf you\u2019re still messing around with \u201cA DOG IS AN ANIMAL\u201d inheritance when\nyou\u2019re explaining object-oriented programming, then what rock have you been\nliving under for the last THIRTY YEARS? There are entire functioning adults\nwho are younger than this.\n\nAnd guess what? Go helps you to do this by making class inheritance\nimpossible. No classes? No inheritance. Simple.\n\nIt also helps you by making ~object~ struct composition as simple as embedding\non struct in another. Look, ma! I just did the delegation pattern in one line\nof code.^1\n\nSo not only is Go good for object-oriented programming, it\u2019s also good for\nmodern object-oriented programming.\n\n## HURR DURR INTERFACES\n\nYou should maybe have taken the point that Go was very object-oriented when\nthey gave you interfaces. I guess nobody could think of a better word and\nSmalltalk already had protocols? Interfaces give you the useful type\ninformation bit of inheritance (\u201cA DOG IS AN ANIMAL WOOOF WOOOF SEE SPOT RUN\u201d)\nthat lets you do the other great bit of Gang of Four advice FROM THIRTY YEARS\nAGO:\n\n> Program to an interface, not an implementation.\n\nSo instead of knowing the concrete object that\u2019s you\u2019ve received, you instead\ncan \u201cprogram to an interface\u201d - some collection of properties - in Go\u2019s case,\nmethods - that the object implements.\n\nGo\u2019s interfaces are a little different to those in nearly every other language\nin that they are structurally subtyped rather that nominally typed. Which is\nfancy talk for saying that I don\u2019t care what my ~object~ struct is, I only\ncare what it can do.\n\n(Lol we\u2019ve circled back to the beginning and Go\u2019s type system is anti-\nessentialist too...)\n\nThis means that you get what the dynamic object-oriented folk call duck typing\ngoing on, but checked at compile time just so you don\u2019t try and make a whale\nfly.\n\nGo would obviously still be an object-oriented language even if it didn\u2019t have\nthis feature, but what it means is that you\u2019re left with an extremely unique\nobject-oriented language that improves the decoupling provided by polymorphism\nby making interfaces a consumer driven property of the system, and giving you\nmultiple (interface) inheritance. I don\u2019t need to tag up my ~objects~ structs\nto say they implement a particular interface; I just put the required\n(exported) methods on them and hey presto.\n\nGo interfaces are more like bundles of function signatures in a more FP\nlanguage. All you\u2019re saying is that this ~object~ struct needs to be all these\nfunctions.\n\nThis decoupling also shifts Go closer to Alan Kay\u2019s \u201cextreme late-binding of\nall things.\u201d (I think, might be wrong here), by moving the knowledege of the\ninterface into where the object is being used rather than where it\u2019s being\npassed, but I might be misunderstanding this.\n\n## In conclusion...\n\nGo is a very object-oriented programming language. More so than Java I think\nwe can safely say, and edging towards something like a statically-typed\nSmalltalk without inheritance.\n\nIf you choose not to use these features, or write in this style, that\u2019s fine.\nIn my view you\u2019re throwing over forty years of software design out with the\ndirty Java bathwater.\n\n  1. This is like Kotlin, which also makes delegation (and so composition) easier.\n\n", "frontpage": false}
