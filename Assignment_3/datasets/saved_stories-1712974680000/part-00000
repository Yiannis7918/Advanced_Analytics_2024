{"aid": "40017176", "title": "DIY Wi-Fi thermostat from scratch with ESPHome and Home Assistant", "url": "https://olegtarasov.me/opentherm-thermostat-esphome/", "domain": "olegtarasov.me", "votes": 2, "user": "oleg_tarasov", "posted_at": "2024-04-12 20:15:59", "comments": 0, "source_title": "OpenTherm thermostat with ESPHome and Home Assistant", "source_text": "OpenTherm thermostat with ESPHome and Home Assistant\n\nAutomate this\n\nApr 12, 2024 16 min read\n\n# OpenTherm thermostat with ESPHome and Home Assistant\n\n  1. The water heating system\n  2. Boiler control signals\n  3. Monitoring\n  4. Schematics and soldering\n  5. Configuring ESPHome\n\n    1. Installing ESPHome in Home Assistant\n    2. Creating a new configuration\n    3. Basic setup\n    4. OpenTherm configuration\n    5. Adding room temperature sensor\n    6. Adding PID control\n    7. Uploading the firmware\n  6. Conclusion\n\nIn this series of posts I describe my journey of automating a heating system\nin my suburban home. This particular post is about a simple, but fully\nfunctional thermostat that uses a PID controller to maintain a target room\ntemperature. I use this thermostat with an OpenTherm gas boiler, but most of\nthe ESPHome configuration is universal and can be reused with other boilers,\nif they have a ESPHome component.\n\nIn the previous post I left off with a prototype interface board for an\nOpenTherm boiler, which was loosely connected to a ESP32 dev board by a bunch\nof jumper wires. In this post I am going to build a first useful device using\nESPHome and Home Assistant.\n\n## The water heating system\n\nIt's always good to plan in advance and gather requirements before you heat up\nthe soldering iron. First of all, let's take a look at the system I am dealing\nwith:\n\nAt first glance it looks really intimidating, and it took me a good portion of\na week to figure out how it works. I had no prior experience with heating\nsystems, so I had to read up quite a lot theory before I could make heads or\ntails of it. It really helps to remember that it's all just water, flowing in\nthe direction of lower pressure \ud83d\ude04\n\nAnyway, here I have 3 subsystems:\n\n  1. Wall-mounted radiators that do the bulk of heating.\n  2. Heated floor, with one or two individual loops in each room.\n  3. Indirect water heater that prepares domestic hot water for use in showers and faucets.\n\nRadiators and heated floors are merged into one branch, and water heater uses\na separate branch. Natural gas boiler can operate only one branch at a time,\nswitching between them when necessary. Hot water for showers and faucets has\npriority (it's hardwired), so when it becomes colder, the boiler stops heating\nthe house and starts heating the water tank. These two heating branches are\nclosed loops which contain water under pressure of 1.5 atm. So a gas boiler\nheats up the water in these branches and moves it around the loop with\nelectric pumps. When heated water passes radiators, heated floor pipes or\nwater heater, it transfers its heat, gets colder, and then comes back to the\nboiler to be heated again. Whew, easy!\n\nAnother branch goes to the indirect water heater that transfers heat from\nboiler to cold water stored in the tank. This way, faucet water never enters\nthe boiler itself, so that boiler heating loop maintains its own pressure at\nall times. Here is a simple schematic of how indirect water heater operates:\n\nImage from https://sippin.com/hvac/hot-water-systems/indirect-water-heaters/\n\n## Boiler control signals\n\nControlling such a system would seem like a great challenge, but luckily a lot\nof low-level logic is hidden inside the boiler itself. It turns out,\nthermostat needs to provide only two control signals to the boiler:\n\n  1. Central Heating setpoint, which is the temperature of heated water coming out of the boiler in a central heating loop. For example, I can tell the boiler that I want water to be 60\u00b0 C at all times, and it will control its burning intensity and on-off cycles to match this temperature to the best of its ability. So I would always get water entering my heating system at 60\u00b0.\n  2. Domestic Hot Water (DHW) setpoint, which is the temperature of hot water coming out of the water heater to showers and faucets. Since domestic hot water never enters the boiler and heat transfer is happening inside the storage tank, the boiler needs an additional temperature sensor that needs to be placed in a special slot in the water heater. That way boiler knows when hot water stored in the tank becomes cooler and it's time to switch to DHW loop from central heating.\n\nIn theory, I could tell the boiler to always support each setpoint temperature\nconstant, and it's usually OK with DHW. But this approach is suboptimal for\ncentral heating, especially when weather is not that cold yet. Wall-mounted\nradiators would run for a short period of time at full capacity, overshoot\ntarget room temperature by 1-2 degrees and then turn off for a long time to\nwait for temperature to drop. This leads to unnecessary temperature\nfluctuations, which can easily be avoided. In order to control target room\ntemperature more smoothly, I can vary Central Heating setpoint so that\nradiators and heated floors don't blast with full power, but rather stay just\nwarm enough to support a comfortable room temperature.\n\n## Monitoring\n\nIt's always a good idea to monitor production systems, and water heating is no\nexception. There is not much variety in what I can monitor:\n\n  1. Temperature. Placing temperature sensors strategically can help \u201edebug\u201d heating systems and tune some hard to guess parameters like water pump power.\n  2. Pressure. Maintaining near-constant pressure is critical for a heating system. It's usually achieved by installing expansion tanks, but it's always a good idea to be able to monitor system pressure remotely.\n  3. Various boiler parameters, like whether it's currently burning, or what heating loop is active.\n\nIn this prototype I decided to limit monitoring to temperature and boiler\nparameters, since I wasn't able to find an affordable and reliable digital\npressure sensor. In order to monitor temperature, I decided to use widely\npopular DS18B20 temperature sensor. I like its simplicity and ability to\ndaisy-chain several sensors on a single 1-Wire bus.\n\n## Schematics and soldering\n\nIt's time to design a schematic for my thermostat. I am using a variation of\nWemos D1 Mini ESP32 development boards in this design. You can use any ESP32\ndev board that is supported by ESPHome, or even roll with a bare bones ESP32\nSoC. I find dev boards exceptionally handy during prototyping phase. I even\ncontemplate using dev boards in my final designs due to their small footprint\nand ease of soldering. Another perk of using a dev board is on-board USB and\nvoltage conversion support. You can power your whole device with any 5V USB\npower supply and easily debug it if something goes wrong.\n\nAs you can see here, most of the schematic is an implementation of Ihor\nMelnik's OpenTherm adapter. I also added one 4-pin connector for a Nextion\nDisplay (will be covered in one of the next posts) and 10 3-pin connectors for\nvarious temperature sensors I plan to install into my system.\n\nLong story short, this is the final prototype PCB:\n\nIt's definitely not a pinnacle of soldering mastery, but it works \ud83d\ude04 You can\nnotice that there is a second screw terminal that is absent from the\nschematics. This an additional 5V power terminal that can be used to power the\nPCB instead of ESP32 board USB connector. I'm not sure whether it will be used\nin the final design, so I omitted it from the schematics. Here's how it looks\nin a temporary enclosure with boiler and one temperature sensor connected:\n\nI also made 8 or 9 screw-in temperature sensors to monitor temperature in\nvarious point in my system. I bought super cheap analogue gauge thermometers,\nthrew out the thermometers and glued a bunch of DS18B20 sensors into screw-in\nenclosures. I used a thermal glue which is also used to glue CPU heat sinks,\nand later filled it all with heat-resistant resin. Here is an individual\ntemperature sensor and the whole rat's nest of wires when they are all\nconnected:\n\n## Configuring ESPHome\n\nThe final step in this little adventure is configuring and uploading ESPHome\nfirmware to the device. But first we need to install ESPHome.\n\n### Installing ESPHome in Home Assistant\n\nThe great advantage of ESPHome is its tight integration with Home Assistant.\nWhile you can install ESPHome on your machine and don't use HA at all, it's\nmuch easier to start with HA integration, if using your device in HA is\nultimately your goal.\n\nTo install ESPHome in HA, I went to Settings \u2192 Add-ons \u2192 Add-on store. I found\nESPHome in the add-on list and installed it. It's also a good idea to turn on\nthe \u201cShow in sidebar\u201d checkbox in order to find ESPHome dashboard more easily.\nI am running Home Assistant in its Operating System form, so I'm able to\ninstall and maintain add-ons easily. If you are not using HA OS, then you\nprobably can't install ESPHome add-on from the store. Your other option might\nbe installing ESPHome on your machine by following the docs.\n\n### Creating a new configuration\n\nCreating a new device in ESPHome dashboard is really easy. I followed the\nwizard and after a little while ended up with a basic firmware uploaded to my\nprototype device. After that first upload updating the device is usually\nperformed over the Wi-Fi. If you are not sure about this step, be sure to\nconsult the official docs for the most up-to-date instructions.\n\nIn the next few sections I will gradually build up ESPHome configuration to\nget a minimally functioning thermostat with PID control.\n\n### Basic setup\n\nFirst of all, I declare some basic stuff: dev board configuration, wi-fi\ncredentials and API keys:\n\n    \n    \n    esphome: name: boilotron friendly_name: Boilotron esp32: board: mhetesp32minikit framework: type: arduino external_components: - source: github://olegtarasov/esphome-opentherm@new_lib # Enable logging logger: level: INFO logs: component: ERROR sensor: WARN opentherm.output: INFO # Enable Home Assistant API api: encryption: key: \"<your key>\" ota: password: \"<your password>\" wifi: ssid: !secret wifi_ssid password: !secret wifi_password\n\nNote the external_components section. Since there is no built-in support for\nOpenTherm in ESPHome, I need to reference an external component. I will be\nusing my fork of the esphome-opentherm component. As I've mentioned in a\nprevious post, the upstream component seems to be abandoned and doesn't even\ncompile with latest versions of ESPHome. Nevertheless, this component seems to\nbe the most mature, so I decided to fork it, integrate several outstanding\npull requests and replace the underlying OpenTherm protocol library. More on\nthis in one of the next posts \ud83d\ude03 Here we just reference the external component.\n\n### OpenTherm configuration\n\nNext I declare OpenTherm configuration with its controls and sensors:\n\n    \n    \n    # Declare the phisical pins that OpenTherm adapter is connected to opentherm: in_pin: 21 out_pin: 26 # Outputs are controlled by some other components, not manually output: - platform: opentherm t_set: id: boilotron_ch_setpoint min_value: 40 max_value: 60 zero_means_zero: true # Values that can be set maually from HA interface number: - platform: opentherm t_dhw_set: id: boilotron_dhw_setpoint name: \"Hot Water target temperature\" min_value: 20 max_value: 60 restore_value: true initial_value: 60 # Switches that can be operated manually from HA interface switch: - platform: opentherm ch_enable: id: boilotron_ch_enable name: \"Central Heating enabled\" restore_mode: RESTORE_DEFAULT_OFF dhw_enable: id: boilotron_dhw_enable name: \"Hot Water enabled\" restore_mode: RESTORE_DEFAULT_OFF # Boiler numeric sensors sensor: - platform: opentherm rel_mod_level: id: boilotron_rel_mod_level name: \"Boiler Relative modulation level\" t_boiler: id: boilotron_temperature_ch name: \"Boiler Feed Temperature\" # Boiler binary (True/False) sensors binary_sensor: - platform: opentherm ch_active: id: boilotron_ch_active name: \"Boiler Central Heating active\" dhw_active: id: boilotron_dhw_active name: \"Boiler Hot Water active\" flame_on: id: boilotron_boiler_flame_on name: \"Boiler Flame on\" fault_indication: id: boilotron_boiler_fault name: \"Boiler Fault\" entity_category: diagnostic diagnostic_indication: id: boilotron_boiler_diagnostic name: \"Boiler Diagnostic\" entity_category: diagnostic\n\nThere is a lot to process here, but let's dissect this config step-by-step.\nFirst of all, on the top level you can see components: outputs, numbers,\nswitches etc. These are sometimes confusing, because a component can live on\nthe top level, like opentherm here, but in other cases top-level statements\nrepresent component \u201eclasses\u201d, with components nested underneath, like\nswitches and sensors. There is no apparent system to this, you just need to\nconsult ESPHome documentation a lot \ud83d\ude03\n\nFirst of all I'm configuring base OpenTherm hub component to let ESPHome know\nwhich pins my adapter is connected to.\n\nNext I declare several components that let me control the boiler and read its\nstate. The most important is t_set component of class output. It corresponds\nto central heating setpoint, and declaring it as output means that I will not\nset its value manually, but rather through some other component. In a couple\nof moments I will connect a software PID controller to this output. There are\nsome additional properties like min and max values. Recommended maximum\ntemperature for heating system with wall-mounted radiators is usually 60\u00b0 C\nand minimum temperature needs to be discovered empirically. I found that 40\u00b0\nis the minimum temperature that my boiler can sustain on its lowest burn\nintensity without turning off and on again.\n\nNote that esphome-opentherm allows to declare any non-sensor component as a\nnumber \u2014 that way you will be able to set its value manually using Home\nAssistant UI. This is exactly what happens with t_dhw_set component \u2014 as noted\nearlier, we usually want faucet water to be roughly the same temperature, so I\njust need to set this temperature once and let boiler handle the rest.\n\nI also declare two switches that allow me turn central heating and DHW on or\noff completely: ch_enable and dhw_enable. The state of these switches can be\nrestored by ESPHome after reboot and I also prefer to set them to \u201eoff\u201d in\ncase no saved value is present. RESTORE_DEFAULT_OFF allows me to do just that.\n\nAfter that I declare a bunch of sensors that can be read from the boiler.\nrel_mod_level shows current burn intensity and t_boiler shows the temperature\nof the water coming out of the boiler (this is the temperature that we set\nwith t_set). There is also a bunch of binary flags that indicate current state\nof the boiler.\n\nOpenTherm is a common standard with many vendors and boilers implementing it\nto a different degree. My boiler is one of the simpler ones, and this is all\nthe info that I can get out of it. Other boilers support more sensors, and you\ncan find the whole list in the library readme on GitHub.\n\n### Adding room temperature sensor\n\nMy goal is to maintain a fixed room temperature with minimum variation. In\norder to do that, I need to get this temperature from somewhere. In my target\ndesign I will place climate sensors in every room and connect them all to Home\nAssistant. It will be a complex control system which will have an ability to\ncontrol temperature in each room individually with TRVs placed on radiators.\nBut I should also plan for failure and make sure that my heating system can\noperate on a basic level when Home Assistant and even Wi-Fi are down. It's\nalso impractical to try and build a complex system right off the bat. I better\nstart with something simple, and then iterate to add complexity.\n\nThe most self-contained way to measure room temperature that will be resilient\nto network failure is to connect a temperature sensor to the thermostat\nitself. So it's time to connect a sensor to one of the temperature connectors\nthat I left on the board and add some more ESPHome configuration (I omitted\nall the screw-in temperature sensors for the sake of simplicity):\n\n    \n    \n    # Temperature sensor hub dallas: - pin: GPIO18 update_interval: 30s sensor: # [.. boiler sensors omitted ..] # Temperature sensors - platform: dallas address: 0x2001229265635128 name: \"Room Temperature\" id: boilotron_temp_room accuracy_decimals: 2 filters: - sliding_window_moving_average: window_size: 5 # Average over this number of last measurements send_every: 2 # When sensor update interval is 30s, new value will be pushed every minute # PID controller updates its parameters only on sensor signal, so we push the last value every second # We don't want to actually read the sensor temperature every second, since it would hurt performance. - heartbeat: 1s\n\nFirst of all, I declared a dallas component, which contains pin number for all\nthe temperature sensors that are daisy-chained on a single 1-Wire bus. I also\nset update_interval so that all sensors on that bus will be polled once every\n30 seconds. I wouldn't recommend decreasing this interval by much, since\n1-Wire communication seems to hurt performance and even interfere with\nOpenTherm protocol (more on this in a separate post).\n\nNext I setup individual temperature sensors. It's important to note that this\nconfiguration goes into the existing sensor section, where I placed some\nOpenTherm sensors earlier. The most important here is sensor address. You can\nfind out your sensor addresses by temporarily setting logger level to DEBUG\nand rebooting your device. ESPHome will print out addresses of all found\nsensors, so in order to determine an individual address you need to connect\nyour sensors one by one and reboot after each new sensor is connected.\n\nI also want to add several filters to this particular sensor. I'm going to use\na PID controller to calculate target t_set temperature based on\nboilotron_temp_room temperature and there is a couple of considerations here:\n\n  1. Digital temperature sensors can be rather noisy. For example, you can observe random small changes from one measurement to the next. These are OK when you just print your temperature reading to a dashboard, but for a PID controller every input change is a trigger to adjust the control signal. Such noise doesn't reflect well on the resulting signal, so you typically want to make your temperature readings smoother. That's why I added a sliding_window_moving_average filter which does just that: it takes last 5 measurements, averages them, and reports every other one to ESPHome. So if my update_interval is 30 seconds, every minute I will get a new measurement averaged over last 2.5 minutes. These values are eyeballed empirically and you might need different values based on how your particular sensors behave.\n  2. PID controller output is adjusted only when new input value is received. PID controller works is by making small changes to current output value, so pushing a new input each minute will be ineffective: we would wait for a very long time for t_set to change even a little bit. To combat that I apply a heartbeat filter to my temperature sensor. It remembers last known temperature reading and pushes it out every second. So effectively I will drive my PID controller every second with the same input, and each minute that input has a chance of updating if room temperature actually changes enough to go through the sliding average filter.\n\nI know, all these settings seem a bit arbitrary \u2014 that's because they are.\nFinding the right combination of filters and coefficients took me some time of\njust running this system and staring at Home Assistant dashboard. If you try\nto reproduce this design, you might get lucky and these numbers work for you\ntoo. If they don't \u2014 don't despair, you can probably tune it to your\nenvironment in a couple of hours \ud83d\ude03\n\n### Adding PID control\n\nOK, this is a super long post already, but bear with me \u2014 we are almost there.\nIt's time to put all these things together by adding a PID controller. It will\ntake room temperature as an input and output a single number in range of\n[0..1], which is then scaled to fit the range of [min_value..max_value] in our\nt_set component.\n\nThe most useful example to help you understand a PID controller is cruise\ncontrol in a car. You tell the car its desired speed and an onboard computer\nslowly tunes fuel intake and other parameters to reach that speed over a\nperiod of time. It's important to understand that no control system reaches\nits target instantaneously (you can't accelerate from 0 to 100 in 0 seconds)\nand it's usually not desirable to change control signals by large amount (you\ncan shift from first to fourth gear, but you car won't thank you).\n\nPID controller is a vital part of large and complex fields of control theory\nand industrial automation. People actually get degrees in this stuff, and\nthat's exactly what I did more than a decade ago \ud83d\ude00 But the truth is that most\nof this theoretical apparatus is very rarely used and people are just\neyeballing the coefficients, even at serious establishments like oil\nrefineries and nuclear plants. If you want to dive deeper into the theory, I\nsuggest starting at ESPHome documentation for PID controller. It's a good idea\nto understand how it works in detail, but it's not required right away. You\ncan try my values and see if they make sense in your environment.\n\nHere is how I configure a PID controller:\n\n    \n    \n    climate: - platform: pid id: boilotron_boiler_pid name: \"Central heating\" heat_output: boilotron_ch_setpoint default_target_temperature: 23 sensor: boilotron_temp_room visual: min_temperature: 15 max_temperature: 30 temperature_step: target_temperature: 0.5 current_temperature: 0.1 control_parameters: kp: 0.76394 ki: 0.00050 kd: 0 # Derivative term reacts too much to small changes in temperature, effectively turning off the boiler while target temperature is still far output_averaging_samples: 10 deadband_parameters: threshold_high: 0.5 threshold_low: -0.5 # Will try to turn off any control signal inside the deadband in order to minimize flame jerking kp_multiplier: 0 # Added proportional gain since integral alone doesn't seem to fall fast enough when target is reached (but removed again after changing min feed temperature to 40 deg) ki_multiplier: 0.15 # integral accumulates at only 20% of normal ki kd_multiplier: 0.0 # derviative is turned off inside deadband deadband_output_averaging_samples: 15 # average the output over 15 samples within the deadband\n\nThe most important settings are these:\n\n  * sensor \u2014 this is the input that is used to calculate the control signal. I put boilotron_temp_room there to point to my temperature sensor.\n  * heat_output \u2014 the component that I want to control. I put boilotron_ch_setpoint there to control t_set value.\n  * default_target_temperature \u2014 default temperature that I would like to have in my room. This is a starting point, and I can change target temperature in home Assistant UI later.\n\nThere is a visual section that configures how the component will render in\nHome Assistant UI. I put some sensible boundaries on target temperature and\nadjust step size.\n\ncontrol_parameters and deadband_parameters sections contain the actual\ncoefficients that are used for PID control algorithm. In an ideal world of\ncontrol theory you would use complicated methods to measure you particular\nsystem's response to various control signals, maybe solve a couple of partial\ndifferential equations and arrive at perfect values that work for you and\nflawlessly. But in the real world these methods are seldomly used and you can\ntry to reuse my values as they are.\n\nThe main idea here is that PID regulator outputs lower temperature when room\ntemperature is close to target, and higher temperature if it's further from\ntarget. For example, if my target is 23\u00b0 and current room temperature is\n22.7\u00b0, PID controller might output 40\u00b0, which is the lower bound in t_set\ncomponent, heating my radiators just a little bit so that target temperature\nis reached slowly without little overshoot. But if my current temperature is\n19\u00b0, the controller will likely output 60\u00b0 in order to make radiators go full\nblast and heat the room faster.\n\n### Uploading the firmware\n\nAfter all this was done I compiled and uploaded new firmware to my device\nwirelessly using the \u201eInstall\u201d button in ESPHome dashboard. After a couple of\nseconds, my device showed up in Home Assistant device list and this is roughly\nwhat I see if I open it:\n\nIf I click on \u201eCentral Heating\u201d, I get a nice Home Assistant thermostat UI:\n\nNow I can add some of these items to my dashboard and control my heating\nsystem from my phone!\n\n## Conclusion\n\nThis turned out to be a much larger post than I anticipated. I didn't cover a\nlot of topics like adding an LCD display or rewriting half of the OpenTherm\nlibrary. Stay tuned for more posts with hairy details \ud83d\ude03\n\n### You might also like...\n\nApr\n\n08\n\n## Making a prototype OpenTherm thermostat\n\n5 min read\n\nFeb\n\n21\n\n## Export anaconda environment with conda export\n\n3 min read\n\nFeb\n\n20\n\n## Alternatives to Parallels Desktop for running virtual machines on M1, M2\nand M3 Macs\n\n5 min read\n\nMay\n\n26\n\n## How to fix \"The provided certificate file is not a valid PFX file\" with\ndotnet dev-certs https import on macOS\n\n1 min read\n\nJun\n\n20\n\n## Mamba: a robust alternative to Anaconda package manager\n\n3 min read\n\nAutomate this \u00a9 2024\n\nPowered by Ghost\n\n", "frontpage": false}
