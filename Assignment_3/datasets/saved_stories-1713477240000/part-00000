{"aid": "40077490", "title": "Show HN: iceoryx2 v0.3.0 released \u2013 zero-copy IPC middleware in Rust", "url": "https://github.com/eclipse-iceoryx/iceoryx2/releases/tag/v0.3.0", "domain": "github.com/eclipse-iceoryx", "votes": 2, "user": "elfenpiff", "posted_at": "2024-04-18 15:53:14", "comments": 0, "source_title": "Release v0.3.0 \u00b7 eclipse-iceoryx/iceoryx2", "source_text": "Release v0.3.0 \u00b7 eclipse-iceoryx/iceoryx2 \u00b7 GitHub\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\neclipse-iceoryx / iceoryx2 Public\n\n  * Notifications\n  * Fork 16\n  * Star 334\n\n# v0.3.0\n\nPre-release\n\nPre-release\n\nelfenpiff released this 18 Apr 15:27\n\nv0.3.0\n\na33cc28\n\nFull Changelog\n\n## Features\n\n  * Add docker example #83\n  * Introduce iceoryx2-bb-posix::process_state for process monitoring #96\n  * Introduce concept iceoryx2-cal::monitoring #96\n  * New constructs from #123\n\n    * Introduce semantic string iceoryx2-bb-system-types::base64url\n    * Introduce iceoryx2-cal::hash::HashValue that contains the result of a hash\n  * Port UsedChunkList from iceoryx1 #129\n  * From #133\n\n    * Add Notifier|Listener|Publisher|Subscriber::id() method to acquire unique port id\n    * Add Sample::origin() to determine the UniquePublisherId of the sender\n  * Performance improvements, especially for AMD CPUs #136\n  * Introduce lock-free mpmc BitSet #139\n  * Refactor Event API #175\n\n    * Add event_id_max_value() setting to Event service builder\n    * Add defaults.event.event_id_max_value to config file (iceoryx2.toml)\n    * Add Listener::{try|timed|blocking}_wait_all to grab a batch of EventIds to avoid infinite busy loop\n  * Example for complex data types #175\n\n## Bugfixes\n\n  * Fix undefined behavior in spsc::{queue|index_queue} #87\n  * Fix open_or_create race #108\n  * Fixes for #116\n\n    * Fix retrieve channel overflow caused by big publisher loans\n    * Fix CreationMode::OpenOrCreate in iceoryx2-bb-posix::SharedMemory\n    * Add missing memory synchronization to posix shm zero copy connection\n    * Remove retrieve buffer full check from zero copy connection - sender had insufficient infos available\n    * Fix data race in iceoryx2-bb-lock-free::mpmc::Container\n  * Fix insufficient memory reordering protection in spsc::Queue::push and spsc::Queue::pop #119\n  * Fix data race due to operation reordering in spmc::UnrestrictedAtomic::load #125\n  * Fix broken Publisher|Subscriber::populate_{subscriber|publisher}_channels() #129\n  * Fix failing reacquire of delivered samples in the zero copy receive channel #130\n  * Fix receiving of invalid samples when subscriber is connected #131\n  * Fix problem where sample is released to the wrong publisher #133\n  * Fix event notifier deadlock with reconnecting listeners #139\n  * Fixes for FreeBSD 14.0 #140\n\n    * Fix segfault in iceoryx2-pal-posix;:shm_list() caused by sysctl\n    * Adjust test to handle unordered event notifications\n  * Fix non UTF-8 windows platform error messages #145\n  * Correct inconsistent default config entries for windows #149\n  * Fix that drop is not called when DynamicStorage is destroyed #160\n  * Fix race in UniqueSystemId that leads to non-unique unique ids #181\n\n## Refactoring\n\n  * Replace iceoryx2::service::Service with iceoryx2::service::Details #100\n  * Remove 'config lifetime from all structs #100\n  * Remove UniqueIndex returning method from iceoryx2-bb-lock-free::mpmc::Container, cannot be implemented correctly in our context #116\n  * All iceoryx2-cal::shared_memory implementations use a DynamicStorage concept as base #153\n  * Hardening DynamicStorage, storages with distinct types cannot be opened #160\n  * IpcCapable handles explicity destroy underlying object in drop, instead of ref counting #162\n\n## New API features\n\n  * Add FixedSizeByteString::from_bytes_truncated #56\n  * Add Deref, DerefMut, Clone, Eq, PartialEq and extend_from_slice to (FixedSize)Vec #58\n  * MessagingPattern implements Display #64\n  * Introduce traits for all ports (Listen, Notify, Publish, DefaultLoan, UninitLoan, Subscribe) and for samples (PayloadMut, Payload) #69\n  * Implement Ord and PartialOrd for FixedSizeByteString and ServiceName #110\n  * Remove publish_subscribe::Header::time_stamp() due to ordering and performance problems #136\n\n## API Breaking Changes\n\n  1. Use SampleMut::send() instead of Publisher::send()\n    \n        // old let publisher = service.publisher().create()?; let sample = publisher.loan()?; // set sample value publisher.send(sample)?; // new let publisher = service.publisher().create()?; let sample = publisher.loan()?; // set sample value sample.send()?;\n\n  2. All port Publisher, Subscriber, Listener and Notifier no longer have a generic 'config lifetime parameter.\n    \n        // old let publisher: Publisher<'service, 'config, iceoryx2::service::zero_copy::Service::Type<'config>, MessageType> = ..; let subscriber: Subscriber<'service, 'config, iceoryx2::service::zero_copy::Service::Type<'config>, MessageType> = ..; let notifier: Notifier<'service, 'config, iceoryx2::service::zero_copy::Service::Type<'config>> = ..; let listener: Listener<'service, 'config, iceoryx2::service::zero_copy::Service::Type<'config>> = ..; // new let publisher: Publisher<'service, iceoryx2::service::zero_copy::Service, MessageType> = ..; let subscriber: Subscriber<'service, iceoryx2::service::zero_copy::Service, MessageType> = ..; let notifier: Notifier<'service, iceoryx2::service::zero_copy::Service> = ..; let listener: Listener<'service, iceoryx2::service::zero_copy::Service> = ..;\n\n  3. iceoryx2::service::Details no longer has a generic 'config lifetime parameter. iceoryx2::service::Details replaced iceoryx2::service::Service. All custom services need to implement iceoryx2::service::Service.\n    \n        // old pub struct MyCustomServiceType<'config> { state: ServiceState<'config, static_storage::whatever::Storage, dynamic_storage::whatever::Storage<WhateverConfig>> } impl<'config> crate::service::Service for MyCustomServiceType<'config> { // ... } impl<'config> crate::service::Details for MyCustomServiceType<'config> { // ... } // new pub struct MyCustomServiceType { state: ServiceState<static_storage::whatever::Storage, dynamic_storage::whatever::Storage<WhateverConfig>> } impl crate::service::Service for MyCustomServiceType { // ... }\n\n  4. Writing functions with generic service parameter no longer require Service + Details<'config>. Now it suffices to just use Service\n    \n        // old fn my_generic_service_function<'config, ServiceType: iceoryx2::service::Service + iceoryx2::service::Details<'config>>(); // new fn my_generic_service_function<ServiceType: iceoryx2::service::Service>();\n\n  5. Do not use Header::time_stamp(), when required make it part of the payload type. Be aware, this can be expensive and can lead to a significantly increased latency!\n    \n        // old let subscriber = service.subscriber().create()?; println!(\"sample timestamp: {:?}\", sample.unwrap().header().time_stamp()); // new use iceoryx2_bb_posix::clock::{Time, TimeBuilder}; #[derive(Debug)] #[repr(C)] pub struct TimeStamp { seconds: u64, nanoseconds: u32, } impl TimeStamp { pub fn new() -> Self { let now = Time::now().unwrap(); Self { seconds: now.seconds(), nanoseconds: now.nanoseconds(), } } } pub struct MyMessageType { payload: u64, time_stamp: TimeStamp } // sender side let publisher = service.publisher().create()?; let sample = publisher.loan_uninit()?; let sample = sample.write_payload(MyMessageType { payload: 1234, time_stamp: TimeStamp::now(); }); sample.send()?; // receiver side let subscriber = service.subscriber().create()?; println!(\"sample timestamp: {:?}\", sample.unwrap().time_stamp);\n\n  6. Listener::{try|timed|blocking}_wait_one() replace Listener::{try|timed|blocking}_wait() and return an Option<EventId> instead of a slice of EventIds.\n    \n        // old if let Ok(events) = listener.try_wait() { for event_id in events { println!(\"event was triggered with id: {:?}\", event_id); } } // new, iterative approach while let Ok(Some(event_id)) = listener.try_wait_one() { println!(\"event was triggered with id: {:?}\", event_id); } // new, functional approach to grap a batch of id's listener.try_wait_all(|id| { println!(\"event was triggered with id: {:?}\", event_id); });\n\n  7. Renamed method EventId::as_u64() to EventId::as_value().\n    \n        // old println!(\"event id value {}\", my_event_id.as_u64()); // new println!(\"event id value {}\", my_event_id.as_value());\n\n  8. EventIds have a max default value of 32.\n    \n        // old let name = ServiceName::new(\"EventName\")?; let event = zero_copy::Service::new(&name) .event() .open_or_create()?; let notifier = event.notifier().create()?; // leads now to `NotifierNotifyError::EventIdOutOfBounds` notifier.notify_with_custom_event_id(EventId::new(1234)); // new let name = ServiceName::new(\"EventName\")?; let event = zero_copy::Service::new(&name) .event() // supports event id values up to 2048 // be aware, the greater the max value the slower the // event mechanism is .event_id_max_value(2048) .open_or_create()?; let notifier = event.notifier().create()?; notifier.notify_with_custom_event_id(EventId::new(1234));\n\n1 person reacted\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
