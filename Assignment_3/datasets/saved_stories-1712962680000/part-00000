{"aid": "40015062", "title": "Vulkan \"But Why?\" FAQ", "url": "https://www.yosoygames.com.ar/wp/2023/04/vulkan-why-faq/", "domain": "yosoygames.com.ar", "votes": 1, "user": "goranmoomin", "posted_at": "2024-04-12 16:56:04", "comments": 0, "source_title": "Vulkan \u201cBut WHY?\u201d FAQ", "source_text": "Vulkan \u201cBut WHY?\u201d FAQ \u2013 Yosoygames\n\nSkip to content\n\n# Yosoygames\n\n## Think out of the box. A site about software, video games, graphics, music\nand media in general\n\n## Think out of the box. A site about software, video games, graphics, music\nand media in general\n\n  * BLOG\n  * OGRE MESHY\n  * ROYALTY FREE MUSIC\n  * DISTANT SOULS\n\nHome \u00bb Graphics \u00bb Vulkan \u201cBut WHY?\u201d FAQ\n\n# Vulkan \u201cBut WHY?\u201d FAQ\n\nThis entry was posted in Graphics and tagged faq Vulkan why on April 4, 2023\nby Matias\n\nVulkan isn\u2019t newbie friendly.\n\nBut something that I get asked a lot are questions that aren\u2019t answered\nanywhere or is hard to find (i.e. typically in the form of \u201cwhy are things\ndone this way?\u201d) unless you are familiar with previous APIs (i.e. D3D11 &\nMetal) and existing HW limitations.\n\nNote that for brevity and clarity I\u2019ll shorten the following:\n\n  * RGBA8_UNORM is VK_FORMAT_R8G8B8A8_UNORM\n  * RGBA8_SRGB is VK_FORMAT_R8G8B8A8_SRGB\n  * PSO (Pipeline State Object) is a VkPipeline\n  * USAGE_STORAGE_BIT is VK_IMAGE_USAGE_STORAGE_BIT\n\n# Why Vulkan hardcodes the viewport in the PSO?\n\nVkPipeline (from now on PSOs) asks for viewport & scissor values. That means\nthat targetting a 1440\u00d7900 viewport and a 1920\u00d71080 require two different PSOs\njust because the resolution is different. As you can guess, this is insane.\n\nThe solution is to do what everyone does: use dynamic states for these two\nsettings. Add VK_DYNAMIC_STATE_VIEWPORT & VK_DYNAMIC_STATE_SCISSOR and now the\nsame PSO can be used for both resolutions. Just set them via vkCmdSetViewport\nand vkCmdSetScissor.\n\nNow you may be wondered WHY? Well, the answer is simple: Because one mobile\nvendor ferociously requested the vp/scissor values to be hardcoded into the\nPSO because it was faster in their HW. They claimed it would save a few\nmultiplications (thus saving perf and battery).\n\nThat\u2019s it, that\u2019s the reason. It was to appease one vendor.\n\nPretty pointless if you ask me, given that AFAIK nobody, I mean nobody\nhardcodes the viewport into the PSO; other than perhaps a tech demo.\n\nEverybody complained about this, and everyone agreed it was unreasonable to\ndemand viewport settings to be hardcoded, so dynamic state was created for\nthis and shipped with Vulkan 1.0. And everyone secretly knew that everyone\nwould ignore the hardcoded path.\n\n# Why does PSO ask for a VkRenderPass? Doesn\u2019t this tie a PSO to a specific\nresolution???\n\nThis is the ugliest part of Vulkan to explain that has ties down to its\nobsession for using subpasses for TBDR (aka mobile) GPUs; instead of much\nfriendlier approaches like Metal giving read/write access to gl_FragColor\n(something that sadly was only just added in end of 2021 via\nVK_ARM_rasterization_order_attachment_access).\n\nIf you use VK_KHR_dynamic_rendering you can skip this question. If not, keep\nreading.\n\nIndeed, a PSO needs a VkRenderPass and in turn it needs a VkImage. Therefore,\neach PSO is still tied to a specific resolution.\n\nBut here\u2019s the thing: You don\u2019t really need the VkImage!\n\nVulkan Specs have a hard-to-read \u201ccompatibility\u201d concept:\n\n> VUID-VkRenderPassBeginInfo-renderPass-00904 renderPass must be compatible\n> with the renderPass member of the VkFramebufferCreateInfo structure\n> specified when creating framebuffer\n\nThe rough TL;DR is that two VkRenderPass are \u201ccompatible\u201d if they have the\nexact same pixel format, same MSAA settings and same number of attachments in\nthe same order with the same settings. Their resolutions don\u2019t matter! The\nload/store actions don\u2019t matter either.\n\nIronically the easiest way to understand what makes two VkRenderPass\ncompatible is to look what Metal asks for in\nMTLRenderPipelineColorAttachmentDescriptor,\nMTLRenderPassDepthAttachmentDescriptor, and\nMTLRenderPassStencilAttachmentDescriptor.\n\nIn OgreNext, we use VulkanRenderSystem::getVkRenderPass to build a dummy\nVkRenderPass that is compatible (based on our own abstraction called\nHlmsPassPso) providing pixel format and MSAA settings without ever providing a\nVkImage.\n\nAnd we use a cache via VulkanCache::getRenderPass to ensure all PSOs share the\nsame VkRenderPass pointer.\n\n## Wait, but that means I need to track pass format and msaa? That\u2019s a lot of\nwork!\n\nYes, you need to track that. If you design your engine properly around PSOs,\nit isn\u2019t that much work. Note that you need to do this not just for Vulkan,\nbut also for D3D12 and Metal.\n\nIf you already have an existing engine that isn\u2019t designed around PSOs, you\ncan use a caching system instead to bind current state to an abstracted pass\nentry.\n\nThis is what modern drivers do internally for D3D11 and OpenGL.\n\n# Why can\u2019t I reinterpret RGBA8_UNORM into RGBA8_SRGB if I use\nUSAGE_STORAGE_BIT?\n\nYou can. But there was an API oversight.\n\nSee... on a lot of HW, USAGE_STORAGE_BIT is not supported with\nRGBA8_UNORM_SRGB due to HW limitations.\n\nThus a very simple & common solution is to create an RGBA8_UNORM texture with\nUSAGE_STORAGE_BIT, write to it in a compute shader (doing sRGB conversion by\nhand in the shader) and then reinterpret the texture as RGBA8_SRGB for\nsampling like a regular texture.\n\nBut validation layers will complain if you do this.\n\nYou need the VK_KHR_maintenance2 extension to tell Vulkan drivers you intend\nto do this.\n\nSimply add VkImageViewUsageCreateInfo to VkImageViewCreateInfo::pNext\n\n    \n    \n    VkImageViewCreateInfo imageViewCi; VkImageViewUsageCreateInfo flagRestriction; memset( flagRestriction, 0, sizeof( flagRestriction ) ); flagRestriction.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO; imageViewCi.pNext = &flagRestriction; flagRestriction.usage = VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT; if( isTexture() ) flagRestriction.usage |= VK_IMAGE_USAGE_SAMPLED_BIT; if( isRenderToTexture() ) { flagRestriction.usage |= PixelFormatGpuUtils::isDepth( pixelFormat ) ? VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT : VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; }\n\nThis signals that you want to reinterpret the regular non-sRGB to SRGB without\nUSAGE_STORAGE_BIT because you don\u2019t care about it.\n\nThe texture must have been created with VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT.\n\nSee OgreNext code for reference.\n\n# Why can\u2019t RGBA8_SRGB use USAGE_STORAGE_BIT?\n\nThis is a HW limitation. Internally texture formats are rearranged in\ndifferent patterns. Not just morton order to make it cache friendly, but also\nat the bit level.\n\nWhereas we think of an RGBA8_UNORM texture to be 8 bits of red, followed by 8\nbits of green i.e.: RRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA but internally it may\nactually be interleaved in weird ways RRGGBBRRRRBBBG... with morton order\napplied on top of it.\n\nThey may even choose to take a 2\u00d72 pixel block and put all R bits first (i.e.\n64 bits of red), then all G next and so on. This arrangement is better if you\nintend to use textureGather for example.\n\nHow bits and pixels are interleaved is opaque and up to each HW. This\narrangement is supposedly done so to simplify bilinear filtering. GPUs might\nuse lossless compression if they can.\n\nThe exact details are unknown to me. However the point is, that the GPU does\nnot do what you think it is doing.\n\nsRGB complicates things because data must be converted from sRGB to linear on\ndemand during sampling (and before filtering). And it seems that giving write\naccess to sRGB (which is what the USAGE_STORAGE_BIT flag is for) makes things\ntoo complicated.\n\nSo the easy path for HW vendors is to just forbid this combination and force\nthe developer to make the sRGB conversion before writing the data as raw\nRGBA8_UNORM.\n\nAlso note that adding the flag USAGE_STORAGE_BIT to RGBA8_UNORM can disable\nsome of these optimizations I mention. So don\u2019t add it if you don\u2019t have to.\n\n# Why resource binding is done through VkPipelineLayout &\nVkDescriptorSetLayout and all that madness?\n\nFaith Ekstrand answers this question much better than I ever could.\n\nThe short version is that HW supported by Vulkan can be divided in 4 binding\nmodels:\n\n  1. Direct Access\n  2. Descriptor buffers\n  3. Descriptor heaps\n  4. Fixed HW bindings\n\nAnd descriptor set is the only \u201creasonable\u201d abstraction very clever people\nfound to cover all those 4 models.\n\nParticularly if you can ditch certain HW, you can go full bindless and make\nyour life easier. But if you want the broadest support, you need to go in\ndeep.\n\nSee Faith Ekstrand\u2019s post for in-depth explanation.\n\n### Recent Posts\n\n  * You\u2019re calculating framerate percentiles wrong!\n  * Samsung Galaxy A54 Gaming Performance: WHAT THE HECK IS GOING ON?\n  * Vulkan \u201cBut WHY?\u201d FAQ\n  * An Open Letter to ARM / Mali: Please stop doing this\n  * My Ubuntu Linux boots into a black screen: GUIDE\n\n### Recent Comments\n\n  * Dave Ranck on A little clarification on modern shader compile times\n  * Matias on A little clarification on modern shader compile times\n  * Simon Deschenes on A little clarification on modern shader compile times\n  * Simon Deschenes on A little clarification on modern shader compile times\n  * steve m on A little clarification on modern shader compile times\n\n### Archives\n\n  * September 2023\n  * July 2023\n  * April 2023\n  * February 2023\n  * November 2022\n  * July 2022\n  * May 2022\n  * January 2022\n  * December 2021\n  * November 2021\n  * August 2021\n  * June 2021\n  * May 2021\n  * January 2021\n  * August 2020\n  * May 2020\n  * April 2020\n  * March 2020\n  * September 2019\n  * June 2018\n  * March 2018\n  * January 2018\n  * December 2017\n  * July 2017\n  * March 2017\n  * February 2017\n  * December 2016\n  * November 2016\n  * September 2016\n  * August 2016\n  * April 2016\n  * January 2016\n  * October 2015\n  * September 2015\n  * August 2015\n  * July 2015\n  * May 2015\n  * January 2015\n  * December 2014\n  * November 2014\n  * October 2014\n  * September 2014\n  * August 2014\n  * June 2014\n  * May 2014\n  * April 2014\n  * March 2014\n  * January 2014\n  * December 2013\n  * November 2013\n  * October 2013\n  * September 2013\n  * August 2013\n  * July 2013\n  * June 2013\n  * May 2013\n\n\u00b7 \u00a9 2024 Yosoygames \u00b7 Powered by \u00b7 Designed with the Customizr theme \u00b7\n\n", "frontpage": false}
