{"aid": "40033795", "title": "How to check you're in the initial PID namespace? (2022)", "url": "https://leahneukirchen.org/blog/archive/2022/01/how-to-check-you-re-in-the-initial-pid-namespace.html", "domain": "leahneukirchen.org", "votes": 1, "user": "fanf2", "posted_at": "2024-04-14 19:42:04", "comments": 0, "source_title": "leah blogs: How to check you're in the initial pid namespace?", "source_text": "leah blogs: How to check you're in the initial pid namespace?\n\n# leah blogs\n\n\u00ab Merry Christmas! January 2022 Note taking in Emacs with howm \u00bb\n\n## 08jan2022 \u00b7 How to check you're in the initial pid namespace?\n\nIt all started with a simple question: how can a Linux process determine\nwhether it is the init process of a freshly booted system?\n\nA dozen years ago, the Unix textbook answer to this would have been: well, if\nits process id (pid) is 1, then it is init by definition.\n\n\u2042\n\nThese days, things are not that simple anymore. Containerization creates\nsituations where pid is 1, but the process runs, well, in a container. In\nLinux, this is realized by using a feature called \u201cpid namespaces\u201d. The\nclone(2) syscall can take the flag CLONE_NEWPID (\u201csince Linux 2.6.24\u201d), which\nputs the new process into a new pid namespace. This means that this process\nwill have pid 1 inside the pid namespace, but outside (i.e. in the parent pid\nnamespace), the process has a regular pid. Various Linux API transparently\ntranslate pids between these namespaces.\n\nThe pid namespaces form a hierarchy, and the one at the very top is called\n\u201cinitial pid namespace\u201d.\n\nYou can use the tool unshare(1) to play with pid namespaces:\n\n    \n    \n    % unshare --fork --map-root-user --pid bash -c 'echo $$' 1\n\nThis is a way to spawn (as a regular user!) a process that has pid 1, at\nleast, that\u2019s what it looks like to the process.\n\nWe can try to find some evidence that we\u2019re a freshly booted init, but none of\nit is really conclusive:\n\n  * Our user id is 0, we are root (necessary but not sufficient of course).\n  * $TERM should be linux; trivial to override.\n  * $BOOT_IMAGE is set, but this depends on the boot loader.\n  * System uptime is \u201clow\u201d, but it takes the initrd boot time into account. Our non-root init could be spawned in a container at boot time.\n\nThere are also some indicators the process runs in a container using one of\nthe popular solutions such as docker or podman:\n\n  * The process has a lot of supplementary groups already.\n  * If we were put inside a cgroup, reading /proc/1/cgroup will indicate it.\n  * The file /.dockerenv exists.\n\nBut there are still situations, such as the unshare call above, where all of\nthese things may not be true.\n\nTherefore I tried to find the ultimate way to detect whether we are in the\ninitial pid namespace.\n\nI started to research this and quickly found the ioctl(2) NS_GET_PARENT which\nseemed to be useful: \u201cReturns a file descriptor that refers to the parent\nnamespace of the namespace referred to by fd.\u201d However, it is useless for this\npurpose:\n\n    \n    \n    EPERM The requested namespace is outside of the caller's namespace scope. This error can occur if, for example, the owning user namespace is an ancestor of the caller's current user namespace. It can also occur on attempts to obtain the parent of the initial user or PID namespace.\n\nOf course, it makes a lot of sense that we cannot get a handle to the\nsurrounding pid namespace, as this would make the encapsulation provided by\nnamespaces futile. However, coalescing these two error conditions (namespace\nis outside the caller namespace, and namespace is initial pid namespace)\ndoesn\u2019t make our life easier.\n\nSo, we need to bring out bigger guns in. I searched the kernel source for\noccurrences of init_pid_ns, as this namespace is called in the Linux source\ncode. There are not too many occurrences we can rely on. The taskstats module\nlimits the TASKSTATS_CMD_ATTR_REGISTER_CPUMASK command to the initial pid\nnamespace only, but to use this requires speaking the netlink interface, which\nis terrible. Also, the behavior could change in future versions.\n\nOne interesting, and viable approach, is this limitation of the reboot(2)\nsyscall: only some LINUX_REBOOT_CMD_* commands are allowed to be sent inside a\nnested pid namespace. Now, we need to find a \u201charmless\u201d command to call\nreboot(2) with to test this! (Obviously, only being able to suspend the\nmachine from the initial pid namespace is not a very useful check...) There\nare two commands that do not do much harm: LINUX_REBOOT_CMD_CAD_{ON,OFF} will\ntoggle the action that Ctrl-Alt-Delete performs. Unfortunately, it is\nimpossible to read the state of this flag, making this test a destructive\noperation still. (But if you are pid 1, you may want to set it anyway, so you\nget pid namespace detection for free.)\n\n\u2042\n\nSo I kept looking for other ways until I realized there\u2019s a quite natural\nproperty to check for, and that is to find out if there are kernel threads in\nthe pid namespace. Kernel threads are spawned by the kernel in the initial pid\nnamespace and help perform certain asynchronous actions the kernel has to do,\nsubject to process scheduling. As far as I know, kernel threads never occur in\na nested pid namespace, and at least the parent process of kernel threads,\nkthreadd, will always exist. Conveniently, it also always has pid 2.\n\nThus, we just need to figure out if pid 2 is a kernel thread! Note that just\nchecking whether pid 2 exists is cheap, but racy: the container runtime could\nhave spawned another process before we are scheduled to do the check, and this\nprocess will as well get pid 2 then.\n\nLuckily, kernel threads have quite a few special properties, that are of\ndifferent difficulty to check from a C program:\n\n  * /proc/PID/cmdline is empty (not a good indicator, user space processes can clear it too).\n  * kernel threads have parent pid 0 (requires parsing /proc/PID/stat, which everyone gets wrong the first time, or /proc/PID/status).\n  * kernel threads have no Vm* data in /proc/PID/status.\n  * kernel threads have the flag PF_KTHREAD set (requires parsing /proc/PID/stat again).\n  * kernel threads have an empty symlink for /proc/PID/exe.\n\nI decided to go with the latter. On Linux, empty symlinks are impossible to\ncreate as a user, so we just need to check that and we\u2019re done, right?\n\nOn a regular file system, using lstat(2) would have filled st_size with the\nlength of the symlink. But on a procfs, lstat is not to be trusted, and even\nnon-empty symlinks have st_size equal to 0. We thus really need to use the\nreadlink(2) syscall to read the link. After doing this, you will notice that\nit returns ENOENT... exactly the same as if pid 2 did not exist!\n\nWe therefore need another check, to verify that pid 2 does exist. Luckily,\nhere a lstat on /proc/2/exe file is fine. It must return zero.\n\nNote that you need to do these operations in exactly this order, else you are\nsubject to race conditions again: the only reason this works is that if pid 2\nis kthreadd, it will not have terminated before the lstat check (because it\ncannot terminate).\n\n[Addendum 2023-09-17: vmann points out that this is still racy: a container\ncan spawn a new pid 2 between the lstat and the readlink call. Please use one\nof the more complicated approaches mentioned above!]\n\nTherefore, readlink(2) failing with ENOENT and lstat(2) succeeding is exactly\nthe combination required to check pid 2 is kthreadd, which implies there are\nkernel threads in our pid namespace, which implies that we are in the initial\nnamespace.\n\nPhew, this went deeper than expected.\n\nNP: David Bowie\u2014Lazarus\n\nCopyright \u00a9 2004\u20132022 Leah Neukirchen\n\n", "frontpage": false}
