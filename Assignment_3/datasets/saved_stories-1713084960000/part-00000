{"aid": "40028288", "title": "Making Ijq Fast", "url": "https://gpanders.com/blog/making-ijq-fast/", "domain": "gpanders.com", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-14 02:53:42", "comments": 0, "source_title": "Making ijq Fast | g.p. anders", "source_text": "Making ijq Fast | g.p. anders\n\nGregory Anders\n\n# Making ijq Fast\n\nApril 13, 2024\n\nI recently received an issue report that ijq was performing slowly. The issue\nclaimed that, when used on a large (16 MB) JSON file, ijq was \u201ctoo slow to be\nusable\u201d. I downloaded the test file which was (helpfully) provided in the\nissue and tried it myself. Even using the most charitable definition, I agree\nthat this classifies as \u201cunusably slow\u201d. Note that in this screen recording I\nam displaying my key presses to show just how unresponsive ijq is:\n\nIn the rest of this post I\u2019ll talk about why ijq was performing so badly, and\nwhat I changed to fix it. The end result is that ijq is now, dare I say, not\njust usable, but downright snappy:\n\n## Background\n\nFirst, a brief explanation of how ijq works.\n\nijq is, more or less, an interactive TUI wrapper around jq. When ijq starts,\nthe input document (whether read from a file or stdin) is read and processed\nwith jq using the default filter (.), and the output is written to the left\n(Input) pane. A second jq process is run which processes the input document\nusing whatever filter the user supplied to ijq; that output is written to the\nright (Output) document. The input text box is the filter passed to jq.\nWhenever the input text box changes, jq is run on the input document using the\nnew filter and the output is written to the right pane.\n\nConceptually, this is fairly simple, but there are plenty of ways to do this\nwrong (as I learned).\n\nThe input document is represented as a Document object:\n\n    \n    \n    type Document struct { input string filter string options Options }\n\nThe Document object implements the WriterTo interface for writing to an\nio.Writer object:\n\n    \n    \n    // Filter the document with the given jq filter and options func (d *Document) WriteTo(w io.Writer) (n int64, err error) { opts := d.options if _, ok := w.(*tview.TextView); ok { // Writer is a TextView, so set options accordingly opts.forceColor = true opts.monochrome = false opts.compact = false opts.rawOutput = false } args := append(opts.ToSlice(), d.filter) cmd := exec.Command(d.options.command, args...) stdin, err := cmd.StdinPipe() if err != nil { return 0, err } go func() { defer stdin.Close() _, _ = io.WriteString(stdin, d.input) }() out, err := cmd.CombinedOutput() if err != nil { if exiterr, ok := err.(*exec.ExitError); ok { exiterr.Stderr = out } return 0, err } if tv, ok := w.(*tview.TextView); ok { w = tview.ANSIWriter(tv) tv.Clear() } m, err := w.Write(out) n = int64(m) return n, err }\n\nIf the Writer is a TextView (the TUI widget used for the input and output\npanes) then we set some options which are passed to the child jq process. The\nchild process is started and the document\u2019s input is piped to the process\u2019s\nstdin. When the process finishes, the stdout is written to the Writer.\n\nThe filter input text box has a callback which is fired anytime its value\nchanges:\n\n    \n    \n    filterInput.SetChangedFunc(func(text string) { go app.QueueUpdateDraw(func() { errorView.Clear() doc.filter = text outputView.ScrollToBeginning() _, err := doc.WriteTo(outputView) if err != nil { exitErr, ok := err.(*exec.ExitError) if ok { fmt.Fprint(tview.ANSIWriter(errorView), string(exitErr.Stderr)) } return } }) })\n\nWhenever the input changes, we update the current Document\u2019s filter and call\nWriteTo using the output text view. If the jq subprocess returns an error,\nwrite the error text to the error text view.\n\nThese two functions are the backbone of ijq, and both have fatal flaws\n(experienced Go and/or UI developers have perhaps already spotted them)\nresponsible for ijq\u2019s slow performance.\n\nBefore moving on, it\u2019s worth mentioning that these problems had not been\nnoticed so far because I have only ever used ijq on relatively small inputs.\nWhen the input is small enough, the typing speed of the user becomes the\nbottleneck, not the jq process or updating the text views, so these issues\nhave gone undetected (by me) for a long time (maybe other ijq users have\nnoticed them, but until this issue report I was unaware!).\n\n## Problem\n\nRefer back to the filter input callback implementation above. The first\nproblem is the use of QueueUpdateDraw. ijq uses a TUI widget framework called\ntview to manage the application run loop. tview\u2019s documentation for\nQueueUpdate states:\n\n> QueueUpdate is used to synchronize access to primitives from non-main\n> goroutines. The provided function will be executed as part of the event loop\n> and thus will not cause race conditions with other such update functions or\n> the Draw() function.\n\nQueueUpdate (and QueueUpdateDraw) is used to modify UI primitives from non-\nmain threads. Importantly, these functions block the caller until the main\nthread processes the callback and synchronizes the state. tview\u2019s wiki page on\nConcurrency says:\n\n> Any event handlers you install, e.g. InputField.SetChangedFunc() or\n> Table.SetSelectedFunc(), are invoked from the main goroutine. It is safe to\n> make changes to your primitives in these handlers. If they are invoked in\n> response to a key event, you must not call Application.Draw() as the\n> application\u2019s main loop will do that for you and calling Application.Draw()\n> (or Application.QueueUpdate() or Application.QueueUpdateDraw()) from within\n> an event handler will lead to a deadlock.\n\nThe use of QueueUpdateDraw() in this handler is in violation of this advice.\nThe function is started in a separate goroutine (it\u2019s called with go), so this\navoids deadlock, but it still blocks the main thread until the WriteTo\nfunction finishes. Recall that WriteTo runs the jq subprocess, so effectively\nthis runs each jq process on the main thread every time the filter input\nchanges.\n\nThis change was added (by me) over 3 years ago, because it (apparently) solved\nanother issue with race conditions in the prior implementation (no doubt that\nit did: when everything is on the main thread there are no race conditions).\n\nThe second important problem is in the WriteTo implementation above. This\nfunction uses the CombinedOutput function to get both stdout and stderr from\nthe jq process. This function writes the process\u2019s stdout and stderr into a\ntemporary buffer. After the jq process completes, that buffer is then written\nto the output text view.\n\nThis is slow, because we first wait for the process to write to the buffer,\nand only when that is finished do we start writing to the text view. This is\nthe cause of ijq\u2019s long startup time (visible in the first video at the top of\nthe post). Instead, we should be able to pipe the output from the subprocess\ndirectly to the text view so that the output is visible immediately.\n\n## Solutions\n\nFixing the first problem was straightforward: drop QueueUpdateDraw, run\nWriteTo in a separate thread, and use a ChangedFunc on the output view to\nredraw the application when the output view changes. With this change ijq\nimmediately becomes more responsive. User input is never blocked on the jq\nprocess.\n\nThis is suboptimal though, because a new jq process is spawned on every input\nchange. We should be able to cancel old processes when the input changes, and\nif multiple input change callbacks are fired before starting a new jq process,\nwe should only ever use the most recent input. Go\u2019s native channels are almost\na good fit here, but what we want is a LIFO (last-in, first-out), whereas Go\u2019s\nchannels are FIFO (first-in, first-out): every input written into a channel is\nread out in the same order. On the receiving end of the channel, there\u2019s no\n(easy) way to only read the most recent one. So instead of channels, we use a\nregular old mutex and condition variable. The mutex guards changes to the\nDocument object and a pending variable. When the filter input changes, the\nDocument object is updated, pending is set to true, any existing jq processes\nare cancelled, and the condition variable is signalled. A separate thread\nwaits for pending to become true and when it does, makes a copy of the\nDocument object before starting a new jq process.\n\nFixing the second problem was a bit trickier. Go\u2019s Cmd object can use any\nobject that implements the io.Writer interface in its Stdout and Stderr\nfields. Instead of writing to a temporary buffer, waiting for the process to\ncomplete, and then copying to the text view, we can simply write to the text\nview immediately! This change, combined with removing another incorrect use of\nQueueUpdateDraw in the app startup, solves the initial startup time issue.\n\nBut sometimes fixing one issue introduces another: in this case, when the jq\nprocess writes directly to the text view, we have to clear the text view\nbefore running the jq process (or else each successive process will append to\nthe previous process\u2019s output). But when we do this, the output view is\ncleared every time the user updates the filter input. We only want the output\nview to change when there is actually new visible output. This ensures that if\nthe user types in an invalid filter, the last output is still visible. This is\nan important property for an interactive jq tool where experimenting with the\nright filter is a large part of the value proposition.\n\nTo address this, we make a new type that wraps a TextView and tracks its\n\u201cdirty\u201d state. When the text view is dirty, we call the view\u2019s Clear() method\nbefore it is written (and then reset the dirty state).\n\n    \n    \n    type pane struct { tv *tview.TextView dirty bool } func (pane *pane) Write(p []byte) (n int, err error) { if pane.dirty { pane.tv.Clear() pane.dirty = false } return pane.tv.Write(p) }\n\nThe dirty state is then set before the jq process is invoked.\n\nWith these changes, ijq\u2019s performance problems are solved!\n\n## Conclusion\n\nI\u2019m not sure there is a lesson here other than re-learning that concurrency\n(and UIs) are hard, even in languages like Go which give you great tools to\nmanage concurrency. Ultimately, for me, it was a learning experience and a fun\nexcuse to hack on a side project. If you are an ijq user, I hope this makes\nyour user experience even better!\n\nLast modified on April 13, 2024\n\nThis work by Gregory Anders is licensed under CC BY-SA 4.0\n\n", "frontpage": false}
