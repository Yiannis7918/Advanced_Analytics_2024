{"aid": "40099146", "title": "Hexagonal Architecture in Python", "url": "https://blog.szymonmiks.pl/p/hexagonal-architecture-in-python/", "domain": "blog.szymonmiks.pl", "votes": 1, "user": "lenerdenator", "posted_at": "2024-04-20 17:42:56", "comments": 0, "source_title": "Hexagonal architecture in Python", "source_text": "Hexagonal architecture in Python\n\n\ud83d\udc0d\n\n# Szymon Miks - personal blog\n\n## Software Developer - Pythonista\n\n  1. Home\n  2. About\n  3. Books on my bookshelf\n  4. Podcasts\n  5. My knowledge sources\n  6. Interesting projects\n  7. Interesting tools\n  8. Archives\n  9. Search\n\n  10. Dark Mode\n\nPython Software Development Architecture\n\n## Hexagonal architecture in Python\n\n### Let me show you a hands-on example using our lovely Python language\n(FastAPI example included).\n\nOct 07, 2022\n\n6 minute read\n\n## Intro\n\nHexagonal architecture is one of the styles of application architecture that\nyou can use in your project. In today\u2019s blog post I would like to show you how\nyou can build your application using a hexagonal architecture with Python.\n\nInstead of focusing on the theoretical side (there are already enough of these\narticles on the web), we will take a more practical approach.\n\n## History\n\nOriginally hexagonal architecture was invented by Alistair Cockburn in 2005.\nThen around 2008, Jeffrey Palermo invented something very similar called onion\narchitecture. And then, as the last one, around 2011, Robert C. Martin came up\nwith his idea called clean architecture.\n\nSo if you hear the following terms:\n\n  * hexagonal architecture (aka. ports and adapters)\n  * onion architecture\n  * clean architecture\n  * screaming architecture\n\nIt\u2019s generally about the same idea, with some minor variations.\n\n## Quick intro\n\nPlease consider the following diagram:\n\nhexagonal-architecture-diagram\n\nLet me quickly introduce you to all the concepts included in the diagram. The\nbest explanation will be a code example where all these concepts are applied\nsimultaneously. For the example please have a look at the section below.\n\nGenerally speaking, ports are responsible for communication with the outside\nworld. Usually, they are implemented as interfaces, whereas adapters are\nconcrete implementations of our ports.\n\ninput port (aka. driver port or primary port) - exposes the application\nfeatures to the outside world. It\u2019s an entry point to our business logic.\n\ninput adapter - is a concrete implementation of how we want to enter our\napplication, for example via REST endpoint etc.\n\noutput port (aka. driven or secondary) - it is used to interact with outbound\nthings, for example, reading/writing data from/to a database.\n\noutput adapter - it is the concrete implementation of the above. For example,\nimplementation of communication with a specific database, e.g. MySQL.\n\nuse case (aka. application layer) - this layer answers the question \u201cwhat to\ndo\u201d. It controls the flow.\n\ndomain - in contrast to the above layer, this one answers the question \u201chow to\ndo\u201d. Here our business logic lives. This is the place where our application\nmakes money. This is the heart of our app.\n\nAs you can see on the diagram the use case layer knows what to do but is not\naware of how to do it. The use case layer delegates it to the domain layer.\nBecause of this, the domain layer is not aware of any ports or adapters. The\ndomain layer should not have any dependencies to the layers above it.\n\n## Example\n\nFor the purpose of this article I created a separate project on my GitHub. You\ncan find it here: https://github.com/szymon6927/hexagonal-architecture-python\n\nThis project is a simplified gym management software. We have clients, gym\nclasses and gym passes.\n\nThe project consists of four modules:\n\nproject-structure\n\n  * building_blocks - contains all utilities used across different modules\n  * clients - module responsible for clients. There is no complicated business logic here, but we have a lot of integrations that\u2019s why we use hexagonal architecture here\n  * gym_classes - simple CRUD responsible for management of gym classes. No business logic here, therefore there is no need to use hexagonal architecture here\n  * gym_passes - management of gym passes, which is the core of our business. This is where our business is making money\n\nproject-structure\n\nThere is no fancy structure for the gym_classes module. The answer is simple -\nthere is no need for that. We should use hexagonal architecture only where\nit\u2019s really needed.\n\nI developed this example specifically to show you that using hexagonal\narchitecture doesn\u2019t mean using it everywhere. Not every module has to have\nit.\n\nThis is also visible in tests.\n\ntests\n\nThere are no unit tests for the gym classes module because unit tests for it\nwould make no sense. All we do here are CRUD operations.\n\nWhen it comes to modules that were built using hexagonal architecture. They\nfollow such structure:\n\n  * application - contains our use cases together with DTOs and other classes that are responsible for coordinating the business processes\n  * domain - contains all domain objects like entities, value objects, etc. The objects there are not anemic, but they follow the principle of the rich domain model which means that we encapsulate data and behaviours together. You can check it by looking at src/gym_passes/domain/gym_pass.py\n  * infrastructure - contains output adapters, which are objects responsible for communication with external world, for example database\n  * bootstrap.py - contains the definition of our DI container. I wrote a separate article about the DI. If you have not heard about a technique called \u201cdependency injection\u201d you can read about it here\n  * controllers.py - definition of our REST endpoints\n  * facade.py (optional) - if your module needs to expose some behaviours for other modules then I recommend using a facade to achieve it. It is the public API of your module\n\n## Pros and Cons\n\nPros:\n\n  * testability - you can test your domain logic without any dependencies\n  * ability to postpone some decisions - when your project starts you don\u2019t have to know which database you will use. You can make this decision later on\n  * it supports easy technology change - you can change your REST adapter to a gRPC adapter without touching your business logic/core domain\n\nCons:\n\n  * if your project has multiple adapters it means that you will have more integration tests. This may impact the total execution time of your test suite\n  * it\u2019s harder to navigate through the project with such architecture. You will mostly encounter interfaces instead of real implementation\n  * additional effort is needed to configure the adapters. You need to have some mechanism that will specify: this adapter is on prod env, this on local env, etc\n\n## When to use / when not to use\n\nIf you are wondering about cases to which hexagonal architecture suits the\nbest, I prepared a simple heuristic for you.\n\nUse if:\n\n  * your project has complex and frequently changing business domain\n  * you need to implement the core domain of your application\n\nDon\u2019t use if:\n\n  * your project or module has a CRUD-like complexity - in such a scenario, there will be no benefits of hexagonal architecture, and it will be overengineering\n\n## Additional resources\n\n  * Alistair Cockburn\u2019s original paper on Hexagonal Architecture\n  * Robert C. Martin\u2019s book \u201cClean Architecture\u201d\n  * Implementing the Clean Architecture\n\n## Summary\n\nI hope you enjoyed it. As with everything in our industry, hexagonal\narchitecture is not a silver bullet. It will not solve all the problems for\nyou, but it\u2019s a great way to improve things in your project especially when it\ncomes to testability or the possibility to postpone some decisions. If applied\ncorrectly it may improve your project and make your life easier.\n\nLet me know what you think, I would love to hear your opinion. Also, if you\nhave experience with hexagonal architecture let me know what your\nthoughts/feelings are about it.\n\npython software development architecture hexagonal architecture clean\narchitecture ports and adapters\n\n## Related content\n\n## Don't put your business logic in the controllers\n\n## How to implement CommandBus in Python\n\n## Services vs Command Handlers\n\n## Domain model with SQLAlchemy\n\n## The outbox pattern in Python\n\n\u00a9 2021 - 2024 Szymon Miks - personal blog\u00a9 All rights reserved Built with Hugo\nTheme Stack designed by Jimmy\n\n", "frontpage": false}
