{"aid": "40078343", "title": "Match Operator Guards in Elixir", "url": "https://blog.brettbeatty.com/2024_03_20_match_operator_guards.html", "domain": "brettbeatty.com", "votes": 1, "user": "clessg", "posted_at": "2024-04-18 17:01:11", "comments": 0, "source_title": "Match Operator Guards \u2014 Brett's Dev Blog v2024.3.21", "source_text": "Match Operator Guards \u2014 Brett's Dev Blog v2024.3.21\n\n# Match Operator Guards\n\n## Context\n\nOne of my favorite things about Elixir is pattern matching, and guards are a\npowerful component of that. However, the simplest pattern matching mechanism,\nthe match operator (=), does not allow for guards.\n\n    \n    \n    {:ok, x} when is_integer(x) = {:ok, \"not an integer\"}\n    \n    \n    error: undefined function when/2 (there is no such import)\n\nIn this experiment I will attempt to introduce guard clauses to the match\noperator. I was also talking to a friend today about quoted expression woes,\nso I will attempt to talk some about metaprogramming and how I approach such\nproblems.\n\n## Goal\n\nThe match operator attempts to pair the match on the left of the operator with\nthe value on the right. If the match succeeds, variables are bound as needed.\n\n    \n    \n    {:ok, x} = {:ok, \"not an integer\"} x\n    \n    \n    \"not an integer\"\n\nIf the match fails, a MatchError is raised.\n\n    \n    \n    try do {:ok, _x} = :error rescue error -> Exception.format(:error, error) end\n    \n    \n    \"** (MatchError) no match of right hand side value: :error\"\n\nMy goal for this experiment is to have matching fail when guards are not\nsatisfied.\n\n    \n    \n    {:ok, x} when is_integer(x) = {:ok, \"not an integer\"} #=> ** (MatchError) no match of right hand side value: {:ok, \"not an integer\"}\n\nThe match operator should still work as usual when guards return true.\n\n    \n    \n    {:ok, x} when is_integer(x) = {:ok, 23} #=> {:ok, 23} x #=> 23\n\nIt should also fail as usual when the pattern doesn't match at all.\n\n    \n    \n    {:ok, x} when is_integer(x) = :error #=> ** (MatchError) no match of right hand side value: :error\n\n## Plan\n\nOften when I want to experiment with tweaking Elixir syntax I check for a\nfunction or macro in Kernel I can replace with my own version via import. The\nmatch operator, however, is Kernel.SpecialForms.=/2. Functions in\nKernel.SpecialForms don't actually get called--the compiler replaces calls to\nthem. That prevents me from making my own =/2 function and importing it\ninstead of the built-in operator.\n\nI thought my experiment was foiled, but did you notice the error logged by the\ncompiler when I tried using a guard clause with the match operator?\n\n    \n    \n    error: undefined function when/2 (there is no such import)\n\nIt thinks I'm calling a function named when/2. That's not a replaced special\nform in this context! This is a good time to check out the expression\nstructure using quote/2.\n\n    \n    \n    quote do {:ok, x} when is_integer(x) = {:ok, \"not an integer\"} end\n    \n    \n    {:when, [], [ {:ok, {:x, [], Elixir}}, {:=, [], [ {:is_integer, [context: Elixir, imports: [{1, Kernel}]], [{:x, [], Elixir}]}, {:ok, \"not an integer\"} ]} ]}\n\nI'll talk more about quoted expressions further down, but essentially that\nmeans my guarded match actually looks something more like this call under the\nhood.\n\n    \n    \n    when({:ok, x}, is_integer(x) = {:ok, \"not an integer\"})\n\nThe operator precedence there is not what I expected (it makes sense, though,\nwhen I think about using the match operator within another match that may be\nguarded), but that works out in my favor. I can define and import a when/2\nmacro that transforms the code in those parts to a form that actually works!\n\nWhat does that transformed code look like? I'm not aware of a way to have the\nmatch operator fail on a guard--that's what I'm trying to change--but guards\nwork fine in other match contexts. The simplest way to go about things is\nprobably just to transform that code into a match on a case/2 expression like\nthis:\n\n    \n    \n    {:ok, x} = case {:ok, \"not an integer\"} do {:ok, x} = term when is_integer(x) -> term term -> raise MatchError, term: term end\n\nThat seems like a good plan, so now I just need a when/2 macro that performs\nthat transformation.\n\n## Macro Introspection Utility\n\nMacros are special functions that instead of taking and returning values at\nruntime take and return code at compile time.\n\nWhen working with quoted expressions, I often find it helpful to use\nMacro.to_string/1 and IO.puts/1 to better understand the code I'm\nmanipulating. Usually I inline these in my macro to print the returned code.\n\n    \n    \n    quote do # macro implementation end # remove when I'm satisfied with macro |> tap(fn quoted -> quoted |> Macro.to_string() |> IO.puts())\n\nBut for this experiment I'm repeating this enough I'll create a macro that\ntakes an implementation module and a block, imports the implementation module,\nprints what the block expands to, runs it in a try/rescue block since I want\nthe macro to raise a MatchError, and prints any variables bound in the block.\n\n    \n    \n    defmodule Introspection do defmacro introspect(module, do: block) do print_block(__CALLER__, module, block) quote do try do import unquote(module) binding_before = binding() result = unquote(block) binding_after = binding() IO.inspect(binding_after -- binding_before, label: \"binding\") result rescue error -> :error |> Exception.format(error) |> IO.puts() end end end defp print_block(env, module, block) do module = Macro.expand(module, env) block |> Macro.prewalk(&import_and_expand(module, &1)) |> Macro.expand(env) |> Macro.to_string() |> IO.puts() end defp import_and_expand(module, quoted) do with {:when, context, args} <- quoted do context |> Keyword.put(:imports, [{2, module}]) |> Keyword.put_new(:context, __MODULE__) |> then(&{:when, &1, args}) end end end\n    \n    \n    {:module, Introspection, <<70, 79, 82, 49, 0, 0, 13, ...>>, {:import_and_expand, 2}}\n\nThe first iteration of my macro will just return :ok (atoms are valid quoted\nexpressions of themselves). There's a fun hurdle around defining a function\nnamed when/2. The parser tries interpreting the call as a guard to defining\nthe left value as a function, so I have to include a guard to signal that the\ncall to when/2 is actually a function I want defined.\n\n    \n    \n    defmodule When.OK do defmacro (_left when _right) when true do :ok end end\n    \n    \n    {:module, When.OK, <<70, 79, 82, 49, 0, 0, 6, ...>>, {:when, 2}}\n\nIf I use that macro, it generates the code :ok (which prints and binds no\nvariables).\n\n    \n    \n    import Introspection introspect When.OK do {:ok, x} when is_integer(x) = {:ok, \"not an integer\"} end\n    \n    \n    :ok binding: []\n    \n    \n    :ok\n\nAt its most basic, calls to when/2 will be in the form left when {:=, _meta,\n[guard, right]}. Using quote/1 and unquote/1, I can structure these pieces in\nthe target form.\n\n    \n    \n    defmodule When.Basic do defmacro (left when {:=, _meta, [guard, right]}) when true do quote do unquote(left) = case unquote(right) do unquote(left) = term when unquote(guard) -> term term -> raise MatchError, term: term end end end end\n    \n    \n    {:module, When.Basic, <<70, 79, 82, 49, 0, 0, 8, ...>>, {:when, 2}}\n\nIf I try the new version of the macro, it prints the desired case/2 block and\nin this instance raises the desired exception.\n\n    \n    \n    introspect When.Basic do {:ok, x} when is_integer(x) = {:ok, \"not an integer\"} end\n    \n    \n    {:ok, x} = case {:ok, \"not an integer\"} do {:ok, x} = term when is_integer(x) -> term term -> raise MatchError, term: term end ** (MatchError) no match of right hand side value: {:ok, \"not an integer\"}\n    \n    \n    :ok\n\nIf the guard passes, however, the match succeeds and binds variables as\nexpected.\n\n    \n    \n    introspect When.Basic do {:ok, x} when is_integer(x) = {:ok, 23} end\n    \n    \n    {:ok, x} = case {:ok, 23} do {:ok, x} = term when is_integer(x) -> term term -> raise MatchError, term: term end binding: [x: 23]\n    \n    \n    {:ok, 23}\n\n## Multiple Guards\n\nMatches can use when more than once, so I will want to support that too.\n\nIn the source quoted expression, left will be the first argument in the\ntopmost when call, right will be the second argument in the = call, which will\nbe the second argument in the deepest when call.\n\n    \n    \n    quote do left when a when b when c = right end\n    \n    \n    {:when, [], [ {:left, [], Elixir}, {:when, [], [ {:a, [], Elixir}, {:when, [], [{:b, [], Elixir}, {:=, [], [{:c, [], Elixir}, {:right, [], Elixir}]}]} ]} ]}\n\nThe desired quoted expression looks much the same, a series of when calls\nwhere the first argument is a guard expression (except for the topmost where\nthe first argument is left). The difference is that c = right is replaced with\nc.\n\n    \n    \n    [{:->, [], [[guards], _term]}] = quote do left when a when b when c -> term end guards\n    \n    \n    {:when, [], [ {:left, [], Elixir}, {:when, [], [{:a, [], Elixir}, {:when, [], [{:b, [], Elixir}, {:c, [], Elixir}]}]} ]}\n\nI will want to yank right out of that deepest level and pass it as the first\nargument to case/2. This seems like a great case for recursion. I want a\nfunction that walks through the when sequence:\n\n  * If call is a when, make a recursive call on its second argument to get an extracted right and an updated guard chain. Return when call with first guard and updated guard chain.\n  * If call is =, return right and guard.\n\nOnly the outermost when will call my when/2 macro. The others will be given to\ncase/2 and treated as special forms.\n\n    \n    \n    defmodule When.MultiGuard do defmacro (left when guards_and_right) when true do {guards, right} = parse_guards_and_right(guards_and_right) quote do unquote(left) = case unquote(right) do term = unquote(left) when unquote(guards) -> term term -> raise MatchError, term: term end end end defp parse_guards_and_right(guards_and_right) defp parse_guards_and_right({:when, meta, [guard, guards_and_right]}) do {guards, right} = parse_guards_and_right(guards_and_right) {{:when, meta, [guard, guards]}, right} end defp parse_guards_and_right({:=, _meta, [guard, right]}) do {guard, right} end end\n    \n    \n    {:module, When.MultiGuard, <<70, 79, 82, 49, 0, 0, 9, ...>>, {:parse_guards_and_right, 1}}\n\nThis new macro supports multiple guards, which allow a match as long as one\nguard succeeds.\n\n    \n    \n    introspect When.MultiGuard do {:ok, x} when is_integer(x) when is_binary(x) = {:ok, \"some string\"} end\n    \n    \n    {:ok, x} = case {:ok, \"some string\"} do term = {:ok, x} when is_integer(x) when is_binary(x) -> term term -> raise MatchError, term: term end binding: [x: \"some string\"]\n    \n    \n    {:ok, \"some string\"}\n\nMatching still fails if none of the guards pass.\n\n    \n    \n    introspect When.MultiGuard do {:ok, x} when is_integer(x) when is_binary(x) = {:ok, []} end\n    \n    \n    {:ok, x} = case {:ok, []} do term = {:ok, x} when is_integer(x) when is_binary(x) -> term term -> raise MatchError, term: term end ** (MatchError) no match of right hand side value: {:ok, []}\n    \n    \n    :ok\n\nMatching also continues to fail for match errors beyond the guards.\n\n    \n    \n    introspect When.MultiGuard do {:ok, x} when is_integer(x) when is_binary(x) = :error end\n    \n    \n    {:ok, x} = case :error do term = {:ok, x} when is_integer(x) when is_binary(x) -> term term -> raise MatchError, term: term end ** (MatchError) no match of right hand side value: :error\n    \n    \n    :ok\n\n## Unused Variables\n\nThe left match in the macro is used twice: once in the case/2 match and once\nmatching on the result of case/2. Some bound variables may only be used in one\nor the other, and the compiler will try and warn about unused variables. The\nintrospect/2 macro checks the bindings from the context outside of case, so I\nhaven't been seeing these warnings yet. If the match contains variables not\nused in the guard, however, I'll get a warning because the variables are bound\ninside case/2 but not used in that context.\n\n    \n    \n    introspect When.MultiGuard do result = {:ok, x} when is_integer(x) = {:ok, 19} end\n    \n    \n    (result = {:ok, x}) = case {:ok, 19} do term = result = {:ok, x} when is_integer(x) -> term term -> raise MatchError, term: term end warning: variable \"result\" is unused (if the variable is not meant to be used, prefix it with an underscore) binding: [result: {:ok, 19}, x: 19]\n    \n    \n    {:ok, 19}\n\nIf I wanted to get really smart about things, I would traverse the guards to\ncreate a list of variables used there. Then for the match inside case/2 I\nwould traverse left and replace any variables not used in guards with _. For\nthe match outside case/2, I would mark the variables used in guards with\ngenerated: true, which suppresses warnings. Then any variables not used in\nguards would still need used in the context outside case/2 to avoid warnings.\n\nFor simplicity, though, I'll just tag every part of the quoted expression in\nleft with generated: true.\n\n    \n    \n    defmodule When.UnusedVars do defmacro (left when guards_and_right) when true do left = Macro.prewalk(left, &tag_generated/1) {guards, right} = parse_guards_and_right(guards_and_right) quote do unquote(left) = case unquote(right) do term = unquote(left) when unquote(guards) -> term term -> raise MatchError, term: term end end end defp tag_generated(quoted) do with {name, meta, args_or_context} <- quoted do {name, Keyword.put(meta, :generated, true), args_or_context} end end defp parse_guards_and_right(guards_and_right) defp parse_guards_and_right({:when, meta, [guard, guards_and_right]}) do {guards, right} = parse_guards_and_right(guards_and_right) {{:when, meta, [guard, guards]}, right} end defp parse_guards_and_right({:=, _meta, [guard, right]}) do {guard, right} end end\n    \n    \n    {:module, When.UnusedVars, <<70, 79, 82, 49, 0, 0, 11, ...>>, {:parse_guards_and_right, 1}}\n\nNow variables can go unused.\n\n    \n    \n    introspect When.UnusedVars do result = {:ok, x} when is_integer(x) = {:ok, 19} end\n    \n    \n    (result = {:ok, x}) = case {:ok, 19} do term = result = {:ok, x} when is_integer(x) -> term term -> raise MatchError, term: term end binding: [result: {:ok, 19}, x: 19]\n    \n    \n    {:ok, 19}\n\n## Conclusion\n\nMy goal was to add support for guard clauses to the match operator, with\neverything working as one might expect.\n\nThe latest version of when/2 can match on values when guards are satisfied.\n\n    \n    \n    alias When.UnusedVars, as: When introspect When do {:ok, x} when is_integer(x) = {:ok, 15} end\n    \n    \n    {:ok, x} = case {:ok, 15} do term = {:ok, x} when is_integer(x) -> term term -> raise MatchError, term: term end binding: [x: 15]\n    \n    \n    {:ok, 15}\n\nIt fails to match when the guards do not pass.\n\n    \n    \n    introspect When do {:ok, x} when is_integer(x) = {:ok, \"not an integer\"} end\n    \n    \n    {:ok, x} = case {:ok, \"not an integer\"} do term = {:ok, x} when is_integer(x) -> term term -> raise MatchError, term: term end ** (MatchError) no match of right hand side value: {:ok, \"not an integer\"}\n    \n    \n    :ok\n\nIt also rejects values that would fail a regular match.\n\n    \n    \n    introspect When do {:ok, x} when is_integer(x) = :error end\n    \n    \n    {:ok, x} = case :error do term = {:ok, x} when is_integer(x) -> term term -> raise MatchError, term: term end ** (MatchError) no match of right hand side value: :error\n    \n    \n    :ok\n\nIn most cases when/2 seems to work as expected, but there could be\nconsequences to replacing the match operator with a case expression,\nespecially in macros expecting the match operator.\n\nExUnit.Assertions.assert/1, for example, prints both sides of a failed match\nfor an improved experience. Guarded matches using when/2 instead raise\nMatchError on the right side of the match instead of failing the match itself,\nso they won't get the improved experience.\n\n    \n    \n    ExUnit.start(autorun: false, seed: 0) defmodule WhenTest do use ExUnit.Case, async: true import When test \"match failure without guard\" do assert {:ok, _x} = :error end test \"match failure with guard\" do assert {:ok, x} when is_integer(x) = :error end end ExUnit.run()\n    \n    \n    1) test match failure without guard (WhenTest) match (=) failed code: assert {:ok, _x} = :error left: {:ok, _x} right: :error 2) test match failure with guard (WhenTest) ** (MatchError) no match of right hand side value: :error Finished in 0.00 seconds (0.00s async, 0.00s sync) 2 tests, 2 failures Randomized with seed 0\n    \n    \n    %{total: 2, failures: 2, excluded: 0, skipped: 0}\n\nMy when/2 macro could be improved by having the case/2 only raise MatchError\nif left matches but doesn't pass the guards. Then any matching that could\nstill be done by the match operator would be.\n\nFor testing, specifically, I could also make an assert/2 macro that wraps\nExUnit.Assertions.assert/2 and breaks guarded matches into multiple asserts\n(assert {:ok, x} = {:ok, \"not an integer\"}, assert is_integer(x)), but you\nwould have to do something similar anyplace a macro expected a match\nspecifically.\n\nI had also intended to show some of my process for approaching difficult\nquoted expressions, but the writeup isn't exactly chronological. I made plenty\nof mistakes along the way and amended the livebook as needed.\n\nOverall, though, I'm pretty happy with the macro. It's fairly simple, but (in\nmy opinion) it feels like a natural part of the language.\n\nNext Page \u2192 Alternate Multi-Clause Function Syntax\n\nBuilt using ExDoc (v0.31.2) for the Elixir programming language\n\n", "frontpage": false}
