{"aid": "40033354", "title": "Fastest way to get IPv4 address from string", "url": "https://stackoverflow.com/questions/31679341/fastest-way-to-get-ipv4-address-from-string", "domain": "stackoverflow.com", "votes": 14, "user": "melenaboija", "posted_at": "2024-04-14 18:47:29", "comments": 3, "source_title": "Fastest way to get IPv4 address from string", "source_text": "c++ - Fastest way to get IPv4 address from string - Stack Overflow\n\nStack Overflow\n\n  1. About\n  2. Products\n  3. For Teams\n\n  1. Stack Overflow Public questions & answers\n  2. Stack Overflow for Teams Where developers & technologists share private knowledge with coworkers\n  3. Talent Build your employer brand\n  4. Advertising Reach developers & technologists worldwide\n  5. Labs The future of collective knowledge sharing\n  6. About the company\n\n##### CollectivesTM on Stack Overflow\n\nFind centralized, trusted content and collaborate around the technologies you\nuse most.\n\nLearn more about Collectives\n\nTeams\n\nQ&A for work\n\nConnect and share knowledge within a single location that is structured and\neasy to search.\n\nLearn more about Teams\n\nGet early access and see previews of new features.\n\nLearn more about Labs\n\n# Fastest way to get IPv4 address from string\n\nAsk Question\n\nAsked 8 years, 8 months ago\n\nModified 8 years, 8 months ago\n\nViewed 7k times\n\nThis question shows research effort; it is useful and clear\n\n18\n\nSave this question.\n\nShow activity on this post.\n\nI have the following code which is about 7 times faster than inet_addr . I was\nwondering if there is a way to improve this to make it even faster or if a\nfaster alternative exists.\n\nThis code requires that a valid null terminated IPv4 address is supplied with\nno whitespace, which in my case is always the way, so I optimized for that\ncase. Usually you would have more error checking, but if there is a way to\nmake the following even faster or a faster alternative exists I would really\nappreciate it.\n\n    \n    \n    UINT32 GetIP(const char *p) { UINT32 dwIP=0,dwIP_Part=0; while(true) { if(p[0] == 0) { dwIP = (dwIP << 8) | dwIP_Part; break; } if(p[0]=='.') { dwIP = (dwIP << 8) | dwIP_Part; dwIP_Part = 0; p++; } dwIP_Part = (dwIP_Part*10)+(p[0]-'0'); p++; } return dwIP; }\n\n  * c++\n  * c\n  * string\n  * optimization\n  * ip-address\n\nShare\n\nCC BY-SA 3.0\n\nFollow this question to receive notifications\n\nedited Jul 28, 2015 at 14:59\n\nHarry\n\nasked Jul 28, 2015 at 14:30\n\nHarryHarry\n\n23133 silver badges88 bronze badges\n\n17\n\n  * 9\n\nI think this is better suited to codereview.stackexchange.com\n\n\u2013 M.M\n\nJul 28, 2015 at 14:38\n\n  * 4\n\nWhy? I want to know what the fastest way to get an IP address from a string\nis.\n\n\u2013 Harry\n\nJul 28, 2015 at 14:41\n\n  * 6\n\nYou also should note that UINT32 might be not suitable for an IP address,\nwithout adjusting endianess to network byte order.\n\n\u2013 \u03c0\u03ac\u03bd\u03c4\u03b1 \u1fe5\u03b5\u1fd6\n\nJul 28, 2015 at 14:43\n\n  * 9\n\n@Harry CodeReview specializes in reviewing working code (your code works), and\nthey can suggest algorithmic improvements. That's not to say speed hacks\naren't on-topic here.\n\n\u2013 Iwillnotexist Idonotexist\n\nJul 28, 2015 at 14:43\n\n  * 3\n\n@Iwillnotexist Idonotexist I guess if my code is indeed the fastest in the\nworld currently it might be worth going to the codereview to see if it can be\nfaster? ;) I have seen faster integer conversion questions put on here and I\nthink this is related to those types of questions. I couldn't find anything\nelse myself on this topic and it may help others in the future if there are no\nother alternatives.\n\n\u2013 Harry\n\nJul 28, 2015 at 14:49\n\n| Show 12 more comments\n\n## 2 Answers 2\n\nReset to default\n\nThis answer is useful\n\n30\n\nSave this answer.\n\nShow activity on this post.\n\nSince we are speaking about maximizing throughput of IP address parsing, I\nsuggest using a vectorized solution.\n\nHere is x86-specific fast solution (needs SSE4.1, or at least SSSE3 for poor):\n\n    \n    \n    __m128i shuffleTable[65536]; //can be reduced 256x times, see @IwillnotexistIdonotexist UINT32 MyGetIP(const char *str) { __m128i input = _mm_lddqu_si128((const __m128i*)str); //\"192.167.1.3\" input = _mm_sub_epi8(input, _mm_set1_epi8('0')); //1 9 2 254 1 6 7 254 1 254 3 208 245 0 8 40 __m128i cmp = input; //...X...X.X.XX... (signs) UINT32 mask = _mm_movemask_epi8(cmp); //6792 - magic index __m128i shuf = shuffleTable[mask]; //10 -1 -1 -1 8 -1 -1 -1 6 5 4 -1 2 1 0 -1 __m128i arr = _mm_shuffle_epi8(input, shuf); //3 0 0 0 | 1 0 0 0 | 7 6 1 0 | 2 9 1 0 __m128i coeffs = _mm_set_epi8(0, 100, 10, 1, 0, 100, 10, 1, 0, 100, 10, 1, 0, 100, 10, 1); __m128i prod = _mm_maddubs_epi16(coeffs, arr); //3 0 | 1 0 | 67 100 | 92 100 prod = _mm_hadd_epi16(prod, prod); //3 | 1 | 167 | 192 | ? | ? | ? | ? __m128i imm = _mm_set_epi8(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, 4, 2, 0); prod = _mm_shuffle_epi8(prod, imm); //3 1 167 192 0 0 0 0 0 0 0 0 0 0 0 0 return _mm_extract_epi32(prod, 0); // return (UINT32(_mm_extract_epi16(prod, 1)) << 16) + UINT32(_mm_extract_epi16(prod, 0)); //no SSE 4.1 }\n\nAnd here is the required precalculation for shuffleTable:\n\n    \n    \n    void MyInit() { memset(shuffleTable, -1, sizeof(shuffleTable)); int len[4]; for (len[0] = 1; len[0] <= 3; len[0]++) for (len[1] = 1; len[1] <= 3; len[1]++) for (len[2] = 1; len[2] <= 3; len[2]++) for (len[3] = 1; len[3] <= 3; len[3]++) { int slen = len[0] + len[1] + len[2] + len[3] + 4; int rem = 16 - slen; for (int rmask = 0; rmask < 1<<rem; rmask++) { // { int rmask = (1<<rem)-1; //note: only maximal rmask is possible if strings are zero-padded int mask = 0; char shuf[16] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}; int pos = 0; for (int i = 0; i < 4; i++) { for (int j = 0; j < len[i]; j++) { shuf[(3-i) * 4 + (len[i]-1-j)] = pos; pos++; } mask ^= (1<<pos); pos++; } mask ^= (rmask<<slen); _mm_store_si128(&shuffleTable[mask], _mm_loadu_si128((__m128i*)shuf)); } } }\n\nFull code with testing is avaliable here. On Ivy Bridge processor it prints:\n\n    \n    \n    C0A70103 Time = 0.406 (1556701184) Time = 3.133 (1556701184)\n\nIt means that the suggested solution is 7.8 times faster in terms of\nthroughput than the code by OP. It processes 336 millions of addresses per\nsecond (single core of 3.4 Ghz).\n\nNow I'll try to explain how it works. Note that on each line of the listing\nyou can see contents of the value just computed. All the arrays are printed in\nlittle-endian order (though set intrinsics use big-endian).\n\nFirst of all, we load 16 bytes from unaligned address by lddqu instruction.\nNote that in 64-bit mode memory is allocated by 16-byte chunks, so this works\nwell automatically. On 32-bit it may theoretically cause issues with out of\nrange access. Though I do not believe that it really can. The subsequent code\nwould work properly regardless of the values in the after-the-end bytes.\nAnyway, you'd better ensure that each IP address takes at least 16 bytes of\nstorage.\n\nThen we subtract '0' from all the chars. After that '.' turns into -2, and\nzero turns into -48, all the digits remain nonnegative. Now we take bitmask of\nsigns of all the bytes with _mm_movemask_epi8.\n\nDepending on the value of this mask, we fetch a nontrivial 16-byte shuffling\nmask from lookup table shuffleTable. The table is quite large: 1Mb total. And\nit takes quite some time to precompute. However, it does not take precious\nspace in CPU cache, because only 81 elements from this table are really used.\nThat is because each part of IP address can be either one, two, three digits\nlong => hence 81 variants in total. Note that random trashy bytes after the\nend of the string may in principle cause increased memory footprint in the\nlookup table.\n\nEDIT: you can find a version modified by @IwillnotexistIdonotexist in\ncomments, which uses lookup table of only 4Kb size (it is a bit slower,\nthough).\n\nThe ingenious _mm_shuffle_epi8 intrinsic allows us to reorder the bytes with\nour shuffle mask. As a result XMM register contains four 4-byte blocks, each\nblock contains digits in little-endian order. We convert each block into a\n16-bit number by _mm_maddubs_epi16 followed by _mm_hadd_epi16. Then we reorder\nbytes of the register, so that the whole IP address occupies the lower 4\nbytes.\n\nFinally, we extract the lower 4 bytes from the XMM register to GP register. It\nis done with SSE4.1 intrinsic (_mm_extract_epi32). If you don't have it,\nreplace it with other line using _mm_extract_epi16, but it will run a bit\nslower.\n\nFinally, here is the generated assembly (MSVC2013), so that you can check that\nyour compiler does not generate anything suspicious:\n\n    \n    \n    lddqu xmm1, XMMWORD PTR [rcx] psubb xmm1, xmm6 pmovmskb ecx, xmm1 mov ecx, ecx //useless, see @PeterCordes and @IwillnotexistIdonotexist add rcx, rcx //can be removed, see @EvgenyKluev pshufb xmm1, XMMWORD PTR [r13+rcx*8] movdqa xmm0, xmm8 pmaddubsw xmm0, xmm1 phaddw xmm0, xmm0 pshufb xmm0, xmm7 pextrd eax, xmm0, 0\n\nP.S. If you are still reading it, be sure to check out comments =)\n\nShare\n\nCC BY-SA 3.0\n\nFollow this answer to receive notifications\n\nedited Jul 30, 2015 at 4:46\n\nanswered Jul 28, 2015 at 17:49\n\nstgatilovstgatilov\n\n5,4633232 silver badges5454 bronze badges\n\n42\n\n  * 3\n\n@PeterCordes The pmovmskb instruction is guaranteed to zero-fill the entire\nregister (r32 or r64) it's asked to blow out. Unfortunately, the\n_mm_movemask_epi8() and underlying (on GCC) __builtin_ia32_pmovmskb128()\nintrinsics both return int, whence the compiler's urge to use the pmovmskb\nr32, xmm form rather than the pmovmskb r64, xmm form that would have been\nprofitable. The compiler then feels the need to sign-extend, since the return\nvalue is nominally an int. I noticed that too and was trying to suppress it\nbut realized the problem is deep-rooted.\n\n\u2013 Iwillnotexist Idonotexist\n\nJul 28, 2015 at 20:44\n\n  * 2\n\n@Harry Must you absolutely make the table disappear, or can you afford to make\nit much smaller (say, 256 entries x 16 bytes/entry?) If so, stgatilov's code\ncan be modified to distill the 81 possible valid digit masks using a perfect\nhash. A secret trick of mine for hashing is to use the single SSE4.2\ninstruction CRC, which you can use with _mm_crc32_*(). For this usecase, find\na and n in mask = _mm_crc32_u16(0, mask << a) >> (32-n); such that you have\n2^n bins and none of the valid masks collide after hashing. You probably\nshould be able to get down to n=8 (256 entries).\n\n\u2013 Iwillnotexist Idonotexist\n\nJul 29, 2015 at 5:05\n\n  * 3\n\n@EvgenyKluev I was successful in crafting a 256-bin perfect hash variant of\nstgatilov's excellent start. You may view it here (Warning, uses a GCC aligned\nattribute). It is just over half as fast, but occupies 256x less space for the\nLUT.\n\n\u2013 Iwillnotexist Idonotexist\n\nJul 29, 2015 at 21:26\n\n  * 4\n\nGentlemen, I've just successfully removed the crc instruction by using a\ndifferent magic multiplication constant in my perfect hash. This new version\ntherefore does not even require SSE4.2, and is slightly faster. Currently, on\nmy i7-4700MQ processor, Time resources: stgatilov @ 0.465, myself @ 0.645 and\nHarry @ 2.996 seconds. Space resources: stgatilov @ 1MB, myself @ 4KB, Harry @\nnegligible. I'm therefore 40% slower but have 0.4% of the memory use, and my\nhash table load factor is 81/256 ~ 31.6% rather than 81/65536 ~ 0.12%.\n\n\u2013 Iwillnotexist Idonotexist\n\nJul 30, 2015 at 11:07\n\n  * 3\n\n@Harry: I didn't test it but I expect that if we completely replace lookup by\ncomputations, this will slow up the fastest algorithm by 2 to 3 times. Still\nit is likely to be much faster than your version because many computations are\ndone in parallel. Skylake architecture coming soon allows to vectorize lzcnt\ninstruction (with AVX512 instruction set) so almost all computations may be\ndone in parallel with it; but it is unlikely to outperform both approaches\nmentioned here.\n\n\u2013 Evgeny Kluev\n\nJul 30, 2015 at 12:28\n\n| Show 37 more comments\n\nThis answer is useful\n\n1\n\nSave this answer.\n\nShow activity on this post.\n\nAs for alternatives: this is similar to yours but with some error checking:\n\n    \n    \n    #include <iostream> #include <string> #include <cstdint> uint32_t getip(const std::string &sip) { uint32_t r=0, b, p=0, c=0; const char *s; s = sip.c_str(); while (*s) { r<<=8; b=0; while (*s&&((*s==' ')||(*s=='\\t'))) s++; while (*s) { if ((*s==' ')||(*s=='\\t')) { while (*s&&((*s==' ')||(*s=='\\t'))) s++; if (*s!='.') break; } if (*s=='.') { p++; s++; break; } if ((*s>='0')&&(*s<='9')) { b*=10; b+=(*s-'0'); s++; } } if ((b>255)||(*s=='.')) return 0; r+=b; c++; } return ((c==4)&&(p==3))?r:0; } void testip(const std::string &sip) { uint32_t nIP=0; nIP = getip(sip); std::cout << \"\\nsIP = \" << sip << \" --> \" << std::hex << nIP << \"\\n\"; } int main() { testip(\"192.167.1.3\"); testip(\"292.167.1.3\"); testip(\"192.267.1.3\"); testip(\"192.167.1000.3\"); testip(\"192.167.1.300\"); testip(\"192.167.1.\"); testip(\"192.167.1\"); testip(\"192.167..1\"); testip(\"192.167.1.3.\"); testip(\"192.1 67.1.3.\"); testip(\"192 . 167 . 1 . 3\"); testip(\" 192 . 167 . 1 . 3 \"); return 0; }\n\nShare\n\nCC BY-SA 3.0\n\nFollow this answer to receive notifications\n\nanswered Jul 29, 2015 at 10:01\n\nslashmaisslashmais\n\n7,08799 gold badges5555 silver badges8080 bronze badges\n\n2\n\n  * What speed did you get compared to my original?\n\n\u2013 Harry\n\nJul 30, 2015 at 11:23\n\n  * @Harry: I didn't do (don't have data for) specific bulk speed testing; would anyway only relate to the specific machine, but just running both with above data gives about same speed (meaningless here).\n\n\u2013 slashmais\n\nJul 31, 2015 at 7:20\n\nAdd a comment |\n\n##\n\nNot the answer you're looking for? Browse other questions tagged\n\n  * c++\n  * c\n  * string\n  * optimization\n  * ip-address\n\nor ask your own question.\n\n  * The Overflow Blog\n  * Climbing the GenAI decision tree\n\nsponsored post\n\n  * Diverting more backdoor disasters\n\n  * Featured on Meta\n  * New Focus Styles & Updated Styling for Button Groups\n\n  * Upcoming initiatives on Stack Overflow and across the Stack Exchange network\n\n  * Staging Ground is coming back and moving out of beta\n\n  * Temporary policy: Generative AI (e.g., ChatGPT) is banned\n\n  * Pausing the 1-rep voting experiment on Stack Overflow: reflecting on the...\n\n#### Linked\n\n30\n\nHow to implement atoi using SIMD?\n\n12\n\nCan I use SIMD for speeding up string manipulation?\n\n11\n\nWhere is VPERMB in AVX2?\n\n8\n\nsse/avx equivalent for neon vuzp\n\n5\n\nComparing 2 vectors in AVX/AVX2 (c)\n\n5\n\nWhat is the fastest way to count the number of nonzero entries in an __mm256\nvector?\n\n8\n\nefficient way to convert scatter indices into gather indices?\n\n4\n\nUnnecessary instructions generated for _mm_movemask_epi8 intrinsic in x64 mode\n\n5\n\nWhat is the fastest way to swap the bytes of an unaligned 64 bit value in\nmemory?\n\n3\n\nVectorizing indirect access through avx instructions\n\nSee more linked questions\n\n#### Related\n\n55\n\nHow do you validate that a string is a valid IPv4 address in C++?\n\n27\n\nDetermine if a string is a valid IPv4 address in C\n\n3\n\nhow to store and serach for an ipv4 ipaddress in c more efficiently\n\n4\n\nHow to convert IPv4-mapped-IPv6 address to IPv4 (string format)?\n\n1\n\nParsing and Comparing IP Addresses In C++\n\n3\n\nComparing strings containing IPv4 addresses in C\n\n9\n\nEfficient way to store IPv4/IPv6 addresses\n\n0\n\nIP address detection in string (C++)\n\n2\n\nWhat is the fastest way to convert unsigned char array to IP string\n\n2\n\nc: Convert ipv6 address to string at compile time\n\n#### Hot Network Questions\n\n  * We adopted a rescue dog that we are pretty sure was abused. After about a week hes started peeing on my daughter\n\n  * from a security standpoint why should unused software be deleted?\n\n  * Who has the right to examine a will?\n\n  * Can I completely omit \"of\" when speaking quickly?\n\n  * Why are the solar prominences visible during a total solar eclipse - orange? Is the sun orange?\n\n  * Practical implementation of Shor and other factoring algorithms\n\n  * What fauna can survive a permanently dark sky?\n\n  * Growing coffee indoors from cherries; to dry or not to dry?\n\n  * A version of Hilbert's Nullstellensatz for real zeros\n\n  * Toilet rocks regardless how tight floor bolts are turned\n\n  * Replicate a \"thermometer\" with color gradient\n\n  * How does the situation in the Gaza Strip affects the voters' view of the two candidates for the US Presidential election?\n\n  * What is the name of a horror movie about small insects that destroyed humanity?\n\n  * How to cut a key? (limit linear extrapolation)\n\n  * Does Japan's \"Kami\" have a divine rank?\n\n  * Linking number and intersection number\n\n  * First airplane with software?\n\n  * The sun path angle of elevation\n\n  * Dyslexic friendly packages in latex\n\n  * Output a 1-2-3 sequence\n\n  * Recycle buying soda problem\n\n  * Can I reconnect a battery to pull up windows while alternator is out?\n\n  * What is a word for battery \"longevity\"?\n\n  * How to say politely not to doze off during progress meeting?\n\nQuestion feed\n\n# Subscribe to RSS\n\ndefault\n\n  * Blog\n  * Facebook\n  * Twitter\n  * LinkedIn\n  * Instagram\n\nSite design / logo \u00a9 2024 Stack Exchange Inc; user contributions licensed\nunder CC BY-SA. rev 2024.4.12.7646\n\n## We Care About Your Privacy\n\nWe and our 4 partners store and/or access information on a device, such as\nunique IDs in cookies to process personal data. You may accept or manage your\nchoices by clicking below, including your right to object where legitimate\ninterest is used, or at any time in the privacy policy page. These choices\nwill be signaled to our partners and will not affect browsing data.\n\nCookie Policy.\n\n### We and our partners perform the following based on your settings:\n\nUse precise geolocation data. Actively scan device characteristics for\nidentification. Understand audiences through statistics or combinations of\ndata from different sources. Store and/or access information on a device.\nDevelop and improve services. Create profiles to personalise content. Measure\ncontent performance. Use limited data to select content. Measure advertising\nperformance. Use limited data to select advertising. Create profiles for\npersonalised advertising. Use profiles to select personalised advertising. Use\nprofiles to select personalised content.\n\n", "frontpage": true}
