{"aid": "40017068", "title": "How to Read the Rails Codebase", "url": "https://www.writesoftwarewell.com/how-to-read-rails-codebase/", "domain": "writesoftwarewell.com", "votes": 1, "user": "thunderbong", "posted_at": "2024-04-12 20:04:46", "comments": 0, "source_title": "How I Read Rails Source Code", "source_text": "How I Read Rails Source Code\n\nSkip to content\n\nWrite Software, Well\n\nSign in Subscribe\n\n# How I Read Rails Source Code\n\nHere're two techniques I've found really helpful for reading the Rails\ncodebase, without getting overwhelmed. If you want to dive into the Rails\nsource code for a deeper understanding, but feel intimidated by the sheer size\nof the codebase and don't know where to begin, this post is for you.\n\nRails Internals 13 min read Apr 12, 2024\n\nAfter my previous post, How a Ruby Method Becomes a Rails Action, I got quite\na few emails asking about the best way to read the Rails source code. Here's\none from Peter, a long-time reader of the blog:\n\n> You have mentioned that you enjoy just reading the Rails source code. I am\n> interested in going through the Rails source code but the code base is so\n> large, I'm not quite sure where to start. Would you have a suggestion for\n> someone like me, just learning Rails, to tackle this?\n>\n> It just seems so overwhelming that I'm not quite sure where to start and how\n> to proceed.\n\nWhile I don't think there's one best way to read the Rails codebase, I've\nfound a few techniques that are much more effective than the common strategy\nmany employ: clone and open the Rails repository, start reading, get\noverwhelmed, and give up.\n\nI hope they will allow you to efficiently understand the functionality you're\nexploring without getting bogged down in irrelevant details that are not\nimportant to the feature you're trying to make sense of.\n\nBut first, why should you read the Rails codebase? and why it's important?\n\nAs developers, we spend a bulk of our time reading the source code. You read\ncode because you have to add new features or fix bugs. You also read the code\nto understand the underlying system to make changes to it. Sometimes, like me,\nyou may even read code just for the pleasure.\n\nYet, reading code is never taught in school, even though it's a very effective\ntechnique to learn programming and become a better software developer, in my\nhumble opinion.\n\nIf you know how to effectively read the source code (not just of Rails, but\nany system in general), you gain a deeper understanding of the system at a\nlevel that you just can't get as a user of that system.\n\nJust as reading high-quality writing improves your vocabulary, improves your\ntaste, and make you a better writer, reading high-quality source code teaches\nyou new patterns and practices, data structures, algorithms, coding styles,\nand even a new domain-specific language (DSL).\n\nWhat's more, you get to learn from the best. As an example, check out this PR\nfrom Jeremy, I'm sure you'll learn a thing or two that you didn't before.\n\nStill not convinced? Let's try an example from a different industry. Imagine\nthat you're a salesperson pitching something to a prospect. You have never\ndone this before, so you have no reference point. All you have done so far is\nto read the features of thing you're selling and memorize the sales script.\n\nAfter you've done the initial spiel (an elaborate or glib speech or story,\ntypically one used by a salesperson), the prospect comes up with an objection\nthat you can't counter. As expected, you're stunned and have no idea how to\nreact.\n\nNow consider this: You're an experienced salesman who's done hundreds of these\nsales calls and encountered thousands of objections. By the time the prospect\nraises their concern, you already know how to address it. You handle the\nobjection gracefully and make the sale, not despite, but because of the\nobjection.\n\nThe same principle applies to programming. When you're building software you\nrun into various problems, many of which you may have never seen before.\nHowever, if you're read and learned a ton of source code, you start to build\nthe mental models for common causes of bugs, performance issues, and best\npractices. You learn and remember how some gem author ran into this problem\nand how they resolved it, and so on.\n\n\ud83d\udca1\n\nWhen you go through the stages of reading, copying, and referencing, you're\nbuilding a memory of a situation.\n\nAll this to say: Reading code is important.\n\nWith that prelude out of the way, let's look at two concrete techniques you\ncan use to read the Rails source code.\n\n> The core idea behind both techniques is to focus on one feature or a method\n> at a time, and not only to passively read the source, but actively step\n> through the specific method you're interested in with debugger.\n>\n> This keeps the scope small, and lets you inspect the local variables, follow\n> the conditional path, and learn exactly what's happening behind the scene.\n\n## Bundle Open Gem\n\nLet's start with a concrete example. Imagine you want to understand how\nbackground jobs work in Rails. You've read the Rails guides and skimmed\nthrough a few tutorials, and understand the basic usage:\n\n    \n    \n    # A background job to remind users class SendReminderJob < ApplicationJob def perform(user) # send a reminder to the user end end # Somewhere else in your app... SendReminderJob.perform_later(user)\n\nPlain and simple.\n\nHowever, you want to go a level deeper to understand exactly how Rails\naccomplishes this. Specifically, you want to understand what happens when you\ncall the perform_later method.\n\nRails Internals: A Deep Dive Into Active Job Codebase\n\nDo you want to understand how Active Job works behind the scenes? Reading and\nunderstanding the source code is one of the best ways to learn a framework (or\nanything). This post breaks it all down for you by tracing the journey of a\nRails background job, from its creation to execution.\n\nWrite Software, WellAkshay Khot\n\nOne way is to just open the Rails codebase, do a global search for the\nperform_later method, find the method definition, and try to make sense of the\ncode.\n\nHowever, a better approach is to put a breakpoint and step through the\nmethod's control flow.\n\nBut how can you put a breakpoint inside the Rails source code? You can't just\nopen the Rails repository you cloned and put the breakpoint in it, since your\napplication is not using that particular Rails project. It uses a bundled\nRails project stored somewhere under the Ruby installation.\n\nSo how can you open that specific Rails installation, add a breakpoint in it,\nand step through the exact Rails method your app is using?\n\nLet's ask DHH:\n\nSimply run bundle open activejob and Bundler will open the exact version of\nthe ActiveJob framework your application is using.\n\n\ud83d\udca1\n\nYou can't do bundle open rails as Rails itself is a collection of various sub-\nframeworks (or gems) like ActiveJob, ActiveRecord, and so on. You have to open\nthe specific gem you're interested in.\n\nLet's try this:\n\n    \n    \n    $ bundle open activejob\n\nAnd voila! Bundler opens the gem in a new editor window.\n\nBundle opens ActiveJob Gem\n\nThis is the exact source code your app is using.\n\nNote that Bundler doesn't include the tests for the gem, which is fine, we'll\ncome back to the tests in the second code-reading technique, covered below.\n\nNext step is to find the perform_later method. So you'll do a global search\nfor def perform_later and find two instances of the method.\n\nsearch for perform_later method\n\nLet's imagine we have no idea which perform_later method is actually getting\ncalled. So let's add breakpoints in both methods by editing the source files.\n\n    \n    \n    # lib/active_job/enqueuing.rb def perform_later(...) debugger # \ud83d\udc48 add this line job = job_or_instantiate(...) enqueue_result = job.enqueue yield job if block_given? enqueue_result end # lib/active_job/configured_job.rb def perform_later(...) debugger # \ud83d\udc48 add this line @job_class.new(...).enqueue @options end\n\nBy the way, I am using the debug gem for debugging Ruby code, and highly\nrecommend that you use it as well. Rails includes this gem out of the box, and\nfor any other codebase, you can run bundle add debug to install and add it to\nyour gemfile.\n\nNext, I'll go back to my Rails app, open the Rails console, and enqueue a\nsample job.\n\n    \n    \n    $ bin/rails console irb(main):001> GreetUserJob.perform_later\n\nAnd just like magic, the Ruby interpreter will halt execution on on of the\nbreakpoints you inserted:\n\nTurns out, it's the perform_later method in the Enqueuing module that's\ngetting called, whenever we enqueue a background job.\n\nSweet, we learned something new!\n\nAt this point, you are inside the Rails codebase. You can step through the\nentire Rails source code as you'd in your regular application.\n\n  * To step into a method, type s,\n  * To step out of a method, type u,\n  * To continue, type c.\n  * To show the state, type i\n\nHow great is that?\n\nAnd of course, you have access to all local variables as usual. Just type the\nname of the variable and the debugger will show you its value.\n\n\ud83d\udca1\n\nFor detailed instructions on using the debugger, check out debug gem's\ndocumentation.\n\nTry reading the perform_later method on your own. Explore what paths it's\ntaking, what variables it's setting, what instances it's creating, and what\nvalue it's returning. I am sure you'll learn a ton.\n\nLet's move on to the second code-reading technique now.\n\n## Run and Follow the Tests\n\nOne of the best ways to understand any codebase is to read the tests, and\nRails is no exception.\n\nThe obvious benefit of a test is to make sure that the code still works after\nmaking a change. However, another hidden benefit is that a test can help us\nget familiar with the codebase quickly. You can execute the code without\nlaunching the application in the browser or running the complete program.\n\nWhat's more, a test allows you to run a specific feature in isolation, which\nhelps you understand the relevant code without worrying about irrelevant\ndetails.\n\nRails puts very high importance on tests. The source code for the framework\ncontains thousands and thousands of high-quality tests that thoroughly test\nthe framework code that hundreds of people contribute to.\n\n\ud83d\udca1\n\nUnderstanding tests makes it easy to understand the Rails codebase.\n\nIn this section, you'll learn how to:\n\n  1. Run the entire Rails test suite\n  2. Run the tests specific to a module\n  3. Run all tests in a file\n  4. Run a single test\n\nFirst, make sure you have cloned the Rails repository on your computer.\n\n    \n    \n    $ git clone https://github.com/rails/rails.git $ cd rails\n\n### Run the Entire Rails Test Suite\n\nTo run all the tests in the entire repository, you can run the following\ncommand from the rails directory.\n\n    \n    \n    $ bundle exec rake test\n\nBut we are not going to do that, as it will take a while, and for our purpose,\nwhich is to understand the source of a particular feature, and not contribute\nto Rails (yet!), we need to know how to run a single test, or multiple tests\nin a file we are trying to understand.\n\n\ud83d\udca1\n\nYou'll typically run the entire test suite while contributing a feature,\nbefore submitting a pull request, to ensure you haven't broken anything.\n\nSo let\u2019s start by running all the tests in the Action Pack module, a core\nRails framework. It contains the source for Rails Controllers and Views,\nessential parts of any web application.\n\n### Running All Tests in a Module\n\nWe will switch to the Action Pack directory and run the same command to run\nall tests for this framework.\n\n    \n    \n    $ cd actionpack $ bin/test # or, bundle exec rake test # Running: ... Finished in 6.537328s, 589.9964 runs/s, 2762.1377 assertions/s. 3857 runs, 18057 assertions, 0 failures, 0 errors, 0 skips\n\nAs you can see, it took about 6.5 seconds to run almost 4000 tests.\n\nThat said, often you won't even need to run all the tests in a sub-framework.\nSince you'll be working with a particular feature at any time, you only need\nto run the tests for that particular feature, which we'll explore next.\n\n### Running All Tests in a File\n\nWe can go further and run the tests in a specific file that we are trying to\nunderstand.\n\n    \n    \n    $ actionpack git:(main) \u2717 bin/test test/controller/request_forgery_protection_test.rb Running 286 tests in parallel using 4 processes Run options: --seed 29532 # Running: .............................................................................................................................................................................................................................................................................................. Finished in 0.726885s, 393.4598 runs/s, 1349.5945 assertions/s. 286 runs, 981 assertions, 0 failures, 0 errors, 0 skips\n\nYou can go even further and run a specific test.\n\n### Running a Single Test\n\nRunning all tests in a file is great, but we can also run a single test, which\nis what we will be doing a lot, while reading the source.\n\nTo run a single test, run the same command, passing the line number of the\ntest:\n\n    \n    \n    $ activejob git:(main) \u2717 bin/test test/cases/queuing_test.rb:15 Using inline Run options: --seed 16622 # Running: . Finished in 0.061077s, 16.3728 runs/s, 16.3728 assertions/s. 1 runs, 1 assertions, 0 failures, 0 errors, 0 skips\n\nAt this point, you might be wondering what does running tests have to do with\nreading the codebase.\n\nRunning the test is only one part of the equation, and we won't run tests in\nisolation. To understand the source code, when we run the tests, we will debug\nit by putting breakpoints in the source, following the control flow, pausing\nthe execution, and examining the state of the variables at any particular\nmoment in time.\n\nAgain, let's imagine that I want to understand how ActiveJob enqueues a job to\nbe executed in background using the perform_later method.\n\nFirst, I will require the debug gem in the test helper as follows:\n\n    \n    \n    # activejob/test/helper.rb # frozen_string_literal: true require \"active_job\" require \"debug\" # add this line\n\nNext, I'll insert a breakpoint in the perform_later method.\n\n    \n    \n    # lib/active_job/enqueuing.rb def perform_later(...) debugger job = job_or_instantiate(...) enqueue_result = job.enqueue yield job if block_given? enqueue_result end\n\nFinally, I'll run a test that uses the perform_later method, such as the\nfollowing one.\n\n    \n    \n    # active_job/test/cases/queuing_test.rb class QueuingTest < ActiveSupport::TestCase test \"run queued job\" do HelloJob.perform_later assert_equal \"David says hello\", JobBuffer.last_value end end\n\nI want to run the single test, so I'll use the following command:\n\n    \n    \n    $ bin/test test/cases/queuing_test.rb:15\n\nAnd voila! The test halts at our breakpoint.\n\nHalted at Breakpoint\n\nOnce again, you are free to explore the flow of control, local variables,\nglobal state, and much more, to your heart's content! This is the part I find\nmost enjoying, to be honest. Just follow the code, wherever it takes you.\n\nTo re-iterate what we learned in section one, I can hit n a few times to step\nforward, or s to step into a function. Pressing i shows me the available\nvariables. At any point, you can type whereami to see your whereabouts in the\ncodebase. To step out of a function, type u and to continue, press c. Easy\npeasy.\n\nDebugging\n\nCheck out following post to learn more about debugging:\n\nHow to Debug and Step-Through Rails Codebase\n\nDo you want to read the Rails source code for a deeper understanding of the\nframework, but feel intimidated by the sheer size of the codebase, or don\u2019t\nknow where to start? Start with a specific feature, insert a breakpoint, and\nstep through the method line-by-line. This article shows how.\n\nWrite Software, WellAkshay Khot\n\nBy the way, if all this talk about ActiveJob has made you curious about how it\nactually works, you may find the following post helpful.\n\nRails Internals: A Deep Dive Into Active Job Codebase\n\nDo you want to understand how Active Job works behind the scenes? Reading and\nunderstanding the source code is one of the best ways to learn a framework (or\nanything). This post breaks it all down for you by tracing the journey of a\nRails background job, from its creation to execution.\n\nWrite Software, WellAkshay Khot\n\nAnd also check the rails-internals tag on this blog, which contains all the\nposts where we try to make sense of a particular Rails feature by reading its\nsource code.\n\n## A Few More Tips\n\nStart your reading with small programs.\n\nIf you've never read any open-source codebase before, don't directly jump into\nRails, as you'll be overwhelmed and quit soon.\n\nInstead, start with a simple Ruby gem, such as rack, or mail. Personally, I am\ncurrently reading the source code of the solid_queue gem from 37signals and\nlearning a ton. Once you find yourself comfortable reading smaller pieces of\ncode, move on to the larger ones.\n\nWhen you work on a feature that you don't quite understand, make a note of\ncoming back later and read how it's implemented. Run its tests. This provides\nyou with not only the immediate feedback on the way the code is supposed to\nwork but also a sense of achievement and motivation.\n\nNext, try making a few changes to the code to test your understanding. When\nyou open a gem using bundle open gem, you can modify the source code, save,\nand execute it. Begin with small changes and gradually increase their scope.\nYour active involvement with real code give you much more confidence and a\nlevel of comfort that cannot be gained by just reading the code.\n\nFinally, since Rails makes a ton of use of Ruby's metaprogramming techniques,\nit's good to know some basics. You don't have to be an expert, just enough to\nunderstand what you're reading and how it works.\n\nFor a cursory overview, check out my notes on Paolo Perrotta's classic,\nMetaprogramming Ruby 2.\n\nMetaprogramming in Ruby\n\nMetaprogramming in Ruby enables you to produce elegant, clean, and beautiful\nprograms as well as unreadable, complex code that\u2019s not maintainable. This\nbook teaches you the powerful metaprogramming concepts in Ruby, and how to use\nthem judiciously.\n\nWrite Software, WellAkshay Khot\n\nThat's a wrap. I hope you found this article helpful and you learned something\nnew.\n\nAs always, if you have any questions or feedback, didn't understand something,\nor found a mistake, please leave a comment below or send me an email. I reply\nto all emails I get from developers, and I look forward to hearing from you.\n\nIf you'd like to receive future articles directly in your email, please\nsubscribe to my blog. Your email is respected, never shared, rented, sold or\nspammed. If you're already a subscriber, thank you.\n\n### Tags\n\nRails Internals\n\n#### Share with friends\n\n##### Posted by Akshay Khot\n\nI'm a software developer living in beautiful Victoria, BC. This blog is my\nattempt to share my learnings and to spread the joy of programming in Ruby\nwith the world.\n\n### Join our newsletter\n\nSubscribe to get the new posts via email. Your email address is never sold or\nshared.\n\n### You might also like\n\n## Custom URL Helpers in Rails with the direct Method\n\nRails Internals 6 min read\n\n## How a Ruby Method Becomes a Rails Action: Part One (Metal)\n\nRails Internals 7 min read\n\n## Prevent Logging Sensitive Data with Rails Parameter Filters\n\nRails Internals 10 min read\n\n## \ud83d\udcac Understanding How Rails Environments Work\n\nRails Internals 6 min read\n\n## Rails Internals: A Deep Dive Into Active Job Codebase\n\nRails Internals 10 min read\n\n## Understanding the Instrumentation API in Rails\n\nRails Internals 5 min read\n\n### No Comments\n\n### Featured\n\n## Announcing: Rails Companion - Build a WebApp in Ruby Without Rails\n\nrails-companion 8 min read\n\n## Annual Blog Review: 2023\n\nAnnual Review 31 min read\n\n## Announcing: Crash Course on Turbo (Hotwire) Framework\n\n3 min read\n\n## Akshay's Blog is now Write Software, Well\n\n4 min read\n\n\u00a9 2024 - Write Software, Well\n\n", "frontpage": false}
