{"aid": "39962963", "title": "A Full Stack SaaS Template with Loco", "url": "https://www.shuttle.rs/blog/2024/02/29/fullstack-loco-rust", "domain": "shuttle.rs", "votes": 1, "user": "colund", "posted_at": "2024-04-07 19:09:58", "comments": 0, "source_title": "A Full Stack SaaS Template with Loco", "source_text": "A Full Stack SaaS Template with Loco\n\n\u2b50\ufe0f If you like Shuttle, give it a star on GitHub or follow us on Twitter\n\n# A Full Stack SaaS Template with Loco\n\nJoshua Mo \u2022 29 February 2024\n\nLoco is a Rust framework that aims to do it all - authentication, tasks,\nmigrations and more. While initially being more complex to use than using pure\nAxum, it can save a lot of time setting up boilerplate and provides a great\nplatform to build on.\n\nIn this guide, we\u2019ll deploying Loco on Shuttle via a fullstack template that\nalso additionally includes SaaS subscription payments. By using their SaaS\nstarter, we can leverage their pre-built authentication features to build\npayments out quickly and easily. Interested in deploying or trying out the\nfinal repo? You can check it out here.\n\nSteps to deploy from cloning:\n\n  * Run cargo shuttle init --from joshua-mo-143/shuttle-stripe-ex and follow the prompt (requires cargo-shuttle installed)\n  * Set up API keys (see below)\n  * Use cargo shuttle deploy --allow-dirty and watch the magic happen!\n\n## Prerequisites\n\nBefore we get started, you will need a Stripe API key. It\u2019s free to sign up\nwith Stripe and you can turn on Test Mode before you do anything in\nproduction. Stripe also has docs on this if you need assistance here.\n\nOnce you\u2019ve created your project, make sure you create a Secrets.toml file in\nthe root of your project and add it like so:\n\n    \n    \n    STRIPE_API_KEY = \"<YOUR-STRIPE-KEY-HERE>\"\n\n### Getting started\n\nWe\u2019re going to use the following command to initialise our project (requires\ncargo-shuttle installed), following the prompt to initialise a project with\nour name. The --from flag allows us to take the starter from\n\n    \n    \n    cargo shuttle init --from loco-rs/loco --subfolder starters/saas\n\nWe will then use cargo loco generate deployment to generate a Shuttle\ndeployment for our Loco project!\n\nWhile we\u2019re here, make sure you\u2019re using the latest version of cargo-shuttle\nand Shuttle dependencies in your project. We released v0.40.0 today!\n\nWe\u2019ll also add the following dependencies with a shell snippet:\n\n    \n    \n    cargo add async-stripe@0.34.1 -F runtime-tokio-hyper-rustls cargo add shuttle-shared-db -F postgres cargo add shuttle-secrets\n\nNote that you will get a blank Shuttle deployment with no database installed.\nTo remedy this, we\u2019ll adjust the main function to provide our database\nannotation and make sure that the Migrator (from the migrations folder) is\nadded:\n\n    \n    \n    use migrations::Migrator; #[shuttle_runtime::main] async fn main( #[shuttle_shared_db::Postgres] conn_str: String, #[shuttle_metadata::ShuttleMetadata] meta: shuttle_metadata::Metadata, #[shuttle_secrets::Secrets] secrets: shuttle_secrets::SecretStore ) -> shuttle_axum::ShuttleAxum { std::env::set_var(\"DATABASE_URL\", conn_str); let stripe_api_key = secrets .get(\"STRIPE_API_KEY\") .expect(\"STRIPE_API_KEY not found in secrets\"); std::env::set_var(\"STRIPE_API_KEY\", stripe_api_key); let environment = match meta.env { shuttle_metadata::Environment::Local => Environment::Development, shuttle_metadata::Environment::Deployment => Environment::Production, }; let boot_result = create_app::<App, Migrator>(StartMode::ServerOnly, &environment) .await .unwrap(); let router = boot_result.router.unwrap(); Ok(router.into()) }\n\nIn the regular src/bin/main.rs, you may also need to adjust the app so that\nMigrator is also included.\n\nOnce done, you can use cargo shuttle run and it should just automatically\nwork! You\u2019ll get a database connection URL (save this for later!).\n\n### Migrations\n\nTo get started, we\u2019ll make some migrations that we can then reference later on\nin the program. You can do this like so:\n\n    \n    \n    cargo loco generate model --migration-only subscription_tiers tier:string! stripe_item_id:string! stripe_price_id:string! cargo loco generate model --migration-only user_subscriptions user:references stripe_customer_id:string! stripe_subscription_id:string! user_tier:string!\n\nThen we\u2019ll use the following to migrate your database and generate entities:\n\n    \n    \n    DATABASE_URL=<DB_URL_HERE> cargo loco db migrate DATABASE_URL=<DB_URL_HERE> cargo loco db entities\n\nNote that you will need a database URL for this. If you don\u2019t have one yet,\nyou can use cargo shuttle run to automatically spin up a Postgres container\nwith a provided connection string or spin up your own Docker container.\n\nThese two commands will generate some files in the migrations folder as well\nas in src/models, which we\u2019ll be making heavy use of as they are the main way\nto interface with the database when using Loco.\n\n## Frontend\n\nWe won\u2019t be covering the frontend in this tutorial as there\u2019s a lot of\ndifferent ways you can do it - however, if you\u2019d like to look at the way that\nwe\u2019ve done it, feel free to check out the repo here! We use React as provided\nby Loco with react-router-dom for routing and zustand for state management,\nwith vanilla CSS.\n\nThe following pages in the repo have been provided:\n\n  * A home page\n  * Login and register pages\n  * A dashboard page that allows users to downgrade/upgrade their subscription tier, cancel it and check what tier they are.\n  * Pricing and payment checkout pages\n  * A payment success/fail page\n\n## Error handling\n\nLoco by default uses anyhow to be able to provide easy error handling.\nHowever, for our purposes, let\u2019s create our own error type. This will allow us\na couple of things:\n\n  * We know exactly what error is happening and where\n  * We can customise the behavior of our error handling\n\nLet\u2019s start by using the thiserror crate we added earlier to add macros for\nautomatically implementing std::fmt::DIsplay and std::error::Error. The\nthiserror::Error derive macro also allows us to add attribute macros to our\nstruct for automatic From<T> implementations, which saves a lot of time! That\nbeing said, you can also implement From<T> manually if you want to create more\nthan one enum variant for an error based on what the reason of the error is.\n\n    \n    \n    use thiserror::Error; #[derive(Error, Debug)] pub enum ApiError { #[error(\"Stripe error: {0}\")] Stripe(#[from] stripe::StripeError), #[error(\"User already has this subscription tier!\")] UserTierAlreadyExists, #[error(\"SQL error: {0}\")] SQL(#[from] sea_orm::DbErr), #[error(\"Model error: {0}\")] Model(#[from] loco_rs::model::ModelError), }\n\nTo be able to use this in our API, we will need to implement\naxum::response::IntoResponse. We can do this by simply matching each enum\nvariant like below:\n\n    \n    \n    use axum::{http::StatusCode, response::{Response, IntoResponse}}; impl IntoResponse for ApiError { fn into_response(self) -> Response { let res = match self { Self::Stripe(err) => (StatusCode::INTERNAL_SERVER_ERROR, err.to_string()), Self::SQL(err) => (StatusCode::INTERNAL_SERVER_ERROR, err.to_string()), Self::UserTierAlreadyExists => ( StatusCode::BAD_REQUEST, \"User already has this tier!\".to_string(), ), Self::Model(e) => (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()), }; res.into_response() } }\n\n## Using Stripe\n\nTo get started with using Stripe, we\u2019ll want to create a new loco controller\nfile that will hold all of our routes. We can do this with cargo loco generate\ncontroller stripe, which will generate a new controller route at\nsrc/controllers/stripe.rs and inject some code into src/app.rs to make sure\nthe controller gets automatically included.\n\nLooking inside src/controllers/stripe.rs should give you a function that\nreturns Routes (a struct that builds on axum::Router) and a couple of routes\nfor returning \u201cHello, world!\u201d and the contents of a given request.\n\nLet\u2019s start first by defining what our user tiers are. Let\u2019s say we have the\nPro tier, and the Team tier. We can write an enum with relevant impls like so:\n\n    \n    \n    use std::fmt; use serde::{Deserialize, Serialize}; use sea_orm::{EnumIter, DeriveActiveEnum}; #[derive(EnumIter, DeriveActiveEnum, Clone, Deserialize, Debug, Serialize, PartialEq, Eq)] #[sea_orm(rs_type = \"String\", db_type = \"String(StringLen::N(1))\")] pub enum UserTier { #[sea_orm(string_value = \"P\")] Pro, #[sea_orm(string_value = \"T\")] Team, } impl UserTier { fn get_price(&self) -> Option<i64> { match self { Self::Pro => Some(1000), Self::Team => Some(2500), } } fn from_str(str: &str) -> Self { match str { \"Pro\" => Self::Pro, \"Team\" => Self::Team, _ => panic!(\"There should only be the Pro and Team tier!\") } } } impl fmt::Display for UserTier { fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { match self { Self::Pro => write!(f, \"Pro\"), Self::Team => write!(f, \"Team\"), } } }\n\nNote that the macros we are importing from sea_orm will let the enum be stored\nas a varchar type in Postgres.\n\n### Creating Stripe products and prices\n\nBefore we do anything else, we will want to create a Stripe product that has\nsome prices attached to it. To do that, we can create two functions; one for\ncreating the Product item, and then one for adding a price (as products on\nStripe can have multiple prices). Creating a price requires a product. To keep\nit simple, we\u2019ll keep one price attached to one item. Both functions will be\nused as part of other functions.\n\n    \n    \n    use stripe::{Client, Product, Price, CreatePrice, CreateProduct, IdOrCreate, CreatePriceRecurring, CreatePriceRecurringInterval, Currency}; async fn create_product_item(client: &Client, user_tier: &UserTier) -> Result<Product, ApiError> { let product = { let mut create_product = match user_tier { UserTier::Pro => CreateProduct::new(\"Pro User Subscription\"), UserTier::Team => CreateProduct::new(\"Team Subscription\"), }; create_product.metadata = Some(std::collections::HashMap::from([( String::from(\"async-stripe\"), String::from(\"true\"), )])); Product::create(client, create_product).await? }; Ok(product) } async fn create_product_price( client: &Client, user_tier: &UserTier, product: &Product, ) -> Result<Price, ApiError> { let price = { let mut create_price = CreatePrice::new(Currency::USD); create_price.product = Some(IdOrCreate::Id(&product.id)); create_price.metadata = Some(std::collections::HashMap::from([( String::from(\"async-stripe\"), String::from(\"true\"), )])); create_price.unit_amount = user_tier.get_price(); create_price.recurring = Some(CreatePriceRecurring { interval: CreatePriceRecurringInterval::Month, ..Default::default() }); create_price.expand = &[\"product\"]; Price::create(client, create_price).await? }; Ok(price) }\n\nThis then allows us to build a more higher-level function that can either\nsimply retrieve the Stripe product ID if it already exists in the database, or\ncreate a product with price then save the details in the database. For\nsimplicity (and not wanting to deal with securing financial information in the\ndatabase), we will only be storing the IDs and relevant information, such as\nwhat product tier a user is.\n\n    \n    \n    use sea_orm::DatabaseConnection; async fn retrieve_product( client: &Client, user_tier: &UserTier, db: &DatabaseConnection, ) -> Result<Price, ApiError> { use crate::models::_entities::subscription_tiers; let product = subscription_tiers::Entity::find() .filter(subscription_tiers::Column::Tier.contains(user_tier.to_string())) .one(db) .await?; let price = match product { Some(product) => { Price::retrieve( client, &PriceId::from_str(&product.stripe_price_id.to_string()).unwrap(), &[\"product\"], ) .await? } None => { let product = create_product_item(client, &user_tier).await?; let price = create_product_price(client, &user_tier, &product).await?; let tier_model = subscription_tiers::ActiveModel { tier: ActiveValue::Set(user_tier.to_string()), stripe_item_id: ActiveValue::Set(product.id.to_string()), stripe_price_id: ActiveValue::Set(price.id.to_string()), ..Default::default() }; subscription_tiers::Entity::insert(tier_model) .exec(db) .await?; price } }; Ok(price) }\n\nLater on, when we run the web service, the API should automatically be able to\nknow if it is required to remake the Stripe product or not.\n\nLet\u2019s write a function for creating a subscription. To get started, we will\ndefine what the JSON input should look like when the API receives a request:\n\n    \n    \n    #[derive(Deserialize, Clone)] #[serde(rename_all = \"camelCase\")] pub struct UserSubscription { name: String, email: String, card_num: String, exp_year: i32, exp_month: i32, cvc: String, user_tier: UserTier, }\n\nNote that when sending the request, the variables must be in camel case and\nnot snake case.\n\nTo make things a little bit easier for ourselves later, we will add an impl\nfor UserSubscription which will allow us to automatically turn it into some\nstructs that we\u2019ll be using later on to create the customer and\nCardDetailsParams.\n\n    \n    \n    impl UserSubscription { fn as_create_customer(&self) -> CreateCustomer { CreateCustomer { name: Some(&self.name), email: Some(&self.email), description: Some( \"A paying user.\", ), metadata: Some(std::collections::HashMap::from([( String::from(\"async-stripe\"), String::from(\"true\"), )])), ..Default::default() } } fn as_card_details_params(&self) -> CardDetailsParams { CardDetailsParams { number: self.card_num.to_string(), exp_year: self.exp_year, exp_month: self.exp_month, cvc: Some(self.cvc.clone()), ..Default::default() } } }\n\n### Creating subscriptions\n\nNext, we\u2019ll want to get started on writing an endpoint for creating user\nsubscriptions! We\u2019ll create a stripe::Client here from the API key that we\nstored earlier.\n\n    \n    \n    use crate::models::_entities::user_subscriptions; use crate::models::_entities::users; use loco_rs::controller::middleware::auth::JWTWithUser; pub async fn create_subscription( State(ctx): State<AppContext>, auth: middleware::auth::JWTWithUser<users::Model>, Json(json): Json<UserSubscription>, ) -> Result<StatusCode, ApiError> { let secret_key = std::env::var(\"STRIPE_API_KEY\").expect(\"Missing STRIPE_API_KEY in env\"); let client = Client::new(secret_key); // .. rest of your code }\n\nHere, note that we specifically use the JWTWithUser middleware to extract a\nBearer JWT from the Authorization header and return a user model.\n\nNext, we want to create a customer and add it to our Stripe account. We will\nalso create the payment method and attach it to the customer. Note here that\nwhile we\u2019re using card payments as it\u2019s a very common form of payment, Stripe\nalso has quite a few other types of payments you can try.\n\n    \n    \n    use stripe::{Customer, PaymentMethod, PaymentMethodTypeFilter, CreatePaymentMethodCardUnion, AttachPaymentMethod}; let customer = Customer::create(&client, json.as_create_customer()).await?; let payment_method = { let pm = PaymentMethod::create(&client, CreatePaymentMethod { type_: Some(PaymentMethodTypeFilter::Card), card: Some(CreatePaymentMethodCardUnion::CardDetailsParams(json.as_card_details_params())), ..Default::default() }).await?; PaymentMethod::attach(&client, &pm.id, AttachPaymentMethod { customer: customer.id.clone(), }).await?; pm };\n\nNext, we\u2019ll want to add the part that creates the subscription. This part is\nrelatively simple as there\u2019s only one item in our subscription list we want -\nwhich is the base price for our SaaS subscription (although if you want to\nextend it, there are options for adding more too!):\n\n    \n    \n    use stripe::{CreateSubscription, CreateSubscriptionItems, Subscription, let mut params = CreateSubscription::new(customer.id.clone()); params.items = Some( vec![CreateSubscriptionItems { price: Some(price.id.to_string()), ..Default::default() }] ); params.default_payment_method = Some(&payment_method.id); params.expand = &[\"items\", \"items.data.price.product\", \"schedule\"]; let subscription = Subscription::create(&client, params).await?; let subscription_activemodel = user_subscriptions::ActiveModel { user_id: ActiveValue::Set(auth.user.id), stripe_customer_id: ActiveValue::Set(customer.id.to_string()), stripe_subscription_id: ActiveValue::Set(subscription.id.to_string()), user_tier: ActiveValue::Set(json.user_tier), ..Default::default() }; user_subscriptions::Entity::insert(subscription_activemodel).exec(&ctx.db).await?; Ok(StatusCode::OK);\n\nIf you get stuck on errors while writing this function, you can find the\nfunction in the repo here.\n\n### Cancelling Stripe Subscriptions\n\nOkay, now let\u2019s say you want your users to be able to use self-service to\ncancel the SaaS subscription. This primarily involves canceling the\nsubscription and then making sure to update the database. In this case, we are\nchoosing to outright delete the record from the database on successful\ncancellation.\n\nFirstly, we\u2019ll create the Stripe client again by grabbing our API key:\n\n    \n    \n    pub async fn cancel_subscription( State(ctx): State<AppContext>, auth: middleware::auth::JWTWithUser<UsersModel>, ) -> Result<StatusCode, ApiError> { let user = users::Model::find_by_pid(&ctx.db, &auth.claims.pid).await?; let secret_key = std::env::var(\"STRIPE_API_KEY\").expect(\"Missing STRIPE_API_KEY in env\"); let client = Client::new(secret_key); // .. rest of your code }\n\nNext, we\u2019ll find our user subscription from the user_subscriptions table based\non the user ID foreign key. We will then use the Stripe subscription ID to\ncancel the subscription.\n\n    \n    \n    let subscription = user_subscriptions::Entity ::find() .filter(user_subscriptions::Column::UserId.eq(user.id)) .one(&ctx.db).await? .unwrap(); let _ = Subscription::cancel( &client, &SubscriptionId::from_str(&subscription.stripe_subscription_id).unwrap(), CancelSubscription { cancellation_details: None, invoice_now: Some(true), prorate: Some(true), } ).await?;\n\nOnce the subscription has been successfully canceled and there\u2019s nothing else\nwe need to do with Stripe, we can go back and update our database to delete\nthe record:\n\n    \n    \n    let subscription_to_delete = user_subscriptions::Entity ::find() .filter(user_subscriptions::Column::UserId.eq(user.id)) .one(&ctx.db).await? .unwrap(); subscription_to_delete.delete(&ctx.db).await?; Ok(StatusCode::OK);\n\nNote that there are quite a few different ways to handle this. You may find\nthat you want to explicitly mark a customer\u2019s subscription as \u201cexpired\u201d rather\nthan outright deleting it from the database if you want users to be able to\ncheck their subscription history and other such details.\n\n### Upgrading/Downgrading Subscription Tiers\n\nFinally, we will add the ability to upgrade and downgrade subscription tiers.\nIn Stripe terms, we\u2019re grabbing information about a user\u2019s subscription and\nupdating the price ID of an existing item on the subscription.\n\nAs before, we\u2019ll start with creating the stripe::Client:\n\n    \n    \n    pub async fn update_subscription_tier( State(ctx): State<AppContext>, auth: middleware::auth::ApiToken<UsersModel>, Json(new_user_tier): Json<UpdateUserTier>, ) -> Result<StatusCode, ApiError> { use crate::models::_entities::subscription_tiers; use crate::models::_entities::user_subscriptions; let secret_key = std::env::var(\"STRIPE_API_KEY\").expect(\"Missing STRIPE_API_KEY in env\"); let client = Client::new(secret_key); // .. rest of your code }\n\nAfter that, we will find the user_subscription based on the user ID. We will\nthen retrieve the subscription data from Stripe and get the first item on the\nsubscription list. Note that while we are using a vector index which can\ntechnically panic, there should always be at least one item so it is safe to\nuse index 0. We will also return an error if the user\u2019s current tier is the\nsame as the requested tier.\n\n    \n    \n    let user_subscription = user_subscriptions::Entity ::find() .filter(user_subscriptions::Column::UserId.eq(auth.user.id)) .one(&ctx.db).await? .unwrap(); let subscription_item = Subscription::retrieve( &client, &SubscriptionId::from_str(&user_subscription.stripe_subscription_id).unwrap(), &[\"items\"] ).await?.items; let subscription_item = &subscription_item.data[0]; if new_user_tier.user_tier == user_subscription.user_tier { return Err(ApiError::UserTierAlreadyExists); }\n\nOnce done, we can then find the subscription tier data from our database\naccording to the requested tier change and update the subscription using the\nnew tier\u2019s Stripe price object ID.\n\n    \n    \n    let new_subscription = subscription_tiers::Entity ::find() .filter(subscription_tiers::Column::Tier.contains(new_user_tier.user_tier.to_string())) .all(&ctx.db).await?; let new_sub_tier: String = new_subscription .iter() .find(|x| x.tier == new_user_tier.user_tier.to_string()) .map(|x| x.stripe_price_id.to_string()) .unwrap(); let updated_subscription = Subscription::update( &client, &SubscriptionId::from_str(&user_subscription.stripe_subscription_id).unwrap(), UpdateSubscription { items: Some( vec![UpdateSubscriptionItems { id: Some(subscription_item.id.to_string()), price: Some(new_sub_tier), ..Default::default() }] ), ..Default::default() } ).await?;\n\nBefore we finish this function up, we will need to update the user tier in the\nuser_subscriptions table.\n\n    \n    \n    use sea_orm::IntoActiveModel; let mut updated_user_subscription = user_subscription.into_active_model(); updated_user_subscription.user_tier = ActiveValue::Set(new_user_tier.user_tier); let _ = updated_user_subscription.update(&ctx.db).await?; Ok(StatusCode::OK);\n\n### Grabbing a user\u2019s product tier\n\nOf course, for the frontend you\u2019ll probably want a quick way to be able to\ngrab the user\u2019s product tier. You can do this like so:\n\n    \n    \n    pub async fn get_current_tier( State(ctx): State<AppContext>, auth: middleware::auth::JWTWithUser<UsersModel>, ) -> Result<Json<UpdateUserTier>, ApiError> { let user = users::Model::find_by_pid(&ctx.db, &auth.claims.pid).await?; let subscription = user_subscriptions::Entity::find() .filter(user_subscriptions::Column::UserId.eq(user.id)) .one(&ctx.db) .await? .unwrap(); Ok(Json(UpdateUserTier { user_tier: subscription.user_tier })) }\n\n### Hooking it all up\n\nNow that we\u2019re done, we can add it back to our router file for the controller.\nWe can add it back in, like so:\n\n    \n    \n    pub fn routes() -> Routes { Routes::new() .prefix(\"stripe\") .add(\"/get_current_tier\", get(get_current_tier)) .add(\"/create\", post(create_subscription)) .add(\"/update\", post(update_subscription_tier)) .add(\"/cancel\", delete(cancel_subscription)) }\n\n## Deployment\n\nTo deploy, you just need to run cargo shuttle deploy --allow-dirty and let\nShuttle make the magic happen! Once done, you\u2019ll see information about your\nservice.\n\n## Finishing up\n\nLoco is a really strong framework to get started with, and by implementing\nsubscription payments we\u2019ve managed to slot in the final piece of the puzzle\nfor a potential SaaS in the making.\n\nInterested in reading more?\n\n  * Try using Qdrant and OpenAI to add a RAG-based LLM to your SaaS here.\n  * Add tracing to your project for better logging here.\n  * Try implementing Oauth2-based authentication here.\n\nThis blog post is powered by shuttle - The Rust-native, open source, cloud\ndevelopment platform. If you have any questions, or want to provide feedback,\njoin our Discord server!\n\nShare article\n\nWriting & Compiling WASM in Rust\n\n29 February 2024 \u2022 11 minute read\n\nAsync Rust in a Nutshell\n\n29 February 2024 \u2022 12 minute read\n\nCategories\n\nrustfullstacklocoguide\n\nOn this page\n\n  * Prerequisites\n\n    * Getting started\n    * Migrations\n  * Frontend\n  * Error handling\n  * Using Stripe\n\n    * Creating Stripe products and prices\n    * Creating subscriptions\n    * Cancelling Stripe Subscriptions\n    * Upgrading/Downgrading Subscription Tiers\n    * Grabbing a user\u2019s product tier\n    * Hooking it all up\n  * Deployment\n  * Finishing up\n\nRelated articles\n\nWorking with OpenAPI using RustSend logs to Grafana Loki with RustSending Logs\nto Datadog with RustEverything you need to know about testing in RustBuilding\na Notification Service in Rust with AWS SNS\n\nView all\n\n## Build the Future of Backend Development with us\n\nJoin the movement and help revolutionize the world of backend development.\nTogether, we can create the future!\n\n### Shuttle\n\nFeaturesStartersStatusReleases\n\n### Company\n\nAboutContactCareersTerms of ServicePrivacy PolicyAcceptable Use PolicyCookie\nPolicyData Processing Addendum\n\n### Developers\n\nDocsGuidesExamplesShuttle HeroesLaunchpadCode HuntShuttle AI\n\n### Community\n\nGitHubDiscordTwitterLinkedIn\n\n\u00a9 2024 Shuttle\n\nBacked by\n\nWe use cookies to enhance the user experience and measure engagement.\n\n", "frontpage": false}
