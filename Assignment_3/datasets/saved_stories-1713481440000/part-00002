{"aid": "40078351", "title": "Reverie \u2013 A user space system-call interception framework for Linux", "url": "https://github.com/facebookexperimental/reverie", "domain": "github.com/facebookexperimental", "votes": 1, "user": "peter_d_sherman", "posted_at": "2024-04-18 17:02:30", "comments": 0, "source_title": "GitHub - facebookexperimental/reverie: An ergonomic and safe syscall interception framework for Linux.", "source_text": "GitHub - facebookexperimental/reverie: An ergonomic and safe syscall\ninterception framework for Linux.\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nfacebookexperimental / reverie Public\n\n  * Notifications\n  * Fork 25\n  * Star 487\n\nAn ergonomic and safe syscall interception framework for Linux.\n\n### License\n\nView license\n\n487 stars 25 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# facebookexperimental/reverie\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n2 Branches\n\n0 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nifd3fandfacebook-github-botthird-party/rust: Bump bytes 1.1 -> 1.6.0Apr 6,\n20249a1320b \u00b7 Apr 6, 2024Apr 6, 2024\n\n## History\n\n280 Commits  \n  \n### .github/workflows\n\n|\n\n### .github/workflows\n\n| ci: Make clippy less strict (#29)| Feb 15, 2024  \n  \n### assets\n\n|\n\n### assets\n\n| Initial commit| Dec 30, 2021  \n  \n### experimental\n\n|\n\n### experimental\n\n| Upgrade tokio| Mar 18, 2024  \n  \n### public_autocargo/experimental\n\n|\n\n### public_autocargo/experimental\n\n| Add default crate information| Dec 11, 2023  \n  \n### reverie-examples\n\n|\n\n### reverie-examples\n\n| third-party/rust: make tracing and tracing-subscriber available to no...|\nMar 26, 2024  \n  \n### reverie-memory\n\n|\n\n### reverie-memory\n\n| Add default crate information| Dec 11, 2023  \n  \n### reverie-process\n\n|\n\n### reverie-process\n\n| rust/third-party: update to futures-0.3.30| Mar 27, 2024  \n  \n### reverie-ptrace\n\n|\n\n### reverie-ptrace\n\n| third-party/rust: Bump bytes 1.1 -> 1.6.0| Apr 6, 2024  \n  \n### reverie-syscalls\n\n|\n\n### reverie-syscalls\n\n| reverie-syscalls: Fix broken OSS CI| Jan 16, 2024  \n  \n### reverie-util\n\n|\n\n### reverie-util\n\n| third-party/rust: make tracing and tracing-subscriber available to no...|\nMar 26, 2024  \n  \n### reverie\n\n|\n\n### reverie\n\n| bitflags: enable feature 'serde'| Feb 22, 2024  \n  \n### safeptrace\n\n|\n\n### safeptrace\n\n| rust/third-party: update to futures-0.3.30| Mar 27, 2024  \n  \n### scripts\n\n|\n\n### scripts\n\n| Add script to dump the VDSO| Nov 29, 2022  \n  \n### tests\n\n|\n\n### tests\n\n| Fix broken test after toolchain update| Feb 9, 2024  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| Initial commit| Dec 30, 2021  \n  \n### CHANGELOG.md\n\n|\n\n### CHANGELOG.md\n\n| Initial commit| Dec 30, 2021  \n  \n### CODE_OF_CONDUCT.md\n\n|\n\n### CODE_OF_CONDUCT.md\n\n| Initial commit| Dec 30, 2021  \n  \n### CONTRIBUTING.md\n\n|\n\n### CONTRIBUTING.md\n\n| Initial commit| Dec 30, 2021  \n  \n### Cargo.toml\n\n|\n\n### Cargo.toml\n\n| Extract MemoryAccess into separate crate| Dec 8, 2022  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| Appease the copyright linter| Jun 2, 2022  \n  \n### README.md\n\n|\n\n### README.md\n\n| Fix README commands being treated as Rust code| Nov 29, 2022  \n  \n### rust-toolchain.toml\n\n|\n\n### rust-toolchain.toml\n\n| migrate affected rust-toolchain.toml files to rust/llvm-fb-15| Aug 1, 2023  \n  \n### rustfmt.toml\n\n|\n\n### rustfmt.toml\n\n| format_code_in_doc_comments = true| Jan 10, 2024  \n  \n## Repository files navigation\n\n# Reverie\n\nReverie is a user space system-call interception framework for Linux. It can\nbe used to intercept, modify, or elide a syscall before the kernel executes\nit. In essence, Reverie sits at the boundary between user space and kernel\nspace.\n\nSome potential use cases include:\n\n  * Observability tools, like strace.\n  * Failure injection to test error handling logic.\n  * Manipulating scheduling decisions to expose concurrency bugs.\n\nSee the reverie-examples directory for examples of tools that can be built\nwith this library.\n\n## Features\n\n  * Ergonomic syscall handling. It is easy to modify syscall arguments or return values, inject multiple syscalls, or suppress the syscall entirely.\n  * Async-await usage allows blocking syscalls to be handled without blocking other guest threads.\n  * Can intercept CPUID and RDTSC instructions.\n  * Typed syscalls. Every syscall has a wrapper to make it easier to access pointer values. This also enables strace-like pretty-printing for free.\n  * Avoid intercepting syscalls we don't care about. For example, if we only care about sys_open, we can avoid paying the cost of intercepting other syscalls.\n  * Can act as a GDB server. This allows connection via the GDB client where you can step through the process that is being traced by Reverie.\n\n## Terminology and Background\n\nClients of the Reverie library write tools. A tool runs a shell command\ncreating a guest process tree, comprised of multiple guest threads and\nprocesses, in an instrumented manner. Each Reverie tool is written as a set of\ncallbacks (i.e. handlers), which are invoked each time a guest thread\nencounters a trappable event such as a system call or inbound signal. The tool\ncan stipulate exactly which events streams it subscribes to. The tool itself\nis stateful, maintaining state between consecutive invocations.\n\n## Building and Testing\n\nReverie needs the following system-level dependencies:\n\n    \n    \n    sudo apt install pkg-config libunwind-devel\n\n(These are required to get backtraces from the guest process.)\n\nTo test, run:\n\n    \n    \n    cargo test -- --test-threads=1\n\nTo run the strace example:\n\n    \n    \n    cd reverie-examples cargo run --bin strace -- ls\n\n## Usage\n\nCurrently, there is only the reverie-ptrace backend which uses ptrace to\nintercept syscalls. Copy one of the example tools to a new Rust project (e.g.\ncargo init). You\u2019ll see that it depends both on the general reverie crate for\nthe API and on the specific backend implementation crate, reverie_ptrace.\n\n## Performance\n\nSince ptrace adds significant overhead when the guest has a syscall-heavy\nworkload, Reverie will add similarly-significant overhead. The slowdown\ndepends on how many syscalls are being performed and are intercepted by the\ntool.\n\nThe primary way you can improve performance with the current implementation is\nto implement the subscriptions callback, specifying a minimal set of syscalls\nthat are actually required by your tool.\n\n## Overall architecture\n\nWhen implementing a Reverie tool, there are three main components of the tool\nto consider:\n\n  * The process-level state,\n  * the thread-level state, and\n  * the global state (which is shared among all processes and threads in the traced process tree).\n\nThis separation of process-, thread-, and global-state is meant to provide an\nabstraction that allows future Reverie backends to be used without requiring\nthe tool to be rewritten.\n\n### Process State\n\nWhenever a new process is spawned (i.e., when fork or clone is called by the\nguest), a new instance of the process state struct is created and managed by\nthe Reverie backend.\n\n### Thread State\n\nWhen a syscall is intercepted, it is always associated with the thread that\ncalled it.\n\n### Global State\n\nThe global state is accessed via RPC messages. Since a future Reverie backend\nmay use in-guest syscall interception, the syscall handler code may not be\nrunning in the same address space. Thus, all shared state is communicated via\nRPC messages. (There is, however, currently only a single ptrace-based backend\nwhere all tracer code is in the same address space.)\n\n## Platform and Architecture Support\n\nReverie currently only supports the following platforms and architectures:\n\nPlatform| Architecture| Notes  \n---|---|---  \nLinux| x86-64| Full support  \nLinux| aarch64| Missing timers & cpuid/rdtsc interception  \n  \nOther platforms and architectures are currently unplanned.\n\n## Future Plans\n\n  * Add a more performant backend. The rough goal is to have handlers executing in the guest with close to regular functional call overhead. Global state and its methods will still be centralized, but the RPC/IPC mechanism between guest & the centralized tool process will become much more efficient.\n\n## Contributing\n\nContributions are welcome! Please see the CONTRIBUTING.md file for guidance.\n\n## License\n\nReverie is BSD 2-Clause licensed as found in the LICENSE file.\n\n## About\n\nAn ergonomic and safe syscall interception framework for Linux.\n\n### Resources\n\nReadme\n\n### License\n\nView license\n\n### Code of conduct\n\nCode of conduct\n\n### Security policy\n\nSecurity policy\n\nActivity\n\nCustom properties\n\n### Stars\n\n487 stars\n\n### Watchers\n\n15 watching\n\n### Forks\n\n25 forks\n\nReport repository\n\n## Releases\n\nNo releases published\n\n## Packages 0\n\nNo packages published\n\n## Contributors 38\n\n\\+ 24 contributors\n\n## Languages\n\n  * Rust 95.1%\n  * C 4.6%\n  * Other 0.3%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
