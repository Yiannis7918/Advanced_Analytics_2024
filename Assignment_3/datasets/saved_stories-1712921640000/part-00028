{"aid": "40009477", "title": "Modern PHP Without a Framework (2018)", "url": "https://kevinsmith.io/modern-php-without-a-framework/", "domain": "kevinsmith.io", "votes": 1, "user": "Tomte", "posted_at": "2024-04-12 04:47:47", "comments": 0, "source_title": "Modern PHP Without a Framework", "source_text": "Modern PHP Without a Framework | Kevin Smith\n\nKevin Smith\n\nIn it for the long haul\n\n# Modern PHP Without a Framework\n\nKevin Smith \u00b7 Mar 20, 2018 @ 8:29am CDT\n\nI\u2019ve got a challenge for you. The next time you start a new project, try not\nusing a PHP framework.\n\nNow, this isn\u2019t an anti-framework screed. Neither is it a promotion of not-\ninvented-here thinking. After all, we\u2019re going to be using some packages\nwritten by several framework developers in this tutorial. I\u2019ve got nothing but\ngreat respect for the innovation going on in that space.\n\nThis isn\u2019t about them. This is about you. It\u2019s about giving yourself the\nopportunity to grow as a developer.\n\nPerhaps the biggest benefit you\u2019ll find working without a framework is the\nwealth of knowledge about what\u2019s going on under the hood. You get to see\nexactly what\u2019s happening without relying on the framework\u2019s magic to take care\nof things for you in a way that you can\u2019t debug and don\u2019t really understand.\n\nIt\u2019s quite possible your next job will not grant the luxury of starting a\ngreenfield project with your framework of choice. The reality is that most\nhigh-value, business-critical PHP jobs involve existing applications. And\nwhether that application is built in a framework currently enjoying popular\nsupport like Laravel or Symfony, a framework from days gone by like\nCodeIgniter or FuelPHP, or even the depressingly widespread legacy PHP\napplication employing an \u201cinclude-oriented architecture\u201d, building without a\nframework now will better prepare you to take on any PHP project in the\nfuture.\n\nIn the past, it was an uphill battle to build without a framework because some\nkind of system had to interpret and route HTTP requests, send HTTP responses,\nand manage dependencies. The lack of industry standards necessarily meant\nthat, at the very least, those components of a framework were tightly coupled.\nIf you didn\u2019t start with a framework, you\u2019d end up building one yourself.\n\nBut today, thanks to all the autoloading and interoperability work done by\nPHP-FIG, building without a framework doesn\u2019t mean building it all by\nyourself. There are so many excellent, interoperable packages from a wide\nrange of vendors. Pulling it all together is easier than you think!\n\n## # PHP, How Does it Work?\n\nBefore we get into anything else, it\u2019s important to understand how PHP\napplications interact with the outside world.\n\nPHP runs server-side applications in a request/response cycle. Every\ninteraction with your app\u2014whether it\u2019s from the browser, the command line, or\na REST API\u2014comes into the app as a request. When that request is received, the\napp is booted up, it processes the request to generate a response, the\nresponse is emitted back to the client that made the request, and the app\nshuts down. That happens with every interaction.\n\n## # The Front Controller\n\nArmed with that knowledge, we\u2019ll kick things off with the front controller.\nThe front controller is the PHP file that handles every request for your app.\nIt\u2019s the first PHP file a request hits on its way into your app, and\n(essentially) the last PHP file a response runs through on its way out of your\napp.\n\nLet\u2019s use the classic Hello, world! example served up by PHP\u2019s built-in web\nserver just to make sure we\u2019ve got everything wired up correctly. If you\nhaven\u2019t already done so, be sure you have PHP 7.2 or newer installed in your\nenvironment.\n\nCreate a project directory with a public directory in it, and then inside it\ncreate index.php with the following code.\n\n    \n    \n    <?php declare(strict_types=1); echo 'Hello, world!';\n\nNote that we\u2019re declaring strict typing here\u2014which is something you should do\nat the top of every PHP file in your app\u2014because type hints are important for\ndebugging and clearly communicating intent to developers that come behind you.\n\nNavigate to your project directory using a command-line tool (like Terminal on\nmacOS) and start PHP\u2019s built-in web server.\n\n    \n    \n    php -S localhost:8080 -t public/\n\nNow load http://localhost:8080/ in your browser. See \u201cHello, world!\u201d without\nany errors?\n\nAwesome. Now let\u2019s move on to the meat and potatoes!\n\n## # Autoloading and Third-Party Packages\n\nWhen you first started with PHP, you may have used includes or requires\nstatements throughout your app to bring in functionality or configuration from\nother PHP files. In general, we want to avoid that because it makes it much\nharder for a human to follow the code path and understand where dependencies\nlie. That makes debugging a real nightmare.\n\nThe solution is autoloading. Autoloading just means that when your application\nneeds to use a class, PHP knows where to look for it and automatically loads\nit when it\u2019s called for. It\u2019s been available since PHP 5, but its usage really\nstarted picking up steam with the introduction of PSR-0 (the autoloading\nstandard that has since been superseded by PSR-4).\n\nWe could go through the rigamarole of writing our own autoloader, but since\nwe\u2019re going to use Composer to manage third-party dependencies and it already\nincludes a perfectly serviceable autoloader, let\u2019s just use that one.\n\nMake sure you\u2019ve got Composer installed on your system. Then setup Composer\nfor this project.\n\n    \n    \n    composer init\n\nThis will take you through an interactive guide to generate your composer.json\nconfiguration file. Once that\u2019s done, open it in an editor and add the\nautoload field so it looks something like this. (This makes sure the\nautoloader knows where to look to find our app\u2019s classes.)\n\n    \n    \n    { \"name\": \"kevinsmith/no-framework\", \"description\": \"An example of a modern PHP application bootstrapped without a framework.\", \"type\": \"project\", \"require\": {}, \"autoload\": { \"psr-4\": { \"ExampleApp\\\\\": \"src/\" } } }\n\nNow install composer for this project, which brings in any dependencies (if we\nhad any yet) and sets up the autoloader for us.\n\n    \n    \n    composer install\n\nUpdate public/index.php to bring in the autoloader. Ideally this is one of the\nfew \u201cinclude\u201d statements you\u2019ll use in your app.\n\n    \n    \n    <?php declare(strict_types=1); require_once dirname(__DIR__) . '/vendor/autoload.php'; echo 'Hello, world!';\n\nIf you reload your app in the browser, you won\u2019t see anything different. The\nautoloader is there, it\u2019s just not doing any heavy lifting for us. Let\u2019s move\nthe Hello, world! example to an autoloaded class to see how that works.\n\nCreate a new directory from the project root called src, and inside it add\nHelloWorld.php with the following code.\n\n    \n    \n    <?php declare(strict_types=1); namespace ExampleApp; class HelloWorld { public function announce(): void { echo 'Hello, autoloaded world!'; } }\n\nNow in public/index.php, replace the echo statement with a call to the\nannounce method on the HelloWorld class.\n\n    \n    \n    // ... require_once dirname(__DIR__) . '/vendor/autoload.php'; $helloWorld = new \\ExampleApp\\HelloWorld();$helloWorld->announce();\n\nReload your app in the browser to see the new message!\n\n## # What is Dependency Injection?\n\nDependency Injection is a programming technique where each dependency is\nprovided to a class that requires it rather than that class reaching outside\nitself to get the information or functionality it needs.\n\nFor example, let\u2019s say a class method in your application needs to read from\nthe database. For that, you\u2019ll need a database connection. A common technique\nis to create a new connection with credentials retrieved from the global\nspace.\n\n    \n    \n    class AwesomeClass { public function doSomethingAwesome() { $dbConnection = new \\PDO( \"{$_ENV['type']}:host={$_ENV['host']};dbname={$_ENV['name']}\", $_ENV['user'], $_ENV['pass'] ); // Make magic happen with $dbConnection } }\n\nBut that\u2019s messy, it puts responsibilities in this method that don\u2019t really\nbelong here\u2014creating a new DB connection object, retrieving credentials, and\nhandling any issues that might come up if the connection fails\u2014and it leads to\na lot of code duplication across the app. If you ever try to unit test this\nclass, you\u2019ll find that you can\u2019t. This class is tightly coupled to both the\napp environment and the database.\n\nInstead, why not be as clear as possible about what your class needs to begin\nwith? Let\u2019s just require that the PDO object be injected into the class in the\nfirst place.\n\n    \n    \n    class AwesomeClass { private $dbConnection; public function __construct(\\PDO $dbConnection) { $this->dbConnection = $dbConnection; } public function doSomethingAwesome() { // Make magic happen with $this->dbConnection } }\n\nThat\u2019s a lot cleaner, easier to understand, and less prone to bugs. Through\ntype hinting and dependency injection, the method declares exactly what it\nneeds to do its job and gets it without calling up an external dependency from\ninside itself. When it comes to unit testing, we\u2019re in great shape to mock up\na database connection and pass it in.\n\nNow a dependency injection container is a tool that you wrap around your\nentire application to handle the job of creating and injecting those\ndependencies. The container is not required to be able to use the technique of\ndependency injection, but it helps considerably as your application grows and\nbecomes more complex.\n\nWe\u2019ll use one of the most popular DI containers for PHP: the aptly named PHP-\nDI. (Worth noting that its docs have a different way of explaining dependency\ninjection that may be helpful to some readers.)\n\n## # The Dependency Injection Container\n\nNow that we\u2019ve got Composer set up, it\u2019s pretty painless to install PHP-DI.\nHead back over to your command line to install it.\n\n    \n    \n    composer require php-di/php-di\n\nUpdate public/index.php to configure and build the container.\n\n    \n    \n    // ... require_once dirname(__DIR__) . '/vendor/autoload.php'; $containerBuilder = new \\DI\\ContainerBuilder();$containerBuilder->useAutowiring(false);$containerBuilder->useAttributes(false);$containerBuilder->addDefinitions([ \\ExampleApp\\HelloWorld::class => \\DI\\create(\\ExampleApp\\HelloWorld::class)]); $container = $containerBuilder->build(); $helloWorld = $container->get(\\ExampleApp\\HelloWorld::class);$helloWorld->announce();\n\nNothing earth-shattering going on yet. It\u2019s still a simple example with\neverything in one file so that it\u2019s easy to see what\u2019s going on.\n\nSo far, we\u2019re just configuring the container so that we must explicitly\ndeclare dependencies (rather than using autowiring or attributes), and\nretrieving the HelloWorld object from the container.\n\nA brief aside: Autowiring is a great feature offered by many DI containers to\nhelp minimize mindless configuration, but we\u2019re disabling it in this tutorial\nto maximize learning. Explicitly configuring all dependencies here will give\nyou a much better understanding for what an autowiring DI container is doing\nunder the hood.\n\nLet\u2019s make things even easier to read by importing namespaces where we can.\n\n    \n    \n    <?php declare(strict_types=1); use DI\\ContainerBuilder;use ExampleApp\\HelloWorld;use function DI\\create; require_once dirname(__DIR__) . '/vendor/autoload.php'; $containerBuilder = new ContainerBuilder();$containerBuilder->useAutowiring(false); $containerBuilder->useAttributes(false); $containerBuilder->addDefinitions([ HelloWorld::class => create(HelloWorld::class)]); $container = $containerBuilder->build(); $helloWorld = $container->get(HelloWorld::class);$helloWorld->announce();\n\nAs it stands right now, this just looks like a lot of extra fuss to do what we\nwere already doing before.\n\nNot to worry, the container comes in handy when we add a few other tools to\nhelp direct the request through our application. They\u2019ll use the container to\nload the right classes when and where we need them.\n\n## # Middleware\n\nIf you imagine your application like an onion with requests coming in from the\noutside, going to the center of the onion, and going back out as responses,\nthen middleware is each layer of the onion receiving the request, potentially\ndoing something with that request, and either passing it on to the layer below\nit or creating a response and sending it back up to the layer above it. (That\ncan happen if the middleware is checking for a certain condition that the\nrequest does not satisfy, like requesting a non-existent route.)\n\nIf the request makes it all the way through, the app will process it and turn\nit into a response, and each middleware in reverse order will receive the\nresponse, potentially modify it, and pass it on to the next middleware.\n\nA sampling of use cases where middleware can shine:\n\n  * Debugging issues in development\n  * Gracefully handling exceptions in production\n  * Rate-limiting incoming requests\n  * Responding to incoming requests for unsupported media types\n  * Handling CORS\n  * Routing requests to the appropriate handler class\n\nIs middleware the only way to implement tools for handling these sorts of\nthings? Not at all. But middleware implementations make the request/response\ncycle that much clearer for you, which means debugging is that much easier and\ndevelopment is that much quicker.\n\nWe\u2019ll take advantage of middleware for the last use case listed above:\nrouting.\n\n## # Routing\n\nA router uses information from an incoming request to figure out which class\nshould handle it. (e.g. The URI /products/purple-dress/medium should be\nhandled by ProductDetails::class with purple-dress and medium passed in as\narguments.)\n\nFor our example app, we\u2019ll use the popular FastRoute router through a PSR-15\ncompatible middleware implementation.\n\n## # The Middleware Dispatcher\n\nTo get our app to work with the FastRoute middleware\u2014and any other middleware\nwe install\u2014we\u2019ll need a middleware dispatcher.\n\nPSR-15 is a middleware standard that defines interfaces for both middleware\nand dispatchers (called \u201crequest handlers\u201d in the spec), allowing\ninteroperability amongst a wide variety of middleware and dispatchers. We just\nneed to choose a PSR-15 compatible dispatcher, and we can be sure it\u2019ll work\nwith any PSR-15 compatible middleware.\n\nLet\u2019s install Relay as the dispatcher.\n\n    \n    \n    composer require relay/relay\n\nAnd since the PSR-15 middleware spec requires implementations to pass along\nPSR-7 compatible HTTP messages, we\u2019ll use Laminas Diactoros as our PSR-7\nimplementation.\n\n    \n    \n    composer require laminas/laminas-diactoros\n\nLet\u2019s get Relay ready to accept middleware.\n\n    \n    \n    // ... use DI\\ContainerBuilder; use ExampleApp\\HelloWorld; use Relay\\Relay;use Laminas\\Diactoros\\ServerRequestFactory;use function DI\\create; // ... $container = $containerBuilder->build(); $middlewareQueue = []; $requestHandler = new Relay($middlewareQueue);$requestHandler->handle(ServerRequestFactory::fromGlobals());\n\nWe\u2019re using ServerRequestFactory::fromGlobals() on line 16 to pull together\nall the information necessary to create a new Request and hand it off to\nRelay. This is where Request enters our middleware stack.\n\nNow let\u2019s add the FastRoute and request handler middleware. (FastRoute\ndetermines if a request is valid and can actually be handled by the\napplication, and the request handler sends Request to the handler configured\nfor that route in the routes definition.)\n\n    \n    \n    composer require middlewares/fast-route middlewares/request-handler\n\nAnd define the route to our Hello, world! handler class. We\u2019ll use a /hello\nroute here to show that a route other than the base URI works.\n\n    \n    \n    // ... use DI\\ContainerBuilder; use ExampleApp\\HelloWorld; use FastRoute\\RouteCollector;use Middlewares\\FastRoute;use Middlewares\\RequestHandler;use Relay\\Relay; use Laminas\\Diactoros\\ServerRequestFactory; use function DI\\create; use function FastRoute\\simpleDispatcher; // ... $container = $containerBuilder->build(); $routes = simpleDispatcher(function (RouteCollector $r) { $r->get('/hello', HelloWorld::class);}); $middlewareQueue[] = new FastRoute($routes);$middlewareQueue[] = new RequestHandler(); $requestHandler = new Relay($middlewareQueue); $requestHandler->handle(ServerRequestFactory::fromGlobals());\n\nFor this to work, you\u2019ll also need to update HelloWorld to make it an\ninvokable class, meaning that the class can be called as if it were a\nfunction.\n\n    \n    \n    // ... class HelloWorld { public function __invoke(): void { echo 'Hello, autoloaded world!'; exit; } }\n\n(Note the added exit; in the __invoke() magic method. We\u2019ll get to that in a\nsecond\u2014just didn\u2019t want you to miss it.)\n\nNow load http://localhost:8080/hello and bask in your success!\n\n## # The Glue that Holds it All Together\n\nThe astute reader will quickly notice that although we\u2019re still going to the\ntrouble of configuring and building the DI container, it\u2019s not actually doing\nanything for us. The dispatcher and middleware can do their job without it.\n\nSo when does it come into play?\n\nWell, what if\u2014as would nearly always be the case in a real application\u2014the\nHelloWorld class has a dependency?\n\nLet\u2019s introduce a trivial dependency and see what happens.\n\n    \n    \n    // ... class HelloWorld { private $foo; public function __construct(string $foo) { $this->foo = $foo; } public function __invoke(): void { echo \"Hello, {$this->foo} world!\"; exit; } }\n\nReload the browser, and...\n\nYikes.\n\nLook at that ArgumentCountError.\n\nThat\u2019s happening because now HelloWorld requires a string to be injected at\nconstruction time in order to do its job, and it\u2019s been left hanging. This is\nwhere the container helps out.\n\nLet\u2019s define that dependency in the container and pass the container to\nRequestHandler to resolve it.\n\n    \n    \n    // ... use Laminas\\Diactoros\\ServerRequestFactory; use function DI\\create; use function DI\\get;use function FastRoute\\simpleDispatcher; // ... $containerBuilder->addDefinitions([ HelloWorld::class => create(HelloWorld::class) ->constructor(get('Foo')), 'Foo' => 'bar']); $container = $containerBuilder->build(); // ... $middlewareQueue[] = new FastRoute($routes); $middlewareQueue[] = new RequestHandler($container); $requestHandler = new Relay($middlewareQueue); $requestHandler->handle(ServerRequestFactory::fromGlobals());\n\nVoil\u00e0! You should see \u201cHello, bar world!\u201d when you reload the browser.\n\n## # Properly Sending Responses\n\nRemember earlier when I made a point of mentioning the exit statement sitting\nin HelloWorld?\n\nWell that\u2019s a quick and dirty way to make sure we get a simple response while\nwe\u2019re building things out, but it\u2019s not the best way to send output to the\nbrowser. Such a crude technique gives HelloWorld the additional job of\nresponding\u2014which should really be the responsibility of another class\u2014it\novercomplicates sending proper headers and status codes, and it shuts down the\napp without giving the middleware that comes after HelloWorld a chance to run.\n\nRemember, each middleware has the opportunity to modify Request on its way\ninto our app and (in reverse order) modify the response on its way out of the\napp. In addition to the common interface for Request, PSR-7 also defines the\nstructure for another HTTP message that will help us out on the back half of\nthat cycle: Response. (If you want to really get into the nuts and bolts, read\nall about HTTP messages and what makes PSR-7 Request and Response standards so\ngreat.)\n\nUpdate HelloWorld to return a Response.\n\n    \n    \n    // ... namespace ExampleApp; use Psr\\Http\\Message\\ResponseInterface; class HelloWorld { private $foo; private $response; public function __construct( string $foo, ResponseInterface $response ) { $this->foo = $foo; $this->response = $response; } public function __invoke(): ResponseInterface { $response = $this->response->withHeader('Content-Type', 'text/html'); $response->getBody() ->write(\"<html><head></head><body>Hello, {$this->foo} world!</body></html>\"); return $response; }}\n\nAnd update the container definition to provide HelloWorld with a fresh\nResponse object.\n\n    \n    \n    // ... use Middlewares\\RequestHandler; use Relay\\Relay; use Laminas\\Diactoros\\Response;use Laminas\\Diactoros\\ServerRequestFactory; use function DI\\create; // ... $containerBuilder->addDefinitions([ HelloWorld::class => create(HelloWorld::class) ->constructor(get('Foo'), get('Response')), 'Foo' => 'bar', 'Response' => function() { return new Response(); },]); $container = $containerBuilder->build(); // ...\n\nIf you reload the page now though, you\u2019ll get a blank screen. Our app is\nreturning a proper Response object from the middleware dispatcher, but then...\nwhat?\n\nDoing nothing with it, that\u2019s what.\n\nWe need one more tool to wrap things up: an emitter. An emitter sits between\nyour app and the web server (Apache, nginx, etc.) that will send your response\nto the client that initiated the request. It essentially takes the Response\nobject and translates it into instructions that a server API can understand.\n\nLet\u2019s pull in Narrowspark\u2019s HTTP Emitter.\n\n    \n    \n    composer require narrowspark/http-emitter\n\nUpdate public/index.php to receive Response from the dispatcher and pass it\noff to the emitter.\n\n    \n    \n    // ... use Middlewares\\FastRoute; use Middlewares\\RequestHandler; use Narrowspark\\HttpEmitter\\SapiEmitter;use Relay\\Relay; use Laminas\\Diactoros\\Response; // ... $requestHandler = new Relay($middlewareQueue); $response = $requestHandler->handle(ServerRequestFactory::fromGlobals()); $emitter = new SapiEmitter();return $emitter->emit($response);\n\nReload your browser, and we\u2019re back in business! And this time with a far more\nrobust way of handling responses.\n\nLine 15 in the code example above is where the request/response cycle ends in\nour app and the web server takes over.\n\nNote that for the sake of the example, the emitter configuration we\u2019re using\nhere is very straightforward. Though it can be a bit more complex, a real app\nshould be configured to automatically use a streaming emitter for large\ndownloads. The documentation for Laminas\u2019s HTTP Request Handler Runner, a\ncombo PSR-15 dispatcher and PSR-7 emitter, discusses one interesting way to\naccomplish this.\n\n## # Wrapping Up\n\nSo there you have it. With just 44 lines and the help of several widely-used,\nthoroughly-tested, reliably interoperable components, we have the bootstrap\nfor a modern PHP application. It\u2019s compliant with PSR-4, PSR-7, PSR-11, and\nPSR-15, which means you can use your pick of any of a broad range of vendors\u2019\nimplementations of those standards for your HTTP messages, DI container,\nmiddleware, and middleware dispatcher.\n\nWe dove deep into some of the technology and reasoning behind our decisions,\nbut I hope you can see just how simple it is to bootstrap a new application\nwithout the cruft of a framework. Perhaps more importantly, I hope you\u2019re\nbetter prepared to work these techniques into an existing application when the\nneed arises.\n\nHave a look at the GitHub repo for this example app, and feel free to fork it\nor download it.\n\nIf you\u2019re looking for more great sources for high-quality, decoupled packages,\nI wholeheartedly recommend checking out Aura, The League of Extraordinary\nPackages, Symfony components, Laminas components, Paragon Initiative\u2019s\nsecurity-focused libraries, and this list of PSR-15 middleware.\n\nIf you were to use this example code in production, you\u2019d probably want to\nbreak the routes and container definitions out into their own files so that\nthey\u2019re easier to maintain as the complexity grows. I\u2019d also recommend\nimplementing EmitterStack for smart handling of file downloads and other large\nresponses.\n\nBe sure to read the follow-up: \u201cDidn\u2019t you just build your own framework?\u201d\n\nAny questions, confusion, or suggestions for improvement? Gimme a shout.\n\nUpdated on Jan 12, 2019: Updated all libraries, and bumped the PHP requirement\nto 7.2, the minimum actively supported version of PHP. The latest version of\nZend Diactoros no longer includes an emitter, so the Properly Sending\nResponses section was updated to use Narrowspark\u2019s emitter instead. It was an\nabsolutely seamless replacement, too. Really highlights how wonderful those\nPSRs can be!\n\nUpdated on March 24, 2019: Since originally publishing this post, I\u2019ve been\npersuaded to rethink my stance on autowiring. The benefits are undeniable:\n\n  * Development is generally faster, and with a much lower \u201ccost\u201d to adding new dependencies to a class, there\u2019s one less argument against breaking up responsibilities into separate classes.\n  * Autowiring generally only works with type-hinted parameters, which naturally discourages primitive obsession.\n  * Comprehensibility is improved because container configuration cruft is gone, leaving you with only meaningful configuration.\n\nAs with any \u201cmagic\u201d, autowiring should be carefully considered before\nenabling, but modern DI containers handle it quite sensibly. For example, PHP-\nDI only autowires concrete classes, so there\u2019s no possibility of ambiguity,\nand Symfony\u2019s service container will throw an unavoidable exception in dev\nenvironments if there\u2019s any ambiguity about which dependency should be\nprovided.\n\nUpdated on Dec 31, 2022: Zend was renamed Laminas some time back, so the\ntutorial now uses the equivalent Laminas packages instead.\n\nUpdated on Apr 9, 2024: PHP-DI's Annotations were replaced by PHP's native\nAttributes in version 7. Thanks to surreal30 for the PR to keep the example\nrepo updated.\n\n\u00a9 2024 Kevin Smith\n\n", "frontpage": false}
