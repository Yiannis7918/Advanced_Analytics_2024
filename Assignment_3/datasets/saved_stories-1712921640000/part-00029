{"aid": "40009480", "title": "Monads in 15 minutes: Backtracking and Maybe (2007)", "url": "http://www.randomhacks.net/2007/03/12/monads-in-15-minutes/", "domain": "randomhacks.net", "votes": 1, "user": "Tomte", "posted_at": "2024-04-12 04:48:11", "comments": 0, "source_title": "Monads in 15 minutes: Backtracking and Maybe", "source_text": "Monads in 15 minutes: Backtracking and Maybe | Random Hacks\n\nRandom Hacks\n\nRandom code snippets, projects and musings about software from Eric Kidd, a\ndeveloper and occasional entrepreneur. You're welcome to contact me!\n\n# Monads in 15 minutes: Backtracking and Maybe\n\nMar 12, 2007 \u2022 by Eric Kidd\n\nThis morning, a programmer visited #haskell and asked how to implement\nbacktracking. Not surprisingly, most of the answers involved monads. After\nall, monads are ubiquitous in Haskell: They\u2019re used for IO, for probability,\nfor error reporting, and even for quantum mechanics. If you program in\nHaskell, you\u2019ll probably want to understand monads. So where\u2019s the best place\nto start?\n\nA friend of mine claims he didn\u2019t truly understand monads until he understood\njoin. But once he figured that out, everything was suddenly obvious. That\u2019s\nthe way it worked for me, too. But relatively few monad tutorials are based on\njoin, so there\u2019s an open niche in a crowded market.\n\nThis monad tutorial uses join. Even better, it attempts to cram everything you\nneed to know about monads into 15 minutes. (Hey, everybody needs a gimmick,\nright?)\n\n### Backtracking: The lazy way to code\n\nWe begin with a backtracking constraint solver. The idea: Given possible\nvalues for x and y, we want to pick those values which have a product of 8:\n\n    \n    \n    solveConstraint = do x <- choose [1,2,3] y <- choose [4,5,6] guard (x*y == 8) return (x,y)\n\nEvery time choose is called, we save the current program state. And every time\nguard fails, we backtrack to a saved state and try again. Eventually, we\u2019ll\nhit the right answer:\n\n    \n    \n    > take 1 solveConstraint [(2,4)]\n\nLet\u2019s build this program step-by-step in Haskell. When we\u2019re done, we\u2019ll have\na monad.\n\n### Implementing choose\n\nHow can we implement choose in Haskell? The obvious version hits a dead-end\nquickly:\n\n    \n    \n    -- Pick one element from the list, saving -- a backtracking point for later on. choose :: [a] -> a choose xs = ...\n\nWe could be slightly sneakier, and return all the possible choices as a list.\nWe\u2019ll use Choice whenever we talk about these lists, just to keep things\nclear:\n\n    \n    \n    type Choice a = [a] choose :: [a] -> Choice a choose xs = xs\n\nRunning this program returns all the possible answers:\n\n    \n    \n    > choose [1,2,3] [1,2,3]\n\nNow, since Haskell is a lazy language, we can work with infinite numbers of\nchoices, and only compute those we actually need:\n\n    \n    \n    > take 3 (choose [1..]) [1,2,3]\n\nBecause Haskell doesn\u2019t compute answers until we ask for them, we get the\nactual backtracking for free!\n\n### Combining several choices\n\nNow we have the list [1,2,3] from our example. But what about the list\n[4,5,6]? Let\u2019s ignore guard for a minute, and work on getting the final pairs\nof numbers, unfiltered by any constraint.\n\nFor each item in the first list, we need to pair it with every item in the\nsecond list. We can do that using map and the following helper function:\n\n    \n    \n    pair456 :: Int -> Choice (Int,Int) pair456 x = choose [(x,4), (x,5), (x,6)]\n\nSure enough, this gives us all 9 combinations:\n\n    \n    \n    > map pair456 (choose [1,2,3]) [[(1,4),(1,5),(1,6)], [(2,4),(2,5),(2,6)], [(3,4),(3,5),(3,6)]]\n\nBut now we have two layers of lists. We can fix that using join:\n\n    \n    \n    join :: Choice (Choice a) -> Choice a join choices = concat choices\n\nThis collapses the two layers into one:\n\n    \n    \n    > join (map pair456 (choose [1,2,3])) [(1,4),(1,5),(1,6), (2,4),(2,5),(2,6), (3,4),(3,5),(3,6)]\n\nNow that we have join and map, we have two-thirds of a monad! (Math trivia: In\ncategory theory, join is usually written \u03bc.)\n\nIn Haskell, join and map are usually combined into a single operator:\n\n    \n    \n    -- Hide the standard versions so we can -- reimplement them. import Prelude hiding ((>>=), return) (>>=) :: Choice a -> (a -> Choice b) -> Choice b choices >>= f = join (map f choices)\n\nThis allows us to simplify our example even further:\n\n    \n    \n    > choose [1,2,3] >>= pair456 [(1,4),(1,5),(1,6), (2,4),(2,5),(2,6), (3,4),(3,5),(3,6)]\n\n### Completing our monad: return\n\nWe\u2019re getting close! We only need to define the third monad function (and then\nfigure out what to do about guard).\n\nThe missing function is almost too trivial to mention: Given a single value of\ntype a, we need a convenient way to construct a value of type Choice a:\n\n    \n    \n    return :: a -> Choice a return x = choose [x]\n\n(More math trivia: return is also known as unit and \u03b7. That\u2019s a lot of names\nfor a very simple idea.)\n\nLet\u2019s start assembling the pieces. In the code below, (\\x -> ...) creates a\nfunction with a single argument x. Pay careful attention to the parentheses:\n\n    \n    \n    makePairs :: Choice (Int,Int) makePairs = choose [1,2,3] >>= (\\x -> choose [4,5,6] >>= (\\y -> return (x,y)))\n\nWhen run, this gives us a list of all possible combinations of x and y:\n\n    \n    \n    > makePairs [(1,4),(1,5),(1,6), (2,4),(2,5),(2,6), (3,4),(3,5),(3,6)]\n\nAs it turns out, this is a really common idiom, so Haskell provides some nice\nsyntactic sugar for us:\n\n    \n    \n    makePairs' :: Choice (Int,Int) makePairs' = do x <- choose [1,2,3] y <- choose [4,5,6] return (x,y)\n\nThis is equivalent to our previous implementation:\n\n    \n    \n    > makePairs' [(1,4),(1,5),(1,6), (2,4),(2,5),(2,6), (3,4),(3,5),(3,6)]\n\n### The final piece: guard\n\nIn our backtracking monad, we can represent failure as a choice between zero\noptions. (And indeed, this is known as the \u201czero\u201d for our monad. Not all\nuseful monads have zeros, but you\u2019ll see them occasionally.)\n\n    \n    \n    -- Define a \"zero\" for our monad. This -- represents failure. mzero :: Choice a mzero = choose [] -- Either fail, or return something -- useless and continue the computation. guard :: Bool -> Choice () guard True = return () guard False = mzero\n\nAnd now we\u2019re in business:\n\n    \n    \n    solveConstraint = do x <- choose [1,2,3] y <- choose [4,5,6] guard (x*y == 8) return (x,y)\n\nNote that since the return value of guard is boring, we don\u2019t actually bind it\nto any variable. Haskell treats this as if we had written:\n\n    \n    \n    -- \"_\" is an anonymous variable. _ <- guard (x*y == 8)\n\nThat\u2019s it!\n\n    \n    \n    > take 1 solveConstraint [(2,4)]\n\n### Another monad: Maybe\n\nEvery monad has three pieces: return, map and join. This pattern crops up\neverywhere. For example, we can represent a computation which might fail using\nthe Maybe monad:\n\n    \n    \n    returnMaybe :: a -> Maybe a returnMaybe x = Just x mapMaybe :: (a -> b) -> Maybe a -> Maybe b mapMaybe f Nothing = Nothing mapMaybe f (Just x) = Just (f x) joinMaybe :: Maybe (Maybe a) -> Maybe a joinMaybe Nothing = Nothing joinMaybe (Just x) = x\n\nOnce again, we can use do to string together individual steps which might\nfail:\n\n    \n    \n    tryToComputeX :: Maybe Int tryToComputeX = ... maybeExample :: Maybe (Int, Int) maybeExample = do x <- tryToComputeX y <- tryToComputeY x return (x,y)\n\nOnce you can explain how this works, you understand monads. And you\u2019ll start\nto see this pattern everywhere. There\u2019s something deep about monads and\nabstract algebra that I don\u2019t understand, but which keeps cropping up over and\nover again.\n\n### Miscellaneous notes\n\nIn Haskell, monads are normally defined using the Monad type class. This\nrequires you to define two functions: return and >>=. The map function for\nmonads is actually named fmap, and you can find it in the Functor type class.\n\nAlso, every monad should obey three fairly reasonable rules if you don\u2019t want\nbad things to happen:\n\n    \n    \n    -- Adding and collapsing an outer layer -- leaves a value unchanged. join (return xs) == xs -- Adding and collapsing an inner layer -- leaves a value unchanged. join (fmap return xs) == xs -- Join order doesn't matter. join (join xs) == join (fmap join xs)\n\nThat\u2019s it! For more information, see Wadler\u2019s Monads for Functional\nProgramming and the excellent All About Monads tutorial. And if you liked the\nbacktracking monad, you\u2019ll also like The Reasoned Schemer.\n\n(This tutorial is dedicated to \u201civanm\u201d on #haskell. I hope this helps! And\nmany thanks to Reg Braithwaite for commenting on an early draft.)\n\nUpdate: Replaced mult456 with pair456, and explained what\u2019s going on with\nguard in the final backtracking example.\n\n### More posts\n\n  * Pair programming with ChatGPT: A simple dice roller\n  * Smart classification using Bayesian monads in Haskell\n  * 8 ways to report errors in Haskell\n  * How to make Data.Set a monad\n  * Robot localization using a particle system monad\n\nWant to contact me about this article? Or if you're looking for something else\nto read, here's a list of popular posts.\n\nDan P wrote on Mar 12, 2007:\n\nThree cheers for 'join'! The function 'join' has an important advantage over\n'bind' - it's not a higher order function. I think this may be what makes it\neasier to grasp for some people.\n\nivanm wrote on Mar 12, 2007:\n\nThanks for this! It makes the monad concept a little easier. But now you've\ndefined a new error type of mzero ;) The only thing that confuses me (as I\ndon't have a Haskell interpreter handy to play with) is how \"guard (x*y == 8)\"\nworks... aren't x and y lists? Or does it try every value of the two lists\ncompared to each other?\n\nEric wrote on Mar 12, 2007:\n\nOops! I should have explained that better. I may update the main post later,\nbut for now, here are some notes. First, guard (x*y == 8) in the do-body is\nshort for ignored <\\- guard (x*y == 8). So you're really looking at this:\nsolveConstraint :: Choice (Int,Int) solveConstraint = choose [1,2,3] >>= (\\x\n-> choose [4,5,6] >>= (\\y -> guard (x*y==8) >>= (\\ignored -> return (x,y))))\nAs to why x and y are integers, not lists: Remember that xs >>= f is just join\n(map f xs). So the individual bindings expand to something that looks like:\njoin (map (\\x -> ...) xs) ...where x is clearly bound to an individual value\nfrom xs. When I'm trying to understand something like this, I have the most\nluck if I go over things a couple of times (and maybe write a test program or\ntwo). Reading this kind of Haskell is more like reading math than it is like\nreading regular code. Definitely a chance of pace. :-) Good luck, and please\ndon't hesitate to ask if you have any more questions!\n\nquicksilver wrote on Mar 13, 2007:\n\nActually map for Monads isn't called 'fmap' it's called liftM, and you can\ndefine liftM given >>= and return (liftM f xs = xs >>= return.f). Monads in\nhaskell aren't automatically Functors, although by rights they should be, and\ngiven a Monad you should get a valid functor instance using fmap = liftM. The\nconcept of failure, in monads which have it, is very powerful though. Nice\ntutorial.\n\nEric wrote on Mar 13, 2007:\n\nquicksilver: Thanks for the kind words! And yeah, I'm exceedingly annoyed that\nHaskell monads aren't automatically functors. But they should be! :-) You're\nabsolutely right that liftM is guaranteed to exist, and that fmap is left up\nto the whims of library authors. But still, the connection between fmap and\nmonads is pretty important from a mathematical perspective.\n\npetekaz wrote on Mar 13, 2007:\n\nI don't understand the guard (x*y==8) piece of the puzzle. If the result of\nthis is bound to ignored, I'm missing in the case of guard True, how does it\nreturn (x,y). And then conversely, in the case of guard False, why does it\nskip return (x,y)?\n\nEric wrote on Mar 13, 2007:\n\npetekaz: Yup, that's the tricky bit. guard returns either [()] (if is succeeds), or [] (if it fails). So if the guard succeeds, you can imagine it as: -- Only one choice. Pick it and -- continue. choose [()] ...and if it fails: -- No choices, so just give up with -- this branch of the computation. choose [] If we go back to the map example, we can see how it works: > map guard [True,False,False,True] [[()], [], [], [()]] When we call join, two branches of the computation disappear entirely: > join (map guard [True,False,False,True]) [(), ()] So where are the x and y in this example? Well, they're the arguments of the anonymous functions in my previous comment, so they'll be available when we need them in the final step. (It might help to read about closures if none of this makes any sense at all.) Alternatively, are you familiar with list comprehensions? If so, this program is equivalent to: [(x,y) | x <\\- [1,2,3], y <\\- [4,5,6], ignored <\\- if (x*y == 8) then [()] else [] ] If x*y doesn't equal 8, then there are no values to pick from for ignored, and the final (x,y) won't be computed. Anyway, I hope one of these perspectives will help you puzzle it out!\n\nMichael wrote on Mar 14, 2007:\n\nNice article, Eric. Another fun citation of type \"If you like the backtracking\nmonad...\" is Oleg Kiselyov's paper:\nhttp://okmij.org/ftp/Computation/monads.html#LogicT\n\nEric wrote on Mar 14, 2007:\n\nYeah, I was reading that yesterday evening! I recommended it highly for\nanybody who's into backtracking monads.\n\nMiles Gould wrote on Mar 30, 2007:\n\nA friend of mine claims he didn\u2019t truly understand monads until he understood\njoin. There's a reason why category theorists invariably define monads in\nterms of join rather than bind! As for your question about monads and algebra:\nI don't really understand monad transformers myself, so can't help with that\nbit, but there is indeed a deep connection between monads and algebraic\ntheories. Any standard category theory book should help you here - try\nBorceux's Handbook of Categorical Algebra. Or just google for \"category theory\nlecture notes\". I found enlightenment came from considering this: an /algebra/\nfor a monad T on a category C is an object A and a morphism a:TA->A,\nsatisfying some obvious compatibility conditions with eta and mu. Now, what is\nan algebra for the List monad, also known as the \"free monoid\" monad? How\nabout the free group monad? Sorry if I'm teaching you to suck eggs here...\n\nEric wrote on Mar 31, 2007:\n\nInitial algebras are definitely interesting! And they are related to monads,\nat least according to Edmund Robinson\u2019s Variations on Algebra: monadicity and\ngeneralisations of equational theories (which I haven't finished reading yet).\nA monad is a triple (M,\u03b7,\u03bc), where M is a functor, and \u03b7: a \u2192 M a and \u03bc: M (M\na) \u2192 M a are natural transformations. A monad morphism is a transformation\nfrom one monad to another, e.g., (M,\u03b7,\u03bc) \u2192 (M\u2032,\u03b7\u2032,\u03bc\u2032). And you can build\nvarious interesting algebras by composing monad morphisms. And that's the bit\nI still haven't wrapped my brain completely around. :-)\n\nosfameron wrote on Apr 18, 2007:\n\nYour 15 minutes are not my 15 minutes ;-) Some things are still unclear: like\nwhy you need to use \"choose [1,2,3]\" given that that just evaluates to\n[1,2,3]. I have a feeling that might be important though? Still, working\nthrough the code bit by bit is very helpful, and I *almost* understand some of\nit now... though I am still having problems with the guard - I don't\nunderstand how it affects the following return statement. I will give another\n\"15 minutes\" to this tonight if I get a chance...\n\nEric wrote on Apr 18, 2007:\n\nY15MMY: Your 15 minutes may vary. ;-) The choose function does nothing but\nmake the code more readable; it's not actually needed, not even for the type\ndeclaration. The guard is fairly sneaky. If the condition is true, it chooses\na dummy value from a single-element list and throws it away. If the condition\nis false, though, it \"chooses\" an element from an empty list. Imagine, for a\nmoment, the guard condition is always false. We bind x to one of 3 values, and\ny to one of 3 values, giving us 3\u00d73=9 different possible answers. If we\nimagine that the guard condition is always false, it would choose from 0\npossibilities, giving us 3\u00d73\u00d70=0 possible answers. Do you see how the empty\nchoice suppresses answers? It doesn't have to effect the return statement\ndirectly, because we never make it there. Of course, if the guard is only\nfalse some of the time, then it only suppresses certain answers. I hope this\nhelps! Please don't hesitate to ask more questions.\n\nosfameron wrote on Apr 19, 2007:\n\nThanks for the reply: ok, I think I get that better: because >>= is defined in\nterms of map, it combines with the output of guard as well as the unfiltered\n3x3, that's the piece that I wasn't seeing. I think in the description above,\nsaying that the output of guard is \"boring\" maybe throws you off the scent a\nlittle? It's only boring to us in that we don't need a variable bound to it,\nbut it still participates in the join.\n\nSteven Brandt wrote on Jun 27, 2007:\n\nAs an old imperative programmer I can't help but think this is just like:\nfor(int x=1;x<=3;x++) { for(int y=4;y<=6;y++) { if(x*y == 8) { list.append(new\nPair(x,y)); } } } Except the imperative code is a lot easier to understand.\nI'm trying really hard to understand monads and see their value, but I still\ncan't quite get there.\n\nEric wrote on Jun 29, 2007:\n\nSteven: Don't assume that the simplest example of something is also the most\ncompelling. :-) For more interesting monads, see the the paper on composable\nmemory transactions, the various probability monads, sigfpe's article on\ngraph-walking monads, and the paper on using monads for safe hardware\nabstraction (PDF). If you work with .NET, you may also want to check out\nMicrosoft's new LINQ technology, which relies heavily on monads for database\naccess and XML processing. Once you understand monads, you start seeing them\neverywhere--they're very general tools, and they can be used to solve a wide\nvariety of problems. As with any other abstraction, you can do without monads.\nBut if one abstraction solves so many problems so elegantly, it's worth\nlearning about.\n\nErik wrote on Jul 29, 2007:\n\nSo, before going back over this posting using a full fifteen minutes (I just skimmed it), why use an example that could be solved with the following? fun :: [Int] -> [Int] -> [(Int, Int)] fun r s = [(x,y) | x <\\- r, y <\\- s, x*y == 8] I find that when toy problems with both simple and obvious solutions are used to demonstrate hard concepts it can obfuscate the idea because while you may be showing the how of the concept, you aren't explaining the why. Could you maybe show an example of join that wouldn't be simple to express with a simple list comprehension?\n\nEric wrote on Jul 29, 2007:\n\nErik: Well, a list comprehension is a monad. Or, if you want to look at it the\nother way around, a monad is a generalized comprehension that can be defined\nfor almost any parameterized data type. For a more complicated monad, see\nBayes' rule in Haskell. For a rather different monad, see SPJ's papers on\nSoftware Transactional Memory. Basically, by slightly generalizing list\ncomprehensions, you get a tool which solves a surprisingly large and diverse\nset of problems. I'll write a longer post one of these days cataloging a bunch\nof useful monads. Until then, would anyone like to plug their favorite monads?\n:-)\n\nErik wrote on Jul 30, 2007:\n\nEric: Yes, after making that post I went on to read the \"All About Monads\"\nlink you placed at the end of the post and came to that understanding. Thanks!\n\nMichael wrote on Aug 13, 2007:\n\nNice tutorial, maybe would be a good idea to abstract to tuples of arbitrary\nlength instead of just pairs, to make the backtracking even more obvious.\n\nDrew Vogel wrote on Oct 19, 2007:\n\nI understand the Haskell constructs involved in your example, but I had\ntrouble finding the actual backtracking. I learned of backtracking as an\noptimization of a search algorithm that worked by tossing out large chunks of\nthe search space. Because 2*4 is the only combination that equals 8, it isn't\nobvious that the \"take 1\" is throwing out the rest of the problem space.\nPerhaps you could use a combination of the even function and infinite lists to\nincrease the search space and illustrate how you are tossing out a portion of\nthe search space. Also, a single file with the final code would be wonderful.\nIt's hard looking at it outside of vim :)\n\nSampo wrote on Oct 20, 2007:\n\nNow that was helpful. Time well spend even though it was a bit more than 15\nminutes :-) I think you managed to bring me on the verge of understanding\nmonads. I think the Option -monad explanation did it for me... I'm reiterating\njust to see if I really understand: I see the the functions returnMaybe,\nmapMaybe and joinMaybe as 'rules'. For example mapMaybe tells how to handle\nfunction calls where arguments belong to Maybe -monad. 1) If function gets\ncalled with Nothing, the return value will always be Nothing. 2) If function\ngets called with a valid value Just(x), the value x is extracted from Just(x)\nand handed to the function. This ensures the Maybe works as expected but not\nevery function needs to know how to handle them. joinMaybe defines how to\nhandle the returned (nested) values. If the nested values all are\nJust(something) we can get rid of extra Justs and keep values. If there is a\nsingle Nothing, everything will end up being Nothing.\n\nDoug Auclair wrote on Nov 14, 2007:\n\nFinally! (an aside: I did read the LogicT paper) I've been looking for concise\nbacktracking in Haskell. Of course, it's been there all the time, and there's\nbeen several mentions that monads permit backtracking, but your tutorial,\nEric, gave me a simple and clear example. Thank you. I'll start working\nthrough some other (similar) examples. I've also read Reasoned Schemer (Dr.\nWilliam Byrd autographed it for me at the PADL 2006) several times, so I'm\nlooking to combine that and LogicT and your example into a full-blown\n(concise) rule- or relational-based programming system. Backtracking is key,\nbut do I need full unification? Not too sure. Thanks, again.\n\nDoug Auclair wrote on Nov 15, 2007:\n\nOf course, it's been pointed out in other papers about monads that the do\nnotation: do x <\\- choose [1,2,3] ... is very similar to the list compression\nnotation: [x|x <\\- [1,2,3]] (in fact, gopher, Haskell's predecessor, they were\nso similar that they were the same thing) And, seeing that the type Choice is\nan alias for the list type, the monadic expression can simply be rewritten:\n[(x,y)|x<\\- [1,2,3], y<-[4,5,6], x*y == 8] Haskell programmers claim their\nlist compression is even more powerful that Prolog's, and the above example is\ngood supporting evidence ...\n\nDan Dingleberry wrote on Nov 28, 2007:\n\nDude, WTH is a monad? at least define the dang thing first for casual passers\nby.\n\nEric wrote on Nov 29, 2007:\n\nMonads are a somewhat mysterious programming language feature, most commonly\nencountered in Haskell. See the examples I link to in the first paragraph.\nBasically, monads are a clever bit of category theory that can be used to\nstructure control flow in a program. If you weren't already thinking, \"Hmm, I\nreally ought to learn more about monads,\" then you might be happier avoiding\nthe entire topic. :-)\n\nMichael wrote on Nov 29, 2007:\n\nTo add to what Eric wrote, I'd go so far as to say that monads aren't even all\nthat mysterious, but in fact you will have an easier time understanding them\n(at least in terms of their utility to a programmer) if you just forget about\ncategory theory entirely. From a programmer's perspective, a monad is more or\nless a way of factoring out some common code from various types of operations\nthat are composed sequentially. The fact that this is possible seems strange\nat first---and I think that's what leads people to feel monadic types are\nconfusing. Well, that, and the terminology, which can be misleadingly\nabstruse.\n\nDavid wrote on Jan 27, 2008:\n\nThanks for this! I've read a lot about Haskell but I've been confounded by\nmonads. I've read every tutorial I've found and each helps me understand a\nlittle bit more. This one was very helpful. I have an unanswered question\nthough... The map part of a monad doesn't seem to have to be the actual \"map\"\nfunction. The Maybe monad's \"map\" seems to just propagate the Nothing or Just\nalong as appropriate. Is this correct? How does this work in the case of the\nIO monad? I've been staring at the GHC prelude code for the past 15 minutes\nbut I'm not fully comprehending what it is doing. I _think_ its >>= function\nis just doing a function application instead of a \"map\", but I'm not sure\n(that case part is confusing me). I _do_ see the \"join\" where it strips out\nnested IOs. Can anyone help out?\n\nEric wrote on Jan 28, 2008:\n\nDavid: Excellent questions! The \"map\" function used in monads is a\ngeneralization of the regular \"map\". This will make more sense if you think of\n\"Maybe\" as a very specialized container---a container which can only hold a\nsingle element. From that perspective, \"mapMaybe\" looks very natural: mapMaybe\n:: (a -> b) -> Maybe a -> Maybe b mapMaybe f Nothing = Nothing mapMaybe f\n(Just x) = Just (f x) In English, this says: \"If the container is empty, leave\nit that way. If it contains an element, apply 'f' to the element.\" Basically,\nit's no different than applying \"map\" to a zero- or one-element list. As for\nthe IO monad, don't worry too much about it. :-) It's actually a pretty\natypical monad. But if it helps, try reading the type \"IO a\" as \"an IO action\nreturning type a\". Again, if you squint at it right, you can think of an IO\naction as a single-element collection. You just have to some IO to find out\nwhat element is stored in it! The \"mapIO\" function can be defined as:\n\n  1. Perform the IO action and extract the value of type \"a\".\n  2. Calculate \"f a\", and jam the result back into a dummy IO action.\n\nDoes this help any?\n\nJoel Hough wrote on Apr 10, 2008:\n\nGreat article! A few things clicked for me while reading. I found that writing\nout the choice monad example step by step helped me to understand. Like so:\nchoose [1,2,3] >>= (\\x -> choose [4,5,6] >>= (\\y -> guard (x*y==8) >>=\n(\\ignored -> return (x,y)))) is equivalent to... step1 = concat $ map step2\n[1,2,3] step2 x = concat $ map (step3 x) [4,5,6] step3 x y = concat $ map\n(step4 x y) (if x*y == 8 then [()] else []) step4 x y _ = [(x, y)] Thanks for\nthe epiphanies!\n\nDoug Auclair wrote on May 14, 2008:\n\nLinking this article on an introductory post about Maybe, List and Either\nmonads and their uses for nondeterministic programming. Coincidentally, I\nwrote a same-game-like puzzle solver (cf. comp.lang.haskell), where I needed\nto flatten a list of lists. I didn't see `flatten` in the Prelude or List, so\nI wrote it out. I then realized that `msum` is flatten for lists of depth 1\n... then I reread this article where join :: m (m a) \u2192 m a does the same\nthing. Applied that in my code and noticed I had this pattern: join $ map f x\n... and replaced that with x >>= f. *Sigh*! Months later and I'm still not\nrecognizing when to use a simple bind!\n\n## Random Hacks\n\n  * Contact me\n\n  * Portfolio\n  * emk\n  * emk\n\nRandom code snippets, projects and musings about software from Eric Kidd, a\ndeveloper and occasional entrepreneur.\n\n", "frontpage": false}
