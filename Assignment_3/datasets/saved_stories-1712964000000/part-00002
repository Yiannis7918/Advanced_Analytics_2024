{"aid": "40015305", "title": "Using meta data to add custom styles in tanstack table", "url": "https://newbeelearn.com/blog/using-tanstack-table-in-react/", "domain": "newbeelearn.com", "votes": 1, "user": "pdyc", "posted_at": "2024-04-12 17:18:55", "comments": 0, "source_title": "How to add custom styling in tanstack react table", "source_text": "How to add custom styling in tanstack react table \u00b7 Newbeelearn\n\n\u2193Skip to main content\n\nNewbeelearn\n\n# How to add custom styling in tanstack react table\n\n10 April 2024\u00b7Updated: 11 April 2024\u00b71983 words\u00b710 mins\n\nTanstack-Table React\n\nAuthor\n\npdyc\n\nTLDR; How to use tanstack table in react and add custom styling with meta\ncolumn definitions\n\nI recently started using tanstack table in Easyanalytics and faced some issues\nwith styling. In this article i will explain the problem i faced and the\nsolution to the problem using meta data.\n\n## Introduction to Tanstack Table\n\nTanstack Table is a powerful and lightweight headless library for building\ntables. It provides a flexible and extensible API for creating feature-rich\nand highly customizable tables without enforcing a specific UI or styling.\nSome of the features include sorting, searching, filetering and pagination.\n\nThe headless nature of Tanstack Table means that it separates the logic and\nfunctionality from the presentation layer. This allows developers to have\ncomplete control over the UI and styling of their tables while leveraging the\nrobust feature set provided by the library. Tanstack Table can be integrated\nwith any UI framework or component library, such as Material-UI, Chakra UI, or\neven custom-built components.\n\n### Tanstack table with react\n\nTo show tables with tanstack table we need three things data, column\ndefinitions and UI. Column definitions are mapping of fields from data to\ntanstack table, they tell tanstack table about how the data is structured,\ni.e. which fields in data correspond to columns in tanstack table. You can\nalso define how the individual cells of the table would be rendered in UI but\nwe will get to that later. UI is simply displaying of table using normal\nthead, tr and td elements.\n\nHere is the basic example of setting up table. In the example given below\n\"name\" field indicates the name of person so in column we have defined\naccessorKey as \"name\" to indicate that this column will contain all the\nentries of \"name field\", similarly heading of the column indicated by \"name\"\nfield is defined by header.\n\n    \n    \n    // Basic React Table Setup (defining columns, data, and rendering) import React from 'react'; import { useReactTable, flexRender, getCoreRowModel } from '@tanstack/react-table'; // Define the table data const data = [ { name: 'John', age: 25, city: 'New York' }, { name: 'Jane', age: 30, city: 'London' }, { name: 'Bob', age: 35, city: 'Paris' }, ]; // Define the table columns const columns = [ { accessorKey: 'name', header: 'Name' }, { accessorKey: 'age', header: 'Age' }, { accessorKey: 'city', header: 'City' }, ]; export function BlogTable() { const table = useReactTable({ data, columns, getCoreRowModel: getCoreRowModel(), }); return ( <table> <thead> {table.getHeaderGroups().map((headerGroup) => ( <tr key={headerGroup.id}> {headerGroup.headers.map((header) => ( <th key={header.id}> {flexRender(header.column.columnDef.header, header.getContext())} </th> ))} </tr> ))} </thead> <tbody> {table.getRowModel().rows.map((row) => ( <tr key={row.id}> {row.getVisibleCells().map((cell) => ( <td key={cell.id}>{flexRender(cell.column.columnDef.cell, cell.getContext())}</td> ))} </tr> ))} </tbody> </table> ); }\n\nIn this example, we define the table data and columns, and then use the\n`useReactTable` hook from Tanstack Table to create a table instance. We render\nthe table by mapping over the header groups and rows, using the `flexRender`\nutility to render the header and cell content based on the defined column\ndefinitions.\n\nThis basic setup demonstrates how to create a table with Tanstack Table, but\nit doesn't include any custom styling or UI customizations.\n\n## Customizing UI with Tanstack Table\n\nDefining styles for headers and cells: One of the key benefits of using\nTanstack Table is the ability to customize the UI and styling of the table\ncomponents. The library provides hooks and render props that allow you to\ndefine custom styles for table headers and cells.\n\nFor example, you can define custom styles for table headers using the `header`\nproperty of the column definition:\n\n    \n    \n    const columns = [ { accessorKey: 'name', header: () => <span style={{ fontWeight: 'bold' }}>Name</span>, }, // other columns... ];\n\nSimilarly, you can customize the styling of table cells using the `cell`\nproperty:\n\n    \n    \n    const columns = [ { accessorKey: 'age', cell: (info) => <span style={{ color: info.getValue() < 30 ? 'green' : 'red' }}>{info.getValue()}</span>, }, // other columns... ];\n\nLimitations in applying styles to table head, rows, and columns aka the\nproblem of styling table structures: While Tanstack Table provides a flexible\nway to style the content within table headers and cells, there is a limitation\nin applying styles directly to the HTML elements representing the table head\n(`<thead>`), rows (`<tr>`), and columns (`<th>` or `<td>`).\n\nThe styles defined using the `header` and `cell` properties of the column\ndefinitions are applied only to the content rendered within those elements,\nnot to the elements themselves. Not without giving up some flexiblity.\n\nFor example, if you wanted to change the background color of the table header\nor add padding to the table cells, you wouldn't be able to achieve that\ndirectly using the `header` and `cell` properties if you are using them for\nstyling content.\n\nWorkaround 1: Modifying thead, tr, and td elements using IDs and separate CSS\nfiles: One approach to style the table structures is to modify the thead, tr,\nand td elements directly using their IDs and applying styles in separate CSS\nfiles. This can be achieved by adding unique IDs to the rendered elements and\ntargeting them with CSS selectors.\n\nHere's an example of how you can add IDs to the table elements:\n\n    \n    \n    <table> <thead id=\"table-header\"> {/* ... */} </thead> <tbody> {table.getRowModel().rows.map((row, index) => ( <tr key={row.id} id={`table-row-${index}`}> {row.getVisibleCells().map((cell, cellIndex) => ( <td key={cell.id} id={`table-cell-${index}-${cellIndex}`}> {flexRender(cell.column.columnDef.cell, cell.getContext())} </td> ))} </tr> ))} </tbody> </table>\n\nIn this example, we added an id attribute to the <thead>, <tr>, and <td>\nelements with unique values. You can then target these elements in a separate\nCSS file using their IDs:\n\n    \n    \n    /* style.css */ #table-header { background-color: #f0f0f0; } #table-header th { padding: 8px; } #table-row-0 { background-color: #e0e0e0; } #table-cell-0-1 { font-weight: bold; }\n\nWhile this workaround allows you to style the table structures, it also has\nsome drawbacks. It can become cumbersome to manage styles for large tables\nwith many rows and columns, as you need to add unique IDs for each element and\nmaintain the corresponding CSS rules. This also does not works if you are\nusing inline css libraries like tailwindcss. Additionally, it can make the\ncode less readable and harder to maintain, especially if the styling logic\nbecomes more complex.\n\nWorkaround 2: Defining entire `thead` or `td` inside `header` or `cell`:\nAnother approach to overcome this limitation, a common workaround is to define\nthe entire `<thead>` or `<td>` element within the `header` or `cell` property,\nrespectively. This allows you to apply styles to the HTML elements directly.\n\nHere's an example of how you can style the table header using this workaround:\n\n    \n    \n    const columns = [ { accessorKey: 'name', header: () => ( <th style={{ backgroundColor: '#f0f0f0', padding: '8px' }}>Name</th> ), }, // other columns... ];\n\nAnd for styling table cells:\n\n    \n    \n    const columns = [ { accessorKey: 'age', cell: (info) => ( <td style={{ padding: '8px', color: info.getValue() < 30 ? 'green' : 'red' }}> {info.getValue()} </td> ), }, // other columns... ];\n\nWhile this workaround allows us to style the table structures, it also\nintroduces some drawbacks\n\nForced styling of `thead` or `td` for all columns: The workaround of defining\nthe entire `<thead>` or `<td>` element within the `header` or `cell` property,\nrespectively, forces you to define styles for these HTML elements for all\ncolumns, even if you don't need to style some of them.\n\nFor example, if you only want to style the table header for the \"Name\" column\nand leave the other column headers with the default styling, you would still\nneed to define the `<th>` element for all columns within the `header`\nproperty.\n\n    \n    \n    const columns = [ { accessorKey: 'name', header: () => ( <th style={{ backgroundColor: '#f0f0f0', padding: '8px' }}>Name</th> ), }, { accessorKey: 'age', header: () => <th>Age</th>, // Still need to define <th> even without custom styles }, { accessorKey: 'city', header: () => <th>City</th>, // Still need to define <th> even without custom styles }, ];\n\nThis can lead to unnecessary code duplication and make the codebase more\ndifficult to maintain, especially as the number of columns grows.\n\n### Using Meta Data of tanstack table to Overcome Limitations\n\nTanstack Table provides a powerful feature called `meta` that allows you to\ndefine custom properties and behaviors for individual columns. This feature\ncan be used to overcome the limitations of the workaround discussed in the\nprevious section and provide a more flexible and maintainable solution for\nstyling table structures.\n\nWith the `meta` feature, you can define custom rendering functions for the\n`<thead>` and `<td>` elements, which gives you the flexibility to apply styles\nto these elements only when needed.\n\nHere's an example of how you can use `meta` to style the table header for the\n\"Name\" column:\n\n    \n    \n    const columns = [ { accessorKey: 'name', header: 'Name', meta: { headerProps: { style: { backgroundColor: '#f0f0f0', padding: '8px', }, }, }, }, { accessorKey: 'age', header: 'Age' }, { accessorKey: 'city', header: 'City' }, ];\n\nIn this example, we use the `meta.headerProps` property to define custom\nproperties (in this case, styles) for the `<th>` element of the \"Name\" column\nheader. The other columns will use the default `<th>` element styling.\n\nSimilarly, you can use the `meta.cellProps` property to define custom\nproperties for the `<td>` elements of individual columns.\n\nFallback option for unstyled columns One of the key benefits of using `meta`\nis that it provides a fallback option for columns where you don't want to\napply any custom styles. If you don't define any custom properties in the\n`meta` object for a column, Tanstack Table will use the default rendering for\nthe `<thead>` and `<td>` elements.\n\nThis fallback option eliminates the need to explicitly define the HTML\nelements for unstyled columns, as was the case with the workaround discussed\nearlier.\n\nExample Code: Using Meta Data for Styling: Here's an example that demonstrates\nhow to use the `meta` feature for styling table structures:\n\n    \n    \n    import React from 'react'; import { useReactTable, flexRender, getCoreRowModel } from '@tanstack/react-table'; // Define the table data const data = [ { name: 'John', age: 25, city: 'New York' }, { name: 'Jane', age: 30, city: 'London' }, { name: 'Bob', age: 35, city: 'Paris' }, ]; // Define the table columns const columns = [ { accessorKey: 'name', header: 'Name', meta: { headerProps: { style: { backgroundColor: '#f0f0f0', padding: '8px', }, }, }, }, { accessorKey: 'age', header: 'Age' }, { accessorKey: 'city', header: 'City' }, ]; export function BlogTable() { const table = useReactTable({ data, columns, getCoreRowModel: getCoreRowModel(), }); return ( <table> <thead> {table.getHeaderGroups().map((headerGroup) => ( <tr key={headerGroup.id}> {headerGroup.headers.map((header) => ( <th key={header.id} {...header.column.columnDef.meta?.headerProps}> {flexRender(header.column.columnDef.header, header.getContext())} </th> ))} </tr> ))} </thead> <tbody> {table.getRowModel().rows.map((row) => ( <tr key={row.id}> {row.getVisibleCells().map((cell) => ( <td key={cell.id} {...cell.column.columnDef.meta?.cellProps}>{flexRender(cell.column.columnDef.cell, cell.getContext())}</td> ))} </tr> ))} </tbody> </table> ); }\n\nIn this example, we use the `meta.headerProps` property to define custom\nstyles for the \"Name\" column header. For the other columns, we don't define\nany custom properties in `meta`, so Tanstack Table will use the default\nrendering for the `<th>` and `<td>` elements.\n\nBy using the `meta` feature, we've eliminated the need to define the `<th>`\nand `<td>` elements explicitly for unstyled columns, making the code more\nconcise and readable.\n\nAdditionally, the `meta` feature provides a more flexible and maintainable\nsolution for styling table structures, as you can easily add or remove custom\nproperties for individual columns without affecting the rest of the table.\n\n## Conclusion\n\nIn this article, we explored the challenges of styling table structures with\nTanstack Table and the various approaches to overcome these limitations. While\nthe workaround of defining entire `<thead>` or `<td>` elements within the\n`header` or `cell` properties provides a solution, it can lead to code\nduplication and reduced maintainability. Fortunately, Tanstack Table's `meta`\nfeature offers a more flexible and elegant solution, allowing you to add\ncustom styling to `<thead>` and `<td>` elements only when needed, with a\nfallback option for unstyled columns. Although the examples provided were in\nReact, the problems discussed and the solutions presented using the `meta`\nfeature are applicable to any UI framework or component library used with\nTanstack Table.\n\n## Related\n\nComparison of astro themes for saas 2024\n\n15 March 2024\u00b7854 words\u00b75 mins\n\nAstro\n\nTLDR; Comparison of Astro themes for SAAS marketing site and selecting best\ntheme\n\nHow to add search to a website using flexsearch\n\n6 March 2024\u00b72373 words\u00b712 mins\n\nHugo\n\nTLDR; Describes how to implement local search using flexsearch js library to\nwebsite\n\nWhat happens when your article gets on second page of hackernews - 2024\n\n21 February 2024\u00b7958 words\u00b75 mins\n\nHn Analytics\n\nTLDR; Details of traffic volume and other insights when page is featured on\nhackernews and authors lame attempt at humor\n\nHow ChatGPT is making me lazy\n\n20 February 2024\u00b7Updated: 4 April 2024\u00b71141 words\u00b76 mins\n\nAi Chatgpt Cloudflare\n\nTLDR; Describes how author used chatgpt to create workaround for downloading\ndata from cloudflare D1 beta that he would have long given up on if not for\nchatGPT\n\nHow to commit part of file in git\n\n13 February 2024\u00b7Updated: 19 February 2024\u00b7881 words\u00b75 mins\n\nEmacs Git Magit\n\nTLDR; How to commit parts of file or individual lines with Emacs, magit and\ngit cli\n\nHow to use cache in cloudflare workers\n\n7 February 2024\u00b7Updated: 8 February 2024\u00b71297 words\u00b77 mins\n\nCloudflare\n\nTLDR; Explains how to use web cache API in Cloudflare workers.\n\n\u2190 \u2192 Comparison of astro themes for saas 2024 15 March 2024\n\n\u2191\n\n\u00a9 2024 pdyc\n\n", "frontpage": false}
