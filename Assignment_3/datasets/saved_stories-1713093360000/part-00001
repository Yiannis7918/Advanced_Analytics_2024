{"aid": "40028826", "title": "Vulnerability in AWS STS", "url": "https://www.stedi.com/blog/stedi-discovered-an-aws-access-vulnerability", "domain": "stedi.com", "votes": 1, "user": "mparnisari", "posted_at": "2024-04-14 05:14:34", "comments": 0, "source_title": "We discovered an AWS access vulnerability | Stedi - Modern EDI", "source_text": "We discovered an AWS access vulnerability | Stedi - Modern EDI\n\nBlog\n\nApr 9, 2024\n\n# We discovered an AWS access vulnerability\n\nIt\u2019s not AWS.\n\nThere\u2019s no way it\u2019s AWS.\n\nIt was AWS.\n\nWe use AWS IAM extensively throughout our codebase. Last year, we extended our\nuse of IAM to build and enforce role-based access control (RBAC) for our\ncustomers using AWS Security Token Service (STS), an IAM service you can use\nto provide temporary access to AWS resources. Along the way, we discovered a\nvulnerability in STS that caused role trust policy statements to be evaluated\nincorrectly.\n\nYes, you read that right \u2013 during the development process, we found an edge\ncase that would have allowed certain users to gain unauthorized access to\ntheir AWS accounts.\n\nWe caught it before rolling out our RBAC product, and AWS has since corrected\nthe issue and notified all affected users, so you don\u2019t need to hit the panic\nbutton. However, we wanted to share how we discovered this vulnerability, our\ndisclosure process with AWS, and what we learned from the experience.\n\n## How Stedi uses IAM and STS\n\nTo understand how we found the bug, you need to know a bit about Stedi\u2019s\narchitecture.\n\nBehind the scenes, we assign a dedicated AWS account per tenant \u2013 that is,\neach customer account in the Stedi platform is attached to its own separate\nAWS account that contains Stedi resources, such as transactions and trading\npartner configurations. Our customers usually aren\u2019t even aware that the\nunderlying AWS resources exist or that they have a dedicated AWS account\nassigned to them, but using a dedicated AWS account as the tenancy boundary\nhelps ensure data isolation (which is important for regulated industries like\nhealthcare) and also eliminates potential noisy neighbor problems (which is\nimportant for high-volume customers).\n\nWhen a customer takes an action in their account, it triggers a call to a\nresource using a Stedi API, or by calling the underlying AWS resource\ndirectly. One example is filtering processed transactions on the Stedi\ndashboard \u2013 when a customer applies a filter, the browser makes a direct\nrequest to an AWS database that contains the customer\u2019s transaction data. This\napproach significantly reduces the code we need to write and maintain (since\nwe don\u2019t need to rebuild existing AWS APIs) and allows us to focus on shipping\nfeatures and fixes faster.\n\nTo facilitate these requests, Stedi uses AWS STS to provide temporary access\nto AWS IAM policies, allowing the user\u2019s browser session to access their\ncorresponding AWS account. Specifically, we use the STS\nAssumeRoleWithWebIdentity operation, which allows federated users to\ntemporarily assume an IAM role in their AWS account with a specific set of\npermissions.\n\n### IAM tags\n\nOur IAM role trust policies use tags to control who can view and interact with\nresources.\n\nA tag is a custom attribute label (a key:value pair) you can add to an AWS\nresource. There are three tag types you can use to control access in IAM\npolicies:\n\n  * Request: A tag added to a resource during an operation. You can use the aws:RequestTag/key-name condition key to specify what tags can be added, changed, or removed from an IAM user or role.\n\n  * Resource: An existing tag on an AWS resource, such as a tag describing a resource\u2019s environment (\u201cenvironment: production\u201d). You can use the aws:ResourceTag/key-name condition key to specify which tag key-value pair must be attached to the resource to perform an operation.\n\n  * Principal tag: A tag on a user or role performing an operation. You can use the aws:PrincipalTag/key-name condition key to specify what tags must be attached to the user or role before the operation is allowed.\n\n### Assuming roles\n\nHere\u2019s how we set up RBAC for Stedi accounts.\n\nWe give Stedi users a JSON Web Token (JWT) containing the following AWS-\nspecific principal tags:\n\n    \n    \n    \"https://aws.amazon.com/tags\": { \"principal_tags\": { \"StediAccountId\": [ \"39b2f40d-dc59-4j0c-a5e9-37df5d1e6417\" ], \"MemberRole\": [ \"stedi:readonly\" ] } }\n\nThe user can assume a role (specifically, they\u2019re granted a time-bound role\nsession) in their assigned AWS account if the following conditions are true:\n\n  1. The token is issued by the referenced federation service and has the appropriate audience set.\n\n  2. The role has a trust relationship granting access to the specified StediAccountId.\n\n  3. The role has a trust relationship granting access to the specified MemberRole.\n\nThe following snippet from our role trust policy evaluates these requirements\nin the Condition object. For example, we check whether the StediAccountId tag\nin the JWT token is equal to the MappedStediAccountId tag on the AWS account.\n\n    \n    \n    { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [\"sts:AssumeRoleWithWebIdentity\", \"sts:TagSession\"], \"Principal\": { \"Federated\": { \"Ref\": \"ProdOidcProvider\" } }, \"Condition\": { \"StringEquals\": { \"tokens.saas.stedi.com/v1:aud\": \"tenants\", \"aws:RequestTag/StediAccountId\": \"${iam:ResourceTag/MappedStediAccountId}\", \"aws:RequestTag/MemberRole\": \"${iam:ResourceTag/MemberRole}\" } } } ] }\n\nCaption: If the IAM role's resource tag for MappedStediAccountId and\nMemberRole matches the StediAccountId and MemberRole request tag (the JWT\ntoken principal tag), the user can access this role. Otherwise, role access is\ndenied.\n\nWhen assuming a role from a JWT token (or with SAML), STS reads the token\nclaims under the principal_tags object and adds them to the role session as\nprincipal tags.\n\nHowever, during the AssumeRoleWithWebIdentity operation (within the policy\nlogic), you must reference the principal tags from the JWT token as request\ntags because the IAM principal isn\u2019t the one making the request, instead the\ntags are being added to a resource. Existing tags on the role are referenced\nas resource tags because they are tags on the subject of the operation.\n\nThese naming conventions are a bit confusing \u2013 more on that later.\n\n## Discovering the vulnerability\n\nWe set up our role trust policy based on this AWS tutorial, using JWT tokens\ninstead of SAML. Another difference from the tutorial is that our policy uses\nvariables to reference tags instead of hardcoding the values into the\ncondition statements.\n\nFor example, \"${aws:RequestTag/StediAccountId}\":\n\"${iam:ResourceTag/MappedStediAccountId}\" instead of\n\"${aws:RequestTag/StediAccountId}\": 39b2f40d-dc59-4j0c-a5e9-37df5d1e6417\".\n\nDuring development, we began testing to determine whether our fine-grained\naccess controls were working as expected. They were not.\n\n### Finding the bug\n\nAgain and again, our tests gained access to roles above their designated\nauthorization level.\n\nWe scoured the documentation to find the source of the error. The different\ntag types, IAM statement templating, and different (aws vs. iam) prefixes\ncaused extra confusion, and we kept thinking we weren\u2019t reading the\ninstructions correctly. We attempted to use the IAM policy simulator but found\nit lacked support for evaluating role trust policies.\n\nEventually, we resorted to systematically experimenting with dozens of\nconfiguration changes. For every update, we had to wait minutes for our\nchanges to propagate due to the eventual consistency of IAM. Four team members\nworked for several hours until we finally made a surprising discovery \u2013 the\ntag variable names affected whether trust policy conditions were evaluated\ncorrectly.\n\nIf the request tag referenced a principal tag called MemberRole in the JWT\ntoken, and the IAM role referenced a resource tag with the same variable name,\nthe condition was always evaluated as true, regardless of whether the tag's\nvalues actually matched. This is how test users with stedi:readonly\npermissions in Stedi gained unauthorized admin access to their AWS accounts.\n\nChanging one of the tag variable names appeared to fix the issue. For example,\nthe snippet below changes the resource tag variable name to MemberRole2. The\npolicy only functioned properly when the variable names for the request and\nresource tags were different.\n\n    \n    \n    { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Action\": [\"sts:AssumeRoleWithWebIdentity\", \"sts:TagSession\"], \"Principal\": { \"Federated\": { \"Ref\": \"ProdOidcProvider\" } }, \"Condition\": { \"StringEquals\": { \"tokens.saas.stedi.com/v1:aud\": \"tenants\", \"aws:RequestTag/StediAccountId\": \"${iam:ResourceTag/MappedStediAccountId}\", \"aws:RequestTag/MemberRole\": \"${iam:ResourceTag/MemberRole2}\" } } } ] }\n\nCaption: Initial IAM vulnerability workaround \u2013 ensuring request tag and\nresource tag names did not match.\n\n### Alerting AWS\n\nWe used the documentation to construct a model of the role assumption process\nand contacted AWS Support and AWS Security on June 20, 2023 with our findings.\nWe also contacted Chris Munns, Tech Lead for the AWS Startups team, who\nengaged directly with AWS Security and escalated the issue internally.\n\nAWS was initially skeptical that the problem was with STS/IAM, which is\nunderstandable \u2013 we were too. They first suggested that we used the wrong\nprefixes in our condition statements (aws vs. iam), but we confirmed the issue\noccurred with both prefixes. Then, they suggested that the tag types in our\ncondition statements were incorrect. After some back and forth, we ruled that\nout as well, once again noting that the tag naming conventions for the\nAssumeRoleWithWebIdentity operation are confusing.\n\nIn the following days, we investigated the issue further and found we could\ntrigger the bug with STS AssumeRole calls, meaning the vulnerability was not\nlimited to assuming roles with web identity or SAML. We also found that hard-\ncoding one of the tag values in the policy statement did not expose the\nvulnerability. Only role trust policies that used a variable substitution for\nboth the request tag and the resource tag in the policy statement resulted in\nthe policy evaluating incorrectly.\n\nWe implemented a workaround (changing one of the variable names), confirmed\nour tests passed, and kept building.\n\n### Resolution\n\nOn July 6th, we received an email from AWS stating that their engineering team\nhad reproduced the bug and was working on a fix. On October 30th, STS\nAssumeRole operations for all new IAM roles used an updated tag handling\nimplementation, which provided the corrected tag input values into the logic\nto fix the role evaluation issue. This same change was then deployed for\nexisting roles on January 9, 2024. AWS typically rolls out changes in this\nmanner to avoid unexpectedly breaking customer workflows.\n\nAWS also discovered the issue was not limited to role trust policies, which\nare just resource policies for IAM roles (as a resource) \u2013 it also extended to\nstatements within IAM boundary policies and SCP policies that contained the\nsame pattern of STS role assumption with tag-based conditions.\n\nAWS notified customers with existing problematic roles, SCP trust policies,\nand boundary policies that had usage in the past 30 days. They also displayed\na list of affected resources in each customer\u2019s AWS Health Dashboard.\n\n## Timeline\n\n  * 2023-06-20 - Role access issue discovered, AWS alerted\n\n  * 2023-06-21 - Minimal reproduction steps provided using STS assume role, AWS acknowledges report and the issue is picked up by an engineer\n\n  * 2023-07-06 - AWS acknowledges issue and determines root cause\n\n  * 2023-10-30 - STS tag handling implementation updated for new IAM roles\n\n  * 2024-01-09 - STS tag handling implementation updated for IAM roles for customers impacted in a 30-day window\n\n## What we learned\n\nAfter we implemented our workaround, we conducted a retrospective. Here are\nour key takeaways:\n\nEven the most established software has bugs.\n\nThis might seem obvious, but we think it\u2019s an important reminder. We spent a\nlot of time second-guessing ourselves when discovering and diagnosing this\nbug. We were well aware of IAM\u2019s provable security via automated reasoning,\nand the documentation is so comprehensive (and intimidating at times) that we\nwere sure it had to be our fault. Of course, you should do your due diligence\nbefore reporting issues, but no system is infallible. Sometimes, it is AWS.\n\nGlossaries and indexes are underrated.\n\nDefining service-specific terminology in a single location can be game-\nchanging for users onboarding to a new product and can dramatically speed up\nthe debugging process.\n\nWe struggled to understand the difference between global condition keys with\nthe \u201caws:\u201d namespace and service-specific keys with the \u201ciam:\u201d namespace. We\nwere further confused by how these keys can overlap; the \u201ciam:ResourceTag\u201d and\n\u201caws:ResourceTag\u201d resolve to the same value. Finally, it was hard to keep\ntrack of the lifecycle from a jwt principal tag becoming a request tag before\nfinally being a resource tag.\n\nThe AWS documentation provides all this information, but we lacked the proper\nvocabulary to search for it. A comprehensive glossary would have saved us\nsignificant time and effort. We\u2019re now adding one to the Stedi docs to better\nserve our own users.\n\nWe need better tools for testing IAM policies.\n\nThe IAM policy simulator does not support role trust policy evaluation.\nProving the security of a system to grant federated identities access to IAM\nroles continues to rely on both positive and negative end-to-end tests with\nlong test cycles. Developing more mature tooling would massively improve the\ndeveloper experience, and we hope AWS will consider investing in this area\nmoving forward.\n\nThank you to all the Stedi team members who contributed to uncovering this\nissue and the AWS team for working with us to find a solution.\n\nSHARE\n\nTwitter\n\nLinkedIn\n\nPREVIOUS\n\n## The unwritten laws of engineering at Stedi\n\nSystem status\n\n+1 332-378-5040\n\nAbout\n\nEDI Platform\n\nPricing\n\nDocumentation\n\nCustomers\n\nCompany\n\nCareers\n\nContact\n\nBlog\n\nChangelog\n\nResources\n\nEDI Reference\n\nEDI Inspector\n\nNetwork\n\nLegal\n\nService Terms\n\nPrivacy Notice\n\nBacked by\n\n228 Park Ave S, PMB 58460, New York, NY 10003, USA\n\nStedi is a registered trademark of Stedi, Inc. All names, logos, and brands of\nthird parties listed on our site are trademarks of their respective owners\n(including \u201cX12\u201d, which is a trademark of X12 Incorporated). Stedi, Inc. and\nits products and services are not endorsed by, sponsored by, or affiliated\nwith these third parties. Our use of these names, logos, and brands is for\nidentification purposes only, and does not imply any such endorsement,\nsponsorship, or affiliation.\n\n", "frontpage": false}
