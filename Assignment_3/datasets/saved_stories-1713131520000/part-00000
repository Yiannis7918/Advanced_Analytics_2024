{"aid": "40031987", "title": "Inko 0.14.0 Released", "url": "https://inko-lang.org/news/inko-0-14-0-released/", "domain": "inko-lang.org", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-14 15:50:16", "comments": 0, "source_title": "Inko 0.14.0 released", "source_text": "Inko 0.14.0 released\n\nInko\n\nShow menu\n\n# Inko 0.14.0 released\n\nPublished on February 5, 2024\n\nWe're pleased to announce the release of Inko 0.14.0. This release contains a\nvariety of exciting changes, such as support for parallel and incremental\ncompilation, cross compilation, faster linking, and more!\n\n## Table of contents\n\n  * Parallel compilation of object files\n  * Incremental compilation of object files\n  * Faster linking of object files using Mold\n  * Support for cross compilation\n  * Support for compiling with musl\n  * Additions to the standard library\n  * Warnings for unused variables\n  * A new Inko manual\n  * Rust 1.70 is now required\n  * A lot of bug fixes\n\nFor the full list of changes, refer to the changelog.\n\nA special thanks to the following people for contributing changes included in\nthis release:\n\n  * Axel Pahl\n\nWe'd also like to thank the following people for financially supporting the\ndevelopment of Inko:\n\n  * Amidamaru\n  * Dusty Phillips\n  * Evan Ovadia\n  * Kiril Mihaylov\n  * SEKUN\n\nWe'd also like to thank the NLnet foundation for sponsoring part of the work\nthat went into this release.\n\n## Parallel compilation of object files\n\nThanks to the NLnet foundation for sponsoring the development of this feature.\n\nInko uses LLVM for generating machine code, but LLVM is rather slow. To reduce\ncompile times, Inko now compiles LLVM modules (and thus object files) in\nparallel. In case of Inko's own standard library test suite, the use of\nparallel compilation reduces compile times by a factor of four on a computer\nwith four cores and eight threads.\n\nThe implementation is reasonably straightforward: the compiler spawns a number\nof threads equal to the number of CPU cores (by default, this can be changed\nusing a command-line option). The work \"queue\" is an atomic counter that\nstarts at zero. Each thread races to increment the counter using an atomic\nswap. Whenever a thread succeeds, it uses the resulting value to index an\narray of modules to compile, then performs the necessary work. When threads\nreach the maximum value (equal to the number of modules), they stop.\n\nThis setup means there's no need for any sort of locking or complex concurrent\ndata structures, as the only shared mutable state is an atomic counter. This\nin turn means the setup scales well as the number of CPU cores goes up.\n\nSee commit 9162406 for more details.\n\n## Incremental compilation of object files\n\nIn addition to compiling machine code in parallel, we also perform incremental\ncompilation at the LLVM IR/object file level. This means we only recompile\nobject files if needed, greatly reducing compile times. When using a single\nthread to compile Inko's standard library test suite, we found that\nincremental compilation reduces compile times by a factor of 8 in the best\ncase scenario. When combining this with parallel compilation, we observed\nreductions of a factor of 3, depending on the number of threads used.\n\nImplementing this proved rather tricky, as we had to make sure that when\ncompiling the same code, the compiler performs the same work in the same order\nevery time. For example, symbol names used to include the numerical IDs of\nmethods, but these IDs change based on the order in which they're processed.\nTo solve that, symbol names now use a different name mangling scheme to ensure\nthey're unique, without depending on the order in which code is processed.\n\nIn it's current implementation there are certain scenarios in which caches are\nflushed even though this isn't strictly necessary. In general such cases are\nrare, and it's something we hope to improve in the future when the need for\nthis arises.\n\nSee commit 137304d for more details.\n\n## Faster linking of object files using Mold\n\nIf you're using Linux and have Mold installed, Inko's compiler automatically\nuses it for linking object files, similar to how it automatically uses LLD if\nit's available. If both Mold and LLD are installed, the compiler favours Mold\nover LLD.\n\nSee commit 76cf292 for more details.\n\n## Support for cross compilation\n\nThanks to the NLnet foundation for sponsoring the development of this feature.\n\nCross compilation allows you to compile your programs from one target (e.g.\nAMD64 Linux) to a different target (e.g. ARM64 macOS), without the need for\nextra hardware. Starting with version 0.14.0, Inko officially supports cross\ncompilation to different targets.\n\nTo make this as easy as possible, Inko tries to automatically detect what\ntoolchain to use for cross compilation. For example, if Zig is installed the\ncompiler favours it over GCC and clang, as cross compilation using Zig is much\neasier compared to the alternatives.\n\nCross compilation requires a version of the Inko runtime suitable for the\ncompilation target. To remove the need for manually compiling the runtime for\neach target, we provide pre-built versions of the runtime which are installed\nusing the inko runtime add command. Take the following program for example:\n\n    \n    \n    import std.stdio.STDOUT class async Main { fn async main { STDOUT.new.print('hello') } }\n\nTo cross compile this to AMD64 macOS using Zig, all we need to do is:\n\n  1. Make sure Zig is installed\n  2. Run inko runtime add amd64-mac-native\n  3. Run inko build --target amd64-mac-native test.inko to build the program\n\nOf course without Zig cross compilation is still supported, but the process is\na bit more difficult depending on what target you're compiling to. For more\ndetails, refer to the cross compilation documentation\n\nInko supports cross compiling to AMD64 and ARM64 macOS and Linux, and AMD64\nFreeBSD. ARM64 FreeBSD is supported at the compiler level, but we don't\nprovide pre-built runtimes for FreeBSD as we use rustup as part of building\nthe runtimes, and rustup doesn't provide any pre-built targets for this\ntarget.\n\nSee commit 03ef71f for more details.\n\n## Support for compiling with musl\n\nAs part of the cross compilation work, we've also added support for compiling\nInko programs using musl. This allows you to build Linux executables that\ndon't depend on glibc and as such are much more portable. To compile using\nmusl, use the amd64-linux-musl or arm64-linux-musl target:\n\n    \n    \n    inko runtime add amd64-linux-musl inko build --target amd64-linux-musl test.inko\n\nWhen targeting musl from a GNU host, musl is statically linked. If the host is\ninstead a musl host (e.g. Alpine Linux), the compiler dynamically links musl\nby default to match the expected behaviour on such hosts. In such cases you\ncan force static linking by using inko build --static.\n\n## Additions to the standard library\n\nThis releases includes a variety of additions to the standard library, such as\nmore methods for the Path type (Path.extension, Path.with_extension,\nPath.list_all, and more), support for replacing strings, and methods for\nquerying JSON values. This new querying API allows you to query JSON documents\nas follows:\n\n    \n    \n    import std.json.Json import std.stdio.STDOUT class async Main { fn async main { let json = Json .parse('{ \"name\": \"Donald Duck\" , \"address\": { \"city\": \"Duckburg\" } }') .unwrap let city = json.query.key('address').key('city').as_string.unwrap let stdout = STDOUT.new stdout.print(city) } }\n\n## Warnings for unused variables\n\nInko's compiler now produces warnings for unused local variables. This\nseemingly minor feature can prove useful in finding redundant code, as seen in\nthis commit removing various bits of unused code.\n\nSee commit ac24bcc for more details.\n\n## A new Inko manual\n\nInko's manual has received a significant overhaul. Instead of using mkdocs,\nit's now built using Inko itself using the inko-wobsite static site generator,\nand it uses a new style more in line with the main website. As part of this we\nalso rewrote and reorganized large parts of the manual.\n\nAs part of these changes the ability to search the manual has been removed. We\nmay reintroduce this at some point in the future, when we figure out a\nsolution that provides good and relevant search results (which the old search\nfunction didn't always do).\n\nYou can find the latest version of the new manual here, and the version for\nthe main branch is found here.\n\n## Rust 1.70 is now required\n\nThe minimum required version of Rust is increased from 1.68.0 to 1.70.0,\nallowing us to take advantage of some newer Rust features.\n\n## A lot of bug fixes\n\nThis release includes many fixes, such as fixes for OR patterns, guard\npatterns, uniqueness checking for Channels, compile-time memory usage, and\nmuch more.\n\n## Plans for 0.15.0\n\nFor the next version of Inko, we'll be working on generating source code\ndocumentation, automatic code formatting, various improvements to the type\nsystem (e.g. making working with closures easier), and more.\n\n## Following and supporting Inko\n\nIf Inko sounds like an interesting language, consider joining the Discord\nserver. You can also follow along on the /r/inko subreddit. If you'd like to\nsupport the continued development of Inko, please consider donating using\nGitHub Sponsors.\n\n", "frontpage": false}
