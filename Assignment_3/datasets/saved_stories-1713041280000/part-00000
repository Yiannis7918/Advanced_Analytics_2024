{"aid": "40023485", "title": "Garbage collection in Python: things you need to know", "url": "https://rushter.com/blog/python-garbage-collector/", "domain": "rushter.com", "votes": 1, "user": "ThouYS", "posted_at": "2024-04-13 14:47:02", "comments": 0, "source_title": "Garbage collection in Python: things you need to know | Artem Golubin", "source_text": "Garbage collection in Python: things you need to know | Artem Golubin\n\n# Garbage collection in Python: things you need to know\n\nLast updated on September 10, 2023, in python\n\nThis article describes garbage collection (GC) in Python 3.9.\n\nUsually, you do not need to worry about memory management. When objects\n(variables) are no longer needed, Python automatically reclaims memory from\nthem. However, understanding how GC works can help you write better and faster\nPython programs.\n\n## Memory management\n\nUnlike many other languages, Python does not necessarily release the memory\nback to the Operating System. Instead, it has a dedicated object allocator for\nobjects smaller than 512 bytes, which keeps some chunks of already allocated\nmemory for further use in the future. The amount of memory that Python holds\ndepends on the usage patterns. In some cases, all allocated memory can be\nreleased only when a Python process terminates.\n\nIf a long-running Python process takes more memory over time, it does not\nnecessarily mean that your program has memory leaks. Usually, Python keeps\nsome of the memory blocks (arenas) for future use. If you are interested in\nPython's memory model, you can read my article on memory management.\n\nSince most Python objects are small, custom memory allocator saves a lot of\ntime on memory allocations. Even simple programs that import third-party\nlibraries can allocate millions of objects during the program's lifetime.\n\n## Garbage collection algorithms\n\nIn Python, everything is an object \u2014 even integers. Knowing when to allocate\nthem is easy. Python does it when you need to define a new object. Unlike\nallocation, automatic deallocation is tricky. Python needs to know when your\nobject is no longer needed. Removing objects prematurely will result in a\nprogram crash.\n\nGarbage collections algorithms track which objects can be deallocated and pick\nan optimal time to deallocate them. Standard CPython's garbage collector has\ntwo components, the reference counting collector and the generational garbage\ncollector, known as gc module.\n\nThe reference counting algorithm is incredibly efficient and straightforward\nbut cannot detect reference cycles. That is why Python has a supplemental\nalgorithm called generational cyclic GC. It deals with reference cycles only.\n\nThe reference counting module is fundamental to Python and can't be disabled,\nwhereas the cyclic GC is optional and can be triggered manually.\n\n## Reference counting\n\nReference counting is a simple technique in which objects are deallocated when\nthere is no reference to them in a program.\n\nEvery variable in Python is a reference (a pointer) to an object and not the\nactual value itself. For example, the assignment statement just adds a new\nreference to the right-hand side. A single object can have many references\n(variable names).\n\nThis code creates two references to a single object:\n\n    \n    \n    a = [1, 2, 3] b = a\n\nAn assignment statement itself (everything on the left) never copies or\ncreates new data.\n\nTo keep track of references, every object (even integer) has an extra field\ncalled reference count that is increased or decreased when a pointer to the\nobject is created or deleted. See Objects, Types and Reference Counts section,\nfor a detailed explanation.\n\n#### Examples, where the reference count increases:\n\n  * assignment operator\n  * argument passing\n  * appending an object to a list (object's reference count will be increased).\n\nIf the reference counting field reaches zero, CPython automatically calls the\nobject-specific memory deallocation function. If an object contains references\nto other objects, then their reference count is automatically decremented,\ntoo. Thus, other objects may be deallocated in turn. For example, when a list\nis deleted, the reference count for all its items is decreased. If another\nvariable references an item in a list, the item won't be deallocated.\n\nVariables, which are declared outside of functions, classes, and blocks, are\ncalled globals. Usually, such variables live until the end of the Python's\nprocess. Thus, the reference count of objects, which are referenced by global\nvariables, never drops to zero. To keep them alive, all globals are stored\ninside a dictionary-like structure. You can get the dictionary representation\nby calling the globals() function.\n\nVariables, which are defined inside blocks (e.g., in a function or a class\ndefinition) have a local scope (i.e., they are local to their block). When the\nPython interpreter exits from a block, it destroys local variables and their\nreferences that were created inside the block. In other words, it only\ndestroys the names.\n\nIt's important to understand that until your program stays in a block (e.g.,\nfunction), the Python interpreter assumes that all variables inside it are in\nuse. Generally, that is also true for the majority of the languages. To remove\nsomething from memory, you need to either assign a new value to a variable or\nexit from a block of code. You can also use the del keyword to remove the\nreference. In Python, the most popular block of code is a function; this is\nwhere most of the garbage collection happens. That is another reason to keep\nfunctions small and simple.\n\nYou can always check the number of current references using sys.getrefcount\nfunction.\n\nHere is a simple example:\n\n    \n    \n    import sys foo = [] # 2 references, 1 from the foo var and 1 from getrefcount print(sys.getrefcount(foo)) def bar(a): # 4 references # from the foo var, function argument, getrefcount and Python's function stack print(sys.getrefcount(a)) bar(foo) # 2 references, the function scope is destroyed print(sys.getrefcount(foo))\n\nIn the example above, you can see that function's references get destroyed\nafter Python exits it.\n\nSometimes you need to remove a global or a local variable prematurely. To do\nso, you can use the del statement that removes a variable and its reference\n(not the object itself). This is often useful when working in Jupyter\nnotebooks because all cell variables use the global scope.\n\nThe main reason why CPython uses reference counting is historical. There are a\nlot of debates nowadays about the weaknesses of such a technique. Some people\nclaim that modern garbage collection algorithms can be more efficient without\nreference counting at all. The reference counting algorithm has a lot of\nissues, such as circular references, thread locking, and memory and\nperformance overhead. Reference counting is one of the reasons why Python\ncan't get rid of the GIL.\n\nThe main advantage of such an approach is that the objects can be immediately\nand easily destroyed after they are no longer needed.\n\n## Generational garbage collector\n\nWhy do we need additional garbage collector when we have reference counting?\n\nUnfortunately, classical reference counting has a fundamental problem \u2014 it\ncannot detect reference cycles. A reference cycle occurs when one or more\nobjects are referencing each other.\n\nHere are two examples:\n\nAs we can see, the 'lst' object is pointing to itself, moreover, object 1 and\nobject 2 are pointing to each other. The reference count for such objects is\nalways at least 1.\n\nTo get a better idea, you can play with a simple Python example:\n\n    \n    \n    import gc # We use ctypes moule to access our unreachable objects by memory address. class PyObject(ctypes.Structure): _fields_ = [(\"refcnt\", ctypes.c_long)] gc.disable() # Disable generational gc lst = [] lst.append(lst) # Store address of the list lst_address = id(lst) # Destroy the lst reference del lst object_1 = {} object_2 = {} object_1['obj2'] = object_2 object_2['obj1'] = object_1 obj_address = id(object_1) # Destroy references del object_1, object_2 # Uncomment if you want to manually run garbage collection process # gc.collect() # Check the reference count print(PyObject.from_address(obj_address).refcnt) print(PyObject.from_address(lst_address).refcnt)\n\nIn the example above, the del statement removes the references to our objects\n(i.e., decreases reference count by 1). After Python executes the del\nstatement, our objects are no longer accessible from Python code. However,\nsuch objects are still sitting in memory. That happens because they are still\nreferencing each other, and the reference count of each object is 1. You can\nvisually explore such relations using objgraph module.\n\nTo resolve this issue, the additional cycle-detecting algorithm was introduced\nin Python 1.5. The gc module is responsible for this and exists only for\ndealing with such a problem.\n\nReference cycles can only occur in container objects (i.e., in objects that\ncan contain other objects), such as lists, dictionaries, classes, tuples. The\ngarbage collector algorithm does not track all immutable types except for a\ntuple. Tuples and dictionaries containing only immutable objects can also be\nuntracked depending on certain conditions. Thus, the reference counting\ntechnique handles all non-circular references.\n\n### When does the generational GC trigger\n\nUnlike reference counting, cyclic GC does not work in real-time and runs\nperiodically. To reduce the frequency of GC calls and micro pauses CPython\nuses various heuristics.\n\nThe GC classifies container objects into three generations. Every new object\nstarts in the first generation. If an object survives a garbage collection\nround, it moves to the older (higher) generation. Lower generations are\ncollected more often than higher. Because most of the newly created objects\ndie young, it improves GC performance and reduces the GC pause time.\n\nIn order to decide when to run, each generation has an individual counter and\nthreshold. The counter stores the number of object allocations minus\ndeallocations since the last collection. Every time you allocate a new\ncontainer object, CPython checks whenever the counter of the first generation\nexceeds the threshold value. If so, Python initiates the \u0441ollection process.\n\nIf we have two or more generations that currently exceed the threshold, GC\nchooses the oldest one. That is because the oldest generations are also\ncollecting all previous (younger) generations. To reduce performance\ndegradation for long-living objects, the third generation has additional\nrequirements in order to be chosen.\n\nThe standard threshold values are set to (700, 10, 10) respectively, but you\ncan always check them using the gc.get_threshold function. You can also adjust\nthem for your particular workload by using the gc.set_threshold function.\n\n### How to find reference cycles\n\nIt is hard to explain the reference cycle detection algorithm in a few\nparagraphs. Basically, GC iterates over each container object and temporarily\nremoves all references to all container objects it references. After full\niteration, all objects which reference count lower than two are unreachable\nfrom Python's code and thus can be collected.\n\nTo fully understand the cycle-finding algorithm, I recommend you to read an\noriginal proposal from Neil Schemenauer and collect function from CPython's\nsource code. Also, the Quora answers and The Garbage Collector blog post can\nbe helpful.\n\nNote that, the problem with finalizers, which was described in the original\nproposal, has been fixed since Python 3.4. You can read about it in the PEP\n442.\n\n## Performance tips\n\nCycles can easily happen in real life. Typically, you encounter them in\ngraphs, linked lists, or in structures in which you need to keep track of\nrelations between objects. If your program has an intensive workload and\nrequires low latency, you need to avoid reference cycles as much as possible.\n\nTo avoid circular references in your code, you can use weak references that\nare implemented in the weakref module. Unlike the usual references, the\nweakref.ref doesn't increase the reference count and returns None if the\nobject was destroyed.\n\nIn some cases, it is useful to disable GC and use it manually. The automatic\ncollection can be disabled by calling gc.disable(). To manually run the\ncollection process, you need to use gc.collect().\n\n## How to find and debug reference cycles\n\nDebugging reference cycles can be very frustrating especially when you use a\nlot of third-party libraries.\n\nThe standard gc module provides a lot of useful helpers that can help in\ndebugging. If you set debugging flags to DEBUG_SAVEALL, all unreachable\nobjects found will be appended to gc.garbage list.\n\n    \n    \n    import gc gc.set_debug(gc.DEBUG_SAVEALL) print(gc.get_count()) lst = [] lst.append(lst) list_id = id(lst) del lst gc.collect() for item in gc.garbage: print(item) assert list_id == id(item)\n\nOnce you have identified a problematic spot in your code you can visually\nexplore object's relations using objgraph.\n\n### Immortal objects\n\nPython 3.12 introduces a new concept called immortal objects. It changes the\nway how Python handles reference counting.\n\nPython interpreter can now skip reference counting for some objects that live\nuntil the Python process terminates (e.g., for None, True and False). All\nobjects that have the refcount set to 0xFFFFFFFF (4294967295) are now\nconsidered immortal. Such a change allows some Python objects to be completely\nstatic in memory, which is a good optimization for Python applications that\nuse multiprocessing and copy-on-write mechanism. To get more information, you\ncan read PEP 683.\n\n### Conclusion\n\nMost of the garbage collection is done by reference counting algorithm, which\nwe cannot tune at all. So, be aware of implementation specifics, but don't\nworry about potential GC problems prematurely.\n\nHopefully, you have learned something new. If you have any questions left, I\nwill be glad to answer them in the comments below.\n\n#### Recent posts in Python category\n\n##### October 21, 2020\n\n#### On code isolation in Python\n\n##### August 24, 2020\n\n#### How to turn an ordinary gzip archive into a database\n\n##### April 28, 2019\n\n#### Detecting SQL injections in Python code using AST\n\n##### August 09, 2018\n\n#### How Python saves memory when storing strings\n\n##### June 29, 2018\n\n#### How virtual environment libraries work in Python\n\npython , cpython internals, memory, advanced python\n\n  * Linkedin\n  * Telegram\n  * Reddit\n  * Hacker News\n  * Twitter\n\n# Comments\n\n  * Bob Hyman 2017-10-07 #\n\nVery interesting and useful description of the current state of affairs in\nCython.\n\nAre things different in other pythons? E.g, IPython.\n\nAre there any projects underway to improve memory MGMT in python?\n\nreply\n\n    * Artem 2017-10-07 #\n\nEach implementation of Python uses its own collector. For example, Jyton uses\nstandard Java's gc (since it running on the JVM) , and PyPy uses Mark and\nSweep algorithm. The PyPy's gc is more complicated than CPython's and has\nadditional optimizations\nhttp://doc.pypy.org/en/release-2.4.x/garbage_collection.html.\n\nI'm not aware of any changes in IPython since it's just an interactive shell\nrunning on CPython.\n\nRegarding memory management, there are tens of proposals in the PEP index, but\nonly a few of them will be accepted in future.\n\nreply\n\n  * Madison 2017-10-07 #\n\nNice article. One small correction worth making is that not all block\nstatements introduce a new execution scope. In particular a with statement\ndoes not have its own local scope any more than an if statement does. For this\nmost part this only applies to def and class statements.\n\nreply\n\n    * Artem 2017-10-07 #\n\nThanks, you are right. I was thinking about context's enter/exit.\n\nreply\n\n  * ben 2019-02-08 #\n\nThanks for the explanation. Can you please confirm then, that it would be\npointless to import gc into jupyter notebook?\n\nreply\n\n  * Alice 2020-07-09 #\n\nGood write up.\n\nreply\n\n  * Simon 2020-08-04 #\n\nI don't understand why when you pass a variable to a function it has two more\nreference counts instead of one. You said that it has one from the function\nargument and one from Python's function stack. I don't know what is this\nfunction stack. Otherwise this is a great article!\n\nreply\n\n    * Artem 2020-08-05 #\n\nFunction stack keeps track of all local variables that are avaliable inside\nthe function.\n\nreply\n\n      * Tom 2022-09-25 #\n\nI am sorry,it maybe a mistake.\n\nreply\n\n  * kanch 2020-08-26 #\n\nHi there, your article help me a lot in reduce my python application memory\nusage.\n\nCan I translate it into Chinese , and re-post with reference to my blog? I\nthink it will help more people struggling with python memory usage in long run\napplications.\n\nreply\n\n    * Artem 2020-08-26 #\n\nSure, you can translate it. Just link my article in your translation.\n\nreply\n\n  * jbo 2020-10-05 #\n\nVery well explained, just loved reading it and your other articles. Keep up\nthe good work .\n\nreply\n\n  * ferdizera 2020-12-02 #\n\nSimple and objective. Nice article. Nice explanation.\n\nreply\n\n  * jb 2021-02-13 #\n\nThank you, clear and useful\n\nreply\n\n  * Lokumcu Hayri 2021-02-26 #\n\nNo lollygagging, just to-the-point explanations and examples. Thanks!\n\nreply\n\n  * maz 2021-04-07 #\n\nI think you mean in this sentence \"You can also adjust them for your\nparticular workload by using the gc.get_threshold function.\" gc.set_threshold.\nbtw Thanks for your blog, really helpful!\n\nreply\n\n  * hans 2021-05-09 #\n\n\"It's important to understand that until your program stays in a block\"\n\nDo you mean while instead of \"until\" here? While the interpreter is in a\nblock, all local variables are assumed to be in use and the local variables\nget destroyed once it exits the block.\n\nreply\n\n    * Artem 2021-05-09 #\n\nYes\n\nreply\n\n  * bactone@163.com 2021-11-26 #\n\nvery clear and helpful, thanks\n\nreply\n\n  * pravin patil 2022-06-04 #\n\nvery helpful\n\nreply\n\n  * Siddhant Kumar 2022-08-03 #\n\nThe following talk is quite useful to understand gc -\nhttps://www.youtube.com/watch?v=CLW5Lyc1FN8\n\nreply\n\n  * purplesheep 2023-02-03 #\n\nHello, I'm a korean junior programmer who is interested in all computer\nscience area. This article is very helpful for me to understand GC in python.\nIf you're okay, I want to translate this article and upload it. I'll put your\nwebsite url in my post. Thank you for the article!\n\nreply\n\n    * Artem 2023-02-04 #\n\nSure, you can translate it. Just put a reference to my article at the end of\nyour article.\n\nreply\n\nBack to top\n\n\u00a9 2009-2023, Artem Golubin, me@rushter.com\n\n", "frontpage": false}
