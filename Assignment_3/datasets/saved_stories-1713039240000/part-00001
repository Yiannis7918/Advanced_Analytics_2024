{"aid": "40023277", "title": "How to write a code formatter", "url": "https://yorickpeterse.com/articles/how-to-write-a-code-formatter/", "domain": "yorickpeterse.com", "votes": 1, "user": "YorickPeterse", "posted_at": "2024-04-13 14:13:09", "comments": 0, "source_title": "How to write a code formatter", "source_text": "How to write a code formatter\n\n# How to write a code formatter\n\nApril 13, 2024\n\nAsk ten developers how they think a certain piece of code should be formatted,\nand you'll likely get ten different opinions. Worse, these opinions are almost\nnever based on facts. Instead, when you ask why they prefer style X over Y the\nanswer is almost always the equivalent of \"I just do\".\n\nWhat if we could sidestep this entire debate and let a computer decide for us?\nNo, I'm not talking about asking ChatGPT to format your code for you, I'm\ntalking about \"code formatters\".\n\nA code formatter is a program that takes your source code as its input,\nformats it using a particular style and then writes it back to disk or STDOUT.\nWhile such tools have existed for a long time, their usage has become\nincreasingly more popular in the last 15 years or so. Go's gofmt in particular\nappears to have been a driving force behind the move towards using code\nformatters more, as many popular formatters in use today started showing up in\nthe years following the release of gofmt. To illustrate, here's a short list\nof various formatters that appear to be reasonably popular, along with the\nyear in which they were first introduced:\n\nFormatter| Language| First introduced in  \n---|---|---  \nautopep8| Python| 2010  \ngofmt| Go| 2013  \nrustfmt| Rust| 2015  \ngoogle-java-format| Java| 2015  \nprettier| JavaScript, HTML, and more| 2016  \nrufo| Ruby^1| 2017  \nStandard Ruby| Ruby^1| 2018  \nmix format| Elixir| 2017  \nblack| Python| 2018  \nerlfmt| Erlang| 2019  \ninko fmt| Inko^2| 2024  \n  \nI suspect it's not so much that gofmt in itself is a particular noteworthy\nformatter (other than not allowing you to configure it in any way, as it\nshould be), but rather that Go itself is incredibly popular and thus subjected\nmany developers to the beauty of not having to worry about manually formatting\nyour code. This then caught on over time, resulting in an increase in the\nnumber of available code formatters since the introduction of gofmt.\n\nSo how do you actually build a code formatter? Does it require decades of\nexperience working with Haskell and mastering the ways of the monad? Or maybe\nyou have to read hundreds of computer science papers to understand the deeper\nmeaning of the lambda? What about acquiring a crippling student debt by\nstudying at MIT for four years in an attempt to better understand computer\nscience as a whole?\n\nNo, writing a decent code formatter is in fact straightforward, it just isn't\nexplained in a simple way, like so many other topics in computer science.\nLucky for you, I recently spent several weeks writing a code formatter for\nInko, so naturally I'm now an expert on everything related to code formatting.\n\nThe setup we'll take a look at in this article is based on Inko's formatter,\nwhich in turn is based on Prettier and the paper \"A prettier printer\" (which\nPrettier is also based on, if I'm not mistaken). The paper itself is somewhat\nmundane and I've already forgotten 80% of it, but the concept is deviously\nsimple.\n\nWe'll be using Inko as the language of choice to show how to write a\nformatter, but it should be easy enough to translate the code into different\nlanguages.\n\nOh, and before I forget: if you're also interested in learning how pattern\nmatching is implemented, take a look at this Git repository that contains two\nimplementations in Rust. Like the code we'll discuss today, the Rust code is\nwell documented and should be easy to understand. Fun fact: Gleam based its\nimplementation of pattern matching on this exact code. Neat!\n\n## Table of contents\n\n  * Nodes and trees\n\n    * Text\n    * Whitespace and indentation\n    * Grouping nodes\n    * Conditional formatting\n  * Computing widths\n  * Tracking the need for wrapping\n  * Lowering ASTs into formatting trees\n\n    * The Generator type\n\n      * Rendering Nodes\n      * Rendering Group\n      * Rendering IfWrap\n      * Rendering Text and Unicode\n      * Rendering whitespace\n      * Converting Generator into a String\n      * The final Generator type\n      * Strings\n      * Function calls\n    * The Builder type\n    * Using the Generator and Builder types\n  * Applying this to a real formatter\n\n## Nodes and trees\n\nThe basic idea of the formatter is as follows: we take an Abstract Syntax Tree\n(AST) of sorts, specifically one that includes comments, and convert that into\na formatting tree. The formatting tree has various nodes, such as \"just render\nthis text\" or \"try to fit all sub nodes onto a single line\". After\nconstructing the tree, we visit each node and render it to a string. The\nresulting string is then written to a file or STDOUT.\n\nOur tree will be created using a sum type, or \"enum\". In Inko, you define an\nenum as follows:\n\n    \n    \n    class enum Letter { case A case B case C }\n\nThe Rust equivalent is the following:\n\n    \n    \n    enum Letter { A, B, C, }\n\nIn Inko, enum cases can wrap values when defined like so:\n\n    \n    \n    class enum Option[T] { # This case stores some value of type \"T\", whatever that is. case Some(T) case None }\n\nIn Inko, you create an instance of an enum like so:\n\n    \n    \n    Option.Some(42) Option.None\n\nFor our tree, we'll start with the basic definition:\n\n    \n    \n    class enum Node {}\n\nNow let's look at the different nodes we'll need.\n\n### Text\n\nThe two most basic nodes of our tree are Text(value) and Unicode(value, size).\n\nThe Text node stores an ASCII string (e.g. keywords in your language), while\nthe Unicode node stores a string containing one or more multi-byte characters,\nalong with its size expressed as the number of extended grapheme clusters. The\nsize for Unicode nodes is cached because depending on the structure of our\ntree, we may end up having to calculate the width of such a node multiple\ntimes. Since counting grapheme clusters is an O(n) operation, caching this\nvalue speeds things up a bit.\n\nWe define these nodes as follows:\n\n    \n    \n    class enum Node { case Text(String) case Unicode(String, Int) }\n\nThe String arguments store the string to render, while the Int argument is\nused to store the number of extended grapheme clusters. For the Unicode node\nwe'll also add a helper method to make constructing them a little easier:\n\n    \n    \n    class enum Node { case Text(String) case Unicode(String, Int) fn static unicode(value: String) -> Node { # `value.chars` returns an iterator over the extended grapheme clusters, # and `count` simply counts them. Node.Unicode(value, value.chars.count) } }\n\nUsing this method, we construct the Unicode nodes as follows:\n\n    \n    \n    Node.unicode('this is the string to render')\n\n### Whitespace and indentation\n\nFor handling whitespace and indentation we'll define three nodes: SpaceOrLine,\nLine, and Indent.\n\nSpaceOrLine is a node that renders to a space if it resides in a group that\ndoesn't need wrapping, and renders to a line when wrapping is needed.\n\nLine is a node that renders to a new line if it resides in a group that needs\nwrapping, otherwise it renders to nothing.\n\nIndent(nodes) is a node that renders one or more nodes, indenting each new\nline, but only if it resides in a group that for which wrapping is needed.\n\nIn Inko, we define these nodes like so:\n\n    \n    \n    class enum Node { ... case SpaceOrLine case Line case Indent(Array[Node]) }\n\nTo help understand these nodes and when to use them, consider the following\narray we want to format:\n\n    \n    \n    [100, 200]\n\nWe'll construct the following tree to format this array:\n\n    \n    \n    # I'll explain what \"Group\" is in just a moment. Node.Group( 0, [ Node.Text('['), Node.Line, Node.Indent( [ Node.Text('100'), Node.Text(','), Node.SpaceOrLine, Node.Text('200') ] ), Node.Line, Node.Text(']') ] )\n\nWhen no wrapping is needed, the array is rendered as-is, because Line is\nrendered to nothing, Indent only indents when wrapping is needed, and\nSpaceOrLine renders to a space. When wrapping is needed, the array is rendered\nas follows:\n\n    \n    \n    [ 100, 200 ]\n\n### Grouping nodes\n\nTo group nodes together, we can use one of two nodes: Group or Nodes.\n\nGroup(id, nodes) is a collection of nodes that we try to fit onto the current\nline. If this doesn't fit, each sub node is placed on its own line. Each group\nhas an ID (just a number in the range 0 <= id <= N) unique to the document\nthat we're formatting.\n\nWhen nesting Group nodes (e.g. Group -> something else -> Group), the need for\nwrapping is checked on a per group basis. This means that if an outer Group\nrequires wrapping, this doesn't immediately force all child groups to also\nwrap.\n\nNodes(nodes) is a collection of nodes that we just render without any special\nhandling. This makes it easier code wise to have certain helper functions that\nproduce multiple nodes that we just want to concatenate together.\n\nWe define these nodes like so:\n\n    \n    \n    class enum Node { ... case Group(Int, Array[Node]) case Nodes(Array[Node]) }\n\nThe Int argument is the group ID, while the Array[Node] arguments store the\nchild nodes.\n\nWhen constructing the Group nodes we'll need to keep track of the next ID to\nuse. This is done by storing a counter somewhere, taking the existing value\nfor the new Group, followed by incrementing it:\n\n    \n    \n    let id = the_id_counter the_id_counter += 1 Node.Group(id, nodes)\n\nIn Inko we can shorten this to the following:\n\n    \n    \n    Node.Group(the_id_counter := the_id_counter + 1, nodes)\n\nThe := operator assigns the variable a new value, returning the previous\nvalue. In contrast, the = operator discards the old value.\n\n### Conditional formatting\n\nThe last node we'll introduce is the IfWrap(id, A, B) node. This is a node\nthat renders node A if the group using ID id needs to be wrapped, otherwise it\nrenders node B.\n\nUsing the array example shown earlier, we can use this node to add a trailing\ncomma when wrapping is necessary by using this tree:\n\n    \n    \n    Node.Group( 0, [ Node.Text('['), Node.Line, Node.Indent( [ Node.Text('100'), Node.Text(','), Node.SpaceOrLine, Node.Text('200'), Node.IfWrap(0, Node.Text(','), Node.Text('')) ] ), Node.Line, Node.Text(']') ] )\n\nWhen wrapping is needed, the array is now rendered as follows:\n\n    \n    \n    [ 100, 200, ]\n\n## Computing widths\n\nWhen formatting trees, we need to know how many characters a node occupies on\nthe current line, as this is used to determine if wrapping is needed. This\nmeans we'll need a method to compute the width of a Node, which we'll define\nas follows:\n\n    \n    \n    class enum Node { ... fn width(wrapped: ref Set[Int]) -> Int { match self { case Nodes(nodes) or Group(_, nodes) or Indent(nodes) -> { Int.sum(nodes.iter.map(fn (n) { n.width(wrapped) })) } case IfWrap(id, node, _) if wrapped.contains?(id) -> node.width(wrapped) case IfWrap(_, _, node) -> node.width(wrapped) case Text(str) -> str.size case Unicode(_, chars) -> chars case SpaceOrLine -> 1 case _ -> 0 } } }\n\nThe wrapped argument is an immutable borrow of a hash set containing the IDs\nof all groups that we've processed thus far and that needed to be wrapped. The\nreturn value is the width as an integer. In the body we pattern match against\nthe current node (self). For nodes that contain other nodes, such as Nodes and\nGroup, the width is the sum of the widths of all child nodes.\n\nFor IfWrap we have to calculate the width differently based on whether\nwrapping is needed or not. This is also why we can't compute the width once\nand cache it: the width for a deeply nested node may change based on the\nwrapping needs of parent nodes.\n\nFor Text we use String.size to get the size in bytes (which happens to also be\nits character count, as Text nodes only store ASCII text), while for Unicode\nnodes we use the pre-computed grapheme cluster count.\n\nThe implementation is a recursive algorithm instead of an iterative one,\nmainly for the sake of simplicity and because it's good enough due to\nformatting trees typically not being that deeply nested.\n\nThe final result is as follows:\n\n    \n    \n    class enum Node { case Group(Int, Array[Node]) case Nodes(Array[Node]) case IfWrap(Int, Node, Node) case Text(String) case Unicode(String, Int) case SpaceOrLine case Line case Indent(Array[Node]) fn static unicode(value: String) -> Node { Node.Unicode(value, value.chars.count) } fn width(wrapped: ref Set[Int]) -> Int { match self { case Nodes(nodes) or Group(_, nodes) or Indent(nodes) -> { Int.sum(nodes.iter.map(fn (n) { n.width(wrapped) })) } case IfWrap(id, node, _) if wrapped.contains?(id) -> node.width(wrapped) case IfWrap(_, _, node) -> node.width(wrapped) case Text(str) -> str.size case Unicode(_, chars) -> chars case SpaceOrLine -> 1 case _ -> 0 } } }\n\n## Tracking the need for wrapping\n\nWhen traversing the formatting tree, we need to record if wrapping is needed\nor not for a particular sub tree. To do so, we'll introduce a Wrap enum that\ncan be in one of two states: Enable, meaning wrapping is needed, or Detect\nmeaning we need to detect it based on the width. Detect is the default state:\n\n    \n    \n    class enum Wrap { case Enable case Detect fn enable? -> Bool { match self { case Enable -> true case _ -> false } } }\n\nThe Wrap.enable? method is added to make it a little easier to check if\nwrapping is needed, without having to manually pattern match against the Wrap\nenum.\n\n## Lowering ASTs into formatting trees\n\nTo lower the AST into a formatting tree, we'll need a type that visits the\nnodes in the AST and returns their corresponding Node values. We'll also need\na type that takes a Node and converts it to formatted source code as a string,\nalong with tracking the necessary state such as line lengths. For this we'll\nintroduce two types: Builder and Generator.\n\nThe Builder type is used to define the necessary methods for visiting the AST\nnodes, returning their corresponding Node values. The Generator type is used\nto convert those Node values to strings.\n\nFor the sake of simplicity, we'll restrict the code shown in this article to\nhandling simple function calls, text literals and strings.\n\n### The Generator type\n\nThe basic layout of the Generator type is as follows:\n\n    \n    \n    class Generator { # This field is the buffer we'll write our formatted code into. let @buffer: StringBuffer # This field tracks the indentation levels, not the number of indentation # characters (i.e. if you use 2 spaces for indentation, you increment this # field by one). let @indent: Int # The number of characters/extended grapheme clusters on the current line. let @size: Int # The maximum number of characters we allow per line. If your formatter # doesn't allow users to change this value, you probably want to turn this # into a constant instead. let @max: Int # A hash set containing all the groups that need to be wrapped. let @wrapped: Set[Int] fn static new(max: Int) -> Generator { Generator { @buffer = StringBuffer.new, @indent = 0, @size = 0, @max = max, @wrapped = Set.new, } } }\n\nStringBuffer is a type that we can push String values in and concatenate\ntogether, without producing intermediate String values.\n\nTo use this type, we define a generate method that takes a Node, renders it to\na String and stores the String in the buffer of the Generator type:\n\n    \n    \n    class Generator { ... fn mut generate(node: Node) { node(node, ref Wrap.Detect) } fn mut node(node: Node, wrap: ref Wrap) { } }\n\nThe generate method just calls the node method with a default value for the\nwrap argument. If your language of choice supports default arguments, this\nwon't be necessary and you can instead merge the two methods into a single\nmethod.\n\nInko uses single ownership for memory management. The generate method takes\nover ownership of the Node passed to it, because the type of the node argument\nis Node and not e.g. ref Node (which is an immutable borrow). The expression\nref Wrap.Detect creates an instance of the Wrap.Detect case, then passes an\nimmutable borrow of that value to the node method. This borrow is valid until\nwe return from the call to node.\n\nBefore we implement the node method, we'll add two helper methods to the\nGenerator type and define a constant containing the characters to use for\nindenting lines:\n\n    \n    \n    let INDENT = ' ' class Generator { ... fn mut text(value: String, chars: Int) { @size += chars @buffer.push(value) } fn mut new_line { @size = INDENT.size * @indent @buffer.push('\\n') @indent.times(fn (_) { @buffer.push(INDENT) }) } }\n\nIn Inko, both single and double quoted string literals support escape\nsequences such as \\n and \\t. In fact, they are exactly the same. In other\nlanguages (e.g. Rust) you likely need to use double quotes, so keep that in\nmind.\n\nThe text method adds a String of chars extended grapheme clusters to the\nbuffer. The new_line method adds a new line such, while making sure to indent\nthe new line. The INDENT constant defines the characters to use for indenting\nlines. In this case we're using two spaces, but it could be four spaces, a\ntab, a tab and three spaces, or something else.\n\nNow we can take a look at the node method. We'll start with the basic\nstructure, then step through rendering each node one by one:\n\n    \n    \n    fn mut node(node: Node, wrap: ref Wrap) { match node { case Nodes(nodes) -> {} case Group(id, nodes) -> {} case IfWrap(id, node, _) if @wrapped.contains?(id) -> {} case IfWrap(_, _, node) -> {} case Text(str) -> {} case Unicode(str, width) -> {} case Line if wrap.enable? -> {} case SpaceOrLine if wrap.enable? -> {} case SpaceOrLine -> {} case Indent(nodes) if wrap.enable? -> {} case Indent(nodes) -> {} case _ -> {} } }\n\nIf you're having a hard time understanding Inko's pattern matching syntax, you\ncan learn more about it in the documentation.\n\n#### Rendering Nodes\n\nRendering the Nodes node is easy: we iterate over the child nodes, and render\nthem individually. Similar to the Node.width method we'll be using a recursive\nalgorithm. While you can turn this into an iterative algorithm, it gets a bit\ntricky and I'm not sure it would actually perform better in practice. The code\nfor rendering Nodes is as follows:\n\n    \n    \n    fn mut node(node: Node, wrap: ref Wrap) { match node { case Nodes(nodes) -> nodes.into_iter.each(fn (n) { node(n, wrap) }) ... } }\n\nInko doesn't have for loops, instead you use iterators and closures.\nnodes.into_iter moves the nodes Array into an iterator over the Node values.\nWe then use the each method of the iterator type to call node for each value.\n\n#### Rendering Group\n\nRendering Group nodes is where things get interesting. First, we need to\ncalculate the width of the child nodes, then we need to check if we can fit\nthem onto the current line. If so, we'll do just that, otherwise we'll render\neach child node on its own line:\n\n    \n    \n    fn mut node(node: Node, wrap: ref Wrap) { match node { ... case Group(id, nodes) -> { let width = Int.sum(nodes.iter.map(fn (n) { n.width(@wrapped) })) let wrap = if @size + width > @max { @wrapped.insert(id) Wrap.Enable } else { Wrap.Detect } nodes.into_iter.each(fn (n) { node(n, wrap) }) } } }\n\nLet's break this down, starting with this line:\n\n    \n    \n    let width = Int.sum(nodes.iter.map(fn (n) { n.width(@wrapped) }))\n\nThis iterates over the child nodes (without taking ownership, hence the use of\niter and not into_iter), computes the width for each node, then sums up the\nresult using Int.sum(). Note how we pass the wrapped hash set to each call to\nwidth, this is needed so we can calculate the correct width based on the\nwrapping needs of any Group nodes.\n\nNext, we see if the nodes fit on the current line:\n\n    \n    \n    let wrap = if @size + width > @max { @wrapped.insert(id) Wrap.Enable } else { Wrap.Detect }\n\nWe check if the current line size plus the calculated width doesn't exceed the\nline limit. If it does, we track the current Group ID in the wrapped hash set,\nand use Wrap.Enable to signal wrapping of the child nodes is necessary,\notherwise we use Wrap.Detect. We when render the child nodes, passing this\nWrap value as an immutable borrow to each call to node:\n\n    \n    \n    nodes.into_iter.each(fn (n) { node(n, wrap) })\n\nPerformance wise it would be nice if we could somehow cache the output of\nwidth to speed things up a bit, but I haven't found a way of doing so.\nFortunately, it shouldn't matter much as the resulting setup is fast enough.\nFor example, Inko's code formatter can process around 240 000 lines per second\nusing this exact algorithm, which is more than fast enough.\n\n#### Rendering IfWrap\n\nRendering IfWrap nodes is straightforward: we check if the target group ID is\nin the wrapped set or not, and render the appropriate child node:\n\n    \n    \n    fn mut node(node: Node, wrap: ref Wrap) { match node { ... case IfWrap(id, node, _) if @wrapped.contains?(id) -> { node(node, Wrap.Enable) } case IfWrap(_, _, node) -> node(node, wrap) } }\n\nThe if @wrapped bit is a pattern matching guard, so the body is only evaluated\nif both the pattern and the guard match.\n\n#### Rendering Text and Unicode\n\nRendering of Text and Unicode nodes is straightforward:\n\n    \n    \n    fn mut node(node: Node, wrap: ref Wrap) { match node { ... case Text(str) -> text(str, str.size) case Unicode(str, width) -> text(str, width) } }\n\nWe use the text helper method defined earlier. For the Text node we use\nString.size to pass the byte size (and thus character, as Text is for ASCII-\nonly text), and for Unicode nodes we pass the pre-computed extended grapheme\nclusters count.\n\n#### Rendering whitespace\n\nWe render the various whitespace nodes (Line, SpaceOrLine and Indent) as\nfollows:\n\n    \n    \n    fn mut node(node: Node, wrap: ref Wrap) { match node { ... case Line if wrap.enable? -> new_line case SpaceOrLine if wrap.enable? -> new_line case SpaceOrLine -> text(' ', chars: 1) case Indent(nodes) if wrap.enable? -> { @size += INDENT.size @indent += 1 @buffer.push(INDENT) nodes.into_iter.each(fn (n) { node(n, wrap) }) @indent -= 1 } case Indent(nodes) -> nodes.into_iter.each(fn (n) { node(n, wrap) }) case _ -> {} } }\n\nFor Line and SpaceOrLine we call new_line if wrapping is necessary. If no\nwrapping is needed we ignore the Line node (covered by the wildcard _ pattern\nat the end), while a SpaceOrLine is turned into a single space by calling the\ntext helper method.\n\nFor Indent nodes we first increment the line size, because we start\nindentation at the current line, then we increment the indent level (not the\nnumber of indent characters) and add the indentation text to the current line.\nWe then render the child nodes, and reset the indentation level to its\nprevious value.\n\n#### Converting Generator into a String\n\nOnce we're done with the Generator type, we want to turn the internal buffer\ninto a String we can write to a file or STDOUT. To make this easy, we'll\nimplement the IntoString trait from the std.string module:\n\n    \n    \n    impl IntoString for Generator { fn pub move into_string -> String { @buffer.into_string } }\n\nGiven an instance of Generator, we can then use Generator.into_string to move\nthe Generator into a String.\n\n#### The final Generator type\n\nCombining all this, our Generator type ends up looking like this:\n\n    \n    \n    class Generator { let @buffer: StringBuffer let @indent: Int let @size: Int let @max: Int let @wrapped: Set[Int] fn static new(max: Int) -> Generator { Generator { @buffer = StringBuffer.new, @indent = 0, @size = 0, @max = max, @wrapped = Set.new, } } fn mut generate(node: Node) { node(node, ref Wrap.Detect) } fn mut node(node: Node, wrap: ref Wrap) { match node { case Nodes(nodes) -> nodes.into_iter.each(fn (n) { node(n, wrap) }) case Group(id, nodes) -> { let width = Int.sum(nodes.iter.map(fn (n) { n.width(@wrapped) })) let wrap = if @size + width > @max { @wrapped.insert(id) Wrap.Enable } else { Wrap.Detect } nodes.into_iter.each(fn (n) { node(n, wrap) }) } case IfWrap(id, node, _) if @wrapped.contains?(id) -> { node(node, Wrap.Enable) } case IfWrap(_, _, node) -> node(node, wrap) case Text(str) -> text(str, str.size) case Unicode(str, width) -> text(str, width) case Line if wrap.enable? -> new_line case SpaceOrLine if wrap.enable? -> new_line case SpaceOrLine -> text(' ', chars: 1) case Indent(nodes) if wrap.enable? -> { @size += INDENT.size @indent += 1 @buffer.push(INDENT) nodes.into_iter.each(fn (n) { node(n, wrap) }) @indent -= 1 } case Indent(nodes) -> nodes.into_iter.each(fn (n) { node(n, wrap) }) case _ -> {} } } fn mut text(value: String, chars: Int) { @size += chars @buffer.push(value) } fn mut new_line { @size = INDENT.size * @indent @buffer.push('\\n') @indent.times(fn (_) { @buffer.push(INDENT) }) } } impl IntoString for Generator { fn pub move into_string -> String { @buffer.into_string } }\n\n### The Builder type\n\nThe Builder type is used to visit the AST and turn each AST node into its\ncorresponding Node value. This is typically where most of the complexity\nresides, as it's where you'll deal with constructing your formatting rules,\nedge cases, and more. For the sake of keeping things easy to understand, our\nBuilder type only supports simple function calls, string literals and regular\ntext literals (e.g. simple integers).\n\nWe'll start with the basic definition of this type, which is as follows:\n\n    \n    \n    class Builder { let @id: Int fn static new -> Builder { Builder { @id = 0 } } fn mut new_id -> Int { @id := @id + 1 } }\n\nThe id field is used to keep track of the next ID to use for Group nodes. The\nnew_id method is used to request a new ID and automatically update the id\nfield.\n\n#### Strings\n\nFor strings, we'll define a string method as follows:\n\n    \n    \n    class Builder { ... fn mut string(value: String) -> Node { Node.Group(new_id, [Node.Text('\"'), Node.unicode(value), Node.Text('\"')]) } }\n\nThis method constructs a Group node that represents a double quoted string.\nWhile the argument it takes is a regular String in this example, in a real\nformatter this would be something along the lines of a StringLiteral AST node\nof sorts, containing the actual string value along with extra data (e.g. the\nsource location).\n\n#### Function calls\n\nFor function calls we'll define a call method with two argument names: the\nname as a String, and the argument nodes as an array of Node values:\n\n    \n    \n    class Builder { ... fn mut call(name: String, arguments: Array[Node]) -> Node { let id = new_id if arguments.empty? { return Node.Group(id, [Node.Text(name), Node.Text('()')]) } let max = arguments.size - 1 let vals = arguments .into_iter .with_index .map(fn (index_and_node) { match index_and_node { case (index, node) if index < max -> { Node.Nodes([node, Node.Text(','), Node.SpaceOrLine]) } case (_, node) -> { Node.Nodes([node, Node.IfWrap(id, Node.Text(','), Node.Text(''))]) } } }) .to_array Node.Group( id, [ Node.Text(name), Node.Group( new_id, [ Node.Text('('), Node.Line, Node.Indent(vals), Node.Line, Node.Text(')'), ], ), ], ) } }\n\nWe start of by requesting a new group ID, then we check if we have any\narguments to process. If not, we return a simple Group node that renders to\nNAME() where NAME is the function name.\n\nIf we do have arguments, we turn the list of Node values into a comma\nseparated list, with a trailing comma after the last value that only shows up\nif wrapping is necessary:\n\n    \n    \n    let max = arguments.size - 1 let vals = arguments .into_iter .with_index .map(fn (index_and_node) { match index_and_node { case (index, node) if index < max -> { Node.Nodes([node, Node.Text(','), Node.SpaceOrLine]) } case (_, node) -> { Node.Nodes([node, Node.IfWrap(id, Node.Text(','), Node.Text(''))]) } } }) .to_array\n\nHere we turn arguments into an iterator over Node values, then we create a new\niterator using with_index that yields values in the form of (index, value). We\ndo this so we know when we're processing the last value, such that we can\ninsert a trailing comma that only shows up when wrapping is necessary. Inko\ndoesn't support pattern matching in closure arguments or let bindings at this\nstage, so we need to explicitly match the index_and_node tuple into its\ncomponents.\n\nThe rest is straightforward: for all but the last argument we produce a Nodes\nthat contains the value, followed by a comma and a SpaceOrLine node. For the\nlast argument we instead produce a Node that contains the last argument\nfollowed by an IfWrap, which renders to a comma only when wrapping is\nnecessary.\n\nAs map creates a new iterator (and everything is done lazily), we need to\nconvert the result to an array using the to_array method, such that we can\nstore the resulting array in a Node.\n\nThe Node returned is as follows:\n\n    \n    \n    Node.Group( id, [ Node.Text(name), Node.Group( new_id, [ Node.Text('('), Node.Line, Node.Indent(vals), Node.Line, Node.Text(')'), ], ), ], )\n\nThis tree ensures that the opening parenthesis always comes after the name, no\nmatter the formatting needs, and the closing parenthesis is placed on its own\nline when wrapping is necessary. If wrapping is necessary, we place each\nargument on its own line (as they are in a Group node), and each line is\nindented. The result is that if wrapping is necessary, expressions such as\nthis:\n\n    \n    \n    foo(10000000000000000, 200000000000000000, 'this is a string')\n\nWill be formatted like so:\n\n    \n    \n    foo( 10000000000000000, 200000000000000000, 'this is a string', )\n\n### Using the Generator and Builder types\n\nWith both types set up, we can use them like so:\n\n    \n    \n    # This creates a Generator that enforces a line length of 80 characters. let gen = Generator.new(80) let build = Builder.new let node = build.call( 'foo', [ Node.Text('1000000000000000000000000000000'), build.call( 'bar', [ Node.Text('2000000000000000000000000000000'), build.string('this is a string'), build.call('without_arguments', []), ], ), ], ) gen.generate(node) gen.into_string\n\nThis produces the following output:\n\n    \n    \n    foo( 1000000000000000000000000000000, bar(2000000000000000000000000000000, \"this is a string\", without_arguments()), )\n\nIf we instead change the line limit to 120, the output is as follows instead:\n\n    \n    \n    foo(1000000000000000000000000000000, bar(2000000000000000000000000000000, \"this is a string\", without_arguments()))\n\nAnd if we use a limit of 40, we get this instead:\n\n    \n    \n    foo( 1000000000000000000000000000000, bar( 2000000000000000000000000000000, \"this is a string\", without_arguments(), ), )\n\n## Applying this to a real formatter\n\nWhile what we've discussed so far is a simplified version of a real formatter,\nit's not too different from a real production code formatter. For example,\nInko's own formatter uses the same setup discussed here, it just has some\nextra nodes to handle specific formatting needs, and has to handle things such\nas rendering string escape sequences in their literal form (i.e. \\n is\nrendered as a literal \\n and not an actual newline), and whatever formatting\nedge cases present themselves based on the formatting rules.\n\nTo put it differently, the setup discussed here gets you about 80% of the way,\nwhile the remaining 20% is spent handling edge cases based on your formatting\nneeds. In case of Inko, I probably spent a week or two writing the initial\nformatter, followed by another two to three weeks of dealing with unexpected\nedge cases and careful tweaking of the output.\n\nThe final version of the code shown in this article, along with plenty of\ncomments to help understand the code better, is found in this Git repository,\nwhich you can easily run by either installing Inko or by using Docker/Podman.\nIf you want a more advanced example, consider taking a look at the code used\nby Inko's own formatter.\n\nThe code examples and the linked repository require the use of Inko's main\nbranch, as the code depends on some changes that have yet to be released.\nRefer to the repository's README for more details.\n\nIf you'd like to learn more about the various aspects of building programming\nlanguages, or you're interested in learning more about Inko, please consider\nsponsoring my work through GitHub Sponsors, join Inko's Discord server or\nMatrix channel (bridged to the Discord server), or subscribe to the /r/inko\nsubreddit.\n\n  1. In typical Ruby fashion, the community is seemingly unable to agree on a consistent code formatter to use, so it's not entirely clear how many actually use these formatters. RuboCop is widely used, but it's a linter and not just a style formatter.\n  2. Yes, I'm advertising my own work. Bite me.\n\n", "frontpage": false}
