{"aid": "39961221", "title": "LPython", "url": "https://lpython.org/", "domain": "lpython.org", "votes": 4, "user": "fuzztester", "posted_at": "2024-04-07 15:01:52", "comments": 0, "source_title": "LPython", "source_text": "# LPython\n\nHigh performance typed Python compiler\n\nLPython aggressively optimizes type-annotated Python code. It has several\nbackends, including LLVM, C, C++, and WASM. LPython\u2019s primary tenet is speed.\n\nLPython is in alpha stage (meaning users enthusiastically participate in bug\nreporting and fixing). LPython will compile more of Python in the future, and\naccumulate more optimizations, experimental and production-ready. LPython\nmakes it easy to write new back-ends for custom, exotic, or unusual hardware.\nRelease blog post: LPython: Novel, Fast, Retargetable Python Compiler.\n\nMain repository at GitHub: https://github.com/lcompilers/lpython Star\n\nTry LPython in your browser using WebAssembly: https://dev.lpython.org/\n\nAny questions? Ask us on Zulip .\n\n# Key features of LPython\n\n## Simple, standard, fast\n\n## LPython is fast\n\nLPython is built from the ground up to translate numerical, array-oriented\ncode into simple, readable, and fast code.\n\n## Basic mathematics in the core language\n\nRich array operations, complex numbers, exponentiation, special functions, ...\n\n## Simple but powerful\n\nMore restricting (and higher level) than languages like C or C++, so that the\nresulting code is easier to maintain and write and easier for the compilers to\noptimize. There is one canonical way to do things.\n\n## Just-In-Time (JIT)\n\nLPython supports Just-in-time compilation which requires only decorating\nPython function with @lpython.\n\n## Interoperability with CPython\n\nLPython offers seamless interoperability with CPython. One can easily call\nfunctions in CPython libraries\n\n## Open source\n\nLPython, being an open-source project, enjoys the advantages of community\ncollab, transparency, rapid bug resolution, enhanced security, knowledge\nexchange and more.\n\n# Feature Highlights\n\nLPython is in heavy development, there are features that work today, and there\nare features that are being implemented.\n\n## Works today\n\n  * Best possible performance for numerical, array-oriented code LPython gives you the speed you need for your numerical, array-oriented code. With LPython, you can write Python code that is as fast as C or C++. This is because LPython compiles your code to optimized machine code, which is the fastest way to run code on a computer.\n\n  * Code compatibility with CPython If LPython compiles and runs a code, then it will run in CPython.\n\n  * Seamless interoperability with CPython LPython can call functions in CPython libraries. This feature permits \u201cbreak-out\u201d to Numpy, TensorFlow, PyTorch, and even to matplotlib. The break-outs will run at ordinary (slow) Python speeds, but LPython accelerates the mathematical portions to near maximum speed.\n\n  * Just-In-Time (JIT) compilation LPython also supports Just-in-time compilation which requires only decorating Python function with @lpython. One can also specify the desired backend, as in, @lpython(backend=\u201cc\u201d) or @lpython(backend=\u201cllvm\u201d). Only C is supported at present; LLVM and others will be added in the near future.\n\n  * Clean, modular design, usable as a library LPython is structured around two independent modules, AST (Abstract Syntax Tree) and ASR (Abstract Semantic Representation), both of which are standalone (completely independent of the rest of LPython) and users are encouraged to use them independently for other applications and build tools on top. See the Design and Developer Tutorial documents for more details.\n\n  * Create executables It can create fast optimized executables unlike other interpreted compilers.\n\n  * Runs on Linux, Mac, Windows and WebAssembly All four platforms are regularly tested by our CI.\n\n  * Several backends The LLVM can be used to compile to binaries and for interactive usage. The C/C++ backend translates Python code to a readable C/C++ code. The x86 backend allows very fast compilation directly to x86 machine code. The WebAssembly backend can quickly generate WASM.\n\n## Under Development\n\nThese features are under development:\n\n  * Interactive, Jupyter support LPython is coming soon to Jupyter. It can be used as a Jupyter kernel, allowing Python/Julia-style rapid prototyping and an exploratory workflow (conda install jupyter lpython). It can also be used from the command-line with an interactive prompt (REPL).\n\n  * Support for diverse hardware LLVM makes it possible to run LPython on diverse hardware. We plan to support a wide range of hardware platforms, including:\n\n    * CPUs: compile Python code to run on CPUs of all architectures, including x86, ARM, and POWER.\n    * GPUs: compile Python code to run on GPUs from NVIDIA, AMD, and Intel.\n    * TPUs: compile Python code to run on TPUs from Google.\n\nPlease vote on issues in our issue tracker that you want us to prioritize\n(feel free to create new ones if we are missing anything).\n\n## Links to other available Python compilers:\n\nName| Total Contributors| Total stars  \n---|---|---  \nPyTorch| 2857| 69253  \nPyston| 1263| 2426  \nmypyc| 627| 15995  \nJAX| 523| 24010  \nMicroPython| 520| 16998  \nCython| 435| 8168  \nNumba| 306| 8790  \nCuPy| 286| 7062  \nTaichi| 226| 24023  \nPyPy| 213| -  \nTriton| 155| 7846  \nNuitka| 138| 9385  \nBrython| 94| 6058  \nSkulpt| 91| 3256  \nPythran| 58| 1912  \nDaCe| 58| 419  \nLPython| 44| 1135  \nWeld| 35| 2945  \nIronPython| 33| 2179  \nTranscrypt| 33| 2727  \nPyccel| 32| 279  \nPyjs| 30| 1123  \nGrumpy| 29| 10580  \nMojo| 26| 15569  \nuarray| 22| 98  \nShedskin| 20| 701  \nJython| 18| 897  \nCodon| 12| 13431  \nCompyle| 11| 67  \nSeq| 9| 680  \nHope| 6| 385  \nTransonic| 3| 105  \n  \nNote: we use \u201c-\u201d if there is no github repository. If any compiler is missing,\nor the stats are inaccurate, please let us know.\n\n\u2022 \u00a9 2023 \u2022 LPython\n\n", "frontpage": false}
