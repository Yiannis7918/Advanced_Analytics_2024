{"aid": "39960494", "title": "C++ web app with Crow: early scalability results", "url": "https://lemire.me/blog/2024/04/06/c-web-app-with-crow-early-scalability-results/", "domain": "lemire.me", "votes": 1, "user": "ibobev", "posted_at": "2024-04-07 13:06:05", "comments": 0, "source_title": "C++ web app with Crow: early scalability results", "source_text": "C++ web app with Crow: early scalability results \u2013 Daniel Lemire's blog\n\nSkip to content\n\nDaniel Lemire's blog\n\nDaniel Lemire is a computer science professor at the Data Science Laboratory\nof the Universit\u00e9 du Qu\u00e9bec (T\u00c9LUQ) in Montreal. His research is focused on\nsoftware performance and data engineering. He is a techno-optimist and a free-\nspeech advocate.\n\nJoin over 12,500 email subscribers:\n\nYou can follow this blog on telegram. You can find me on twitter as @lemire or\non Mastodon.\n\n## Support my work!\n\nI do not accept any advertisement. However, you can you can sponsor my open-\nsource work on GitHub.\n\n## Recent Posts\n\n## Recent Comments\n\n## Pages\n\n## Archives\n\n## Boring stuff\n\n# C++ web app with Crow: early scalability results\n\nLast year, I looked at writing small \u201chello world\u201d web applications in various\nprogramming languages (Go, JavaScript, Nim...). Go, using nothing but the\nstandard library, did well.\n\nIn these benchmarks, I am just programming an HTTP route that returns a small\nstring (e.g., \u2018hello world\u2019). The query is from the host itself. The intent\nbehind such a benchmark is to measure how well an web application might scale\nin the best of cases. I call such a benchmark \u2018simplistic\u2019 because nobody only\never returns just a short string and you do not usually query the server from\nthe host.\n\nAt the time, I had wanted to compare with a C++ library, and I ended up trying\nthe lithium framework which scaled very well.\n\nJake Arkinstall pointed out that he uses Crow, to build web applications in\nC++. So I decided to take Crow out on a spin.\n\nMy simplistic application has only few lines:\n\n    \n    \n    #include \"crow.h\" int main() { crow::SimpleApp app; app.loglevel(crow::LogLevel::Warning); CROW_ROUTE(app, \"/simple\")([](){ return \"Hello world\"; }); app.port(18080).multithreaded().run(); }\n\nThis allows the server to use all threads. You can limit the server to fewer\nthreads by replacing multithreaded() by concurrency(32) to limit (e.g.) the\nserver to 32 threads.\n\nTo build it, I use a standard CMakeLists.txt file:\n\n    \n    \n    cmake_minimum_required(VERSION 3.15) project(funserver CXX) find_package(Crow REQUIRED) add_executable(server src/server.cpp) target_link_libraries(server Crow::Crow)\n\nAnd I use a conan file to specify the dependency:\n\n    \n    \n    [requires] crowcpp-crow/1.1.0 [generators] CMakeDeps CMakeToolchain\n\nThat is all. Then to build, I issue the following commands in shell:\n\n    \n    \n    conan profile detect --force conan install . --output-folder=build --build=missing cmake -B build -DCMAKE_TOOLCHAIN_FILE=conan_toolchain.cmake -DCMAKE_BUILD_TYPE=Release cmake --build build ./build/server\n\nI assumes that you have C++ compiler, Conan and CMake, but these are standard\ntools.\n\nAfter issuing these commands, my server is then running. I use bombardier to\nhammer the server with requests. On a Linux server with many processors (two\nIntel Xeon Gold 6338 CPUs, each made of 32 cores) and much memory, I try\nincreasing the number of simultaneous requests (using the tool bombardier) and\nlooking for errors. As the number of simultaneous queries increase, the system\nhas to sustain both a high number of requests and as well as the processing of\nthe server. You can run my benchmark from my source code and instructions.\nYour numbers will differ.\n\nsimultaneous queries| requests/s| errors (%)  \n---|---|---  \n10| 260k| 0%  \n100| 315k| 0%  \n1000| 380k| 0%  \n10,000| 350k| 0.002%  \n  \nThese are numbers comparable to the lithium server. So it seems that Crow\noffers state-of-the-art performance. Crow offers HTTP/1.1 and Websocket\nsupport, but it has currently no support for the more recent standards. It has\na nice Web site.\n\nAppendix. Andrew Johnston invited me to compare these results with a similar\nserver written using Bun, the fast JavaScript runtime. I use the following\nprogram.\n\n    \n    \n    Bun.serve({ fetch (req) { const url = new URL(req.url); if (url.pathname === \"/simple\") return new Response(\"Hello world!\"); return new Response('Should return an error!') }, port: Number(Bun.env.PORT || 3000), address: Bun.env.ADDRESS || '127.0.0.1' })\n\nUsing the same hardware, and the same test setup, I get the following results\nwith Bun:\n\nsimultaneous queries| requests/s| errors (%)  \n---|---|---  \n10| 48k| 0%  \n100| 53k| 0%  \n1000| 54k| 0%  \n10,000| 47k| 0%  \n  \nI have verified that the bun server is multi-threaded. The command ps huH p\nprocessid |wc -l reveals that it uses about 10 threads.\n\nThus Bun is between 6 to 8 times slower than a pure C++ server written with\nCrow, in my tests. Your results will vary.\n\nI found it interesting that Bun never caused error, even under stress. The\nreason is likely that the Bun server never uses many threads, so the system is\nless likely to be under stress.\n\nPlease note that I am not encouraging you to use Crow instead of Bun. I am\ndefinitively encouraging you to check Bun out.\n\n## Published by\n\n### Daniel Lemire\n\nA computer science professor at the University of Quebec (TELUQ). View all\nposts by Daniel Lemire\n\nPosted on April 6, 2024April 7, 2024Author Daniel LemireCategories\n\n### Leave a Reply Cancel reply\n\nYou may subscribe to this blog by email.\n\nTerms of use Proudly powered by WordPress\n\n", "frontpage": false}
