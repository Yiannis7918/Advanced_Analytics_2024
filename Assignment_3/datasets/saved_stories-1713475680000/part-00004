{"aid": "40077234", "title": "Fixing JavaScript Date \u2013 Web Compatibility and Reality (2017)", "url": "https://maggiepint.com/2017/04/11/fixing-javascript-date-web-compatibility-and-reality/", "domain": "maggiepint.com", "votes": 2, "user": "simonpure", "posted_at": "2024-04-18 15:27:15", "comments": 0, "source_title": "Fixing JavaScript Date \u2013 Web Compatibility and Reality", "source_text": "Fixing JavaScript Date \u2013 Web Compatibility and Reality \u2013 Maggie's Blog\n\nSkip to content\n\nMostly JavaScript, and Date and Time, Sometimes Dogs\n\n# Maggie's Blog\n\n# Fixing JavaScript Date \u2013 Web Compatibility and Reality\n\nIn my previous post, I discussed things that could be fixed in JavaScript\u2019s\ndate implementation \u2013 if we wanted to. In this post, I\u2019ll discuss things that\ncan\u2019t be fixed \u2013 no matter how much we want them to be.\n\n## No Semantic Versioning Here!\n\nMost developers are familiar with Semantic versioning, or semver. In semver,\nwe have the idea of three kinds of release:\n\n  * Patch \u2013 releases that fix bugs only\n  * Minor \u2013 releases that add small features\n  * Major \u2013 releases that break things, so you have to change code\n\nSemver is amazing. It clearly describes what versions we can safely upgrade\nto, when we should look for new features, and when we should expect to have to\nchange code that is broken. It enables awesomeness. Unfortunately, it is not a\nreality for JavaScript.\n\nA blessing and curse of JavaScript is that it is currently the world\u2019s most\npopular programming language. Because of the sheer number of users, it\u2019s safe\nto assume that anything that can be expressed with the language, has been\nexpressed with the language, even if the code is what any sane person would\nconsider terrible.\n\nIn addition, terrible code from 1998 is still being served to browsers\neverywhere, and there aren\u2019t enough devs in the world to go update all of that\ncode.\n\nThis results in two very important concepts that members of TC39 must\nconstantly keep in mind:\n\n  1. Web Compatibility \u2013 No change made to ECMAScript can be incompatible with the existing behavior of ECMAScript\n  2. Web Reality \u2013 If code currently behaves a certain way, future versions of the spec should continue to have it behave that way \u2013 even if the behavior present is not described in the spec.\n\nThese concepts can really be summed up with the words \u201cDon\u2019t break the web!\u201d.\nThis creates a reality where there can be no such thing as a semver \u2018major\nrelease\u2019 in JavaScript. This idea drives every moment of the TC39 process, and\nhas resulted in some unpopular but necessary compromises in the spec.\n\n## Mutability \u2013 a Web Compatibility Problem\n\nI am a big fan of Domain Driven Design by Erik Evans. In the DDD world,\nobjects can be differentiated as Entities which change over time and are\ntracked by their ID, and Value Types which are defined by their properties.\nUnder this definition, a DateTime is a value type. If any property of the date\nchanges (for instance, the month changes from January to Feburary), the date\nis certainly a different date. Currently though, JavaScript doesn\u2019t really\nwork this way. Consider the following:\n\n1234| var a = new Date();a.toISOString();\n//\"2017-04-05T05:57:53.350Z\";a.setMonth(11);a.toISOString();//\"2017-12-05T05:57:53.350Z\";  \n---|---  \n  \nAs you can see, the value of object a changes. Yet, April and December are\ncertainly different months, and these are certainly different dates. This kind\nof behavior sets people up for nasty bugs down the road. For instance, the\nfollowing code will not behave as expected:\n\n12345678910| function addOneWeek(myDate) {myDate.setDate(myDate.getDate() +\n7);return myDate;}var today = new Date();var oneWeekFromNow =\naddOneWeek(today);console.log(`today is ${today.toLocaleString()}, and one\nweek from today will be ${oneWeekFromNow.toLocaleString()}`);//today is\n4/16/2017, 10:58:10 AM, and one week from today will be 4/16/2017, 10:58:10 AM  \n---|---  \n  \nWOAH! This is no good. A better, and less bug prone behavior, would be to have\nthe setters on the Date object return a new instance of the date \u2013 or for\ndates to be immutable. Then, the above code could be refactored to this common\nsense code:\n\n12345678| function addOneWeek(myDate) {return myDate.setDate(myDate.getDate()\n+ 7);}var today = new Date();var oneWeekFromNow =\naddOneWeek(today);console.log('today is ${today.toLocaleString()}, and one\nweek from today will be ${oneWeekFromNow.toLocaleString()}');//today is\n4/09/2017, 10:58:10 AM, and one week from today will be 4/16/2017, 10:58:10 AM  \n---|---  \n  \nUnfortunately, this is not to be because of a Web Compatibility issue. In\nshort, if we were to make this change, tons and tons of code that relies on\ndate being mutable (including the entire Moment.js library, BTW) would be\nbroken.\n\n## Broken Parser \u2013 A Web Reality Issue\n\nThe ECMA262 standard currently describes very few rules for parsing date\nstrings. These few excerpts are of particular interest:\n\n> ECMAScript defines a string interchange format for date-times based upon a\n> simplification of the ISO 8601 Extended Format. The format is as follows:\n> YYYY-MM-DDTHH:mm:ss.sssZ\n\nThis quote makes perfect sense. It states that JavaScript uses ISO8601 format\nas it\u2019s main date interchange format. Since this is the most common\ninterchange format for dates in modern computing, this is a great start! The\nstandard then describes ISO8601 format options briefly:\n\n> This format includes date-only forms:\n>\n> YYYY YYYY-MM YYYY-MM-DD\n>\n> It also includes \u201cdate-time\u201d forms that consist of one of the above date-\n> only forms immediately followed by one of the following time forms with an\n> optional time zone offset appended:\n>\n> THH:mm THH:mm:ss THH:mm:ss.sss\n\nSo basically, you can have date only ISO8601 formats, and combined date-time\nformats. All good. But then a few lines further down, you get this wonderful\nquote:\n\n> When the time zone offset is absent, date-only forms are interpreted as a\n> UTC time and date-time forms are interpreted as a local time.\n\nIn practice, what does this mean? Consider the following code:\n\n1234| new Date('2017-04-08').toISOString()//\"2017-04-08T00:00:00.000Z\"new\nDate('2017-04-08T08:30').toISOString()//\"2017-04-08T15:30:00.000Z\"  \n---|---  \n  \nBasically, when I didn\u2019t specify a time, the value was interpreted as a UTC\nvalue, but when I did specify a time it was interpreted as local. This is\nall... a bit mad. The next question one would ask is \u201cis this some oddity of\nthe ISO8601 specification?\u201d But in fact that spec dictates that absent an\noffset, the time should be interpreted as local \u2013 meaning that under ISO8601\nboth values above should have been read as local time.\n\nWhat happened here was a weird \u2018Web Reality\u2019.\n\nIn the days of ES5, the specification read this way:\n\n> The value of an absent time zone offset is \u201cZ\u201d.\n\nThis is saying that absent an offset, the time zone should be interpreted as\nUTC \u2013 the exact opposite of what the ISO8601 spec says. TC39 realized their\nerror, and in ES2015 they corrected to this:\n\n> If the time zone offset is absent, the date-time is interpreted as a local\n> time.\n\nThis is how the spec should read, as it aligns with ISO8601\u2019s standard, and\nhow basically every other date time API works. So why was it changed? Because\nas browsers started shipping this change, they started getting tons of bug\nreports that times weren\u2019t being interpreted as they had been before \u2013 which\nof course they weren\u2019t. By the time TC39 was able to give this issue more\nattention, the ecosystem was stratified, with some browsers picking UTC, and\nothers picking Local, and others still making unique code compromises. After\nmuch evaluation of user feedback about what was expected to happen, the\ncommittee settled on the text as it is today, because it was the \u2018reality\u2019 of\nhow the web worked \u2013 even if it wasn\u2019t correct by the definition of the\nstandard, or even particularly logical.\n\nGiven the amount of pain changes to this part of the spec caused the greater\ncommunity, it is the case that it can\u2019t be changed. The \u2018web reality\u2019 of what\npeople expect from Date\u2019s current parser will not allow it.\n\n## What do Do?\n\nThese two things were the impetuous for Matt, Brian, and I to choose to\nintroduce a new datetime handling object to JavaScript, giving us a clean\nslate to make the world right. Currently we call this object \u2018temporal\u2019. This\nproposal can be found here, but look for a future post discussing our choices.\n\n### Share this:\n\n  * Twitter\n  * Facebook\n\nLike Loading...\n\n### Related\n\nWhy Moment.js Isn\u2019t Immutable YetJune 24, 2016In \"Moment.js\"\n\nFixing JavaScript Date \u2013 Getting StartedApril 9, 2017In \"Date Proposal\"\n\nJavaScript MN 2016-04-27April 28, 2016\n\n  * Date Proposal\n\n  * Maggie Pint\n  * April 11, 2017April 22, 2017\n\n### Leave a comment Cancel reply\n\n## Topics\n\n  * AngularJS (1)\n  * Conference Follow Up (2)\n  * Date Proposal (2)\n  * Moment.js (4)\n  * Raven Mistakes (5)\n  * Uncategorized (14)\n\nBlog at WordPress.com.\n\n  * Comment\n  * Reblog\n  * Subscribe Subscribed\n\n    * Maggie's Blog\n    * Already have a WordPress.com account? Log in now.\n\n  * Privacy\n  *     * Maggie's Blog\n    * Customize\n    * Subscribe Subscribed\n    * Sign up\n    * Log in\n    * Copy shortlink\n    * Report this content\n    * View post in Reader\n    * Manage subscriptions\n    * Collapse this bar\n\n%d\n\n", "frontpage": false}
