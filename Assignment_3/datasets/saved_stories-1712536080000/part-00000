{"aid": "39962649", "title": "Tips and Tricks for Nix Flakes (2021)", "url": "https://ipetkov.dev/blog/tips-and-tricks-for-nix-flakes/", "domain": "ipetkov.dev", "votes": 1, "user": "peter_d_sherman", "posted_at": "2024-04-07 18:25:22", "comments": 0, "source_title": "Tips and Tricks for Nix Flakes", "source_text": "Tips and Tricks for Nix Flakes | Ivan Petkov\n\nipetkov.dev\n\n# Tips and Tricks for Nix Flakes\n\n2021-12-12\n\n:: tags: #NixOS #flakes\n\nAfter working with Nix flakes for a while you develop a sense for how to\ninteract with them in more efficient or ergonomic ways. That said, a number of\nthe interactions I'm about to describe were extremely non-obvious to me,\nespecially as someone who had never peeked at their actual implementation.\n\nThis is the cheat-sheet I wish someone had shown me when I first started\ntinkering with flakes. I hope you find it useful.\n\n# Wrangling Flake Inputs\n\nThe flake input schema allows for:\n\n  1. Having your flake pull in another flake as an input\n  2. Having your flake pull in an input that is specified by another flake\n  3. Forcing another flake to use an input specified in your flake\n  4. Forcing another flake to use an input specified by yet a different flake\n\nBeing aware of this functionality can be useful in ensuring that all inputs\nagree on the same common dependency: for example, using the same revision of\nnixpkgs can avoid having multiple versions of the same package floating in the\noutput closure, each built with slightly different dependencies coming from\ndifferent nixpkgs commits.\n\nLet's take a look at some examples.\n\n    \n    \n    { inputs = { # Case 1, pulling in some flake(s) we care about, locked to some revision dotfiles.url = \"github:ipetkov/dotfiles\"; mypinned-nixpkgs.url = \"github:NixOS/nixpkgs/34ad3ffe08adfca17fcb4e4a47bb5f3b113687be\"; # Case 2, pulling in an input specified by another flake. In this case # we may want to treat the `dotfiles` flake as some common source-of-truth # and use the nixpkgs version from there mynixpkgs.follows = \"dotfiles/nixpkgs\"; # Case 3, forcing another flake to use one of our inputs home-manager = { url = \"github:nix-community/home-manager\"; inputs.nixpkgs.follows = \"mypinned-nixpkgs\"; }; # Case 4, forcing another falke to use a _different flake's input_ as its # own, but without pulling said input in our scope deploy-rs = { url = \"github:serokell/deploy-rs\"; inputs.flake-compat.follows = \"dotfiles/flake-compat\"; }; }; outputs = { self, dotfiles, mypinned-nixpkgs, mynixpkgs, home-manager, deploy-rs, # NB: no ... wildcard here, these are all the inputs we have declared for # our flake! }: { # Rest of flake... }; }\n\nWhen in doubt, nix flake info will show all inputs and what revision (or other\nflake's inputs) are being tracked!\n\n## Updating Inputs\n\n  1. nix flake update will try to update all inputs where possible\n\n     * Inputs pinned to specific revisions will, of course, remain pinned\n     * Easiest way to ensure everything stays up to date\n  2. nix flake lock --update-input $NAME will only try to update the $NAME input\n\n     * Useful for updating one particular input more frequently (e.g. via automation) without necessarily updating other unpinned inputs (like nixpkgs)\n  3. The common flake option --override-input $INPUT $NEW can be used to substitute a different input for the current invocation without updating the lock file\n\n     * This could be useful for building the current flake while programmatically bisecting an input\n\n# Flake Checks\n\nThe nix flake check command is a great way to ensure that the entire flake\nconfiguration is up to snuff with a single invocation. It's also a great\ntarget for your CI system to run so you don't have to keep reconfiguring it\nwhenever a new package or system configuration is added.\n\nOther benefits include:\n\n  * All nixosConfigurations are evaluated (but not built) to check for any option/configuration collisions without needing to go through nixos-rebuild dry-build --flake .\n  * Checks can include any arbitrary derivation. I personally like to include all of my package definitions as well so that they can be built with the same nix flake check invocation (caching will take care of this being fast).\n  * You can include extra targets in there, especially stuff like linters/formatters which you would want to gate CI on (but not necessarily prevent downstream consumers from building packages if these tests fail).\n\n# Exploring Flake Contents\n\nSometimes it can be useful to (interactively) explore what a flake holds which\nyou can't easily spot via something like nix flake show (things like \"what is\nthe actual derivation for X check\", or exploring the fully evaluated\nconfigurations of a NixOS configuration, etc.). This is where nix repl becomes\nvery useful.\n\nIn the same way that :l <nixpkgs> can be invoked to load a Nix expression and\nbring it into scope, :lf . will load a Nix flake from the current directory\nand add it to the scope. The output attribute will already be evaluated so\ntab-completion will work with something like\noutputs.nixosConfigurations.<TAB>.\n\nNote that the :lf built-in is available in Nix 2.4 or later. Flakes can also\nbe loaded via builtins.getFlake (toString ./.) on earlier Nix versions which\nhave the experimental flakes feature enabled.\n\n# Shell Completions\n\nCheck to see if you have shell completions enabled for your favorite shell, if\nthey aren't already. I like to use fish which has really good completion\nsupport out of the box, especially with completions already configured for\nother packages via NixOS/home-manager configs.\n\nCompletions didn't used to work a while back, but they sure do now! So next\ntime you invoke a command on a flake, try out something like nix build\n.#packages.x86_64-linux.<TAB>.\n\n# General Flake Consumption\n\nContrary to how it appears at first, there are only a handful of flake\nproperties which are magical built-in and understood by Nix itself:\n\n  1. Reading/managing the flake.lock file\n  2. Pulling in input sources to the store\n  3. Evaluating the outputs function with the inputs passed in\n\nBesides that, everything else behaves like any other nix expression. Sure, the\nCLI is aware of things like checks/packages/devShells, or it may expect\ncertain formats like checks being derivations or nixosConfigurations nix\nmodules, but it won't mind or stop you from defining your own attributes on\nthe flake itself. It will just ignore them.\n\nFor example, here's how we can define our own home-manager configuration.\n\n    \n    \n    # flake.nix { inputs = { nixpkgs.url = \"nixpkgs/nixos-unstable\"; home-manager = { url = \"github:nix-community/home-manager\"; inputs.nixpkgs.follows = \"nixpkgs\"; }; }; outputs = { self, home-manager }: { homeManagerConfigurations.x86_64-linux = { myConfig = home-manager.lib.homeManagerConfiguration { system = \"x86_64-linux\"; username = \"ivan\"; homeDirectory = \"/home/ivan\"; stateVersion = \"21.03\"; configuration = {...}: { # Some config }; }; }; }; }\n\nIf we want to manually build (and cache) the packages associated with the\nconfiguration, we can invoke nix build\n.#homeManagerConfigurations.x86_64-linux.myConfig.activationPackage.\n\nIf we wanted to automate building all home-manager configurations for a\nparticular system in our CI, we can add the file below and configure our CI to\nexecute nix build -f ciHomeManagerConfigurations.nix!\n\n    \n    \n    # ciHomeManagerConfigurations.nix { system ? builtins.currentSystem }: let flake = builtins.getFlake (toString ./.); inherit (flake.inputs.nixpkgs) lib; homeManagerConfigsForSystem = lib.attrByPath [system] {} flake.homeManagerConfigurations; in # Return all home-manager configuration derivations matching the current system lib.attrsets.mapAttrs (_: hmConfig: hmConfig.activationPackage) homeManagerConfigsForSystem\n\n\u2190 Building with SQLx on Nix Introducing Crane: Composable and Cacheable Builds\nwith Cargo and Nix \u2192\n\n\u00a9 2024 Ivan Petkov :: Theme based on Terminimal by pawroman\n\n", "frontpage": false}
