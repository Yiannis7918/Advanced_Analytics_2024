{"aid": "39963904", "title": "How and why we built our expense tracker with CRDTs", "url": "https://tender.run/blog/tender-and-crdts", "domain": "tender.run", "votes": 1, "user": "luu", "posted_at": "2024-04-07 21:04:01", "comments": 0, "source_title": "How and why we built our expense tracker with CRDTs", "source_text": "How and why we built our expense tracker with CRDTs | Tender\n\nSkip to content\n\nTender\n\nAppearance\n\n\u2190 Back to blog\n\n# How and why we built our expense tracker with CRDTs\n\nWe're Tender - an inbox for your personal finances. We connect with your bank\naccounts and help you get to inbox-zero and stay on top of your spending.\nCheck out the demo to learn more!\n\nI started building Tender a year ago to explore an alternative path for\nbuilding a personal finance app - one that prioritizes privacy and runs\nlocally on the user's device. There are countless personal finance tools out\nthere, but by-and-large they operate in the cloud, exposing user data to a\nbroader surface to secure. I believe that a local-first app not only\nstrengthens our privacy posture, but also makes for a better user experience.\n\nTender uses the Automerge CRDT to store user data - a (conflict-free,\nreplicated) data-type that supports making edits across multiple devices in a\nway that can be merged. CRDTs are common in collaborative apps like Figma or\nApple Notes, where you might have several users working on the same document,\nmaking edits that need to be combined.\n\nAlthough Tender doesn't (yet!) utilize the multiplayer capabilities that CRDTs\nprovide, Automerge gives us the foundations to build a secure, local-first\napp. I wanted to share some of the reasoning behind Tender's CRDT-based\narchitecture, as well as some lessons learned around building local-first.\n\n## Thinking in local-first\n\nAutomerge lets us store user data as opaquely as possible. Instead of every\npiece of functionality in the app touching a server-side database full of user\ndata, we simply treat all user data as opaque binary files, not a complex\ndataset that needs to be carefully managed and worked with. The cloud becomes\nour backup solution, not where all of our application logic lives.\n\nThis architecture has greatly simplified how we build the product. When we\nwant to build new features, we don't have to deal with the boilerplate of\nwriting out a database layer, then a REST or GraphQL API, then finally the\ninterface on top of it. Everything is locally available, already in the\nbrowser where we keep the business logic and application UI side-by-side.\n\n## Interacting with data\n\nSince data is mostly handled on the user's device, our backend takes on fewer\nresponsibilities. For instance, when users sync their data from our data\npartners like Plaid, our server simply acts as an intermediary proxy to plaid\non behalf of the user. The backend isn't handling any user data on its own\nwhen a user's device isn't requesting it.\n\nAs a plus, a simple backend system means that our backend costs are quite low.\nWe run two small virtual machines for all of our traffic, and the second one\nis just there to have a hot standby.\n\nWorking in local-first also naturally sets us up to build end-to-end\nencryption (e2ee) in the future, so that servers would only hold encrypted\ndata that can't be read, even if an attacker broke in. In contrast, grafting\ne2ee might be difficult or impossible to add after-the-fact to a cloud-based\napp.\n\n## Skip the internet connection\n\nHaving user data on-device eliminates the threat of internet latency. In\ntraditional cloud apps interactions might take multiple round trips to a\nserver to fetch, process, and refetch data. In Tender, changes happen\nvirtually instantly since all of the necessary data is already available and\nready to serve.\n\nNot only does this architecture help with times when the user might have a\nspotty connection, but it means we can trivially support offline mode. Changes\nare persisted locally, then synced back to the cloud when the device comes\nback online.\n\n## Indexing on the bleeding edge\n\nLocal-first architectures are still relatively nascent, and we've had to spend\na few of our innovation tokens to get here.\n\nFor one, the Automerge CRDT is structured as a JSON document. As a personal\nfinance tool, Tender has to be able to run queries against its data in ways\nthat don't quite mesh with such a structure. For instance, how would we run a\nfull-text search to match descriptions? Or calculate how much you spent on\nsparkling water this month? There isn't an off-the-shelf way to do these\nthings.\n\nIn Tender, we built an indexing system that takes data out of our CRDT and\nbuilds indices in a sqlite database in the browser. Essentially, we take\nrecords like:\n\nts\n\n    \n    \n    { \"description\": \"Uber Eats\", \"amount\": 1950, \"date\": 1712029191841, // ... }\n\nand turn them into something that can be queried with sql:\n\nsql\n\n    \n    \n    select sum(amount) from transactions where date > datetime('now', '-1 month') order by date;\n\nSupporting both reading from the document structure and querying with SQLite\ngives us a lot flexibility when developing new features.\n\nWe're getting some of this work ready to open source (please send me a note if\nyou're interested!) in case other folks might find it useful as well.\n\n## Proxying connections\n\nEarlier, I mentioned that for operations involving third party providers like\nPlaid and Splitwise, we treat the server as a simple proxy for operations\nkicked off by the client-side application.\n\nWe want as little of our user's data as possible, so ideally we want Tender to\ntalk to these providers directly, cutting us out as a middle man. However,\npractically we can't build a system to work this way - we still need to be\nable to check access control, deal with CORS, rate limit clients, and at the\nvery least, provide our app-level access tokens in the outgoing requests.\n\nSo we do the next best thing - we use the node-based API bindings intended to\nrun on a server, but in the browser instead. We intercept the requests made by\nthose libraries at the browser-level and reroute them through our server. This\nscheme lets us do everything we need for access control, etc. before making\nthe request.\n\nAs an aside, here's an idea for how API providers can make local-first apps\nmore private: providers should support encrypting user data with\npublic/private keys that only the end user's device holds. Our backend could\nfacilitate getting data to users' devices without actually having access to\nit. Unfortunately, the market is likely too small for anyone to undertake such\nan architecture.\n\n## Scaling the CRDT\n\nWe expect a user's data to grow as the user spends more time with Tender. Over\ntime, the data grows larger and larger to sizes that start to get unwieldy in\nthe browser, especially since Automerge's history-based CRDT keeps the history\nof edits over all time in the document.\n\nRight now, Tender uses a single monolithic document to store its data, but\nwe'll likely need to look into splitting this document up to scale to years\nand years of transaction data.\n\nCurrently, Tender also does most of its data manipulation in the main JS\nthread. This has worked perfectly fine for a while just because of how fast\nthe local data structures really are, but we'll need to background more work\nas the application grows in size.\n\n## The local-first future\n\nAutomerge has provided a strong foundation for us to build a private and\nsecure application that has all of the benefits of the modern web with fewer\nof the drawbacks. We're also thinking up more ways we can take advantage of\nthe CRDT (mulitplayer expenses, anyone?) going forward. I'm really excited\nthat we get to be part of the local-first movement.\n\nDiscuss on HN.\n\n## Stephen on April 1, 2024\n\nPrivacy Policy \u00b7 Terms of Service \u00b7 Security Overview\n\nCopyright \u00a9 2024 Tender\n\n", "frontpage": false}
