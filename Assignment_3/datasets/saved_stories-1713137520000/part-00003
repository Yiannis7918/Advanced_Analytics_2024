{"aid": "40032737", "title": "Writing highly scalable backends in UDP. The solution", "url": "https://mas-bandwidth.com/writing-scalable-backends-in-udp-the-solution/", "domain": "mas-bandwidth.com", "votes": 1, "user": "gafferongames", "posted_at": "2024-04-14 17:31:09", "comments": 0, "source_title": "Writing scalable backends in UDP. The solution.", "source_text": "Writing scalable backends in UDP. The solution.\n\nM\u00e1s Bandwidth\n\nSign in Subscribe\n\nApr 14, 2024 3 min read bandwidth\n\n# Writing scalable backends in UDP. The solution.\n\nLast week I shared an interview question I've used successfully at Network\nNext for many years. In this article I share the solution.\n\nThe actual question looks deceptively easy:\n\n> You are tasked with creating a client/server application in Golang that runs\n> in Google Cloud. The client in this application must communicate with the\n> server over UDP.\n>\n> Each client sends 100 requests per-second. Each request is 100 bytes long.\n> The server processes each request it receives and forwards it over HTTP to\n> the backend.\n>\n> The backend processes the request, and returns a response containing the\n> FNV1a 64 bit hash of the request data. The server returns the response it\n> receives from the backend down to the client over UDP.\n>\n> Implement the client, server and backend in Golang. Provide an estimate of\n> the cost to run the solution each month at a steady load of 1M clients, as\n> well as some options you recommend as next steps to reduce the cost.\n\nSounds well enough. I think most programmers familiar with Golang could\nimplement the code above over a weekend, it doesn't seem too hard. Time to get\ncoding right?\n\nNo. Not at all. Turns out, it's basically fucking impossible.\n\n### The Kobayashi Maru\n\n> The Kobayashi Maru is a training exercise in the Star Trek franchise\n> designed to test the character of Starfleet Academy cadets by placing them\n> in a no-win scenario. The Kobayashi Maru test was first depicted in the 1982\n> film Star Trek II: The Wrath of Khan, and it has since been referred to and\n> depicted in numerous other Star Trek media.\n>\n> The nominal goal of the exercise is to rescue the civilian fuel ship\n> Kobayashi Maru, which is damaged and stranded in neutral territory between\n> the Federation and the Klingon Empire. The cadet being evaluated must decide\n> whether to attempt to rescue the Kobayashi Maru\u2014endangering their ship and\n> crew\u2014or leave the Kobayashi Maru to certain destruction. If the cadet\n> chooses to attempt a rescue, an insurmountable enemy force attacks their\n> vessel. By reprogramming the test itself, James T. Kirk became the only\n> cadet to overcome the Kobayashi Maru simulation.\n>\n> The phrase \"Kobayashi Maru\" has entered the popular lexicon as a reference\n> to a no-win scenario. The term is also sometimes used to invoke Kirk's\n> decision to \"change the conditions of the test.\"\n>\n> \\-- Wikipedia\n\n### What's important is how the programmer thinks\n\nI've given this test to many candidates, and I've heard pretty much every\nresponse you could imagine, from \"That's easy! I could code that in a few\nhours\" to \"That's impossible and I won't even try\". You can even see a bunch\nof people getting worked up over this question on the hacker news thread from\nwhen I posted it. https://news.ycombinator.com/item?id=39979078\n\nFrom the answers that people wrote in the comments, I can tell a lot about\nwhat sort of programmers they are. A particularly strong tell comes from\nprogrammers who think that they should just write it in <insert language of\nchoice> and everything would scale fine. Nope. It's still impossible.\n\nIt's also a particularly difficult problem to even get going at a low scale\n(10k clients) when everything is working correctly. UDP is very sneaky and if\nyou are not completely ruthless in tracking expected packets sent, vs. actual\nsent and received, you can easily fool yourself that you are scaling up to 30k\nclients when in reality you're only actually sending ~1k clients worth of\npackets with a naive sendto implementation.\n\nYes, there are many tricks along the way: socket send and receive buffer\nsizes, SO_REUSEPORT, batching, sharding and being stateless, being IO bound,\nhorizontal scaling, load balancing in Google Cloud, how the Linux kernel\nnetworking works and the many ways that UDP packets can get dropped. If you\nknow all these things you are at an advantage \u2013 or perhaps, a disadvantage \u2013\nsince you'll get further along before you realize it's impossible. But at a\ncertain point in this test, any programmer is going to realize \u2013 this is\nbasically impossible and not worth continuing.\n\nJust like the Kobayashi Maru, you can learn a lot about somebody based on how\nthey respond once they realize it's impossible, and the very best programmers\nbreak the rules to pass the test.\n\nHere is my answer. It's worth reviewing if you are curious about how to obtain\nhigh UDP request/response throughput for an application. It's not the only way\nto solve this problem, but it is mine:\n\nhttps://github.com/mas-bandwidth/udp/blob/main/001/README.md\n\nHow would you approach it?\n\n### Published by:\n\n### You might also like...\n\nApr\n\n09\n\n## Writing highly scalable backends in UDP\n\nIn this article I share an interview question I've used for years at Network\nNext. How to implement a highly scalable backend in UDP. Can you solve it?\n\nApr 9, 2024\n\n2 min read\n\nApr\n\n01\n\n## XDP for Game Programmers\n\nLearn how you can use XDP/eBPF to get maximum bandwidth for your applications.\n\nApr 1, 2024\n\n15 min read\n\nM\u00e1s Bandwidth \u00a9 2024\n\nPowered by Ghost\n\n", "frontpage": false}
