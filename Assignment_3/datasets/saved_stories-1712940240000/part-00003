{"aid": "40011145", "title": "Modern JavaScript Explained for Dinosaurs (2017)", "url": "https://peterxjang.com/blog/modern-javascript-explained-for-dinosaurs.html", "domain": "peterxjang.com", "votes": 2, "user": "Tomte", "posted_at": "2024-04-12 10:43:02", "comments": 0, "source_title": "Modern JavaScript Explained For Dinosaurs", "source_text": "Modern JavaScript Explained For Dinosaurs\n\n  * peterxjang\n  * blog\n\n# Modern JavaScript Explained For Dinosaurs\n\n18 Oct 2017\n\nImages from Dinosaur Comics by Ryan North\n\nLearning modern JavaScript is tough if you haven\u2019t been there since the\nbeginning. The ecosystem is growing and changing so rapidly that it\u2019s hard to\nunderstand the problems that different tools are trying to solve. I started\nprogramming in 1998 but only began to learn JavaScript seriously in 2014. At\nthe time I remember coming across Browserify and staring at its tagline:\n\n> \u201cBrowserify lets you require(\u2018modules\u2019) in the browser by bundling up all of\n> your dependencies.\u201d\n\nI pretty much didn\u2019t understand any word in this sentence, and struggled to\nmake sense of how this would be helpful for me as a developer.\n\nThe goal of this article is to provide a historical context of how JavaScript\ntools have evolved to what they are today in 2017. We\u2019ll start from the\nbeginning and build an example website like the dinosaurs did \u2014 no tools, just\nplain HTML and JavaScript. Then we\u2019ll introduce different tools incrementally\nto see the problems that they solve one at a time. With this historical\ncontext, you\u2019ll be better able to learn and adapt to the ever-changing\nJavaScript landscape going forward. Let\u2019s get started!\n\n> Update: I made a video course version of this article, which walks through\n> each section step-by-step for greater clarity, check it out here:\n> https://firstclass.actualize.co/p/modern-javascript-explained-for-dinosaurs\n\n### Using JavaScript the \u201cold-school\u201d way #\n\nLet\u2019s start with an \u201cold-school\u201d website using HTML and JavaScript, which\ninvolves manually downloading and linking files. Here\u2019s a simple index.html\nfile that links to a JavaScript file:\n\n    \n    \n    <!-- index.html --> <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>JavaScript Example</title> <script src=\"index.js\"></script> </head> <body> <h1>Hello from HTML!</h1> </body> </html>\n\nThe line <script src=\"index.js\"></script> refers to a separate JavaScript file\nin the same directory named index.js:\n\n    \n    \n    // index.js console.log(\"Hello from JavaScript!\");\n\nThis is all you need to make a website! Now let\u2019s say you wanted to add a\nlibrary someone else wrote like moment.js (a library which can help format\ndates in a human readable way). For example, you can use the moment function\nin JavaScript as follows:\n\n    \n    \n    moment().startOf('day').fromNow(); // 20 hours ago\n\nBut this is only assuming you include moment.js on your website! On the\nhomepage for moment.js you see the following instructions:\n\nHmm, there\u2019s a lot of stuff going in the Install section on the right. But\nlet\u2019s ignore that for now \u2014 we can add moment.js to our website by downloading\nthe moment.min.js file in the same directory and including it in our\nindex.html file.\n\n    \n    \n    <!-- index.html --> <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>Example</title> <link rel=\"stylesheet\" href=\"index.css\"> <script src=\"moment.min.js\"></script> <script src=\"index.js\"></script> </head> <body> <h1>Hello from HTML!</h1> </body> </html>\n\nNote that moment.min.js gets loaded before index.js, which means you can use\nthe moment function in index.js as follows:\n\n    \n    \n    // index.js console.log(\"Hello from JavaScript!\"); console.log(moment().startOf('day').fromNow());\n\nAnd this is how we used to make websites with JavaScript libraries! The good\nthing was that it was easy enough to understand. The bad thing was that it was\nannoying to find and download new versions of libraries every time they would\nupdate.\n\n### Using a JavaScript package manager (npm) #\n\nStarting around 2010, several competing JavaScript package managers emerged to\nhelp automate the process of downloading and upgrading libraries from a\ncentral repository. Bower was arguably the most popular in 2013, but\neventually was overtaken by npm around 2015. (It\u2019s worth noting that starting\naround late 2016, yarn has picked up a lot of traction as an alternative to\nnpm\u2019s interface, but it still uses npm packages under the hood.)\n\nNote that npm was originally a package manager made specifically for node.js,\na JavaScript runtime designed to run on the server, not the frontend. So that\nmakes it a pretty weird choice for a frontend JavaScript package manager for\nlibraries meant to run in a browser.\n\n> Note: Using package managers generally involves using a command line, which\n> in the past was never required as a frontend dev. If you\u2019ve never used one,\n> you can read this tutorial to get a good overview to get started. For better\n> or for worse, knowing how to use the command line is an important part of\n> modern JavaScript (and it opens up doors in other areas of development as\n> well).\n\nLet\u2019s look at how to use npm to install the moment.js package automatically\ninstead of manually downloading it. If you have node.js installed, you already\nhave npm installed, which means you can navigate your command line to the\nfolder with your index.html file and enter:\n\n    \n    \n    $ npm init\n\nThis will prompt you with several questions (the defaults are fine, you can\nhit \u201cEnter\u201d for each question) and generate a new file named package.json.\nThis is a configuration file that npm uses to save all project information.\nWith the defaults the contents of package.json should look something like:\n\n    \n    \n    { \"name\": \"your-project-name\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"ISC\" }\n\nTo install the moment.js JavaScript package, we can now follow the npm\ninstructions from their home page by entering the following command in the\ncommand line:\n\n    \n    \n    $ npm install moment --save\n\nThis command does two things \u2014 first, it downloads all the code from the\nmoment.js package into a folder called node_modules. Second, it automatically\nmodifies the package.json file to keep track of moment.js as a project\ndependency.\n\n    \n    \n    { \"name\": \"modern-javascript-example\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"moment\": \"^2.22.2\" } }\n\nThis is useful later when sharing a project with others \u2014 instead of sharing\nthe node_modules folder (which can get very large), you only need to share the\npackage.json file and other developers can install the required packages\nautomatically with the command npm install.\n\nSo now we no longer have to manually download moment.js from the website, we\ncan automatically download and update it using npm. Looking inside the\nnode_modules folder, we can see the moment.min.js file in the\nnode_modules/moment/min directory. This means we can link to the npm\ndownloaded version of moment.min.js in the index.html file as follows:\n\n    \n    \n    <!-- index.html --> <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>JavaScript Example</title> <script src=\"node_modules/moment/min/moment.min.js\"></script> <script src=\"index.js\"></script> </head> <body> <h1>Hello from HTML!</h1> </body> </html>\n\nSo the good thing is that we can now use npm to download and update our\npackages through the command line. The bad thing is right now we\u2019re digging\nthrough the node_modules folder to find the location of each package and\nmanually including it in our HTML. That\u2019s pretty inconvenient, so next we\u2019ll\ntake a look at how to automate that process as well.\n\n### Using a JavaScript module bundler (webpack) #\n\nMost programming languages provide a way to import code from one file into\nanother. JavaScript wasn\u2019t originally designed with this feature, because\nJavaScript was designed to only run in the browser, with no access to the file\nsystem of the client\u2019s computer (for security reasons). So for the longest\ntime, organizing JavaScript code in multiple files required you to load each\nfile with variables shared globally.\n\nThis is actually what we\u2019re doing with the above moment.js example \u2014 the\nentire moment.min.js file is loaded in the HTML, which defines a global\nvariable moment, which is then available to any file loaded after\nmoment.min.js (regardless of whether or not it needs access to it).\n\nIn 2009, a project named CommonJS was started with the goal of specifying an\necosystem for JavaScript outside the browser. A big part of CommonJS was its\nspecification for modules, which would finally allow JavaScript to import and\nexport code across files like most programming languages, without resorting to\nglobal variables. The most well-known of implementation of CommonJS modules is\nnode.js.\n\nAs mentioned earlier, node.js is a JavaScript runtime designed to run on the\nserver. Here\u2019s what the earlier example would look like using node.js modules.\nInstead of loading all of moment.min.js with an HTML script tag, you can load\nit directly in the JavaScript file as follows:\n\n    \n    \n    // index.js var moment = require('moment');\n    \n    console.log(\"Hello from JavaScript!\"); console.log(moment().startOf('day').fromNow());\n\nAgain, this is how module loading works in node.js, which works great since\nnode.js is a server side language with access to the computer\u2019s file system.\nNode.js also knows the location of each npm module path, so instead of having\nto write require('./node_modules/moment/min/moment.min.js), you can simply\nwrite require('moment') \u2014 pretty sweet.\n\nThis is all great for node.js, but if you tried to use the above code in the\nbrowser, you\u2019d get an error saying require is not defined. The browser doesn\u2019t\nhave access to the file system, which means loading modules in this way is\nvery tricky \u2014 loading files has to be done dynamically, either synchronously\n(which slows down execution) or asynchronously (which can have timing issues).\n\nThis is where a module bundler comes in. A JavaScript module bundler is a tool\nthat gets around the problem with a build step (which has access to the file\nsystem) to create a final output that is browser compatible (which doesn\u2019t\nneed access to the file system). In this case, we need a module bundler to\nfind all require statements (which is invalid browser JavaScript syntax) and\nreplace them with the actual contents of each required file. The final result\nis a single bundled JavaScript file (with no require statements)!\n\nThe most popular module bundler was Browserify, which was released in 2011 and\npioneered the usage of node.js style require statements on the frontend (which\nis essentially what enabled npm to become the frontend package manager of\nchoice). Around 2015, webpack eventually became the more widely used module\nbundler (fueled by the popularity of the React frontend framework, which took\nfull advantage of webpack\u2019s various features).\n\nLet\u2019s take a look at how to use webpack to get the above require('moment')\nexample working in the browser. First we need to install webpack into the\nproject. Webpack itself is an npm package, so we can install it from the\ncommand line:\n\n    \n    \n    $ npm install webpack webpack-cli --save-dev\n\nNote that we\u2019re installing two packages \u2014 webpack and webpack-cli (which\nenables you to use webpack from the command line). Also note the --save-dev\nargument \u2014 this saves it as a development dependency, which means it\u2019s a\npackage that you need in your development environment but not on your\nproduction server. You can see this reflected in the package.json file, which\nwas automatically updated:\n\n    \n    \n    { \"name\": \"modern-javascript-example\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"moment\": \"^2.19.1\" }, \"devDependencies\": { \"webpack\": \"^4.17.1\", \"webpack-cli\": \"^3.1.0\" } }\n\nNow we have webpack and webpack-cli installed as packages in the node_modules\nfolder. You can use webpack-cli from the command line as follows:\n\n    \n    \n    $ ./node_modules/.bin/webpack index.js --mode=development\n\nThis command will run the webpack tool that was installed in the node_modules\nfolder, start with the index.js file, find any require statements, and replace\nthem with the appropriate code to create a single output file (which by\ndefault is dist/main.js). The --mode=development argument is to keep the\nJavaScript readable for developers, as opposed to a minified output with the\nargument --mode=production.\n\nNow that we have webpack\u2019s dist/main.js output, we are going to use it instead\nof index.js in the browser, as it contains invalid require statements. This\nwould be reflected in the index.html file as follows:\n\n    \n    \n    <!-- index.html --> <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>JavaScript Example</title> <script src=\"dist/main.js\"></script> </head> <body> <h1>Hello from HTML!</h1> </body> </html>\n\nIf you refresh the browser, you should see that everything is working as\nbefore!\n\nNote that we\u2019ll need to run the webpack command each time we change index.js.\nThis is tedious, and will get even more tedious as we use webpack\u2019s more\nadvanced features (like generating source maps to help debug the original code\nfrom the transpiled code). Webpack can read options from a config file in the\nroot directory of the project named webpack.config.js, which in our case would\nlook like:\n\n    \n    \n    // webpack.config.js module.exports = { mode: 'development', entry: './index.js', output: { filename: 'main.js', publicPath: 'dist' } };\n\nNow each time we change index.js, we can run webpack with the command:\n\n    \n    \n    $ ./node_modules/.bin/webpack\n\nWe don\u2019t need to specify the index.js and --mode=development options anymore,\nsince webpack is loading those options from the webpack.config.js file. This\nis better, but it\u2019s still tedious to enter this command for each code change \u2014\nwe\u2019ll make this process smoother in a bit.\n\nOverall, this may not seem like much, but there are some huge advantages to\nthis workflow. We are no longer loading external scripts via global variables.\nAny new JavaScript libraries will be added using require statements in the\nJavaScript, as opposed to adding new <script> tags in the HTML. Having a\nsingle JavaScript bundle file is often better for performance. And now that we\nadded a build step, there are some other powerful features we can add to our\ndevelopment workflow!\n\n### Transpiling code for new language features (babel) #\n\nTranspiling code means converting the code in one language to code in another\nsimilar language. This is an important part of frontend development \u2014 since\nbrowsers are slow to add new features, new languages were created with\nexperimental features that transpile to browser compatible languages.\n\nFor CSS, there\u2019s Sass, Less, and Stylus, to name a few. For JavaScript, the\nmost popular transpiler for a while was CoffeeScript (released around 2010),\nwhereas nowadays most people use babel or TypeScript. CoffeeScript is a\nlanguage focused on improving JavaScript by significantly changing the\nlanguage \u2014 optional parentheses, significant whitespace, etc. Babel is not a\nnew language but a transpiler that transpiles next generation JavaScript with\nfeatures not yet available to all browsers (ES2015 and beyond) to older more\ncompatible JavaScript (ES5). Typescript is a language that is essentially\nidentical to next generation JavaScript, but also adds optional static typing.\nMany people choose to use babel because it\u2019s closest to vanilla JavaScript.\n\nLet\u2019s look at an example of how to use babel with our existing webpack build\nstep. First we\u2019ll install babel (which is an npm package) into the project\nfrom the command line:\n\n    \n    \n    $ npm install @babel/core @babel/preset-env babel-loader --save-dev\n\nNote that we\u2019re installing 3 separate packages as dev dependencies \u2014\n@babel/core is the main part of babel, @babel/preset-env is a preset defining\nwhich new JavaScript features to transpile, and babel-loader is a package to\nenable babel to work with webpack. We can configure webpack to use babel-\nloader by editing the webpack.config.js file as follows:\n\n    \n    \n    // webpack.config.js module.exports = { mode: 'development', entry: './index.js', output: { filename: 'main.js', publicPath: 'dist' }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'] } } } ] } };\n\nThis syntax can be confusing (fortunately it\u2019s not something we\u2019ll be editing\noften). Basically we\u2019re telling webpack to look for any .js files (excluding\nones in the node_modules folder) and apply babel transpilation using babel-\nloader with the @babel/preset-env preset. You can read more about webpack\nconfiguration syntax here.\n\nNow that everything\u2019s set up, we can start writing ES2015 features in our\nJavaScript! Here\u2019s an example of an ES2015 template string in the index.js\nfile:\n\n    \n    \n    // index.js var moment = require('moment');\n    \n    console.log(\"Hello from JavaScript!\"); console.log(moment().startOf('day').fromNow());\n    \n    var name = \"Bob\", time = \"today\"; console.log(`Hello ${name}, how are you ${time}?`);\n\nWe can also use the ES2015 import statement instead of require for loading\nmodules, which is what you\u2019ll see in a lot of codebases today:\n\n    \n    \n    // index.js import moment from 'moment';\n    \n    console.log(\"Hello from JavaScript!\"); console.log(moment().startOf('day').fromNow());\n    \n    var name = \"Bob\", time = \"today\"; console.log(`Hello ${name}, how are you ${time}?`);\n\nIn this example, the import syntax isn\u2019t much different from the require\nsyntax, but import has extra flexibility for more advanced cases. Since we\nchanged index.js, we need to run webpack again in the command line:\n\n    \n    \n    $ ./node_modules/.bin/webpack\n\nNow you can refresh index.html in the browser. At the time of this writing,\nmost modern browsers support all ES2015 features, so it can be hard to tell if\nbabel did its job. You can test it in an older browser like IE9, or you can\nsearch in main.js to find the line of transpiled code:\n\n    \n    \n    // main.js // ... console.log('Hello ' + name + ', how are you ' + time + '?'); // ...\n\nHere you can see babel transpiled the ES2015 template string into regular\nJavaScript string concatenation to maintain browser compatibility. While this\nparticular example may not be too exciting, the ability to transpile code is a\nvery powerful one. There are some exciting language features coming to\nJavaScript like async/await that you can start using today to write better\ncode. And while transpilation may at times seem tedious and painful, it has\nled to a dramatic improvement of the language in the past few years, as people\nare testing out tomorrow\u2019s features today.\n\nWe\u2019re almost done, but there\u2019s still some unpolished edges in our workflow. If\nwe\u2019re concerned about performance, we should be minifying the bundle file,\nwhich should be easy enough since we\u2019re already incorporating a build step. We\nalso need to re-run the webpack command each time we change the JavaScript,\nwhich gets old real fast. So the next thing we\u2019ll look at are some convenience\ntools to solve these issues.\n\n### Using a task runner (npm scripts) #\n\nNow that we\u2019re invested in using a build step to work with JavaScript modules,\nit makes sense to use a task runner, which is a tool that automates different\nparts of the build process. For frontend development, tasks include minifying\ncode, optimizing images, running tests, etc.\n\nIn 2013, Grunt was the most popular frontend task runner, with Gulp following\nshortly after. Both rely on plugins that wrap other command line tools.\nNowadays the most popular choice seems to be using the scripting capabilities\nbuilt into the npm package manager itself, which doesn\u2019t use plugins but\ninstead works with other command line tools directly.\n\nLet\u2019s write some npm scripts to make using webpack easier. This involves\nsimply changing the package.json file as follows:\n\n    \n    \n    { \"name\": \"modern-javascript-example\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"build\": \"webpack --progress --mode=production\", \"watch\": \"webpack --progress --watch\" }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"moment\": \"^2.22.2\" }, \"devDependencies\": { \"@babel/core\": \"^7.0.0\", \"@babel/preset-env\": \"^7.0.0\", \"babel-loader\": \"^8.0.2\", \"webpack\": \"^4.17.1\", \"webpack-cli\": \"^3.1.0\" } }\n\nHere we\u2019ve added two new scripts, build and watch. To run the build script,\nyou can enter in the command line:\n\n    \n    \n    $ npm run build\n\nThis will run webpack (using configuration from the webpack.config.js we made\nearlier) with the --progress option to show the percent progress and the\n--mode=production option to minimize the code for production. To run the watch\nscript:\n\n    \n    \n    $ npm run watch\n\nThis uses the --watch option instead to automatically re-run webpack each time\nany JavaScript file changes, which is great for development.\n\nNote that the scripts in package.json can run webpack without having to\nspecify the full path ./node_modules/.bin/webpack, since node.js knows the\nlocation of each npm module path. This is pretty sweet! We can make things\neven sweeter by installing webpack-dev-server, a separate tool which provides\na simple web server with live reloading. To install it as a development\ndependency, enter the command:\n\n    \n    \n    $ npm install webpack-dev-server --save-dev\n\nThen add an npm script to package.json:\n\n    \n    \n    { \"name\": \"modern-javascript-example\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"build\": \"webpack --progress -p\", \"watch\": \"webpack --progress --watch\", \"serve\": \"webpack-dev-server --open\" }, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"moment\": \"^2.19.1\" }, \"devDependencies\": { \"@babel/core\": \"^7.0.0\", \"@babel/preset-env\": \"^7.0.0\", \"babel-loader\": \"^8.0.2\", \"webpack\": \"^3.7.1\", \"webpack-dev-server\": \"^3.1.6\" } }\n\nNow you can start your dev server by running the command:\n\n    \n    \n    $ npm run serve\n\nThis will automatically open the index.html website in your browser with an\naddress of localhost:8080 (by default). Any time you change your JavaScript in\nindex.js, webpack-dev-server will rebuild its own bundled JavaScript and\nrefresh the browser automatically. This is a surprisingly useful time saver,\nas it allows you to keep your focus on the code instead of having to\ncontinually switch contexts between the code and the browser to see new\nchanges.\n\nThis is only scratching the surface, there are plenty more options with both\nwebpack and webpack-dev-server (which you can read about here). You can of\ncourse make npm scripts for running other tasks as well, such as converting\nSass to CSS, compressing images, running tests \u2014 anything that has a command\nline tool is fair game. There are also some great advanced options and tricks\nwith npm scripts themselves \u2014 this talk by Kate Hudson is a great place to\nstart:\n\n### Conclusion #\n\nSo this is modern JavaScript in a nutshell. We went from plain HTML and JS to\nusing a package manager to automatically download 3rd party packages, a module\nbundler to create a single script file, a transpiler to use future JavaScript\nfeatures, and a task runner to automate different parts of the build process.\nDefinitely a lot of moving pieces here, especially for beginners. Web\ndevelopment used to be a great entry point for people new to programming\nprecisely because it was so easy to get up and running; nowadays it can be\nquite daunting, especially because the various tools tend to change rapidly.\n\nStill, it\u2019s not as bad as it seems. Things are settling down, particularly\nwith the adoption of the node ecosystem as a viable way to work with the\nfrontend. It\u2019s nice and consistent to use npm as a package manager, node\nrequire or import statements for modules, and npm scripts for running tasks.\nThis is a vastly simplified workflow compared to even a year or two ago!\n\nEven better for beginners and experienced developers alike is that frameworks\nthese days often come with tools to make the process easier to get started.\nEmber has ember-cli, which was hugely influential on Angular\u2019s angular-cli,\nReact\u2019s create-react-app, Vue\u2019s vue-cli, etc. All these tools will set up a\nproject with everything you need \u2014 all you need to do is start writing code.\nHowever, these tools aren\u2019t magic, they simply set everything up in a\nconsistent and working fashion \u2014 you may often get to a point where you need\nto do some extra configuration with webpack, babel, etc. So it\u2019s still very\ncritical to understand what each piece does as we\u2019ve covered in this article.\n\nModern JavaScript can definitely be frustrating to work with as it continues\nto change and evolve at a rapid pace. But even though it may seem at times\nlike re-inventing the wheel, JavaScript\u2019s rapid evolution has helped push\ninnovations such as hot reloading, real-time linting, and time-travel\ndebugging. It\u2019s an exciting time to be a developer, and I hope this\ninformation can serve as a roadmap to help you on your journey!\n\nSpecial thanks to @ryanqnorth\u2019s Dinosaur Comics, which has served up some of\nthe finest absurdist humor since 2003 (when dinosaurs ruled the web).\n\n  * Next: A minimalist guide to tmux\n  * Previous: How To Learn Vim: A Four Week Plan\n  * Back to all posts\n\n#### Peter Jang\n\nHi! My name is Peter Jang, I'm an educator and software developer by trade\n(3rd Strike Ken Necro main and amateur karaoke beast by hobby). I'm currently\nthe Dean of Instruction at Actualize, where I design the web development\ncurriculum and teach live classes at our Chicago main campus. This is my\npersonal website where I write about programming and other technology-related\ntopics.\n\nFollow me @peterxjang: twitter, github, linkedin\n\nSubscribe to my blog: rss\n\n", "frontpage": false}
