{"aid": "40023558", "title": "Locking Mechanisms in Python Scripts", "url": "https://aorith.github.io/posts/python-script-locking/", "domain": "aorith.github.io", "votes": 1, "user": "aorith", "posted_at": "2024-04-13 15:00:35", "comments": 0, "source_title": "Locking mechanisms in python scripts | aorith's site", "source_text": "Locking mechanisms in python scripts | aorith's site\n\nLocking mechanisms in python scripts | aorith's site\n\n# Locking mechanisms in python scripts\n\nApril 13, 2024 \u00b7 7 minute read\n\n#python\n\nToday, I wanted to create a basic locking mechanism in Python to prevent\ncertain commands/functions from running concurrently.\n\nI have an script that runs inside of a CI/CD pipeline but it can also be\ntriggered manually. The problem is that certain commands within the script\nshouldn\u2019t be executed in parallel and I would like to handle that gracefully.\n\n## Use case\n\nImagine a Python script that manages the compilation and distribution of\nsoftware builds with two main command modes: build and deploy.\n\n  1. python3 script.py build: Compiles source code into executables and libraries, creating compilation artifacts.\n\n  2. python3 script.py deploy: Tags, packages, and deploys compiled artifacts to an environment.\n\nIt\u2019s easy to notice that it would be a bad idea to run these commands in\nparallel. If a deploy operation starts while a build is still processing, the\ndeployment might catch incomplete or outdated artifacts.\n\nThere are many things that could go wrong in this scenario.\n\n## First try: Initial implementation\n\nI thought that this would be pretty easy to implement, I reached the fcntl\ndocumentation and came up with this:\n\n    \n    \n    import fcntl import sys import time from contextlib import contextmanager from pathlib import Path @contextmanager def lock_execution(lock_file_path: Path = Path(\"/tmp/.example.lock\")): \"\"\"Prevents parallel execution.\"\"\" with open(lock_file_path, \"w\") as f: try: fcntl.flock(f, fcntl.LOCK_EX | fcntl.LOCK_NB) yield except IOError: print( f\"Another instance using the lock '{lock_file_path}' is already running.\", file=sys.stderr, ) sys.exit(0) finally: fcntl.flock(f, fcntl.LOCK_UN) def main(): print(\"Running main ...\") with lock_execution(): print(\"Lock acquired, running ...\") time.sleep(5) print(\"Done.\") if __name__ == \"__main__\": main()\n\nThe idea is to wrap the code that shouldn\u2019t be parallelized with the context\nmanager lock_execution function. Now, when I try to run this script from two\nterminal windows I get the following:\n\n    \n    \n    # Terminal 1 [aorith@arcadia:~] $ python3 /tmp/first.py Running main ... Lock acquired, running ... # Terminal 2 [aorith@arcadia:~] $ python3 /tmp/first.py Running main ... Another instance using the lock '/tmp/.example.lock' is already running. # Terminal 1 (after 5 seconds) Done.\n\nBut what if this script is executed by different users? Only the user that\ncreates the lock file will be able to use the script. Other users will be\ngreeted with this error:\n\n    \n    \n    PermissionError: [Errno 13] Permission denied: '/tmp/.example.lock'\n\n## Second try: Making it compatible with multiple users\n\nThe script cannot just delete the lock file when it finishes as it would\nintroduce race conditions that are very difficult to catch and debug. So let\u2019s\ntry chmoding the file upon creation and see what happens.\n\n    \n    \n    @contextmanager def lock_execution(lock_file_path: Path = Path(\"/tmp/.example.lock\")): \"\"\"Prevents parallel execution.\"\"\" try: lock_file_path.touch() os.chmod(lock_file_path, 0o666) except PermissionError: pass\n\nOk, that should give rw permissions to everyone upon creation. Let\u2019s try it\nand see what happens:\n\n    \n    \n    # Terminal 1 (root) [root@arcadia:~] % python3 /tmp/second.py Running main ... Lock acquired, running ... # Terminal 2 (user) [aorith@arcadia:~] $ python3 /tmp/second.py Running main ... Another instance using the lock '/tmp/.example.lock' is already running. # Now the other way around # Terminal 1 (user) [aorith@arcadia:~] $ python3 /tmp/second.py Running main ... Lock acquired, running ... # Terminal 2 (root) [root@arcadia:~] % python3 /tmp/second.py Running main ... Another instance using the lock '/tmp/.example.lock' is already running.\n\nLooks good, the lock file is created and owned by root but all the users can\nuse it a as lock file without issues.\n\nHmm, just to be safe, let\u2019s remove the lock file and create it with a regular\nuser:\n\n    \n    \n    # Terminal 1 (root) [root@arcadia:~] % rm /tmp/.example.lock [root@arcadia:~] % # Terminal 2 (user) [aorith@arcadia:~] $ python3 /tmp/second.py Running main ... Lock acquired, running ... # Terminal 1 (root) [root@arcadia:~] % python3 /tmp/second.py Running main ... Traceback (most recent call last): File \"/tmp/second.py\", line 42, in <module> main() File \"/tmp/second.py\", line 35, in main with lock_execution(): File \"/nix/store/il591rdaydbqr2cysh6vsa2kazxprzsn-python3-3.11.8/lib/python3.11/contextlib.py\", line 137, in __enter__ return next(self.gen) ^^^^^^^^^^^^^^ File \"/tmp/second.py\", line 19, in lock_execution with open(lock_file_path, \"w\") as f: ^^^^^^^^^^^^^^^^^^^^^^^^^ PermissionError: [Errno 13] Permission denied: '/tmp/.example.lock' [root@arcadia:~] % ls -lrt /tmp/.example.lock -rw-rw-rw- 1 aorith aorith 0 abr 13 13:41 /tmp/.example.lock\n\nWait, what? How comes that root doesn\u2019t have permissions ...?\n\nAfter some digging, I found out that it\u2019s a security measure introduced in the\nLinux kernel for versions >= 4.9, this stackexchange post has more details\nabout it.\n\n## Third try: Fix the permissions issue\n\nAlright, let\u2019s modify the code to workaround the security measure. We are\nalready creating the file with a touch command when it\u2019s missing and the write\npermissions are not required to lock it. So let\u2019s change the open mode:\n\n    \n    \n    with open(lock_file_path, \"r\") as f: try: fcntl.flock(f, fcntl.LOCK_EX | fcntl.LOCK_NB)\n\nNow the lock file is only open in read mode and it seems to work fine:\n\n    \n    \n    # Terminal 1 (user) [aorith@arcadia:~] $ python3 /tmp/third.py Running main ... Lock acquired, running ... # Terminal 2 (root) [root@arcadia:~] % python3 /tmp/third.py Running main ... Another instance using the lock '/tmp/.example.lock' is already running. [root@arcadia:~] % ls -l /tmp/.example.lock -rw-rw-rw- 1 aorith aorith 0 abr 13 13:56 /tmp/.example.lock\n\nHmm, am I done? Not really... What happens if the protected code raises\nanother IOError exception?\n\n    \n    \n    def main(): print(\"Running main ...\") with lock_execution(): print(\"Lock acquired, running ...\") Path(\"/tmp/this/path/does/not/exists\").touch() time.sleep(5) print(\"Done.\")\n    \n    \n    # Terminal 1 (the only one running the script) [aorith@arcadia:~] $ python3 /tmp/third.py Running main ... Lock acquired, running ... Another instance using the lock '/tmp/.example.lock' is already running.\n\nEhm... I don\u2019t have another instance running, what is going on? The answer is\nthat the code block wrapped with the context manager function runs at the\nposition of the yield statement, and that statement is wrapped with a\ntry/except block that captures all the IOError exceptions.\n\nNot good, errors would be hidden unexpectedly.\n\n## Final version: Running the code outside of the try/except block\n\nWe need to move the yield statement outside of the try/except block and be\nvery careful with the finally block as it has priority with some statements as\nexplained here .\n\nI\u2019m also adding a boolean to move the sys.exit out of the IOError exception,\njust to be safe:\n\n    \n    \n    @contextmanager def lock_execution(lock_file_path: Path = Path(\"/tmp/.example.lock\")): \"\"\"Prevents parallel execution.\"\"\" try: lock_file_path.touch() os.chmod(lock_file_path, 0o666) except PermissionError: pass locked: bool = False # https://unix.stackexchange.com/questions/691441/root-cannot-write-to-file-that-is-owned-by-regular-user with open(lock_file_path, \"r\") as f: try: fcntl.flock(f, fcntl.LOCK_EX | fcntl.LOCK_NB) # we don't yield here, we want to raise IOError if it's not coming from flock except IOError: locked = True print( f\"Another instance using the lock '{lock_file_path}' is already running.\", file=sys.stderr, ) finally: if locked: sys.exit(0) yield # code runs here fcntl.flock(f, fcntl.LOCK_UN)\n\nNow when I apply this context manager function over a block of code that\nraises an IOError (or any) exception its raised normally:\n\n    \n    \n    [aorith@arcadia:~] $ python3 /tmp/finalversion.py Running main ... Lock acquired, running ... Traceback (most recent call last): File \"/tmp/finalversion.py\", line 48, in <module> main() File \"/tmp/finalversion.py\", line 42, in main Path(\"/tmp/this/path/does/not/exists\").touch() File \"/nix/store/il591rdaydbqr2cysh6vsa2kazxprzsn-python3-3.11.8/lib/python3.11/pathlib.py\", line 1108, in touch fd = os.open(self, flags, mode) ^^^^^^^^^^^^^^^^^^^^^^^^^^ FileNotFoundError: [Errno 2] No such file or directory: '/tmp/this/path/does/not/exists'\n\n## Extra: Other ways of acquiring a lock\n\nI have considered other ways that do not use a file for locking, for example\nwe can bind a port using the socket library:\n\n    \n    \n    import sys import socket def some_command(): try: s = socket.socket() s.bind((\"127.0.0.1\", 12340)) except OSError: print(\"Another instance is running...\") sys.exit(0) # Main code goes here ...\n\nThe problem with this approach is that we need to reserve port numbers and if\nwe are using this locking mechanism with multiple scripts on the same machine\nwe have to pay attention not to use the same port if those scripts can run in\nparallel. Also port numbers aren\u2019t very intuitive for this, when we use a lock\nfile we can give it a descriptive name.\n\nAnother method would be to bind to a unix socket, so we don\u2019t lose the\nadvantage of having a lock file:\n\n    \n    \n    @contextmanager def lock_execution(lock_file_path: Path = Path(\"/tmp/.example.lock\")): \"\"\"Prevents parallel execution.\"\"\" locked: bool = False try: s = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM) s.bind(str(lock_file_path)) except OSError: locked = True print( f\"Another instance using the lock '{lock_file_path}' is already running.\", file=sys.stderr, ) finally: if locked: sys.exit(0) try: yield finally: # Make sure that the socket is deleted even if the protected code raises an exception or exits lock_file_path.unlink(missing_ok=True)\n\nThis seems to also work in all the scenarios that I\u2019ve tested. It requires an\nextra try/except block to ensure that the lock/socket file is removed at the\nend.\n\nI\u2019ll keep using the fcntl method because it seems less hacky.\n\nPlease, leave a comment if you have some other interesting implementations :)\n\nNixOS Integration Tests\n\n\u00a9 2023 Manuel Sanchez Pinar \u2022 articles under CC-BY license\n\n", "frontpage": false}
