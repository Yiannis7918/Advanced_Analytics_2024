{"aid": "40076048", "title": "Why I Don't Use Game Engines", "url": "https://xianc78.codeberg.page/articles/game-engines.html", "domain": "codeberg.page", "votes": 1, "user": "airhangerf15", "posted_at": "2024-04-18 13:33:11", "comments": 2, "source_title": "Why I Don't Use Game Engines", "source_text": "Why I Don't Use Game Engines\n\n# Xianc78's Personal Website\n\n## Why I Don't Use Game Engines\n\nThis article is a response to the recent-ish news going on with the Unity game\nengine and them charging developers per game install. Of course, the common\nresponse for a FOSS advocate would say is \"This is why you should be using\nGodot instead\". Sure Godot is a better choice than Unity or Unreal and I\nsuspect many Unity devs would switch to Godot over Unreal only because Godot\nactually supports C#, (Unity's scripting language) while Unreal only supports\nC++, UnrealScript, and Blueprints, but I think there is a deeper issue in\nthis, just like with web development, modern game programmers only have a\nhigh-level knowledge of the inner workings of a game. Modern games are bloated\nand a huge contributing factor to that can be attributed to game engines.\nModern game engines are complex because they are designed to be used for\nalmost any game. This means unnecessary, bloated code. This is why even indie\ngames may still struggle on older or lower-end computers. In worse cases, you\nhave 2D games running on engines made for AAA 3D games. I personally believe\nthat if a game looks like it runs on a potato than it SHOULD run on a potato.\n\nIt wasn't too long ago that game programmers were considered the best\nprogrammers because game programming involves a lot of aspects of programming\nsuch as graphics, audio, networking, file system management, AI, parsing,\nvirtual machines, etc. This made it possible for a game programmer to branch\nout to other fields in programming. Now, many game programmers are limited to\nprogramming game mechanics as engines can take care of the rest. So, we end up\nwith the same problem that we see in modern websites in that they rely on\ngeneral purpose frameworks that try to do everything inlcuding functionality\nthat the game isn't using so it results in bloat. Compare that with a game\nthat is written from the ground up and does what it needs to do. It has a much\nsmaller foot-print and can run on weaker hardware.\n\n### The Problems With Game Engines\n\n#### Most Engines Are Proprietary\n\nOf course there are FOSS engines like Godot, but the vast majority of engines\nout there are proprietary, and using these engines mean that you are at the\nwhim of the engine's developers. They can restrict what kind of games you make\neither through EULAs or DRM. Some of these engines may restrict the kind of\ncontent your game has or how you distribute your game (e.g prohibiting\ncommercial use unless you have a premium license). None of the issues going on\nwith Unity right now would happen if the engine is FOSS. Not relying on a\nproprietary engine (or a pre-made engine at all) means that you have more\ncontrol over your game. The game you make is yours and you aren't restricted\nthrough EULAs or proprietary code that you didn't write.\n\n#### Too Many Codebases Too Keep Track Of\n\nModern engines use a lot of third-party libraries which make it hard to keep\ntrack of, even if all libraries and the engine are FOSS. Let's say you have a\nbug. Is the bug relating to your code, the engine, the graphics library, the\nphysics library? What if these libraries are written in different languages\nand you can't read every single codebase? The more dependencies you have the\nharder it is to keep track of this. Also, additional libraries just mean more\nbloat in your code. If you write more stuff by hand, you know how everything\nworks automatically, so it is easier to tweak it yourself. If you wrote the\nphysics library, you have full control over it. Same with anything else.\n\n#### Being Limited By The Features/Performance Of The Engine Itself\n\nUsing a premade engine means that you are limited by the features and\nperformance of the game engine itself. Sure, if the engine is FOSS or you are\nable to obtain a license for the source code, you can modify the engine to\nsuit your needs. Case in point, the developers Cities Skylines had to obtain a\nlicense to Unity's source code and modify the engine to handle a simulation of\na metropolis. Modifying an engine to suit your needs can be done, but that\nrequires going through a huge chunk of code that you didn't write and this\nalso assumes that the engine was written in a language that you understand and\nuses libraries/APIs that you are familar with.\n\n#### Jack Of All Trades Master Of None\n\nAnd finally the biggest reason why I don't use game engines is that they are\nall trying to be general-purpose engines meaning that they are designed for\ngames of any genre, but as a consequence they aren't optimized for a single\ngenre. It's better just to have a tool that does one job right. If I write an\nRPG, I would write a game engine solely designed for RPGs and that can build\nand run RPGs well and it would run better than if it was written in any pre-\nmade engine (most of which were originally designed for first-person\nshooters). It would also be less bloated since there would be a lot less\nunused code. It will have all the code it needs to run and nothing more.\n\n### Why Game/Multimedia Frameworks Are Better\n\nThere are plenty of multimedia frameworks that can be used to create any video\ngame or multimedia application. These frameworks include SDL, SFML, Allegro,\nGLFW, Pygame, MonoGame, Love2D, and LWJGL. These aren't full engines. They\nonly contain functionality for graphics, audio, input, etc, and you are\nresponsible for implementing the rest like levels, AI, physics, etc. If you\nneed help there are additional libraries available for things like physics,\ntiling, etc. This means that you have a lot more control over your game's\ncode. All the other code is just for display graphics and stuff like that,\nstuff that every game needs. Therefore, your game's code is tailor made for\nthat game and will have a much smaller footprint as a result.\n\nAlso, not using a premade engine means that you implement everything, so you\naren't limited to the choices that a premade engine would provide. You get to\nchoose what file formats to use, you get to choose what scripting language for\nthe game, you get to choose what type of rendering your game has, etc. Want to\nuse voxels instead of polygons? You are free to do so. Want to use SVGs\ninstead of raster sprites? Go right ahead. Want to store levels as bitmap\nimages. How about storing levels in a SQL database? Why not?\n\nNow I know that the common objection to this is that using a game engine is\nsimply easier. I understand, but I really think people overestimate the\ndifficulty of just using a multimedia framework, especially if they are only\nmaking 2D games. For 2D games, you really just need a basic understanding of\nAlgebra, Geometry, and Trigonometry. These are all high school level math. 3D\nis probably a bit harder, requiring some Linear Algebra and Calculus\nknowledge. It's probably more excusable to use an existing engine for 3D,\nespecially for first-person shooters since most of them were designed for\nthem, but the transition to 3D shouldn't be hard after mastering 2D. Of course\nthere are plenty of tutorials and documentation on any algorithm you can think\nof so you're not completely re-inventing the wheel.\n\nBack to articles\n\nUnless otherwise stated, all content is licensed under the WTFPL.\n\n", "frontpage": false}
