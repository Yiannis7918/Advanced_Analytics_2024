{"aid": "39958260", "title": "Is the frequency domain a real place?", "url": "https://lcamtuf.substack.com/p/is-the-frequency-domain-a-real-place", "domain": "lcamtuf.substack.com", "votes": 11, "user": "zdw", "posted_at": "2024-04-07 04:52:39", "comments": 0, "source_title": "Is the frequency domain a real place?", "source_text": "Is the frequency domain a real place? - lcamtuf\u2019s thing\n\n# lcamtuf\u2019s thing\n\nShare this post\n\n#### Is the frequency domain a real place?\n\nlcamtuf.substack.com\n\n# Is the frequency domain a real place?\n\n### The discrete Fourier transform is vital to electronics, signal processing,\nand radio -- but we're reading too much into what it means.\n\nApr 07, 2024\n\n2\n\nShare this post\n\n#### Is the frequency domain a real place?\n\nlcamtuf.substack.com\n\n2\n\nShare\n\nIn an earlier article on the Fourier transform, I talked about the frequency\ndomain \u2014 a wondrous mathematical place where complex signals are transmuted\ninto the amplitudes and phases of sine waveforms. The frequency domain allows\nus to perform all kinds of signal processing tricks that seem nearly\nimpossible to pull off when we stare at the data in its most straightforward\nform \u2014 that is, in the time domain.\n\nA waveform (top) and a frequency view (bottom) of \u201cGirl in Blue\u201d.\n\nAt the end of that deep dive, I left one question unanswered: how real is this\nfrequency place, anyway? The discrete Fourier transform (DFT) plays a central\nrole in communications and signal processing \u2014 but does it reveal some deeper,\nunseen truth about the universe? For example, do square waves exist at all?\nAfter all, the transform turns them into a series of odd-numbered sine\nharmonics \u2014 and this model somehow predicts the behavior of electronic\ncircuits in real life.\n\nToday, I\u2019d like to knock the Fourier transform off the pedestal. To be sure,\nsine waves are ubiquitous in nature and are well-suited for a number of tasks.\nThat said, it\u2019s eminently possible to construct other well-behaved frequency\ndomains that play by different rules \u2014 including one where only square waves\nare real, and everything else is just harmonics.\n\n###\n\nRevisiting discrete cosine transform (DCT)\n\nTo get started, let\u2019s circle back to discrete cosine transform \u2014 a simplified,\nreal-numbers-only version of DFT. From the earlier article, you might recall\nthe following DCT-II formula:\n\nThe construct at the heart of this algorithm is the cos() expression that\ngenerates a sine wave with a frequency corresponding to the number of the\ncurrent frequency bin. This is known as the basis function; we can abstract it\naway and rewrite the formula as:\n\nIn this generalized notation for a frequency-domain transform, B(k, n) returns\nsome sort of a multiplier based on the values of k and n. Software engineers\nmight find it intuitive to think about B(k, n) as a lookup array. In fact,\nlet\u2019s calculate that array \u2014 a matrix in the math parlance \u2014 for N=16:\n\nDCT-II basis function plot for N=16.\n\nIf you remember the design of DCT, this visual should be easy to parse. The\nfirst row (k=0) corresponds to the DC component \u2014 i.e., a cosine \u201crunning\u201d at\n0 Hz. The next row contains a cosine completing one half of a cycle, followed\nby twice the speed k=2, and so on.\n\n###\n\nInto the square-verse!\n\nSo, how does one go about building a basis function that splits signals not\ninto sine frequencies, but into square waves? The answer appears almost\nridiculously simple:\n\nThe Walsh matrix for N=16.\n\nThis is known as the Walsh matrix. And yes: every multiplier is just a +1 or a\n-1, so the computation boils down to flipping some signs in the input data and\nthen summing the results.\n\nAlthough the matrix looks simple, its design is fairly ingenious. To capture\nall frequency and phase information, the rows have increasing sequency \u2014 that\nis, each next row has one more sign flip than the one before. Further, the\npattern is carefully engineered to ensure orthogonality \u2014 that is, the fragile\ninput-output symmetry that allows seamless conversions back and forth between\nthe frequency representation and the original time-series data.\n\nThe most intuitive way to construct the Walsh matrix is to start with\nsomething known as the Hadamard matrix, and then to shuffle it around. For\nN=16, this \u201cproxy\u201d matrix looks the following way:\n\nThe Hadamard matrix for N=16. Huh?\n\n###\n\nGetting to know Mr. Hadamard\n\nAt a glance, the plot looks chaotic, but it\u2019s simply a reordering of the Walsh\nmatrix. For example, row #1 in the Walsh matrix ends up in row #8 above. And\nunlike the Walsh matrix, it\u2019s pretty easy to construct.\n\nTo get the ball rolling, we start with the following trivial 1\u00d71 array:\n\nFrom there, we iteratively extend it by taking the array generated in the\nprevious step (H_n-1) and tiling four copies of it on a 2n\u00d72n grid. The first\nthree copies are verbatim, and the final one \u2014 bottom right \u2014 has all the\nsigns flipped. The mathematical notation for this extension is:\n\nThe fancy operator (\u2297) is known as the Kronecker product, but it really just\nglorified copy-and-paste. The first extension is:\n\nAnother iteration gives us:\n\n...and so on.\n\nOn a computer, the matrix can be computed by following this tiling algorithm,\nbut there\u2019s a cute bitwise arithmetic trick we can employ instead: as it turns\nout, the value of the Hadamard function at a particular cell can be divined by\ncalculating x & y and then checking if the number of bits set in the result is\neven or odd. The following C code does just that, and then displays an 8\u00d78\nHadamard matrix on the screen:\n\n>\n>     #include <stdint.h> #include <stdio.h> #define HD_LEN 8 int8_t\n> hadamard(uint32_t x, uint32_t y) { return (__builtin_popcount(x & y) % 2) ?\n> -1 : 1; } int main() { for (uint32_t y = 0; y < HD_LEN; y++) { for (uint32_t\n> x = 0; x < HD_LEN; x++) printf(\"%+d \", hadamard(x, y)); putchar('\\n'); } }\n\nIn principle, the Hadamard matrix is sufficient to construct a frequency-\ndomain transform. That said, its ordering of the frequency bins is\nunintuitive, so we could use some help from the other guy.\n\n###\n\nEnter Mr. Walsh\n\nTo turn the Hadamard matrix in the nicely-ordered flavor showcased earlier, we\nneed to sort the rows based on their sequency. I\u2019m not aware of an algorithm\nmore elegant than counting the number of zero crossings, but in any case, this\nimplementation is pretty fast \u2014 and prints a sorted 8\u00d78 array on the screen:\n\n>\n>     #include <stdint.h> #include <stdio.h> #include <string.h> #define\n> HD_LEN 8 int8_t hadamard(uint32_t x, uint32_t y) { return\n> (__builtin_popcount(x & y) % 2) ? -1 : 1; } int8_t\n> walsh_array[HD_LEN][HD_LEN]; void precompute_walsh() { int8_t tmp[HD_LEN];\n> for (uint32_t y = 0; y < HD_LEN; y++) { uint32_t sign_cnt = 0; int8_t\n> prev_val = 1; for (int x = 0; x < HD_LEN; x++) { tmp[x] = hadamard(x, y); if\n> (tmp[x] != prev_val) { sign_cnt++; prev_val = tmp[x]; } }\n> memcpy(walsh_array[sign_cnt], tmp, HD_LEN); } } int main() {\n> precompute_walsh(); for (uint32_t y = 0; y < HD_LEN; y++) { for (uint32_t x\n> = 0; x < HD_LEN; x++) printf(\"%+d \", walsh_array[y][x]); putchar('\\n'); } }\n\nEquipped with this, we can gut the DCT implementation and make a \u201cdiscrete\nsquare transform\u201d and its inverse:\n\n>\n>     void sqft(double* out_buf, double* in_buf, uint32_t len) { for (uint32_t\n> bin_no = 0; bin_no < len; bin_no++) { double sum = 0; for (uint32_t s_no =\n> 0; s_no < len; s_no++) sum += in_buf[s_no] * walsh_array[s_no][bin_no];\n> out_buf[bin_no] = sum; } } void isqft(double* out_buf, double* in_buf,\n> uint32_t len) { for (int s_no = 0; s_no < len; s_no++) { double sum = 0; for\n> (int bin_no = 0; bin_no < len; bin_no++) sum += in_buf[bin_no] *\n> walsh_array[bin_no][s_no]; out_buf[s_no] = sum / len; } }\n\nTechnically, this is called the Walsh\u2013Hadamard transform, but never mind.\nLet\u2019s confirm that it works:\n\n>\n>     ...previous code here... void print_buf(const char* prefix, double* buf,\n> uint32_t len) { printf(\"%s\", prefix); for (uint32_t i = 0; i < len; i++)\n> printf(\"%+.2f \", buf[i]); putchar('\\n'); } int main() { double in[HD_LEN] =\n> { 1, 1, 1, 1, 5, 5, 5, 5 }; double sq_freq[HD_LEN], out[HD_LEN];\n> precompute_walsh(); sqft(sq_freq, in, HD_LEN); isqft(out, sq_freq, HD_LEN);\n> print_buf(\"Input : \", in, HD_LEN); print_buf(\"SQFT : \", sq_freq, HD_LEN);\n> print_buf(\"ISQFT : \", out, HD_LEN); return 0; }\n\nThe input is a square-wave-ish sequence of numbers: 1 1 1 1 5 5 5 5. The\noutput from DFT or DCT would be a bunch of harmonics across multiple frequency\nbins:\n\n>\n>     DCT : +24.00 -10.25 -0.00 +3.60 +0.00 -2.41 -0.00 +2.04\n\nIn contrast, the frequency-domain representation generated by the program\nshows non-zero components only in F_0 (DC) and F_1, confirming that we have an\nalgorithm that deconstructs the signal into pure square waves:\n\n>\n>     SQFT : +24.00 -16.00 +0.00 +0.00 +0.00 +0.00 +0.00 +0.00\n\nFinally, we can verify that the inverse function \u2014 isqft() \u2014 transforms the\nfrequency domain back to what we started with:\n\n>\n>     ISQFT : +1.00 +1.00 +1.00 +1.00 +5.00 +5.00 +5.00 +5.00\n\nThe Walsh-Hadamard transform, being computationally efficient and well-suited\nfor certain types of data, finds uses here and there. The point isn\u2019t that it\nneeds to be used more; it\u2019s just that discrete Fourier doesn\u2019t have a monopoly\non truth.\n\nFor more articles on electronics, click here.\n\n2 Likes\n\n2\n\nShare this post\n\n#### Is the frequency domain a real place?\n\nlcamtuf.substack.com\n\n2\n\nShare\n\n2 Comments\n\nlcamtuf1 hr agoAuthorPS #1: Apologies to all the folks who signed up for this\nafter the xz article and didn't realize what's coming!PS #2: Here's a person\nexperimenting with Walsh-Hadamard for image compression:\nhttp://rotormind.com/blog/2019/hadamard-days-night/Expand full\ncommentLikeReplyShare  \n---  \n  \nChuck Karish1 hr agoA better question than the title of this piece would be\n\"What other transforms can we imagine that help us understand things for which\nthe DFT is of little help?\" That we could choose other transforms and\ncalculate them easily isn't all that interesting until we see the insights\nthat those other transforms open for us.Expand full commentLikeReplyShare  \n---  \n  \nFake books\n\nMachine-generated books are here. I bought one by accident.\n\nOct 23, 2022\n\n52\n\nShare this post\n\n#### Fake books\n\nlcamtuf.substack.com\n\n14\n\nRadios, how do they work?\n\nA brief introduction to antennas, superheterodyne receivers, and signal\nmodulation schemes.\n\nMar 25\n\n56\n\nShare this post\n\n#### Radios, how do they work?\n\nlcamtuf.substack.com\n\n4\n\nTechies vs spies: the xz backdoor debate\n\nDiving into some of the dynamics and the interpretations of the brazen ploy to\nsubvert the liblzma compression library.\n\nMar 30\n\n85\n\nShare this post\n\n#### Techies vs spies: the xz backdoor debate\n\nlcamtuf.substack.com\n\n36\n\nReady for more?\n\n\u00a9 2024 lcamtuf\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great writing\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": true}
