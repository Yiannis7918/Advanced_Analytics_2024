{"aid": "40078489", "title": "State of the Terminal", "url": "https://gpanders.com/blog/state-of-the-terminal/", "domain": "gpanders.com", "votes": 2, "user": "yarapavan", "posted_at": "2024-04-18 17:15:00", "comments": 0, "source_title": "State of the Terminal | g.p. anders", "source_text": "State of the Terminal | g.p. anders\n\nGregory Anders\n\n# State of the Terminal\n\nMarch 12, 2024\n\nThis is a companion article to my talk at Neovimconf 2023.\n\nI have been using Vim/Neovim as my full time text editor for close to 10\nyears. I\u2019ve spent a lot of time in the terminal and have become very aware of\nthe many flaws and idiosyncrasies of this bizarre platform. But I also think\nit gets a lot of things right! And I\u2019m not alone in this belief: terminal\nbased tools are still widely popular even in the presence of many alternatives\n(the StackOverflow developer survey shows that Neovim is the \u201cmost loved\u201d\neditor 3 years in a row).\n\nIt\u2019s only been in the last couple of years that I\u2019ve begun to dig deep into\nthe inner workings of how terminal emulators, and the applications that run\ninside of them, really work. I\u2019ve learned that there is a lot of innovation\nand creative problem solving happening in this space, even though the\nunderlying technology is over half a century old^1.\n\nI\u2019ve also found that many people who use terminal based tools (including\nshells like Bash and editors like Vim) know very little about terminals\nthemselves, or some of the modern features and capabilities they can support.\n\nIn this article, we\u2019ll discuss some of the problems that terminal based\napplications have historically had to deal with (and what the modern solutions\nare) as well as some features that modern terminal emulators support that you\nmay not be aware of.\n\nBut first, some (very) brief history.\n\n## Background & History\n\nMost terminal emulators today can directly trace their roots back to the DEC\nVT100. The VT100 was not the first video terminal, nor was it the last, but it\nwas the most popular (at the time). And as we\u2019ve learned from history many\ntimes since, what becomes popular creates the de facto standard for everything\nthat comes after.\n\nDEC VT100 Jason Scott, CC BY 2.0 via Wikimedia Commons\n\nVideo terminals were an improvement on the teletype machines that preceded\nthem. They could move the cursor around the screen to create interactive\ninterfaces. They could use color, and clear and redraw their displays quickly\nwithout feeding out reams of paper.\n\nDifferent video terminals had their own unique way of doing things using\nunique, proprietary escape codes (a sequence of bytes beginning with the\nescape 0x1b character). This made life difficult for applications because they\nhad to know which of these sequences to use. Libraries and helper programs\n(e.g. termcap) were created to help ameliorate these issues (we still live\nwith the descendant of these early libraries, terminfo).\n\nEventually, formal standards were created, such as ECMA-48 and ANSI X3.64\n(from which the term \u201cANSI escape codes\u201d derives), which defined a set of\nstandard escape sequences. The DEC VT100 was the first video terminal to\nsupport these new standards. Its popularity, combined with the new standards,\nmeant that programs now had a set of known good escape sequences they could\nreliably use. Its popularity spawned many clones, which in turn supported the\nsame sequences for compatibility with applications.\n\nGraphical window systems eventually replaced hardware video terminals, but\nusers still wanted to use the terminal based programs they were accustomed to\n(you know how those vi people are). In 1984, work began on a software terminal\nemulator at MIT. This emulator became part of the X project and was named\nXterm. Xterm implemented its own features which did not exist on the video\nterminals it emulated, such as mouse tracking and a configurable color\npalette. These features were in turn copied by Xterm clones, until eventually\nXterm itself became the new de facto standard.\n\n## Terminal Emulator Basics\n\nTerminal based applications write two kinds of data to the terminal emulator:\nprintable text that is displayed to the user, and control codes, which modify\nthe terminal emulator\u2019s state. Control codes are either single bytes in the C0\ncharacter set (bytes 0x00 through 0x1f) or sequences of bytes that begin with\nthe escape character (0x1b). These sequences are most commonly referred to as\n\u201cescape sequences\u201d, and it is these sequences that do the bulk of the heavy\nlifting in terminal applications.\n\nMost control codes from the C0 character set are not used today, but\nregardless of experience with terminals or terminal applications, most\ndevelopers are likely familiar with control codes such as \\r (carriage\nreturn), which moves the cursor to the beginning of the current line, and \\n\n(line feed), which moves the cursor to the next line.\n\nEscape sequences are varied and numerous, but the vast majority used in\npractice fall into one of three categories: Control Sequence Introducer (CSI),\nDevice Control String (DCS), and Operating System Command (OSC).\n\nCSI sequences are those which begin with the prefix ESC [ (0x1b 0x5b). Escape\nsequences in this category are those which reposition the cursor, change the\ncursor style, clear the screen, set foreground and background colors, and\nmore.\n\nOSC sequences are those which begin with the prefix ESC ] and are typically\nused for things that modify or interact with the user\u2019s environment outside of\nthe terminal emulator itself (hence the name \u201cOperating System Command\u201d).\nExamples are reading from or writing to the system clipboard, changing the\ntitle of the terminal emulator\u2019s window, or sending desktop notifications.\n\nXterm maintains a list of all of the control sequences it supports on its\nwebsite, which, along with vt100.net, forms an informal pseudo-specification\nfor VT100 emulators. Note that this list may not contain some control\nsequences used by other, modern terminal emulators for features which Xterm\ndoes not support (e.g. the Kitty keyboard protocol, which we\u2019ll discuss\nlater).\n\nEscape sequences are actually quite easy to use, and you can even do it\nstraight from your shell. Try running the following command from any shell:\n\n    \n    \n    printf '\\e[1;32mHello \\e[0;4;31mworld!\\n\\e[0m'\n\nThis command will print the text \u201cHello world!\u201d, with \u201cHello\u201d in green, bold\ntext and \u201cworld!\u201d in red, underlined text.\n\nThe escape sequences used here are of the form CSI <parameters> m, which is so\ncommon it has its own name: Select Graphic Rendition (SGR). The SGR escape\nsequence sets foreground and background colors for all printed text. The first\nescape sequence in the example \\e[1;32m enables the bold attribute (1) and\nsets the foreground color to green (32). The second escape sequence \\e[0;4;31m\nfirst clears any existing styles (0), then enables the underline attribute\n(4), and finally sets the foreground text color to red (31). Finally, the last\nescape sequence \\e[0m resets all styles back to their defaults.\n\nAnother use case for simple CSI sequences is redrawing text on the screen on\nan already existing line (e.g. for a progress bar or text that updates itself\nover time). Hint: look at \\r, CSI A, and CSI K.\n\nMost escape sequences are sent from the application to the terminal emulator,\nbut occasionally the terminal emulator sends escape sequences to the\napplication. Usually this is done in response to a query from the application\n(for instance, to determine if a certain mode is set).\n\n## Problems & Solutions\n\nTerminal emulators are descended from old, legacy technologies, which brings\nwith it its fair share of problems. Many of these problems have been (mostly)\nsolved, or at least ameliorated, while others are still active areas of\ninnovation and research.\n\n### Key Encoding\n\nTerminal emulators and terminal applications communicate through a stream of\nbytes. When a user presses a key the terminal sends the byte representation of\nthe character associated with that key. The old video terminals only supported\nASCII so this was, generally, fairly straightforward.\n\nModifier keys like Ctrl and Alt complicate this situation. Alt modified keys\nare encoded by prefixing the character with an Esc. But this has a problem:\nincluding an extra Esc byte for the Alt modifier introduces ambiguity between\nAlt modified key presses and two separate key presses. When an application\nsees Esc C, should it interpret it as Alt-C or did the user press Esc and then\npress C? Applications usually solve this by measuring the amount of time\nbetween Esc and the next character. If the time is less than some defined\ninterval, it is considered an Alt modified key press (Vim uses the ttimeoutlen\noption, tmux uses the escape-time option).\n\nCtrl modified keys are an even bigger problem. When Ctrl is used as a\nmodifier, the shifted^2 version of the key has the 7th bit masked off (for\nexample, C is 0x43 and after masking the 7th bit the byte becomes 0x03). This\nmeans that not only can the Shift modifier not be used in conjunction with\nCtrl, but that certain Ctrl modified keys are completely indistinguishable\nfrom other control codes.\n\nFor instance, when you press the Return key the terminal emulator sends the\nbyte \\r (0x0d) to the application. But if you press Ctrl-M then the terminal\nemulator also sends the byte 0x0d to the application (M is 0x4d in ASCII, so\nwhen the 7th bit is masked out, it becomes 0x0d). From the application\u2019s\nperspective, there is literally no way to distinguish these two events.\n\nFor a long time this meant that certain modified keys like Ctrl-I, Ctrl-J, and\nCtrl-M could not be used in terminal applications like Vim. There have been a\nfew attempts to solve this problem: the first came from Xterm in 2006 through\nthe modifyOtherKeys option. Paul Evans (author of libvterm and libtickit)\nintroduced an alternate key encoding using the CSI u escape sequence in an\nessay which is sometimes colloquially referred to as \u201cfixterms\u201d. The CSI u\nencoding proposed by Evans was extended by Kovid Goyal, the author of the\nkitty terminal emulator, in what has become known as the kitty keyboard\nprotocol.\n\nWhat all of these solutions have in common is that key presses are sent to the\nterminal application encoded as escape sequences. This eliminates any\nambiguity for modified keys and enables certain modifier combinations (such as\nCtrl + Shift) that are not possible using \u201clegacy\u201d encoding. The CSI u\nencoding proposed by Evans and adapted by kitty encodes a modified key press\nlike Ctrl-M as \\e[109;5u. The encoding of unmodified key presses like Return\ndepend on which \u201clevel\u201d of the kitty keyboard protocol is enabled.\nApplications can opt-in to different levels to ease adoption (for instance,\nNeovim uses only the first level, \u201cDisambiguate escape keys\u201d). See the kitty\ndocumentation for more details.\n\nSending key presses as escape sequences requires that terminal applications\nare able to recognize and parse those sequences, so it is not something that\n\u201cjust works\u201d out of the box. However, the kitty keyboard protocol has been\nwidely adopted by both modern terminal emulators and terminal applications.\nTerminals which support the kitty keyboard protocol (to some degree) include\nWezterm, Alacritty, kitty, foot, Ghostty, and iTerm2. Applications which\nsupport the kitty keyboard protocol (to some degree) include Vim, Neovim,\nHelix, kakoune, and nushell. This means that when using one of these\napplications in one of these terminals, all of the key encoding problems\ndiscussed above (as well as some others which were not discussed...) are\nsolved.\n\n### Decorations\n\nXterm has supported 256 user specified colors since 1999. These colors could\nbe changed at runtime using an escape sequence (OSC 4), which can be used to\ngreat effect (see \u201c8 Bit & \u20188 Bitish\u2019 Graphics-Outside the Box\u201d by Mark\nFerrari for an incredible demonstration, or install notcurses and run\nnotcurses-demo j in your terminal).\n\nWithin the last decade or so, 24 bit color (sometimes referred to as\n\u201ctruecolor\u201d or \u201cRGB color\u201d) has become widely supported by terminal emulators\nwhich allows terminal applications to use whatever arbitrary colors they want.\nThis provides terminal UIs a much greater degree of flexibility and creative\nfreedom.\n\nModern terminals also support other kinds of \u201crich\u201d text markup, such as\nstrikethrough and various types of underlines. For instance, text editors like\nVim and Neovim can add a red squiggly line under misspelled words (as seen in\nmany graphical rich text editors).\n\nExamples of markup styles supported by modern terminal emulators\n\nIt is also possible to display images and even videos inline inside of\nterminal emulators. There are (at least) three different ways to do this\n(sixels, the iTerm2 image protocol, and the kitty graphics protocol) and\nsupport among terminal emulators varies. Unfortunately this means that\nterminal applications are in a bit of an awkward situation, as they must\neither implement support for all of the image protocols, or only support a\nsubset of terminals. For this reason, use of images in terminal applications\nis still relatively uncommon.\n\nIt is important to note that advances in terminal based UIs are not only due\nto the efforts of terminal emulators, but also to the creativity and talent of\nterminal application and library authors. For example, see some of the\nfantastic work that charm.sh has done creating delightful, interactive\nterminal based user interfaces that rival (and in some cases, surpass!)\ngraphical UIs for similar tools.\n\n### Capability Determination\n\nTerminal emulators do not all support the same features. In some cases, the\nsame feature is implemented in different ways. Terminal applications need some\nway to know which features the terminal they\u2019re running in support and how to\nproperly use those features.\n\nToday this is primarily done using a distributed database of \u201cterminfo\u201d files.\nThe terminal emulator uses the $TERM environment variable to communicate to\nterminal applications which terminfo file to use to lookup which capabilities\nthe terminal supports.\n\nThis has a multitude of problems, however. The terminfo database is part of\nthe ncurses library, and different operating systems and distributions package\ndifferent versions of ncurses. This was a problem for tmux users on macOS for\nmany years because the version of ncurses packaged with macOS was so old that\nit did not even include the tmux-256color terminfo entry at all!\n\nThis is also a problem for newer terminals which have not yet been added to\nthe ncurses terminfo database. Terminal emulators can (and often do) ship\ntheir own terminfo entries which are used by applications running on the same\nsystem as the terminal emulator itself. But when connecting to a remote system\n(e.g. with SSH), the terminfo database on the remote system will not have the\nterminfo entry and the user is met with cryptic warnings like WARNING:\nterminal is not fully functional and applications not functioning properly.\n\nTo circumvent this issue, many terminals use xterm-256color as their $TERM\nvalue, essentially claiming to be Xterm even though they are not, piggybacking\non Xterm\u2019s ubiquity. This creates a vicious cycle, as terminal applications\noften hardcode special cases for xterm-256color, which incentivizes terminals\nto claim to be xterm-256color, which incentivizes applications to special case\nxterm-256color, which... and so on. The problem is exacerbated by common (bad)\nadvice to users facing problems with terminal applications to simply override\n$TERM to be xterm-256color (the Xterm FAQ itself warns against this).\n\nUnfortunately there are no easy fixes for these problems, but there is hope.\nThe vast majority of escape sequences used by applications today are common\nacross most (if not all) modern terminal emulators. This makes terminfo less\nnecessary since applications can usually safely assume that a given escape\nsequence will \u201cjust work\u201d.\n\nIn addition, terminal emulators increasingly support applications querying\nsupport for certain capabilities. For instance, applications can query the\nterminal for support of the kitty keyboard protocol mentioned above and only\nenable it if the terminal responds that it is supported. A nice property of\nescape sequence queries is they still work even over remote login connections\nlike SSH.\n\nSome new TUI libraries, such as vaxis, are designed specifically to avoid\nusing terminfo at all and exclusively use queries to determine feature\ncapabilities. As more applications, libraries, and terminal emulators move in\nthis direction, terminfo will become increasingly unnecessary.\n\n### System Integration\n\nOne of the many advantages of software terminal emulators over hardware video\nterminals is that they are one piece of a larger, integrated computing system.\nModern terminal emulators support many escape sequences to interact with their\nbroader environment. These sequences are generally known as Operating System\nCommands (OSCs) and are often referred to by the numeric integer which appears\nafter the OSC prefix.\n\nSome of the more popular OSC sequences are OSC 2 for setting the title of the\nterminal emulator\u2019s window (used frequently by shells and text editors), OSC 8\nfor creating clickable hyperlinks, OSC 9 for sending desktop notifications,\nand OSC 52 for interacting with the system clipboard.\n\nYou can test these sequences out for yourself. Try running the following in\nyour shell:\n\n    \n    \n    printf '\\e]9;This is a notification!\\a'\n\nIf your terminal emulator supports OSC 9, you will see a desktop notification\nappear with the text, \u201cThis is a notification!\u201d (some terminals or operating\nsystems may not display a notificaton for the focused application. In that\ncase, add a sleep 2 before the printf command and quickly change focus to\nanother window).\n\nTerminals which support OSC 8 can create clickable hyperlinks. For instance,\ntry running the below command:\n\n    \n    \n    printf '\\e]8;;https://www.youtube.com/watch?v=dQw4w9WgXcQ\\aClick me for an awesome video!\\n\\e]8;;\\a'\n\nYou will see the text \u201cClick me for an awesome video!\u201d. If your terminal\nemulator supports OSC 8, the text will be clickable (perhaps requiring a\nmodifier key like Shift or Command to be held) and might be styled with an\nunderline or some other visual affordance to indicate that the text is a\nhyperlink. Clicking on the text will open your web browser to the (perfectly\ninnocuous) embedded URL.\n\nA long standing issue for terminal based text editors like Vim is clipboard\nmanagement in remote sessons. A strength of Vim is that it can be run just as\neasily in a remote SSH session as it can locally; however, the remote SSH\nsession is not able to communicate with the clipboard on your local system, so\nit is not possible to copy text inside of Vim on the remote session to your\nclipboard.\n\nVim addresses this by (optionally) linking against X11 and allowing users to\nforward their X connection to the remote server, allowing Vim on the remote\nserver to copy text to the X clipboard on the local system. And while this\ndoes work, it has its own problems (users must use a version of Vim compiled\nagainst X11, with the optional +clipboard feature enabled, and use X11 as\ntheir display server, and remember to forward the X connection to the remote\nsystem).\n\nA better solution is to copy data to the clipboard through the terminal\nemulator directly. An application running in the terminal can use the OSC 52\nescape sequence to write a Base64 encoded string to the terminal emulator. The\nterminal then decodes the string and copies the data into the system\nclipboard. The terminal emulator does not know or care whether the application\nthat sent the sequence is running remotely or not, which means this works on\nany system with zero dependencies.\n\nPasting (reading) from the clipboard has serious security implications,\nbecause any program in the terminal (even ones on remote servers) can request\nthe clipboard contents of the user\u2019s system. For this reason, most terminal\nemulators disable reading from the clipboard by default, or require the user\nto explicitly allow it with a prompt.\n\nNeovim recently added builtin support for using OSC 52 and it will be enabled\nfor users by default (if the terminal emulator supports it) in the forthcoming\n0.10 release.\n\n## Conclusion\n\nWhile it\u2019s true that terminals, as an application platform, are idiosyncratic\nand quirky, their portability, ubiquity, and relative ease of use (for\napplication authors) makes them increasingly popular for many developers, even\nin the face of an increasing number of alternatives.\n\nThis article is not exhaustive, but it is not meant to be. There are other\nchallenges that both terminal emulator and terminal application authors face\nthat are not discussed here, as well as other areas of innovation and creative\nexploration. Some examples: better grapheme clustering, synchronized output to\navoid \u201cflickering\u201d in redraw-heavy UIs, and custom shaders to create arbitrary\nvisual effects.\n\nTerminal emulators are not static: they continue to evolve and innovate to\nsolve users\u2019 problems and improve users\u2019 experience. The underlying technology\nis old: downright ancient by the standards of modern tech. But, instead of a\nflaw, I consider this a strength: it gives me confidence that while individual\nterminal emulators may come and go, the underlying platform will endure.\n\n## References & Further Reading\n\n  * The TTY demystified\n  * What happens when you press a key in your terminal?\n  * A history of the tty\n  * Understanding ASCII (and terminals)\n  * Comprehensive keyboard handling in terminals\n  * Fix Keyboard Input on Terminals - Please\n  * Grapheme Clusters and Terminal Emulators\n\n  1. This depends on your exact definition of \u201cunderlying technology\u201d. Here, I\u2019m referring to the use of teletype machines (TTYs) connected to a digital computer. But teletypes themselves were created well over a century ago, and there are still traces of their design in the inner workings of terminal emulators. \u21a9\ufe0e\n\n  2. Technically, it uses whichever version of the key, shifted or unshifted, falls in the range [0x20, 0x5f]. For alphabetic characters, this is the shifted (uppercase) letter, but for keys like [ or - it uses the unshifted variant. \u21a9\ufe0e\n\nLast modified on March 13, 2024\n\nThis work by Gregory Anders is licensed under CC BY-SA 4.0\n\n", "frontpage": false}
