{"aid": "40010620", "title": "Memgraph Storage Modes Explained", "url": "https://memgraph.com/blog/memgraph-storage-modes-explained", "domain": "memgraph.com", "votes": 6, "user": "taubek", "posted_at": "2024-04-12 08:53:58", "comments": 0, "source_title": "Memgraph Storage Modes Explained", "source_text": "Memgraph Storage Modes Explained\n\nGet started\n\nBack to blog\n\nProduct\n\n# Memgraph Storage Modes Explained\n\nApril 11, 2024\n\nKatarina Supe\n\nMemgraph is an in-memory graph database that ensures data persistence through\nACID compliance by default. While it uses snapshots and write-ahead logs (WAL)\nfor data recovery, in some cases, such additional files and insurance are not\nnecessary. Other databases and analytics tools offer snapshots or WAL, but\nMemgraph offers both with different storage modes.\n\nBefore you start using them, here's a helpful guide on Memgraph storage modes\nso you can understand when to use them and why.\n\n## ACID Compliance in In-Memory Transactional Storage Mode\n\nPreviously, Memgraph only had one storage mode\u2014in-memory transactional. The\nidea was to achieve excellent performance with the in-memory storage but still\nbe ACID compliant.\n\nUnder the hood, a Delta object is the primary tool with which Memgraph\nprovides atomicity, consistency, isolation and durability. These objects,\ninspired by the research presented in the Fast Serializable Multiversion\nConcurrency Control for Main-Memory Database Systems paper, record all\ntransaction modifications to nodes or relationships. This mechanism ensures\nthat periodic snapshots and write-ahead logs (WAL) are accurately maintained\non disk for durability purposes. By default, Memgraph retains the three most\nrecent snapshots and WAL files in the /var/lib/memgraph directory,\nfacilitating efficient backup and recovery processes.\n\nAnother transaction property is isolation. It determines how transaction\nintegrity is visible to other users and systems. Isolation can have different\nlevels. For example, a lower isolation level allows many users to access the\nsame data simultaneously but increases the number of concurrency effects (such\nas dirty reads or lost updates). A higher isolation level secures data\nconsistency but requires more system resources, increasing the chances that\none transaction will block another.\n\nMemgraph defaults to the SNAPSHOT_ISOLATION level. It guarantees that all\ntransaction reads observe a consistent database snapshot. This level also\nmandates that concurrent transactions can\u2019t successfully commit if they are\nupdating the same graph object, and such execution leads to conflicting\ntransactions error.\n\nYou should either avoid such errors or retry the transaction for which its\nexecution raised such an error. Still, it is essential to understand that\nthose errors are expected to occur with concurrent transactions to ensure the\nACID properties of the database transactions.\n\nBecause of strongly consistent ACID transactions in the in-memory\ntransactional mode, you don\u2019t have to worry about consistency even if you have\nmixed read and write transactions. Still, if you\u2019re dealing with large-scale\ndata import, you might notice memory overhead because Delta objects are\nquickly accumulated.\n\nTo avoid such issues and experience fast import without wasting valuable\nmemory resources, Memgraph introduced the in-memory analytical storage mode.\n\n## Fast Writes Without Memory Overhead: In-Memory Analytical Storage Mode\n\nIn the in-memory analytical storage mode, Delta objects are disabled to\nachieve better performance without memory overhead. Which is significantly\nnoticeable during data import. Besides that, no isolation levels are defined\nin the in-memory analytical storage mode.\n\nBefore diving into the details of this storage mode, let\u2019s first explain the\nmotivation behind disabling Delta objects. A while ago, we noticed a common\nchallenge among our users: data import complexities. Since data import is one\nof the first steps when using a database, we knew we had to make improvements.\n\nDuring data import, graph objects are frequently created and updated, which\ncauses a fast accumulation of Delta objects. These objects, while crucial for\nmaintaining ACID properties, also consume considerable memory resources. This\nis particularly noticeable when new relationships are formed, creating Deltas\nfor both the starting and ending nodes. Although Deltas make it possible to\nundo such changes, they significantly slow down subsequent node updates, as\nevery Delta must be processed before any new modification.\n\nAfter detecting Delta objects as the main culprit for slow import, we were\ncurious to know what would happen if we disabled them.\n\nHere is the impact of removing Delta objects:\n\n  * Multiple transactions can modify the same object and create relationships on the same node concurrently (there are no concurrent transactions errors anymore)\n\n  * It leads to improved performance write-heavy workloads\n\n  * The trade-offs include a lack of ACID guarantees; though it\u2019s possible to manually create snapshots for durability.\n\n  * Replication is disabled, as Deltas are essential for this process.\n\nEveryone loves to hear about the positive impact on speed and performance, but\nlet\u2019s explain what not having ACID guarantees means.\n\n  * Deltas being disabled lead to no WALs being created, meaning that if a write transaction fails for any reason, the changes can\u2019t be rolled back -> no Atomicity guarantees\n\n  * Transactions may fail and leave the database in an inconsistent state -> no Consistency guarantees\n\n  * No isolation level, meaning if you have a long-running write transaction, other transactions can see the changes of ongoing transactions even if changes are not committed -> no Isolation guarantees\n\n  * Snapshots and WALs are not created -> No Durability guarantees\n\nWhen you understand what we\u2019ve just covered and review the implications, you\ncan get the most out of this storage mode and achieve the best performance\nwith low memory cost.\n\n## Managing Large Datasets: Introducing On-Disk Transactional Storage Mode\n\nWhat to do when the dataset is larger than the available RAM?\n\nIdeally, if your data is larger than the available RAM, you would have a part\nof it stored on disk and the part used for the analysis in memory. Memgraph\noffers a third storage mode that does precisely that - on-disk transactional\nstorage mode.\n\nLet's go over how Memgraph's on-disk transactional storage mode differs from\nin-memory approaches. We'll get into the implementation and distinctive\nbenefits it brings to the table.\n\nMemgraph utilizes RocksDB as background storage to serialize nodes and\nrelationships into a key-value format to achieve the on-disk transactional\nstorage mode. This storage mode supports only the snapshot isolation level\nbecause it simplifies the query's execution flow since no data is transferred\nto the disk until the transaction is committed.\n\nThe durability is achieved with the help of RocksDB, which keeps its own WAL\nfiles. The imported data is on disk, while the main memory contains two\ncaches\u2014one for executing operations on the main RocksDB instance and the other\nfor operations that require indexes. In both cases, Memgraph's custom SkipList\ncache is used, which allows a multithreaded read-write access pattern.\n\nConcurrent transactions are handled differently in the on-disk storage mode\nthan in the in-memory transactional storage mode. In the on-disk storage mode,\nthe cache is used per transaction, so there is no need to question a certain\nobject's validity, meaning the optimistic approach for conflict resolution\nbetween transactions is used.\n\nIn the on-disk storage mode, Deltas are still used to support Cypher's\nsemantic of the write queries, but they are cleared after each transaction.\nThat happens because the conflict is checked at the transaction\u2019s commit time\nwith RocksDB\u2019s transaction support, which can optimize memory usage during\nexecution. The design of the on-disk storage also simplifies the garbage\ncollection process since all the data is on disk.\n\nBefore using on-disk storage mode, it is important to know the implications.\nAlthough keeping the hardware costs to a minimum sounds perfect, this storage\nmode is still experimental because it does not offer the same performance as\nthe in-memory transactional storage mode. If you try out on-disk transactional\nmode, keep in mind that while executing queries, all the graph objects used in\nthe transactions still need to be able to fit in the RAM, or Memgraph will\nthrow an exception.\n\n## Choosing the Right Storage Mode for Your Needs\n\nWhich storage mode to use?\n\nDeciding between Memgraph\u2019s storage modes depends on your specific needs and\nthe size of your data:\n\n  * In-memory transactional storage mode - Stick with this default mode if its performance meets your current needs. It\u2019s fast and reliable, providing ACID guarantees for your transactions.\n\n  * In-memory analytical storage mode - Use this mode if ACID guarantees are not a priority and you\u2019re looking to maximize performance and efficiency in memory usage. It\u2019s ideal for analytical workloads where speed is of the essence.\n\n  * On-disk transactional storage mode - If your dataset exceeds your available memory, this mode offers a practical solution. It allows you to work with a subset of your data stored on disk, balancing between performance and capacity. However, be mindful of its experimental nature and the potential tradeoffs in performance compared to in-memory modes.\n\n## Conclusion\n\nBefore making a switch, it\u2019s important to understand the consequences of each\nstorage mode on your workflows. Each has its benefits and limitations,\naffecting performance, data integrity, and how you manage your dataset.\n\nNeed help? If you are unsure which mode is best for you or if you have any\nquestions, our DX team is here to help. Feel free to schedule an office hour\ncall for personalized guidance. Additionally, our problem-solving Discord\ncommunity is a great resource for advice, tips, and discussions with fellow\nusers and our team.\n\n## Further Reading\n\n  * Switch Storage Memory Modes\n\n  * Optimistic vs. Pessimistic Approaches\n\n  * Improve Query Execution Performance\n\n  * In-memory vs. disk-based databases: Why do you need a larger than memory architecture?\n\n  * How to Import 1 Million Nodes and Edges per Second into Memgraph\n\nJoin us on Discord!\n\nFind other developers performing graph analytics in real time with Memgraph.\n\nJoin now\n\nProduct\n\nDatabase\n\nTools\n\nCapabilities\n\nEnterprise\n\nPricing\n\nEnterprise license\n\nLegal\n\nPartners\n\nContact us\n\nResources\n\nUse cases\n\nBlog\n\nResource hub\n\nBenchmark\n\nPlayground\n\nDevelopers\n\nDocs\n\nPython\n\nNetworkX\n\nNeo4j vs Memgraph\n\nCompany\n\nAbout us\n\nCareers\n\nCompany\n\nAbout us\n\nCareers\n\n\u00a9 2024 Memgraph Ltd. All rights reserved.\n\nTerms & Privacy\n\n", "frontpage": false}
