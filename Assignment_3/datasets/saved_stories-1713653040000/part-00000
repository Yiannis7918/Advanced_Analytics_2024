{"aid": "40098606", "title": "Tips on adding JSON output to your command line utility. (2021)", "url": "https://blog.kellybrazil.com/2021/12/03/tips-on-adding-json-output-to-your-cli-app/", "domain": "kellybrazil.com", "votes": 4, "user": "fanf2", "posted_at": "2024-04-20 16:42:04", "comments": 0, "source_title": "Tips on Adding JSON Output to Your CLI App", "source_text": "Tips on Adding JSON Output to Your CLI App - Brazil's Blog\n\nSkip to content\n\nBrazil's Blog\n\nMusings on automation, scripting, programing, DevOps, and cybersecurity\n\n# Tips on Adding JSON Output to Your CLI App\n\nPosted bykellyjonbrazilDecember 3, 2021December 3, 2021Posted inAll Posts,\nProgrammingTags:best practices, cli, command-line, json, json-lines\n\nA couple of years ago I wrote a somewhat controversial article on the topic of\nBringing the Unix Philosophy to the 21st Century by adding a JSON output\noption to CLI tools. This allows easier parsing in scripts by using JSON\nparsing tools like jq, jello, jp, etc. without arcane awk, sed, cut, tr,\nreverse, etc. incantations.\n\nIt was controversial because there seem to be a lot of folks who don\u2019t think\nwriting bespoke parsers for each task is a big deal. Others think JSON is\nevil. There are strong feelings as can be seen in response to the article in\nthe comments and also on Hacker News and Reddit.\n\nI\u2019ll let the next generation of DevOps practitioners and developers come to\ntheir own conclusions on the basis of our arguments, but the tide is already\nturning. Something that was just wishful thinking a couple years ago is now\nbecoming a reality! Now, more and more command line applications are offering\nJSON output as an option. And with jc, JSON output can even be coaxed out of\nolder command line applications.\n\n## Structured Output Support is Increasing\n\nNow, there are many new command line applications that offer structured output\nas an option, and even some older ones are adding the option. I find that more\nand more often when a parser is requested for jc, if I check the man page for\nthe application, there is already a JSON or XML output option. Some examples\ninclude nvidia-smi, ffprobe, docker CLI, and tree. Even ip now supports JSON\noutput with ip route, which wasn\u2019t supported when I originally wrote about it\nin the article.\n\nI recently developed standard and streaming parsers for the iostat command and\nfound that versions 11 and above now have a JSON output option. Way to go!\n\nBut when looking at the JSON options for some of these commands, I found some\nthings that could be improved.\n\n## JSON Output Do\u2019s and Don\u2019ts\n\nWhile developing over 80 parsers for the jc project, I stumbled upon some best\npractices. My first goal was to make getting the data easy when using jq, as\nthat was the only CLI JSON processing tool I really used at the time. With\nthat initial goal, and input from scores of users, this is how I try to make\nthe highest quality JSON output:\n\n> Note: Many of these are completely subjective and are just my humble\n> opinion. I\u2019m willing to keep an open mind about these choices.\n\n  * Do Make a Schema\n  * Do Flatten the Structure\n  * Do Output JSON Lines for Streaming Output\n  * Do Use Predictable Key Names\n  * Do Pretty Print with Two Spaces or Don\u2019t Format at All\n  * Don\u2019t Use Special Characters in Key Names\n  * Don\u2019t Allow Duplicate Keys\n  * Don\u2019t Use Very Large Numbers\n  * BONUS\n\nLet\u2019s take a look at these in more detail.\n\n### Do\n\nHere are some good practices when generating JSON output:\n\n#### Make a Schema\n\nWhen possible, which is almost always the case, I document a schema for the\nJSON output. This allows the user to know where they can always find an\nattribute and which type they can expect. (string, integer, float, boolean,\nnull, object, array) This also allows you to test the output to make sure it\nconforms to the schema and there are no bugs.\n\nA schema doesn\u2019t have to be complicated. It can be specified in the\ndocumentation, including the man page. I use this simple structure for jc\ndocumentation:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n[\n\n{\n\n\"foo\": string,\n\n\"bar\": float, # null if blank\n\n\"baz\": [\n\ninteger\n\n]\n\n}\n\n]\n\n[ { \"foo\": string, \"bar\": float, # null if blank \"baz\": [ integer ] } ]\n\n    \n    \n    [ { \"foo\": string, \"bar\": float, # null if blank \"baz\": [ integer ] } ]\n\n#### Flatten the Structure\n\nThe best case is to output an object or an array of objects (most common) with\nno further nesting. Sometimes you can prefix an attribute name if nesting is\nnot absolutely necessary. The idea is to make it as easy for the user to grab\nthe value so they don\u2019t need to traverse the data structure to get what they\nwant.\n\nSometimes this:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n[\n\n{\n\n\"cpu\": {\n\n\"speed\": 5,\n\n\"temp\": 33.2\n\n},\n\n\"ram\": {\n\n\"speed\": 11,\n\n\"mb\": 1024\n\n}\n\n}\n\n]\n\n[ { \"cpu\": { \"speed\": 5, \"temp\": 33.2 }, \"ram\": { \"speed\": 11, \"mb\": 1024 } }\n]\n\n    \n    \n    [ { \"cpu\": { \"speed\": 5, \"temp\": 33.2 }, \"ram\": { \"speed\": 11, \"mb\": 1024 } } ]\n\nCan be turned into this:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n[\n\n{\n\n\"cpu_speed\": 5,\n\n\"cpu_temp\": 33.2,\n\n\"ram_speed\": 11,\n\n\"ram_mb\": 1024\n\n}\n\n]\n\n[ { \"cpu_speed\": 5, \"cpu_temp\": 33.2, \"ram_speed\": 11, \"ram_mb\": 1024 } ]\n\n    \n    \n    [ { \"cpu_speed\": 5, \"cpu_temp\": 33.2, \"ram_speed\": 11, \"ram_mb\": 1024 } ]\n\nThis way I can easily filter the data in jq or other tools without having to\ntraverse levels. Of course, this is not always possible or desirable, but\nkeeping a flat structure should be considered for user convenience.\n\nThis approach is also great for output that contains a long list of items.\nI\u2019ll pick on iostat a bit here to make a point \u2013 but don\u2019t take this the wrong\nway \u2013 I\u2019m thrilled that the author of iostat has included a JSON output option\nand in no way want to discount the work put into that.\n\nThe iostat JSON output option deeply nests the output like so:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n{\n\n\"sysstat\": {\n\n\"hosts\": [\n\n{\n\n\"nodename\": \"ubuntu\",\n\n\"sysname\": \"Linux\",\n\n\"release\": \"5.8.0-53-generic\",\n\n\"machine\": \"x86_64\",\n\n\"number-of-cpus\": 2,\n\n\"date\": \"12/03/2021\",\n\n\"statistics\": [\n\n{\n\n\"avg-cpu\": {\n\n\"user\": 0.6,\n\n\"nice\": 0.01,\n\n\"system\": 1.68,\n\n\"iowait\": 0.14,\n\n\"steal\": 0,\n\n\"idle\": 97.58\n\n},\n\n\"disk\": [\n\n{\n\n\"disk_device\": \"dm-0\",\n\n\"tps\": 29.07,\n\n\"kB_read/s\": 502.25,\n\n\"kB_wrtn/s\": 54.94,\n\n\"kB_dscd/s\": 0,\n\n\"kB_read\": 251601,\n\n\"kB_wrtn\": 27524,\n\n\"kB_dscd\": 0\n\n},\n\n...\n\n{ \"sysstat\": { \"hosts\": [ { \"nodename\": \"ubuntu\", \"sysname\": \"Linux\",\n\"release\": \"5.8.0-53-generic\", \"machine\": \"x86_64\", \"number-of-cpus\": 2,\n\"date\": \"12/03/2021\", \"statistics\": [ { \"avg-cpu\": { \"user\": 0.6, \"nice\":\n0.01, \"system\": 1.68, \"iowait\": 0.14, \"steal\": 0, \"idle\": 97.58 }, \"disk\": [ {\n\"disk_device\": \"dm-0\", \"tps\": 29.07, \"kB_read/s\": 502.25, \"kB_wrtn/s\": 54.94,\n\"kB_dscd/s\": 0, \"kB_read\": 251601, \"kB_wrtn\": 27524, \"kB_dscd\": 0 }, ...\n\n    \n    \n    { \"sysstat\": { \"hosts\": [ { \"nodename\": \"ubuntu\", \"sysname\": \"Linux\", \"release\": \"5.8.0-53-generic\", \"machine\": \"x86_64\", \"number-of-cpus\": 2, \"date\": \"12/03/2021\", \"statistics\": [ { \"avg-cpu\": { \"user\": 0.6, \"nice\": 0.01, \"system\": 1.68, \"iowait\": 0.14, \"steal\": 0, \"idle\": 97.58 }, \"disk\": [ { \"disk_device\": \"dm-0\", \"tps\": 29.07, \"kB_read/s\": 502.25, \"kB_wrtn/s\": 54.94, \"kB_dscd/s\": 0, \"kB_read\": 251601, \"kB_wrtn\": 27524, \"kB_dscd\": 0 }, ...\n\nThis makes sense and is very logical when you look at the output as an entire\nJSON document, but when dealing with command output from certain commands like\niostat, vmstat, ping, ls, etc. which can have huge \u2013 even unlimited \u2013 amounts\nof output, it might make more sense to build the JSON structure into a format\nthat is more easily consumed by tools like jq to be used in a pipeline.\n\nWith this structure, the whole document needs to be loaded before the JSON is\nconsidered valid and searchable, though iostat output can actually go on\nindefinitely depending on how the command is run.\n\nI took a different approach with the jc iostat parser by using a flat array of\nobjects and simply using a type attribute to denote which type of object it\nis. This allows very easy filtering in jq or other tools and also allows\nconsistency with the streaming parser, which I\u2019ll get to in another section.\n\nHere\u2019s the jc version:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n[\n\n{\n\n\"percent_user\": 0.31,\n\n\"percent_nice\": 0.23,\n\n\"percent_system\": 0.48,\n\n\"percent_iowait\": 0.04,\n\n\"percent_steal\": 0.0,\n\n\"percent_idle\": 98.95,\n\n\"type\": \"cpu\"\n\n},\n\n{\n\n\"device\": \"dm-0\",\n\n\"tps\": 8.16,\n\n\"kb_read_s\": 137.26,\n\n\"kb_wrtn_s\": 129.0,\n\n\"kb_dscd_s\": 0.0,\n\n\"kb_read\": 395021,\n\n\"kb_wrtn\": 371240,\n\n\"kb_dscd\": 0,\n\n\"type\": \"device\"\n\n},\n\n{\n\n\"device\": \"loop0\",\n\n\"tps\": 0.01,\n\n\"kb_read_s\": 0.12,\n\n\"kb_wrtn_s\": 0.0,\n\n\"kb_dscd_s\": 0.0,\n\n\"kb_read\": 344,\n\n\"kb_wrtn\": 0,\n\n\"kb_dscd\": 0,\n\n\"type\": \"device\"\n\n},\n\n...\n\n]\n\n[ { \"percent_user\": 0.31, \"percent_nice\": 0.23, \"percent_system\": 0.48,\n\"percent_iowait\": 0.04, \"percent_steal\": 0.0, \"percent_idle\": 98.95, \"type\":\n\"cpu\" }, { \"device\": \"dm-0\", \"tps\": 8.16, \"kb_read_s\": 137.26, \"kb_wrtn_s\":\n129.0, \"kb_dscd_s\": 0.0, \"kb_read\": 395021, \"kb_wrtn\": 371240, \"kb_dscd\": 0,\n\"type\": \"device\" }, { \"device\": \"loop0\", \"tps\": 0.01, \"kb_read_s\": 0.12,\n\"kb_wrtn_s\": 0.0, \"kb_dscd_s\": 0.0, \"kb_read\": 344, \"kb_wrtn\": 0, \"kb_dscd\":\n0, \"type\": \"device\" }, ... ]\n\n    \n    \n    [ { \"percent_user\": 0.31, \"percent_nice\": 0.23, \"percent_system\": 0.48, \"percent_iowait\": 0.04, \"percent_steal\": 0.0, \"percent_idle\": 98.95, \"type\": \"cpu\" }, { \"device\": \"dm-0\", \"tps\": 8.16, \"kb_read_s\": 137.26, \"kb_wrtn_s\": 129.0, \"kb_dscd_s\": 0.0, \"kb_read\": 395021, \"kb_wrtn\": 371240, \"kb_dscd\": 0, \"type\": \"device\" }, { \"device\": \"loop0\", \"tps\": 0.01, \"kb_read_s\": 0.12, \"kb_wrtn_s\": 0.0, \"kb_dscd_s\": 0.0, \"kb_read\": 344, \"kb_wrtn\": 0, \"kb_dscd\": 0, \"type\": \"device\" }, ... ]\n\nYou\u2019ll notice that jc doesn\u2019t bother with metadata around the source of the\ndata that generated the output or even the host statistics. This is because\nincluding the source just makes the object nesting deeper without adding\nvalue, and the header information is available with other tools like uname and\ndate, though I could add them in a future parser version as an object with its\nown type if users want that data.\n\nGetting to the data in this structure is pretty easy: just loop over the\narray, filter by type (if needed), and pull attributes from the top-level of\neach object.\n\n#### Output JSON Lines for Streaming Output\n\nThere\u2019s another advantage to the array of flat objects structure discussed\nabove, and that\u2019s for programs like iostat and others that can stream output\nforever until the user hits <ctrl-c>. In this case, it would be difficult to\npipe the output to a JSON filter, like jq, since the output would not be valid\nJSON until the program ends.\n\nFor these cases, outputting JSON Lines (aka NDJSON) is a good choice.\n\nUnfortunately, this is what the iostat output looks like when running it\nindefinitely:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ iostat 1 -o JSON\n\n{\"sysstat\": {\n\n\"hosts\": [\n\n{\n\n\"nodename\": \"ubuntu\",\n\n\"sysname\": \"Linux\",\n\n\"release\": \"5.8.0-53-generic\",\n\n\"machine\": \"x86_64\",\n\n\"number-of-cpus\": 2,\n\n\"date\": \"12/03/2021\",\n\n\"statistics\": [\n\n{\n\n\"avg-cpu\": {\"user\": 1.23, \"nice\": 0.86, \"system\": 1.23, \"iowait\": 0.06,\n\"steal\": 0.00, \"idle\": 96.62},\n\n\"disk\": [\n\n{\"disk_device\": \"dm-0\", \"tps\": 30.16, \"kB_read/s\": 138.78, \"kB_wrtn/s\":\n476.19, \"kB_dscd/s\": 0.00, \"kB_read\": 654975, \"kB_wrtn\": 2247452, \"kB_dscd\":\n0},\n\n{\"disk_device\": \"sr0\", \"tps\": 0.13, \"kB_read/s\": 4.89, \"kB_wrtn/s\": 0.00,\n\"kB_dscd/s\": 0.00, \"kB_read\": 23067, \"kB_wrtn\": 0, \"kB_dscd\": 0}\n\n]\n\n},\n\n{\n\n\"avg-cpu\": {\"user\": 0.00, \"nice\": 0.00, \"system\": 0.00, \"iowait\": 0.00,\n\"steal\": 0.00, \"idle\": 100.00},\n\n\"disk\": [\n\n{\"disk_device\": \"dm-0\", \"tps\": 0.00, \"kB_read/s\": 0.00, \"kB_wrtn/s\": 0.00,\n\"kB_dscd/s\": 0.00, \"kB_read\": 0, \"kB_wrtn\": 0, \"kB_dscd\": 0},\n\n{\"disk_device\": \"sr0\", \"tps\": 0.00, \"kB_read/s\": 0.00, \"kB_wrtn/s\": 0.00,\n\"kB_dscd/s\": 0.00, \"kB_read\": 0, \"kB_wrtn\": 0, \"kB_dscd\": 0}\n\n]\n\n},\n\n{\n\n\"avg-cpu\": {\"user\": 0.00, \"nice\": 0.00, \"system\": 0.50, \"iowait\": 0.00,\n\"steal\": 0.00, \"idle\": 99.50},\n\n\"disk\": [\n\n{\"disk_device\": \"dm-0\", \"tps\": 5.00, \"kB_read/s\": 0.00, \"kB_wrtn/s\": 20.00,\n\"kB_dscd/s\": 0.00, \"kB_read\": 0, \"kB_wrtn\": 20, \"kB_dscd\": 0},\n\n{\"disk_device\": \"sr0\", \"tps\": 0.00, \"kB_read/s\": 0.00, \"kB_wrtn/s\": 0.00,\n\"kB_dscd/s\": 0.00, \"kB_read\": 0, \"kB_wrtn\": 0, \"kB_dscd\": 0}\n\n]\n\n}\n\n...\n\n$ iostat 1 -o JSON {\"sysstat\": { \"hosts\": [ { \"nodename\": \"ubuntu\", \"sysname\":\n\"Linux\", \"release\": \"5.8.0-53-generic\", \"machine\": \"x86_64\", \"number-of-cpus\":\n2, \"date\": \"12/03/2021\", \"statistics\": [ { \"avg-cpu\": {\"user\": 1.23, \"nice\":\n0.86, \"system\": 1.23, \"iowait\": 0.06, \"steal\": 0.00, \"idle\": 96.62}, \"disk\": [\n{\"disk_device\": \"dm-0\", \"tps\": 30.16, \"kB_read/s\": 138.78, \"kB_wrtn/s\":\n476.19, \"kB_dscd/s\": 0.00, \"kB_read\": 654975, \"kB_wrtn\": 2247452, \"kB_dscd\":\n0}, {\"disk_device\": \"sr0\", \"tps\": 0.13, \"kB_read/s\": 4.89, \"kB_wrtn/s\": 0.00,\n\"kB_dscd/s\": 0.00, \"kB_read\": 23067, \"kB_wrtn\": 0, \"kB_dscd\": 0} ] }, { \"avg-\ncpu\": {\"user\": 0.00, \"nice\": 0.00, \"system\": 0.00, \"iowait\": 0.00, \"steal\":\n0.00, \"idle\": 100.00}, \"disk\": [ {\"disk_device\": \"dm-0\", \"tps\": 0.00,\n\"kB_read/s\": 0.00, \"kB_wrtn/s\": 0.00, \"kB_dscd/s\": 0.00, \"kB_read\": 0,\n\"kB_wrtn\": 0, \"kB_dscd\": 0}, {\"disk_device\": \"sr0\", \"tps\": 0.00, \"kB_read/s\":\n0.00, \"kB_wrtn/s\": 0.00, \"kB_dscd/s\": 0.00, \"kB_read\": 0, \"kB_wrtn\": 0,\n\"kB_dscd\": 0} ] }, { \"avg-cpu\": {\"user\": 0.00, \"nice\": 0.00, \"system\": 0.50,\n\"iowait\": 0.00, \"steal\": 0.00, \"idle\": 99.50}, \"disk\": [ {\"disk_device\":\n\"dm-0\", \"tps\": 5.00, \"kB_read/s\": 0.00, \"kB_wrtn/s\": 20.00, \"kB_dscd/s\": 0.00,\n\"kB_read\": 0, \"kB_wrtn\": 20, \"kB_dscd\": 0}, {\"disk_device\": \"sr0\", \"tps\":\n0.00, \"kB_read/s\": 0.00, \"kB_wrtn/s\": 0.00, \"kB_dscd/s\": 0.00, \"kB_read\": 0,\n\"kB_wrtn\": 0, \"kB_dscd\": 0} ] } ...\n\n    \n    \n    $ iostat 1 -o JSON {\"sysstat\": { \"hosts\": [ { \"nodename\": \"ubuntu\", \"sysname\": \"Linux\", \"release\": \"5.8.0-53-generic\", \"machine\": \"x86_64\", \"number-of-cpus\": 2, \"date\": \"12/03/2021\", \"statistics\": [ { \"avg-cpu\": {\"user\": 1.23, \"nice\": 0.86, \"system\": 1.23, \"iowait\": 0.06, \"steal\": 0.00, \"idle\": 96.62}, \"disk\": [ {\"disk_device\": \"dm-0\", \"tps\": 30.16, \"kB_read/s\": 138.78, \"kB_wrtn/s\": 476.19, \"kB_dscd/s\": 0.00, \"kB_read\": 654975, \"kB_wrtn\": 2247452, \"kB_dscd\": 0}, {\"disk_device\": \"sr0\", \"tps\": 0.13, \"kB_read/s\": 4.89, \"kB_wrtn/s\": 0.00, \"kB_dscd/s\": 0.00, \"kB_read\": 23067, \"kB_wrtn\": 0, \"kB_dscd\": 0} ] }, { \"avg-cpu\": {\"user\": 0.00, \"nice\": 0.00, \"system\": 0.00, \"iowait\": 0.00, \"steal\": 0.00, \"idle\": 100.00}, \"disk\": [ {\"disk_device\": \"dm-0\", \"tps\": 0.00, \"kB_read/s\": 0.00, \"kB_wrtn/s\": 0.00, \"kB_dscd/s\": 0.00, \"kB_read\": 0, \"kB_wrtn\": 0, \"kB_dscd\": 0}, {\"disk_device\": \"sr0\", \"tps\": 0.00, \"kB_read/s\": 0.00, \"kB_wrtn/s\": 0.00, \"kB_dscd/s\": 0.00, \"kB_read\": 0, \"kB_wrtn\": 0, \"kB_dscd\": 0} ] }, { \"avg-cpu\": {\"user\": 0.00, \"nice\": 0.00, \"system\": 0.50, \"iowait\": 0.00, \"steal\": 0.00, \"idle\": 99.50}, \"disk\": [ {\"disk_device\": \"dm-0\", \"tps\": 5.00, \"kB_read/s\": 0.00, \"kB_wrtn/s\": 20.00, \"kB_dscd/s\": 0.00, \"kB_read\": 0, \"kB_wrtn\": 20, \"kB_dscd\": 0}, {\"disk_device\": \"sr0\", \"tps\": 0.00, \"kB_read/s\": 0.00, \"kB_wrtn/s\": 0.00, \"kB_dscd/s\": 0.00, \"kB_read\": 0, \"kB_wrtn\": 0, \"kB_dscd\": 0} ] } ...\n\nThis is not easily parsable downstream when used in a pipeline:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ iostat 1 -o JSON | jq\n\n^C # hangs forever until <ctrl-c> is entered and no JSON is filtered\n\n$ iostat 1 -o JSON | jq ^C # hangs forever until <ctrl-c> is entered and no JSON is filtered\n    \n    \n    $ iostat 1 -o JSON | jq ^C # hangs forever until <ctrl-c> is entered and no JSON is filtered\n\nThe author of iostat did do a cool thing, though, and correctly wrapped the\noutput in the final end brackets when the <ctrl-c> sequence is caught. So it\ndoes finally create a valid JSON document, but I\u2019m not sure all developers\nwill have the forethought to do this. Still, this does not solve the\npipelining problem.\n\nInstead, the streaming iostat parser in jc outputs JSON lines with the same\nschema as the standard parser. Basically, the only difference is that there\nare no beginning and ending array brackets and each object is compact printed\non its own line. This allows JSON processors like jq to work on each line\nimmediately as they are emitted:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ iostat 1 | jc --iostat-s -u | jq -c\n\n{\"percent_user\":1.11,\"percent_nice\":0.78,\"percent_system\":1.12,\"percent_iowait\":0.05,\"percent_steal\":0.0,\"percent_idle\":96.94,\"type\":\"cpu\"}\n\n{\"device\":\"dm-0\",\"tps\":27.4,\"kb_read_s\":125.07,\"kb_wrtn_s\":430.11,\"kb_dscd_s\":0.0,\"kb_read\":654987,\"kb_wrtn\":2252376,\"kb_dscd\":0,\"type\":\"device\"}\n\n{\"device\":\"loop0\",\"tps\":0.02,\"kb_read_s\":0.16,\"kb_wrtn_s\":0.0,\"kb_dscd_s\":0.0,\"kb_read\":862,\"kb_wrtn\":0,\"kb_dscd\":0,\"type\":\"device\"}\n\n{\"percent_user\":2.53,\"percent_nice\":0.0,\"percent_system\":1.52,\"percent_iowait\":0.0,\"percent_steal\":0.0,\"percent_idle\":95.96,\"type\":\"cpu\"}\n\n{\"device\":\"dm-0\",\"tps\":19.0,\"kb_read_s\":0.0,\"kb_wrtn_s\":76.0,\"kb_dscd_s\":0.0,\"kb_read\":0,\"kb_wrtn\":76,\"kb_dscd\":0,\"type\":\"device\"}\n\n{\"device\":\"loop0\",\"tps\":0.0,\"kb_read_s\":0.0,\"kb_wrtn_s\":0.0,\"kb_dscd_s\":0.0,\"kb_read\":0,\"kb_wrtn\":0,\"kb_dscd\":0,\"type\":\"device\"}\n\n{\"percent_user\":1.01,\"percent_nice\":0.0,\"percent_system\":0.0,\"percent_iowait\":0.0,\"percent_steal\":0.0,\"percent_idle\":98.99,\"type\":\"cpu\"}\n\n{\"device\":\"dm-0\",\"tps\":0.0,\"kb_read_s\":0.0,\"kb_wrtn_s\":0.0,\"kb_dscd_s\":0.0,\"kb_read\":0,\"kb_wrtn\":0,\"kb_dscd\":0,\"type\":\"device\"}\n\n{\"device\":\"loop0\",\"tps\":0.0,\"kb_read_s\":0.0,\"kb_wrtn_s\":0.0,\"kb_dscd_s\":0.0,\"kb_read\":0,\"kb_wrtn\":0,\"kb_dscd\":0,\"type\":\"device\"}\n\n...\n\n$ iostat 1 | jc --iostat-s -u | jq -c {\"percent_user\":1.11,\"percent_nice\":0.78,\"percent_system\":1.12,\"percent_iowait\":0.05,\"percent_steal\":0.0,\"percent_idle\":96.94,\"type\":\"cpu\"} {\"device\":\"dm-0\",\"tps\":27.4,\"kb_read_s\":125.07,\"kb_wrtn_s\":430.11,\"kb_dscd_s\":0.0,\"kb_read\":654987,\"kb_wrtn\":2252376,\"kb_dscd\":0,\"type\":\"device\"} {\"device\":\"loop0\",\"tps\":0.02,\"kb_read_s\":0.16,\"kb_wrtn_s\":0.0,\"kb_dscd_s\":0.0,\"kb_read\":862,\"kb_wrtn\":0,\"kb_dscd\":0,\"type\":\"device\"} {\"percent_user\":2.53,\"percent_nice\":0.0,\"percent_system\":1.52,\"percent_iowait\":0.0,\"percent_steal\":0.0,\"percent_idle\":95.96,\"type\":\"cpu\"} {\"device\":\"dm-0\",\"tps\":19.0,\"kb_read_s\":0.0,\"kb_wrtn_s\":76.0,\"kb_dscd_s\":0.0,\"kb_read\":0,\"kb_wrtn\":76,\"kb_dscd\":0,\"type\":\"device\"} {\"device\":\"loop0\",\"tps\":0.0,\"kb_read_s\":0.0,\"kb_wrtn_s\":0.0,\"kb_dscd_s\":0.0,\"kb_read\":0,\"kb_wrtn\":0,\"kb_dscd\":0,\"type\":\"device\"} {\"percent_user\":1.01,\"percent_nice\":0.0,\"percent_system\":0.0,\"percent_iowait\":0.0,\"percent_steal\":0.0,\"percent_idle\":98.99,\"type\":\"cpu\"} {\"device\":\"dm-0\",\"tps\":0.0,\"kb_read_s\":0.0,\"kb_wrtn_s\":0.0,\"kb_dscd_s\":0.0,\"kb_read\":0,\"kb_wrtn\":0,\"kb_dscd\":0,\"type\":\"device\"} {\"device\":\"loop0\",\"tps\":0.0,\"kb_read_s\":0.0,\"kb_wrtn_s\":0.0,\"kb_dscd_s\":0.0,\"kb_read\":0,\"kb_wrtn\":0,\"kb_dscd\":0,\"type\":\"device\"} ...\n    \n    \n    $ iostat 1 | jc --iostat-s -u | jq -c {\"percent_user\":1.11,\"percent_nice\":0.78,\"percent_system\":1.12,\"percent_iowait\":0.05,\"percent_steal\":0.0,\"percent_idle\":96.94,\"type\":\"cpu\"} {\"device\":\"dm-0\",\"tps\":27.4,\"kb_read_s\":125.07,\"kb_wrtn_s\":430.11,\"kb_dscd_s\":0.0,\"kb_read\":654987,\"kb_wrtn\":2252376,\"kb_dscd\":0,\"type\":\"device\"} {\"device\":\"loop0\",\"tps\":0.02,\"kb_read_s\":0.16,\"kb_wrtn_s\":0.0,\"kb_dscd_s\":0.0,\"kb_read\":862,\"kb_wrtn\":0,\"kb_dscd\":0,\"type\":\"device\"} {\"percent_user\":2.53,\"percent_nice\":0.0,\"percent_system\":1.52,\"percent_iowait\":0.0,\"percent_steal\":0.0,\"percent_idle\":95.96,\"type\":\"cpu\"} {\"device\":\"dm-0\",\"tps\":19.0,\"kb_read_s\":0.0,\"kb_wrtn_s\":76.0,\"kb_dscd_s\":0.0,\"kb_read\":0,\"kb_wrtn\":76,\"kb_dscd\":0,\"type\":\"device\"} {\"device\":\"loop0\",\"tps\":0.0,\"kb_read_s\":0.0,\"kb_wrtn_s\":0.0,\"kb_dscd_s\":0.0,\"kb_read\":0,\"kb_wrtn\":0,\"kb_dscd\":0,\"type\":\"device\"} {\"percent_user\":1.01,\"percent_nice\":0.0,\"percent_system\":0.0,\"percent_iowait\":0.0,\"percent_steal\":0.0,\"percent_idle\":98.99,\"type\":\"cpu\"} {\"device\":\"dm-0\",\"tps\":0.0,\"kb_read_s\":0.0,\"kb_wrtn_s\":0.0,\"kb_dscd_s\":0.0,\"kb_read\":0,\"kb_wrtn\":0,\"kb_dscd\":0,\"type\":\"device\"} {\"device\":\"loop0\",\"tps\":0.0,\"kb_read_s\":0.0,\"kb_wrtn_s\":0.0,\"kb_dscd_s\":0.0,\"kb_read\":0,\"kb_wrtn\":0,\"kb_dscd\":0,\"type\":\"device\"} ...\n\n> Tip: If you include a JSON Lines output option, you might also want to\n> include an \u2018unbuffer\u2019 option.\n>\n> When directly printing to the terminal, the OS will disable buffering, but\n> when piping to other programs there will be a buffer typically around 4KB.\n> If the emitted JSON is small, it will look like the terminal is hung. This\n> is why jc offers the -u, or \u2018unbuffer\u2019 option like many other filtering\n> tools do.\n>\n> Note, that there may be a performance impact to disabling the buffer, so it\n> should only be disabled while troubleshooting the pipeline in the terminal.\n\n#### Use Predictable Key Names\n\nThis one basically comes down to \u201cdon\u2019t dynamically generate key names\u201d. If\nkey names aren\u2019t static and predictable, it makes it difficult to have a good\nSchema and also makes it difficult for users to find the data.\n\nInstead of doing something like this:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n{\n\n\"Interface 1\": [\n\n\"192.168.1.1\",\n\n\"172.16.1.1\"\n\n],\n\n\"Wifi Interface 1\": [\n\n\"10.1.1.1\"\n\n]\n\n}\n\n{ \"Interface 1\": [ \"192.168.1.1\", \"172.16.1.1\" ], \"Wifi Interface 1\": [\n\"10.1.1.1\" ] }\n\n    \n    \n    { \"Interface 1\": [ \"192.168.1.1\", \"172.16.1.1\" ], \"Wifi Interface 1\": [ \"10.1.1.1\" ] }\n\nDo this:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n[\n\n{\n\n\"interface\": \"Interface 1\",\n\n\"ip_addresses\": [\n\n\"192.168.1.1\",\n\n\"172.16.1.1\"\n\n]\n\n},\n\n{\n\n\"interface\": \"Wifi Interface 1\",\n\n\"ip_addresses\": [\n\n\"10.1.1.1\"\n\n]\n\n}\n\n]\n\n[ { \"interface\": \"Interface 1\", \"ip_addresses\": [ \"192.168.1.1\", \"172.16.1.1\"\n] }, { \"interface\": \"Wifi Interface 1\", \"ip_addresses\": [ \"10.1.1.1\" ] } ]\n\n    \n    \n    [ { \"interface\": \"Interface 1\", \"ip_addresses\": [ \"192.168.1.1\", \"172.16.1.1\" ] }, { \"interface\": \"Wifi Interface 1\", \"ip_addresses\": [ \"10.1.1.1\" ] } ]\n\nThis is a self-documented structure and the user can simply iterate over all\nof the objects to get the interface names and IP addresses they want. They can\nstill get it the other way, but it\u2019s not as straightforward and it also\ndoesn\u2019t allow you to have a nicely documented Schema.\n\n#### Pretty Print with Two Spaces or Don\u2019t Format at All\n\nHigher-level languages like Python allow very easy formatting of the JSON\noutput, so I typically see the issue of ugly formatted JSON with programs\nwritten in C:\n\nWhat is going on here? Actually \u2013 I can see what the developer was doing \u2013 it\ndoes look quite nice outside of the terminal when pasted into a text editor,\nbut while inside the terminal the line wrapping makes it very unreadable.\n\nI like the look of two-space indentation with JSON \u2013 maybe because that\u2019s the\nway jq formats it and I\u2019m just used to it.\n\nThere\u2019s really no need to format JSON output at all. If it makes your code\nsimpler, just generate the JSON with no newlines or spaces. This is more\ncompact and the user can just as easily pipe the output through jq or other\ntools to format it.\n\nIf you do choose to format the JSON, then take a cue from jq and use two\nspaces of indent and don\u2019t coalesce brackets. Like so:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ iostat -o JSON | jq\n\n{\n\n\"sysstat\": {\n\n\"hosts\": [\n\n{\n\n\"nodename\": \"ubuntu\",\n\n\"sysname\": \"Linux\",\n\n\"release\": \"5.8.0-53-generic\",\n\n\"machine\": \"x86_64\",\n\n\"number-of-cpus\": 2,\n\n\"date\": \"12/03/2021\",\n\n\"statistics\": [\n\n{\n\n\"avg-cpu\": {\n\n\"user\": 0.6,\n\n\"nice\": 0.01,\n\n\"system\": 1.68,\n\n\"iowait\": 0.14,\n\n\"steal\": 0,\n\n\"idle\": 97.58\n\n},\n\n\"disk\": [\n\n{\n\n\"disk_device\": \"dm-0\",\n\n\"tps\": 29.07,\n\n\"kB_read/s\": 502.25,\n\n\"kB_wrtn/s\": 54.94,\n\n\"kB_dscd/s\": 0,\n\n\"kB_read\": 251601,\n\n\"kB_wrtn\": 27524,\n\n\"kB_dscd\": 0\n\n},\n\n<SNIP>\n\n{\n\n\"disk_device\": \"sr0\",\n\n\"tps\": 0.19,\n\n\"kB_read/s\": 6.27,\n\n\"kB_wrtn/s\": 0,\n\n\"kB_dscd/s\": 0,\n\n\"kB_read\": 3139,\n\n\"kB_wrtn\": 0,\n\n\"kB_dscd\": 0\n\n}\n\n]\n\n}\n\n]\n\n}\n\n]\n\n}\n\n}\n\n$ iostat -o JSON | jq { \"sysstat\": { \"hosts\": [ { \"nodename\": \"ubuntu\", \"sysname\": \"Linux\", \"release\": \"5.8.0-53-generic\", \"machine\": \"x86_64\", \"number-of-cpus\": 2, \"date\": \"12/03/2021\", \"statistics\": [ { \"avg-cpu\": { \"user\": 0.6, \"nice\": 0.01, \"system\": 1.68, \"iowait\": 0.14, \"steal\": 0, \"idle\": 97.58 }, \"disk\": [ { \"disk_device\": \"dm-0\", \"tps\": 29.07, \"kB_read/s\": 502.25, \"kB_wrtn/s\": 54.94, \"kB_dscd/s\": 0, \"kB_read\": 251601, \"kB_wrtn\": 27524, \"kB_dscd\": 0 }, <SNIP> { \"disk_device\": \"sr0\", \"tps\": 0.19, \"kB_read/s\": 6.27, \"kB_wrtn/s\": 0, \"kB_dscd/s\": 0, \"kB_read\": 3139, \"kB_wrtn\": 0, \"kB_dscd\": 0 } ] } ] } ] } }\n    \n    \n    $ iostat -o JSON | jq { \"sysstat\": { \"hosts\": [ { \"nodename\": \"ubuntu\", \"sysname\": \"Linux\", \"release\": \"5.8.0-53-generic\", \"machine\": \"x86_64\", \"number-of-cpus\": 2, \"date\": \"12/03/2021\", \"statistics\": [ { \"avg-cpu\": { \"user\": 0.6, \"nice\": 0.01, \"system\": 1.68, \"iowait\": 0.14, \"steal\": 0, \"idle\": 97.58 }, \"disk\": [ { \"disk_device\": \"dm-0\", \"tps\": 29.07, \"kB_read/s\": 502.25, \"kB_wrtn/s\": 54.94, \"kB_dscd/s\": 0, \"kB_read\": 251601, \"kB_wrtn\": 27524, \"kB_dscd\": 0 }, <SNIP> { \"disk_device\": \"sr0\", \"tps\": 0.19, \"kB_read/s\": 6.27, \"kB_wrtn/s\": 0, \"kB_dscd/s\": 0, \"kB_read\": 3139, \"kB_wrtn\": 0, \"kB_dscd\": 0 } ] } ] } ] } }\n\nBeggars can\u2019t be choosers, so I\u2019ll take ugly JSON over no JSON any day. But\nagain, compact JSON with no spaces and newlines is perfectly fine. Anyone\nworking with JSON knows to use jq or other tools to make it easy to read in\nthe terminal.\n\n### Don\u2019t\n\nTry to avoid these JSON smells:\n\n#### Don\u2019t Use Special Characters in Key Names\n\nThere\u2019s nothing more annoying than having to encapsulate an attribute name in\nbrackets because it has special characters or spaces in it.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n$ echo '{\"Foo/ foo\": \"bar\"}' | jq '.Foo/ foo'\n\njq: error: foo/0 is not defined at <top-level>, line 1:\n\n.Foo/ foo\n\njq: 1 compile error\n\n$ echo '{\"Foo/ foo\": \"bar\"}' | jq '.[\"Foo/ foo\"]'\n\n\"bar\"\n\n$ echo '{\"Foo/ foo\": \"bar\"}' | jq '.Foo/ foo' jq: error: foo/0 is not defined at <top-level>, line 1: .Foo/ foo jq: 1 compile error $ echo '{\"Foo/ foo\": \"bar\"}' | jq '.[\"Foo/ foo\"]' \"bar\"\n    \n    \n    $ echo '{\"Foo/ foo\": \"bar\"}' | jq '.Foo/ foo' jq: error: foo/0 is not defined at <top-level>, line 1: .Foo/ foo jq: 1 compile error $ echo '{\"Foo/ foo\": \"bar\"}' | jq '.[\"Foo/ foo\"]' \"bar\"\n\nDon\u2019t make your users do that! This can also be a consequence of dynamically\ngenerating your keys, as discussed in a section above. Instead, keep all key\ncharacters lower-case and convert special characters to underscores (\u2018_\u2018) to\nkeep them alphanumeric.\n\nUnderscores are better than dashes because they allow you to select the entire\nkey with a double-click in most IDEs and text editors. Dashes will typically\nonly select a section of the key name.\n\n#### Don\u2019t Allow Duplicate Keys\n\nIf you are dynamically generating key names it may be possible for duplicates\nto appear in an object. If there is a possibility of this, wrap those items in\nindividual objects. Duplicate keys are undefined in JSON and may cause\ndifferent behavior depending on the client.\n\n#### Don\u2019t Use Extremely Large Numbers\n\nJSON has nice typing, but unfortunately the numeric data type is\nunderspecified in the standard and may have different behavior with different\nclients. This can happen if you output a long UUID as a number \u2013 the UUID may\nactually not turn out to be the same on all clients! If you have a very large\nnumber, it\u2019s probably best to just wrap it in a string so it doesn\u2019t get\nmangled downstream.\n\n#### Don\u2019t Use XML\n\nJust joking! Any standard structured output is better than plain text in many\ncases, and sometimes (but not often) XML is a better choice than JSON. I\nprefer JSON for its readability, support ecosystem, and for its support for\nmaps, arrays, and limited types. After developing JSON schemas for over 80 CLI\nparsers I\u2019ve found that there\u2019s not much JSON can\u2019t do for this type of\noutput.\n\n## In Conclusion\n\nAlways think of the end-user and how they will interact with the data. By\nfollowing these steps, you can keep the users from having to jump through\nextra hoops to get to the data they want:\n\n  * Make a Schema\n  * Flatten the Structure\n  * Output JSON Lines for Streaming Output\n  * Use Predictable Key Names\n  * Pretty Print with Two Spaces or Don\u2019t Format at All\n  * Don\u2019t Use Special Characters in Key Names\n  * Don\u2019t Allow Duplicate Keys\n  * Don\u2019t Use Very Large Numbers\n\nThis is clearly not an exhaustive list. Did I miss any of your pet peeves? Let\nme know in the comments!\n\n### Like this:\n\nLike Loading...\n\nPosted bykellyjonbrazilDecember 3, 2021December 3, 2021Posted inAll Posts,\nProgrammingTags:best practices, cli, command-line, json, json-lines\n\n## Published by kellyjonbrazil\n\nI'm a cybersecurity and cloud computing nerd. View more posts\n\n## 4 thoughts on \u201cTips on Adding JSON Output to Your CLI App\u201d\n\n  1. j0n3s says:\n\nDecember 6, 2021 at 6:14 am\n\n\u201cFlatten the Structure\u201d makes other things harder, though.\n\nIf I want to output the cpu info as JSON, in the flattend structure I\u2019d have\nto filter the array instead of just extracting the cpu sub-object. Using an\narray and setting the \u2018type\u2019 parameter makes the schema definition more\ncomplex/confusing, as valid keys depend on the value of another key in the\nsame object. I also believe that grouping values that belong together in a\nsub-object in JSON transports more information to the user. Like\nsections/chapters in a document.\n\nSo nested structures can help, and should be used when they are actually\nhelpful. Any other time, yeah, flat structures seem to be more\nreadable/accessible.\n\nAnd yeah for large/streaming outputs JSONL would be the right choice, so no\nflattening needed.\n\nLoading...\n\nReply\n\n    1. kellyjonbrazil says:\n\nDecember 6, 2021 at 10:40 am\n\nIn principle, I agree with you. As you can see from the schemas of dozens of\nparsers I\u2019ve written for jc, there are plenty of examples of non-flat\nstructures.\n\nIn the case of output that lends itself to streaming, I think there is an\nadvantage using the type field. In these cases you are basically emitting\nrecords in real-time, so instead of duplicating the entire structure with a\nbunch of null values for branches that are not used for that object (that have\narrays of objects beneath them) this approach makes it very simple to filter\non the object type when selecting the data you want.\n\nIn this way, the JSON Lines is a bit analogous to syslog. You can emit several\ntypes of records, but the consumer may only care about certain ones and the\ntype field enables them to easily filter. Of course, there may still be some\nminor structure (maybe an array of some attribute or whatever) within each\nobject. This type of JSON Lines could be easily ingested by the likes of ELK\nor Splunk, etc.\n\nLoading...\n\nReply\n\n  2. j0n3s says:\n\nJanuary 11, 2022 at 8:27 am\n\nI understand the problem with the nested structure in the streaming case. It\njust always feels unsatisfying to me if an attribute within a JSON determines\nthe structure of that JSON.\n\nWhat about a structure like this?\n\n{\"cpu\":{\"user\":1.11,\"nice\":0.78,\"system\":1.12,\"iowait\":0.05,\"steal\":0.0,\"idle\":96.94}}\n{\"device\":{\"device\":\"dm-0\",\"tps\":27.4,\"kb_read_s\":125.07,\"kb_wrtn_s\":430.11,\"kb_dscd_s\":0.0,\"kb_read\":654987,\"kb_wrtn\":2252376,\"kb_dscd\":0}}\n\nDepending on the case, that could have the advantage that one line could\ncontain multiple types of data (to e.g. make clear that those records were\ngenerated/read at the same time or something like that). The schema for each\npart of the JSON would always be clear, and testing would even be somewhat\nshorter (instead of comparing type to \u2018cpu\u2019 or \u2018device\u2019, just check if the\naccording key exists/its value is set).\n\nPersonally, I\u2019d probably even rewrite the \u2018device\u2019 info to:\n\n{\"device\":{\"name\":\"dm-0\",\"tps\":27.4,\"kb\":{\"read_s\":125.07,\"wrtn_s\":430.11,\"dscd_s\":0.0,\"read\":654987,\"wrtn\":2252376,\"dscd\":0}}}\n\nLoading...\n\nReply\n\n    1. kellyjonbrazil says:\n\nJanuary 11, 2022 at 9:10 am\n\nThat does seem logical as well since it doesn\u2019t break streaming output.\n\nLoading...\n\nReply\n\n### Leave a ReplyCancel reply\n\n  * RSS - Posts\n  * RSS - Comments\n\nBrazil's Blog, Privacy Policy\n\n## Discover more from Brazil's Blog\n\nSubscribe now to keep reading and get access to the full archive.\n\nContinue reading\n\nLoading Comments...\n\n%d\n\n", "frontpage": true}
