{"aid": "39960833", "title": "Portrait of a N00B (2008)", "url": "http://steve-yegge.blogspot.com/2008/02/portrait-of-n00b.html", "domain": "steve-yegge.blogspot.com", "votes": 1, "user": "tie-in", "posted_at": "2024-04-07 14:01:56", "comments": 0, "source_title": "Stevey's Blog Rants: Portrait of a N00b", "source_text": "Stevey's Blog Rants: Portrait of a N00b\n\n# Stevey's Blog Rants\n\nRandom whining and stuff.\n\n## Sunday, February 10, 2008\n\n### Portrait of a N00b\n\nThe older I grow, the less important the comma becomes. Let the reader catch\nhis own breath. \u2014 Elizabeth Clarkson Zwart  \n---  \n  \nThis is how I used to comment my code, twenty years ago (Note: dramatization):\n\n    \n    \n    /** * By the time we get to this point in the function, * our structure is set up properly and we've created * a buffer large enough to handle the input plus some * overflow space. I'm not sure if the overflow space * is strictly necessary, but it can't hurt. Next we * have to update the counter to account for the fact * that the caller has read a value without consuming * it. I considered putting the counter-increment on * the shoulders of the caller, but since it meant every * caller had to do it, I figured it made more sense to * just move it here. We can revisit the decision down * the road if we find some callers that need the option * of incrementing it themselves. */ counter++; // increment the consumed-value counter\n    \n    /** * Now we've got to start traversing the buffer, but we * need an extra index to do it; otherwise we'll wind up * at the end of the function without having any idea * what the initial value was. I considered calling this * variable 'ref', since in some sense we're going to be * treating it as a reference, but eventually I decided * it makes more sense to use 'pos'; I'm definitely open * to discussion on it, though. */ char* pos = buffer; // start our traversal\n    \n    /** * NEXT, we... */\n\nDoes this style look at all familiar? It should! This is, to put it as\nimpolitely as possible, n00b-style. (Incidentally, if u dont no wat a n00b iz,\nu r 1.)\n\nThis is how junior programmers write code. If you've read Malcom Gladwell's\nremarkable and eye-opening book The Tipping Point, you'll notice a striking\nsimilarity to the real-life 2-year-old Emily he describes in Chapter Three,\nwho tells herself stories after her parents leave her room. Here's a short\nexcerpt from one of her stories:\n\n> Tomorrow when we wake up from bed, first me and Daddy and Mommy, you, eat\n> breakfast eat breakfast like we usually do, and then we're going to play and\n> then soon as Daddy comes, Carl's going to come over, and then we're going to\n> play a little while. And then Carl and Emily are both going down to the car\n> with somebody, and we're going to ride to nursery school [whispered], and\n> then when we get there, we're all going to get out of the car...\n\nGladwell's account of Emily is fascinating, as she's allegedly a completely\nnormal 2-year-old; they all do this when Mommy and Daddy aren't around.\n\nGladwell explains:\n\n> Sometimes these stories were what linguists call temporal narratives. She\n> would create a story to try to integrate events, actions, and feelings into\n> one structure \u2014 a process that is a critical part of a child's mental\n> development.\n\nIf you look back at the comments in my hypothetical code from 20 years ago,\nyou'll see that I was doing exactly what Emily does: making up a temporal\nnarrative in an attempt to carve out a mental picture of the computation for\nmyself. These stories I told myself were a critical part of my mental\ndevelopment as a programmer. I was a child trying to make sense of a big,\nscary new world.\n\nMost programmers go through this phase. It's perfectly normal.\n\nIn contrast, here's what my code tends to look like today:\n\nUpdate, Nov 14 2011: I did a terrible job of making my point with this code. I\ndeliberately chose some of the most freakish code I've ever written, because I\nwanted it to look ugly and scary. I'm trying to show here what \"typical\"\nveteran code looks like to a junior programmer. This code serves as a\n*caricature* for illustration purposes. You're supposed to be put off by it.\nIf I had been trying to show you what modern art looks like to the\nuninitiated, I would have showed you a graffitied subway station wall that\nsomeone had just vomited on. This is the coding equivalent.\n\nIf you *insist* on missing my point entirely and arguing about whether this\nfunction is \"good code\" or not, then I assure you: this code is horrific. It's\na Lisp port of a Java port of some old C code. *Both* ports intentionally stay\nas faithful to the original as possible, line-by-line in the most un-idiomatic\ncode imaginable. Why? To make it easy to propagate bug fixes in the original\nto both ports. So it's ugly for a legitimate reason. But it's still frigging\nugly.\n\n    \n    \n    (defun js2-parse-variables (in-for decl-type) \"Parse a 'var', 'const' or 'let' statement or for-loop initializer. IN-FOR is true if we are currently in the midst of the init clause of a for. DECL-TYPE is a token value: either VAR, CONST, or LET depending on context. Returns the parsed statement node.\" (let ((result (make-js2-var-decl-node)) destructuring-init destructuring s start tt init name node (continue t)) ;; Examples: ;; var foo = {a: 1, b: 2}, bar = [3, 4]; ;; var {b: s2, a: s1} = foo, x = 6, y, [s3, s4] = bar; (while continue (setq destructuring nil s nil tt (js2-peek-token) start js2-token-start init nil) (if (or (= tt js2-LB) (= tt js2-LC)) ;; Destructuring assignment, e.g., var [a, b] = ... (setq destructuring (js2-parse-primary-expr)) ;; Simple variable name (js2-must-match js2-NAME \"msg.bad.var\") (setq name (make-js2-name-node)) (js2-define-symbol decl-type js2-ts-string)) (when (js2-match-token js2-ASSIGN) (setq init (js2-parse-assign-expr in-for))) (if destructuring (progn (if (null init) ;; for (var [k, v] in foo) is initialized differently (unless in-for (js2-report-error \"msg.destruct.assign.no.init\"))) (setq node (make-js2-destructuring-init-node :start start :end js2-ts-cursor :lhs destructuring :initializer init)) (js2-node-add-children node destructuring init)) ;; simple variable, possibly with initializer (setq node (make-js2-var-init-node :start start :end js2-ts-cursor :name name :initializer init)) (js2-node-add-children node name init)) (js2-block-node-push result node) (js2-node-add-children result node) (unless (js2-match-token js2-COMMA) (setq continue nil))) result))\n\nIf I'd seen this code 20 years ago I'd have been appalled. The lines of code\nare all crammed together! Some of them aren't even commented! If I'd been\ngiven the task of maintaining this code, I'd have been screaming \"rewrite!\"\n\nI probably write more Java and JavaScript these days, but I picked an Emacs-\nLisp function I wrote recently to highlight how alien my code today would have\nlooked to me twenty years ago.\n\nTo be fair, this function is actually a port of some Java code from Mozilla\nRhino's JavaScript parser, which in turn is a port of some C code from\nSpiderMonkey's parser, which in turn was probably borrowed and modified from\nsome other compiler. Compiler code tends to have some of the purest lineage\naround, tracing back to the assembly-language code they wrote for the first\ncompilers 40 or 50 years ago. Which means it's going to be a bit on the ugly\nside compared to \"ordinary\" code.\n\nBut when I write code in other languages these days, even in Java, it looks a\nlot more like this Emacs Lisp fragment than like the n00b code I was writing\n20 years ago. It's denser: there's less whitespace and far less commenting.\nMost of the commenting is in the form of doc-comments for automated API-doc\nextraction. On the whole, my code today is much more compressed.\n\nIn the old days, seeing too much code at once quite frankly exceeded my\ncomplexity threshold, and when I had to work with it I'd typically try to\nrewrite it or at least comment it heavily. Today, however, I just slog through\nit without complaining (much). When I have a specific goal in mind and a\ncomplicated piece of code to write, I spend my time making it happen rather\nthan telling myself stories about it.\n\nA decade of experience makes you a teenager\n\nAfter going through their 2-year-old phase, programmers eventually have to go\nthrough a stupid-teenager phase. All this month I've been hearing sad but\nunsurprising news stories about teenagers getting stuck on big rocks, being\nkilled falling off cliffs, or dying of exposure. I'm actually lucky the same\ndidn't happen to me when I was a teenager. It's just a bad time for us. Even\nthough teenagers are old enough to understand the warnings, they have this\nfeeling of invincibility that gets them into trouble and often mortal peril.\n\nThe programming equivalent happens around us all the time too. Junior\nprogrammers with five to ten years of experience under their belts (still\nn00bs in their own way) attempt to build giant systems and eventually find\nthemselves stuck on the cliff waiting for a helicopter bailout, telling\nthemselves \"my next system rewrite will be better!\" Or they fall off the cliff\n\u2013 i.e., the project gets canceled, people get laid off, maybe the company goes\nunder.\n\nYes, I've gone through that phase too. And let's face it: even seasoned\nprogrammers need a little optimism and a little bravery in order tackle real\nchallenges. Even as an experienced programmer, you should expect to fail at\nprojects occasionally or you're probably not trying hard enough. Once again,\nthis is all perfectly normal.\n\nThat being said, as a hiring manager or company owner you should keep in mind\nthat \"5 to 10 years of experience\" on a resume does not translate to\n\"experienced\"; it means \"crazy invincible-feeling teenager with a 50/50 shot\nat writing a pile of crap that he or she and his or her team can't handle, and\nthey'll eventually, possibly repeatedly, try to rewrite it all.\" It's just how\nthings are: programmers can't escape being teenagers at some point.\n\nBuilding compression tolerance\n\nHopefully the scene I've painted so far helps you understand why sometimes you\nlook at code and you just hate it immediately. If you're a n00b, you'll look\nat experienced code and say it's impenetrable, undisciplined crap written by\nsomeone who never learned the essentials of modern software engineering. If\nyou're a veteran, you'll look at n00b code and say it's over-commented,\nornamental fluff that an intern could have written in a single night of heavy\ndrinking.\n\nThe sticking point is compression-tolerance. As you write code through your\ncareer, especially if it's code spanning very different languages and problem\ndomains, your tolerance for code compression increases. It's no different from\nthe progression from reading children's books with giant text to increasingly\ncomplex novels with smaller text and bigger words. (This progression\neventually leads to Finnegan's Wake, if you're curious.)\n\nThe question is, what do you do when the two groups (vets and n00bs) need to\nshare code?\n\nI've heard (and even made) the argument that you should write for the lowest\ncommon denominator of programmers. If you write code that newer programmers\ncan't understand, then you're hurting everyone's productivity and chances for\nsuccess, or so the argument goes.\n\nHowever, I can now finally also see things from the veteran point of view. A\nprogrammer with a high tolerance for compression is actually hindered by a\nscreenful of storytelling. Why? Because in order to understand a code base you\nneed to be able to pack as much of it as possible into your head. If it's a\ncomplicated algorithm, a veteran programmer wants to see the whole thing on\nthe screen, which means reducing the number of blank lines and inline comments\n\u2013 especially comments that simply reiterate what the code is doing. This is\nexactly the opposite of what a n00b programmer wants. n00bs want to focus on\none statement or expression at a time, moving all the code around it out of\nview so they can concentrate, fer cryin' out loud.\n\nSo it's a problem.\n\nShould a team write for the least common denominator? And if so, exactly how\ncompressed should they make the code? I think the question may be\nunanswerable. It's like asking for a single format for all books, from\nchildren's books to epic novels. Each team is going to have its own average\npreference. I suspect it's a good idea to encourage people to move their\nstories into design documents and leave them out of the code, since a junior\nprogrammer forced to work in a compressed code base may well grow up faster.\n\nAs for me, at this point in my career I would rather puzzle through a small,\ndense, complex piece of code than a massive system with thousands of files\ncontaining mostly comments and whitespace. To some people this trait\nundoubtedly flags me as a cranky old dinosaur. Since this is likely the\nmajority of programmers out there, maybe I am a cranky old dinosaur. Rawr.\n\nMetadata Madness\n\nEveryone knows that comments are metadata: information about the data (in this\ncase, the data being your source code.) But people often forget that comments\naren't just a kind of metadata. Comments and metadata are the same thing!\n\nMetadata is any kind of description or model of something else. The comments\nin your code are just a a natural-language description of the computation.\nWhat makes metadata meta-data is that it's not strictly necessary. If I have a\ndog with some pedigree paperwork, and I lose the paperwork, I still have a\nperfectly valid dog.\n\nYou already know the comments you write have no bearing on the runtime\noperation of your code. The compiler just throws them away. And we've\nestablished that one hallmark of a n00b programmer is commenting to excess: in\na sense, modeling every single step of the computation in painstaking detail,\njust like Emily modeled her ideal Friday by walking through every step and\nreassuring her 2-year-old self that she really did understand how it was going\nto work.\n\nWell, we also know that static types are just metadata. They're a specialized\nkind of comment targeted at two kinds of readers: programmers and compilers.\nStatic types tell a story about the computation, presumably to help both\nreader groups understand the intent of the program. But the static types can\nbe thrown away at runtime, because in the end they're just stylized comments.\nThey're like pedigree paperwork: it might make a certain insecure personality\ntype happier about their dog, but the dog certainly doesn't care.\n\nIf static types are comments, then I think we can conclude that people who\nrely too much on static types, people who really love the static modeling\nprocess, are n00bs.\n\nHee hee.\n\nSeriously, though: I'm not actually bashing on static-typing here; I'm bashing\non the over-application of it. Junior programmers overuse static typing in the\nexact same way, and for the same reasons, as they overuse comments.\n\nI'll elaborate by first drawing a parallel to data modeling, which is another\nkind of \"static typing\". If you've been working in a field that uses\nrelational databases heavily, you'll probably have noticed that there's a\ncertain personality type that's drawn to relational data modeling as a career\nunto itself. They're usually the logical modelers, not the physical modelers.\nThey may have begun their careers as programmers, but they find they really\nlove data modeling; it's like a calling for them.\n\nIf you know the kind of person I'm talking about, you'll doubtless also have\nnoticed they're always getting in your way. They band together and form\nDatabase Cabals and Schema Councils and other obstructive bureacracies in the\nname of safety. And they spend a lot of time fighting with the engineers\ntrying to get stuff done, especially at the fringes: teams that are not\nworking directly with the schema associated with the main revenue stream for\nthe company, but are out trying to solve tangential problems and just happen,\nby misfortune, to be homed in the same databases.\n\nI've been in surprisingly many situations at different companies where I had a\nfringe team that was being held up by data modelers who were overly-concerned\nabout data integrity when the real business need was flexibility, which is\nsort of the opposite of strong data modeling. When you need flexible storage,\nname/value pairs can get you a long, long, LONG way. (I have a whole blog\nplanned on this topic, in fact. It's one of my favorite vapor-blogs at the\nmoment.)\n\nIt's obviously important to do some amount of data modeling. What's not so\nobvious is when to stop. It's like commenting your code: newer programmers\njust don't know when to quit. When you're a little insecure, adding comments\nand metadata are a great security-blanket that make you feel busy when you've\nin fact stopped making forward progress and are just reiterating (or perhaps\nteaching yourself) what's already been accomplished.\n\nHardcore logical data modelers often suffer from an affliction called metadata\naddiction. Metadata modeling is seductive. It lets you take things at a\nleisurely pace. You don't have to be faced with too much complexity at once,\nbecause everything has to go in a new box before you'll look at it. To be\nsure, having some metadata (be it a data model, or static types, or comments)\nis important for human communication and to some extent for performance\ntuning. But a surprising percentage of people in our industry take it too far,\nand make describing an activity more important than the activity itself.\n\nThe metadata-addiction phenomenon applies equally to coders. Code is data, and\ndata is code. The two are inextricably linked. The data in your genes is code.\nThe floor plans for your house are code. The two concepts are actually\nindistinguishable, linked at a fundamental level by the idea of an\nInterpreter, which sits at the very heart of Computer Science. Metadata, on\nthe other hand, is more like the kidney of Computer Science. In practice you\ncan lose half of it and hardly notice.\n\nCreeping bureacracy\n\nI think that by far the biggest reason that C++ and Java are the predominant\nindustry languages today, as opposed to dynamic languages like\nPerl/Python/Ruby or academic languages like Modula-3/SML/Haskell, is that C++\nand Java cater to both secure and insecure programmers.\n\nYou can write C++ like straight C code if you like, using buffers and pointers\nand nary a user-defined type to be found. Or you can spend weeks agonizing\nover template metaprogramming with your peers, trying to force the type system\nto do something it's just not powerful enough to express. Guess which group\ngets more actual work done? My bet would be the C coders. C++ helps them iron\nthings out in sticky situations (e.g. data structures) where you need a little\nmore structure around the public API, but for the most part they're just\nmoving data around and running algorithms, rather than trying to coerce their\nerror-handling system to catch programmatic errors. It's fun to try to make a\nbulletproof model, but their peers are making them look bad by actually\ndeploying systems. In practice, trying to make an error-proof system is way\nmore work than it's worth.\n\nSimilarly, you can write Java code more or less like straight C, and a lot of\nseasoned programmers do. It's a little nicer than C because it has object-\norientation built in, but that's fairly orthogonal to the static type system.\nYou don't need static types for OOP: in fact OOP was born and proven in\ndynamic languages like Smalltalk and Lisp long before it was picked up by the\nstatic-type camps. The important elements of OOP are syntax (and even that's\noptional) and an object model implemented in the runtime.\n\nSo you can write Java code that's object-oriented but C-like using arrays,\nvectors, linked lists, hashtables, and a minimal sprinkling of classes. Or you\ncan spend years creating mountains of class hierarchies and volumes of UML in\na heroic effort to tell people stories about all the great code you're going\nto write someday.\n\nPerl, Python and Ruby fail to attract many Java and C++ programmers because,\nwell, they force you to get stuff done. It's not very easy to drag your heels\nand dicker with class modeling in dynamic languages, although I suppose some\npeople still manage. By and large these languages (like C) force you to face\nthe computation head-on. That makes them really unpopular with metadata-\naddicted n00bs. It's funny, but I used to get really pissed off at Larry Wall\nfor calling Java programmers \"babies\". It turns out the situation is a little\nmore complicated than that... but only a little.\n\nAnd Haskell, OCaml and their ilk are part of a 45-year-old static-typing\nmovement within academia to try to force people to model everything.\nProgrammers hate that. These languages will never, ever enjoy any substantial\ncommercial success, for the exact same reason the Semantic Web is a failure.\nYou can't force people to provide metadata for everything they do. They'll\nhate you.\n\nOne very real technical problem with the forced-modeling approaches that\nstatic type systems are often \"wrong\". It may be hard to imagine, because by a\ncertain definition they can't be \"wrong\": the code (or data) is\nprogrammatically checked to conform to whatever constraints are imposed by the\ntype system. So the code or data always matches the type model. But the type\nsystem is \"wrong\" whenever it cannot match the intended computational model.\nEvery time want to use multiple inheritance or mixins in Java's type system,\nJava is \"wrong\", because it can't do what you want. You have to take the most\nnatural design and corrupt it to fit Java's view of the world.\n\nAn important theoretical idea behind type systems is \"soundness\". Researchers\nlove to go on about whether a type system is \"sound\" or not, and \"unsound\"\ntype systems are considered bad. C++ and Java have \"unsound\" type systems.\nWhat researchers fail to realize is that until they can come up with a type\nsystem that is never \"wrong\" in the sense I described earlier, they will\ncontinue to frustrate their users, and their languages will be abandoned for\nmore flexible ones. (And, Scala folks, it can't just be possible to express\nthings like property lists \u2013 it has to be trivial.)\n\nTo date, the more \"sound\" a type system is, the more often it's wrong when you\ntry to use it. This is half the reason that C++ and Java are so successful:\nthey let you stop using the type system whenever it gets in your way.\n\nThe other half of their success stems from the ability to create user-defined\nstatic types. Not, mind you, because they're helpful in creating solidly-\nengineered systems. They are, sure. But the reason C++ and Java (particularly\nJava) have been so successful is that their type systems form a \"let's not get\nany work done\" playground for n00bs to spend time modeling things and telling\nthemselves stories.\n\nJava has been overrun by metadata-addicted n00bs. You can't go to a bookstore\nor visit a forum or (at some companies) even go to the bathroom without\nhearing from them. You can't actually model everything; it's formally\nimpossible and pragmatically a dead-end. But they try. And they tell their\npeers (just like our metadata-addicted logical data modelers) that you have to\nmodel everything or you're a Bad Citizen.\n\nThis gets them stuck on cliffs again and again, and because they're teenagers\nthey don't understand what they did wrong. Static type models have weight and\ninertia. They take time to create, time to maintain, time to change, and time\nto work around when they're wrong. They're just comments, nothing more. All\nmetadata is equivalent in the sense of being tangential documentation. And\nstatic type models get directly in the way of flexibility, rapid development,\nand system-extensibility.\n\nI've deleted several thousand words about the evolution of Apache Struts and\nWebWork, an example framework I chose to illustrate my point. Rather than\nwaste a bunch of time with it, I'll just give you a quote from one of the\nStruts developers in \"The Evolution of Struts 2\":\n\n> ...the Struts 1 code base didn\u2019t lend itself to drastic improvements, and\n> its feature set was rather limited, particularly lacking in features such as\n> Ajax, rapid development, and extensibility.\"\n\nStruts 2 was thrown away for WebWork, which was in the process of throwing\naway version 1 (for similar reasons) in favor of version 2 (which has all the\nsame problems).\n\nSome of those several thousand words were devoted to JUnit 4, which has\ncomically (almost tragically) locked on, n00b-style, to the idea that Java 5\nannotations, being another form of metadata, are the answer to mankind's\ncenturies of struggle. They've moved all their code out of the method bodies\nand into the annotations sections. It's truly the most absurd overuse of\nmetadata I've ever seen. But there isn't space to cover it here; I encourage\nyou to go goggle at it.\n\nThere are die-hard Java folks out there who are practically gasping to inject\nthe opinion, right here, that \"rapid development\" is a byproduct of static\ntyping, via IDEs that can traverse the model.\n\nWhy, then, was Struts considered by its own developers to be a failure of\nrapid development? The answer, my dear die-hard Java fans, is that a\nsufficiently large model can outweigh its own benefits. Even an IDE can't make\nthings go faster when you have ten thousand classes in your system.\nDevelopment slows because you're being buried in metadata! Sure, the IDE can\nhelp you navigate around it, but once you've created an ocean, even the best\nboats in the world take a long time to move around it.\n\nThere are hundreds of open-source and proprietary Java frameworks out there\nthat were designed by code-teenagers and are in perpetual trouble. I've often\ncomplained that the problem is Java, and while I think the Java language\n(which I've come to realize is disturbingly Pascal-like) is partly to blame, I\nthink the bigger problem is cultural: it's hard to restrain metadata addiction\nonce it begins creeping into a project, a team, or an organization.\n\nJava programmers, and logical data modelers, and other metadata-addicted\ndevelopers, are burying us with their \"comments\" in the form of models within\ntheir static type system. Just like I did when I was a n00b. But they're doing\nit with the best of intentions, and they're young and eager and energetic, and\nthey stand on street corners and hand you leaflets about how great it is to\nmodel everything.\n\nSeasoned programmers ignore them and just get it done.\n\nSolutions and takeaways\n\nSoftware engineering is hard to get right. One person's pretty data model\nlooks like metadata-addiction to another person.\n\nI think we can learn some lessons from code-commenting: don't try to model\neverything! You need to step back and let the code speak for itself.\n\nFor instance, as just one random illustrative example, you might need to\nreturn 2 values from a function in Java (a language with no direct support for\nmultiple return values). Should you model it as a MyFunctionCallResult class\nwith named ValueOne and ValueTwo fields (presumably with actual names\nappropriate to the problem at hand)? Or should you just return a 2-element\narray (possibly of mixed types) and have the caller unpack it?\n\nI think the general answer to this is: when in doubt, don't model it. Just get\nthe code written, make forward progress. Don't let yourself get bogged down\nwith the details of modeling a helper class that you're creating for\ndocumentation purposes.\n\nIf it's a public-facing API, take a lesson from doc-comments (which should be\npresent even in seasoned code), and do model it. Just don't go overboard with\nit. Your users don't want to see page after page of diagrams just to make a\ncall to your service.\n\nLastly, if you're revisiting your code down the road and you find a spot\nthat's always confusing you, or isn't performing well, consider adding some\nextra static types to clarify it (for you and for your compiler). Just keep in\nmind that it's a trade-off: you're introducing clarifying metadata at the cost\nof maintenance, upkeep, flexibility, testability and extensibility. Don't go\ntoo wild with it.\n\nThat way the cliff you build will stay small enough for you to climb down\nwithout a helicopter rescue.\n\nPostscript\n\nI'm leaving comments on, at least until \"click-my-link\" spam starts to\nsurface. I'm curious to know how this entry goes over. This was an especially\ndifficult entry to write. I did a lot of editing on it, and left out a lot as\na result. I feel like I may not have made my points as clearly as I'd like.\nAnd I'm sure I haven't convinced the metadata-addicted that they have a\nproblem, although at least now they know someone out there thinks they have a\nproblem, which is a start.\n\nLet me know what you think!\n\nposted by Steve Yegge at 8:21 PM\n\n#### 116 Comments:\n\nUnknown said...\n\n    \n\nWell, the typing issue is a thorny one. I think as a general rule, the reddit\ntypes are too eager to denounce it immediately and tell us all that Ruby is\nthe answer, or whatever it is this week, and the Java purists and academics\nmake the opposite argument.\n\nComing from someone from a dynamic background, I didn't use a language with\nany strong typing until I had been programming for 2 years. I'm not a heavy\ncommenter of code (I'm not into redundancy), but I love static typing....until\nI don't.\n\nA few years of not catching an error until a specific code-path is executed\n(and let's be honest, I don't test as much as I should) gets really old. I\nlove it when the compiler says \"you're a moron\" before I even have to think\nabout writing a test.\n\nI think expecting tests for every situation just isn't realistic. I enjoy this\nabout C as well, in as much as the compiler can do this, so maybe it's a\ncompiler thing more than a static thing.\n\nI'm pulling a Yegge. Point is, use both. Use the dynamic side enough to find\nthe static side ridiculous, and use the static side enough to find the dynamic\nside occasionally too eager to not be helpful.\n\nI think this is the point where you'll program with an appropriate level of\nsafety. There are things you can do in a dynamic language to give you that\nsafety, and there are things you can do in a static language to not be stupid\nabout. Keeping perspective on these moments is what professional, accumulated\nknowledge gives you.\n\n    9:42 PM, February 10, 2008\nUnknown said...\n\n    \n\nGood post. I've had some doozy arguments about excessive commenting and\nclass/interface defining myself. You covered some aspects of the issue I\nhadn't thought of.\n\nThere's a parallel with processes: managers develop corporate processes to try\nto allow not-so-smart/experienced people to accomplish the same tasks that the\ntalented people can do. It rarely if ever works because doing so takes away\nthe understanding and flexibility that made the initial accomplishment so\nworthwhile.\n\nIn both cases there's the mistaken belief that the important thing is to allow\nrepetition, reuse, as if we were still on a Henry Ford assembly line instead\nof the modern world where doing things well, and quickly, is usually 10x as\nvaluable as doing them a 2nd time.\n\n    10:06 PM, February 10, 2008\nLightning Dave Bolton said...\n\n    \n\nI'm not really smart enough to debate with the bigwigs, but I can\ncategorically agree with the idea that over modelling costs a lot for\nsometimes negligible gain.\n\nSince shifting focus from enterprise systems in Java to much more rapid\nprojects in Ruby over the last 18 months I'm noticing daily just how much more\nwe get done, even though our team sizes are way smaller.\n\nAnd also, lets not forget that it's very possible to over model in a dynamic\nlanguage as well.\n\nI do worry though that the tradeoff is yet to be felt - there are a lot of\npeople \"just doing it\", but is maintenance of their rapidly developed\nRuby/Python program going to come back and bite them some time down the line?\n\n    10:10 PM, February 10, 2008\nBrian Slesinsky said...\n\n    \n\nUgh. There are some good points in there, but that code is not nearly as good\nas you think it is. Of course you don't have to write paragraph-long comments,\nbut have you ever heard of \"extract method\"?\n\nSince it seems that forced code review hasn't cured you of writing only for\nyourself, I think the only hope of getting beyond the adolescent phase is\neither pair-programming or teaching.\n\n    10:12 PM, February 10, 2008\nMax Kanat-Alexander said...\n\n    \n\nI've thought about some of this a lot, particularly the experienced programmer\nvs. the novice programmer bit. I work on an open-source project, where I'm an\nexperienced and trained programmer but the majority of contributions come from\npeople who are not.\n\nMy experience is that it's up to trained programmers to devise the \"way it's\ngoing to be\" and review and correct the novice programmers on that way. The\nnovice programmers eventually pick it up and understand it, even if in a\nlimited sense, and start to write their code that way.\n\nMy experience says that it's entirely possible to train people to be better\nprogrammers without years and years of experience, and so it's never necessary\nto reduce yourself to writing for the lowest common denominator. Of course, if\nyou're approaching the bound of complexity where even an experienced\nprogrammer would have difficulty reading the code, then that's a completely\ndifferent issue to consider.\n\n-Max\n\n    10:21 PM, February 10, 2008\nMark Roddy said...\n\n    \n\nHi, my name is Mark, and I'm a meta-data addict.\n\nHi Mark\n\nIt all started at my first job supporting a database driven app written by a\ncobol programmer.\n\nI spent more time putting out fires then I did adding new features. The\ndatabase model wasn't locked down. Once I changed the database so that the\ndata model was more explicitly defined through foreign keys and the like the\nbugs in the application code that caused inconsistancies were easier to find.\nI was able to work on features on a regular basis and deal with bugs as the\noccurred rather then when they were discovered.\n\nFast forward 3 years and I'm working in a Python shop. All my functions start\nwith: assert isinstance(x, y) Some of my co-workers complain that things fail\nwhen they pass an int instead of a float. It's easy to ignore their complaints\nas they also state that unit testing isn't important.\n\nI have a problem.\n\n    10:28 PM, February 10, 2008\nnanreh said...\n\n    \n\ni recognize myself in your description of the software teenager, i definitely\nwent through that phase.\n\ni've grown since then and the biggest change i can point to is my move away\nfrom statically-typed programming languages. it feels like my arteries have\nbeen unclogged.\n\nyour statement about tackling technical challenges head-on is exactly the\nfeeling i get when i code these days. i spend most my time solving the problem\ni need to solve instead of building up scaffolding to solve it.\n\nif i read your post a few years ago i would have left an emotional comment\nlisting reasons i thought you were so wrong. being a teenager is tough. i\nwonder what i'll think of my current self ten years from now.\n\n    10:37 PM, February 10, 2008\nSamuel A. Falvo II said...\n\n    \n\n\"To date, the more \"sound\" a type system is, the more often it's wrong when\nyou try to use it.\"\n\nBoy are you ever wrong on this one. Both Oberon and Haskell have type systems\nwhich are very sound, and in my experience, I can count the number of times\nit's been \"wrong\" on one hand. ONE hand. Out of all the programming projects\nI've done with them.\n\nIn point of fact, Oberon's type system nearly is identical to C's in terms of\nexpressivity, but is much stricter than C's to ensure proper coupling of\nmutually untrusted modules. Having many years experience with both C and\nOberon, I find that C offers *ZERO* productivity benefit over Oberon, but\ninstead a 100% more error-prone environment.\n\nThis is why every solid C coder will tell you, \"Use -Wall.\" That forces the\ncompiler (GCC in this case; Visual C/C++ has similar features) to treat all\nwarnings as errors. They'll also tell you to minimize the use of type-casting.\nThese suggestions come from C coders with >20 years experience. These rules of\nthumb in C are mandated in Oberon.\n\nNo, what makes C/C++ more popular than other languages is their relative\nbrevity -- as Paul Graham points out, brevity is what makes a language\n\"popular.\" This is why Oberon, for all its bad-a$$ness, failed to capture the\nmarket. Being a Modula-2-derived language, it was \"too wordy.\"\n\nType systems really, truely, honestly have nothing to do with it.\n\n    10:44 PM, February 10, 2008\nSamuel A. Falvo II said...\n\n    \n\nOops, I should point out that excessive brevity is also a killer, too. Were it\nnot, APL, and perhaps its successor J, would have conquered the world.\nClearly, this also has not happened.\n\n    10:48 PM, February 10, 2008\nTracy Reed said...\n\n    \n\nIsn't it true in general that the average programmer doesn't comment enough?\nIt seems rare to me that I see such a ridiculous narrative in the comments and\nmore often see just pages and pages of code with no comments, no factoring,\netc. It seems that is the more common n00b problem than over-commenting once\nthey are out in industry and not turning in cs101 assignments anymore where\nthey know the professor might spank them for not commenting.\n\n    10:53 PM, February 10, 2008\nJS said...\n\n    \n\nFunny you should pick on database data modeling. The idea behind it is to\neliminate redundancy in data and to represent it in a form usable by multiple\napplications for a wide assortment of purposes. This sort of modeling is\nsupposed to improve flexibility in how data may be used. Compared to\novercommenting or static typing, database metadata seems a very different\nanimal.\n\n    11:03 PM, February 10, 2008\nJustin Rudd said...\n\n    \n\nFunny. I was just working on some code today and started pulling out pieces\nand modeled it as an interface so that I could mock it :) And yes the double\nmeaning is intentional.\n\nI think I've finally hit my rebellious teenage years. I've stopped listening\nto the man (aka authority figures aka \"a\"-list bloggers) about TDD, TFD, BDD,\nADD :), etc. And also mock vs. stub and state vs. behavior testing, etc. Who\nfriggin' cares? I just want to solve the problem at hand and write some tests\nthat turn the bar green and give me a \"good enough\" feeling that the code is\nfine.\n\n    11:19 PM, February 10, 2008\nJustin George said...\n\n    \n\nThe cool thing with Haskell's stuff is that you can completely embed a dynamic\ntype system in it, so you only get the strictness where you want it.\n\nTo be fair, you can do that the other way around in dynamic languages (above\ncommenter and his assert isinstances) but few people build a type inference\nengine into their dynamic apps.\n\nIt's funny, I've gone through both of those stages, and I think I'm moving\nback towards static typing. It even makes testing easier.\n\n    11:25 PM, February 10, 2008\nravinenator said...\n\n    \n\nIt is interesting that you praise code compression and then mock Haskell and\nits type system. It really looks like you're contradicting yourself. Besides\nbeing one of the tersest languages known to man (consider point-free code and\nthe amount of plumbing that can be buried in a stack of monads), you could\nargue that Haskell types are the ultimate in code compression.\n\nA function's type is typically a one-line compression of all of its code -\nenough detail to give you a mental model of what the function does, but\nabstracting away all of the details of how a function does its job. The\ncorrespondence between functions and types can be very tight as we see from\ntools like hoogle and djinn, where, in a magical reversal of type inference,\nfunctions can often be inferred (or found) based on their types.\n\nAnd Haskell has an inference based system (except for some of the more\nexperimental corners), so you can get that compressed mental model for free -\nthe compiler will compute it for you! Or if you want to check that your mental\nmodel corresponds to the code that you writing as you go, you write down a\ntype signature and have the compiler check it. This is a great way to create\nuseful documentation and get feedback while you're working - without taking\nyou out of coding space and into testing space.\n\nI'll agree that learning to use an advanced static type system is a difficult\nskill and that it can take even good programmers years to understand how a\ntype system can be a sword that helps you destroy complexity rather than\ncreate it. But just because a skill is hard to master doesn't mean it isn't\nworth mastering. I'm more productive in Haskell than I am in any other\nlanguage not just because I've been a full-time Haskell programmer (at least\nas much as I can be a full-time anything at a startup) for over 4 years, but\nbecause I've learned how to turn its type system into one of my most powerful\ndevelopment allies - helping me check my mental models, make sure I don't make\nsilly mistakes when refactoring or extending code and, most importantly,\ngiving me a shorthand language that lets me take the vague intuitions I want\nto implement and start giving them (minimal) concrete form. I can use this\nconcrete form as a starting point for code, as an efficient way to communicate\nwith colleagues and as a way to keep more parts of a fantastically complex\nsystem in my head at the same time.\n\nIt really sounds like you've just missed the point of modern type-inference\nsystems. I'll agree that there are plenty of mediocre researchers trying to\nfill in ugly corners with arcane theories, but the core of a Hindley-Milner\nbased type system is a beautiful thing - and the battle-tested set of\nextensions you can see in languages like Haskell and OCaml are worth allies\nfor any programmer.\n\n    11:35 PM, February 10, 2008\nKarl Rosaen said...\n\n    \n\nThe best part of the article:\n\n\"To date, the more \"sound\" a type system is, the more often it's wrong when\nyou try to use it. This is half the reason that C++ and Java are so\nsuccessful: they let you stop using the type system whenever it gets in your\nway.\"\n\nIsn't there truth to the other side then too? The more dynamic a language's\ntype system is the more comments you need to explain what function arguments\nare, and the more unit tests you need? So maybe Java's success is in striking\na balance between the two.\n\n    11:53 PM, February 10, 2008\nTony Morris said...\n\n    \n\nI've called you on your under-qualified comment before, but it seems your\nstate of delusion is getting worse.\n\nPlease clue up a bit before making claims about type systems. Seriously,\npublic ridicule is the only adequate response for such tripe.\n\nCuriously, have you read this? http://cdsmith.twu.net/types.html\n\n    11:57 PM, February 10, 2008\nAlan Keefer said...\n\n    \n\nI get the point about static types being just metadata, but I really feel like\nyou're overstating your case. Types are much more functional as metadata than\ncode comments are; they help ensure the correctness of your program. That\ndoesn't mean they're always the right thing, just that the comparison is a bit\nstretched. They're closer to unit tests than to comments. People can get lost\nin writing the perfect set of tests, too, and unit tests also exert a serious\nmaintenance drag by making changes to the system difficult, but that doesn't\nmean they're not useful. The larger the system is and the more people that\nwork on it, the more useful the type information is. And yeah, I know\nruby/python/lisp/etc. help keep projects smaller so you don't get in those\nsituations as easily, but some systems just end up having a large surface area\nno matter what language they're in.\n\nAs to datamodelling, I think you're completely off. Name value tables? Really?\nMaybe for a prototype or your personal website. But for anything that needs to\nperform or where you actually care whether or not your data is trashed, you\nkind of need some kind of schema with (gasp!) typed, named columns and (double\ngasp!) maybe even some foreign key or nullability constraints. Code is much\neasier to change release to release than the database schema is, which means\nyou do need to spend more time making sure you can live with whatever you\nship/put into production. A bunch of name-value tables with self-pointers\nmight seem more \"flexible\" at development time, but it makes interpreting the\ndata basically impossible, and god help you if your application changes in\nsuch a way that it starts misinterpreting things. If your code is buggy,\nthat's one thing. If your code loses or corrupts data, that's generally game\nover.\n\nAnd maybe the majority of database applications out there never require any\nperformance tuning, but as I'm sure you know if your application is going to\nexpect any significant database load the name/value architecture probably\nisn't going to fly, and given how hard schemas are to change it's not\nsomething you want to find out after your server's fallen over under load.\n\n    12:54 AM, February 11, 2008\nFrans Bouma said...\n\n    \n\nIn general you seem to be able to make a point properly, but not in this post.\nIt sweeps from semi-point to semi-point without getting really TO the point,\nIMHO.\n\nThe main gripe I have with your post is that it tries to sell the idea that\nover-using comments and static types is bad, however it fails to illustrate\nwhat is NOT over-using and what is. This surprises me because it's so simple\nto describe:\n\n\\- with static types: if introducing a static type DECREASES complexity:\nintroduce it, otherwise DONT - with comments: if adding the comment makes it\nfor a mortal easier to understand wtf is going on, add the comment, otherwise,\ndon't.\n\nHumans suck really bad in interpreting code. We need every help we can get and\neven then we suck in it. This implies two things: 1) a programmer who inherits\na project has in general a hard time 2) a programmer who just wrote a piece of\ncode can't in ALL cases find the errors s/he made in that code right away be\nre-reading it.\n\nI.o.w.: if you as a programmer rely on 'the code speaks for itself', you're\nmistaken: a human has to PARSE and INTERPRET the code to understand what it\ndoes and to know what the value of _foo is at line 243 after that wacky loop\nhas completed. Comments can help in that area, and should be added to AID to\nunderstand the code when a human has to read it.\n\nAnd we're not all equal. A programmer who thinks s/he's very very smart can\nperhaps decide not to add any comments because it's so straight forward,\nhowever a person who takes over the project might just because of that have a\nhard time understanding it, and might misinterpret what the code does,\nintroduce a mistake because of that etc.\n\nIs that progress? Did the team as a whole become better because of the lack of\ncomments because the veteran was too snobby to realize that not everyone can\nprogram a C++ compiler in assembler?\n\nI surely think not. That doesn't mean we all should write books inside\ncomments. As I said: comments should describe what the code does for the human\nreader. Not as in: // increases i but as in: /* we have to check ... here\nbecause if we do it later we have a performance problem. */\n\nYou get the idea.\n\n    1:11 AM, February 11, 2008\nJohn Zabroski said...\n\n    \n\nSteve, pay attention to the comments section. In particular, Mark, Alan,\nSamuel, and dipplego. Your critics tend to be right.\n\nIt just seems like you see a problem but don't understand it. Imparting this\nvision on others is one thing. Imparting an incorrect understanding is\nanother. The former is an experience report, while the latter infects reader's\nminds.\n\nProbably the most balanced explanation of the differences between C and Lisp\nis Richard Gabriel's Counterpoint: Do programmers need seat belts?.\n\nPlease do not tell impressionable readers that Database Administrators know\nnothing about programming. I could've put up with most of your nonsense, but\nthat comment is intolerable. Mark the Metadata Addict in the comments section\nexplained why. Telling people to devalue the Schema is the biggest mistake you\ncould possibly make.\n\nMoreover, telling people models aren't important shows that you see a problem\nbut don't understand it. Models are everywhere in languages like Lisp. Just\npick up a book published by Springler-Verlag about AI and planning algorithms,\nand you'll see tons of code written in Lisp along with discussion about how\nthe author's model stacks up against other models.\n\nI read your blog posts mostly for the interesting metaphors, not for the\ntechnical advice.\n\n    1:43 AM, February 11, 2008\nAlBlue said...\n\n    \n\nI've got to disagree with your view that types are purely documentation in the\nsame way that comments are.\n\nComments aren't understood by the compiler. Types are. There's a key\ndifference between 'stuff that a compiler can do things with' and 'stuff that\na compiler can't do things with'.\n\nAll programming is telling a computer what to do. Documentation is explaining\nto humans what it does. Some things, like well-chosen function names, function\nsignatures (whether that's an informal \"this takes two arguments\" or a highly-\nspecified combination of return types and typed arguments) are useful to both\nsides.\n\nThere's also a lot of misinformation. A well-typed program isn't any more\ncorrect than an untyped program; both can still have bugs. The former has a\nclass of problems that a compiler (or IDE) can find out for you in advance,\nbut it's not a guarantee of 'correctness' that some people seem to claim,\nwhich is an easy point to pick on.\n\nAs for the type information at runtime; there *is* information at runtime in\nsome languages (Java's use of 'instanceof' or 'getClass', for example). In\nfact, some of this type information is available in dynamically typed\nlanguages as well; you can find a python's class at runtime and choose to do\ndifferent things.\n\nOne advantage of Python/Ruby vs Java at the moment is that the former allows\nfor functions to be passed around, which Java doesn't. However, that's not a\nfailure with statically typed systems; Scala supports that, for example.\n\nTo conclude; there's merits in types, but the whole argument about types being\n'good' or 'bad' is pretty polarising. I don't see why good systems can't take\nadvantage of both in the right situations; and part of that is understanding\nwhat the limitations are in each place. I wouldn't use a J2EE EJB system for\nmailing me when someone's birthday is coming up; but then again, I wouldn't\nuse Python to write a distributed transactional on-line banking system either.\nThe big problem is people who are only exposed to one type of problem, then\nthink that everything can be done with the same set of tools.\n\n    2:38 AM, February 11, 2008\nSteve Cooper said...\n\n    \n\nBeginners are much more comfortable with their native language, and have to\ncode in both natural language and the target language; // Make the number one\nbigger; i++;\n\nThe type of compression I think you're talking about is mainly one of fluency;\nthe ability to 'think in Russian'(http://www.imdb.com/title/tt0083943/) That\nonce you've internalised 'i++', you don't need to explain it back to yourself.\n\nHopefully, instead of creating big monstrous blocks, you can create better\nabstractions (functions, libraries, macros) to keep your code relatively\nclear; not\n\n(if destructuring (progn\n\nbut\n\n(when destructuring\n\nThe key is the ability to deal with more and better forms of abstraction.\n\n    2:54 AM, February 11, 2008\nAnonymous said...\n\n    \n\nJohn, I don't think Steve is \"telling people models aren't important\". He's\nsaying that overuse is wrong.\n\nOn the other hand, Steve, you are overusing the metaphor that static types are\nmetadata, as some before me have pointed out.\n\nBut, I would like to test a theory of mine. Me, myself and I, am solidly\nanchored in the safety of strongly typed languages. But I can sort of \"feel\"\nadvantages of a loser typed system, but my experice of such languages is\nlimited to a short session on javaScript, in project where we were writing in\nthe old style anyway. So my question is this:\n\nCould it be that the productivity advantage, sometimes seen in dynamic\nlanguages is greater for smaller projects. Could it be that in fact\ndevelopment [of a fully debugged system] becomes a lot harder the dynamic way\nfor a project that is larger than say 10 man-years? Opinions ? Anyone?\n\n    3:07 AM, February 11, 2008\nUnknown said...\n\n    \n\nThis article seems to be an unhealthy mix of overgeneralization and childish\nname calling. (Do you really need to call people \"metatdata addicts\" to convey\nthe notion that there's a point of diminishing returns for modeling\nactivities?)\n\nIn my own experience, what you're going through seems to be common among\n\"senior\" programmers. They tend to confuse \"writing code\" with \"getting stuff\ndone.\" I can only speculate, but I think it may be a natural consequence of\nthe narrow perspective afforded by writing code most of the time.\n\nThe comments on database schemas are particularly telling. You seem to be\nassuming that all the potential use cases for the database occur within the\nconfines of your current code base. Might be true initially, but just plain\nsilly as a long-term assumption.\n\n    3:22 AM, February 11, 2008\nUnknown said...\n\n    \n\nIncidentally, the two \"adam\" commenters above are, in fact, different people.\n(Hi, other person I don't know with the same handle as me! [waves] )\n\n    3:26 AM, February 11, 2008\nThomas David Baker said...\n\n    \n\nThanks for yet another thought-provoking post Steve. Just quickly I have to\nsay please keep posting and keep the posts just as long as they are now (or\nlonger)!\n\nAlmost every line of code I write for my day job is then available to any of\nthe hundreds of thousands of network creators on Ning. Those who actually\ndelve into it (you don't have to) vary from experienced programmers to people\nthat just want to add a new page to their website and it is their first\nexperience with programming.\n\nI wonder what your advice would be on commenting (and static typing, and\neverything else) in that scenario?\n\nWe tend to go moderately big (javadoc-style) on the comments at the class and\nfunction level. And we even have a little static typing in there, even though\nthis is PHP.\n\nA different question from the one you are addressing, for sure, but one that\nis particularly interesting to me!\n\n    3:28 AM, February 11, 2008\nCharles said...\n\n    \n\nI disagree with you lumping comments, static types, and annotations into one\n\"meta-data\" category. An interesting analogy you've made, but it seems\nstretched too far.\n\nStatic types are clearly more powerful than comments. Generics and function\noverloading immediately spring up as (arguably) positive uses of static types.\n\nCode annotations are even more potent, giving rise to new refactoring\npossibilities and even denser code. To be honest though, I found the static\ntype/java annotations link tenous.\n\n    4:09 AM, February 11, 2008\nPaddy said...\n\n    \n\nAll living souls welcome whatever they are ready to cope with; all else they\nignore, or pronounce to be monstrous and wrong, or deny to be possible. -\nGeorge Santayana\n\nSomehow I feel that statement applies to a lot of commenters upstream.\n\nI welcome your musings and I can see the resonance in your ideas :)\n\n    4:21 AM, February 11, 2008\nScript Uncle said...\n\n    \n\nPersonally, I feel that the points Steve gets very well across are these;\n\n1\\. The whole point of programming is to deliver a working system. 2. A lot of\ntime is time is being spent on too much meta-data, instead of problem-solving.\n\nAlso, he makes a case that the features of certain languages makes problem-\nsolving quicker, without impairing the deliverance of the system.\n\n    4:31 AM, February 11, 2008\nMichael Duffy said...\n\n    \n\nComments? We don't need no stinkin' comments, especially those awful ones to\ndemark the end of a block or class:\n\npublic class FooBar { } // end class FooBar\n\nI will admit that I'm getting uncomfortable about my addition to curly brace\nlanguages after reading Steve for a while.\n\nI'd love to see how long his rant about paper architects and UML would be.\nThat's the ultimate meta-data, in my opinion.\n\nI'll bet that Google would laugh at the idea of someone with the title\n\"architect\" not writing code, but that's exactly the direction that many\ncompanies are taking. It dovetails well with their mental model of \"software\ndevelopment as manufacturing\", where UML takes the place of engineering\ndrawings and overseas outsourced coders are the assembly line workers stamping\nout the widgets according to plan.\n\n    5:11 AM, February 11, 2008\nMichael Duffy said...\n\n    \n\ns/addition/addiction/\n\n    5:22 AM, February 11, 2008\nTahseen said...\n\n    \n\nI may be categorized as a n00b or as a teenager.\n\nI have program quiet a bit in Java/C++. But i have also program good enough in\nPython too. To me Python code is smaller and some of situation quicker to\nwrite a solution.\n\nBut i have found one thing that type system does not matter at all. I have\nfailed and succeed irrespective of type system i used.\n\n**The thing that really matter is working code!**\n\nI agree Python have sometime made it possible for me to reach desire working\ncode quicker. But vice versa has also been true.\n\nYou gave struts example i can give you Ruby/python examples too.\n\n\"Type war\" are for those who want to talk about code not write code. God\ndamnit everyone should write some working code! :P\n\nTH http://bootstrapping.wordpress.com/\n\n    5:23 AM, February 11, 2008\nLorenzo said...\n\n    \n\nteenager ... seems rougly analagous to effects seen in Brooks, such as \"second\nsystem syndrome\".\n\nMy commenting style tends more toward somewhat richer \"header block\" comments,\nabout the purpose and general approach to the function and less inline\ncomments unless there's some nasty gotcha in there. ... avoid the nasty\ngotchas.\n\nNice article!\n\n    5:31 AM, February 11, 2008\nUnknown said...\n\n    \n\nI program in English. After reviewing the English, I comment in Java after\neach sentence to let the computer know how to do it. In essence, I program in\ndual languages. IMHO the approach is what's important.\n\n    5:33 AM, February 11, 2008\nmacavity said...\n\n    \n\nNice post, and oh-so-true. One nitpick - being unnecessary is *not* what makes\nmetadata 'meta'. Try deleting your filesystem metadata and see what happens...\n:o)\n\n    5:48 AM, February 11, 2008\ngwenhwyfaer said...\n\n    \n\n\"in fact OOP was born and proven in dynamic languages like Smalltalk and Lisp\nlong before it was picked up by the static-type camps\"\n\n(nitpick alert)\n\nProven, yes, but not born - Simula-67 was statically typed, and inheritance is\narguably as static a concept as data modelling.\n\n\"As for me, at this point in my career I would rather puzzle through a small,\ndense, complex piece of code than a massive system with thousands of files\ncontaining mostly comments and whitespace. To some people this trait\nundoubtedly flags me as a cranky old dinosaur\"\n\nYeah, me too, except I've always felt that way. If I can see something all at\nonce, there's a much higher chance I can work it out all at once. (But then I\nalso have the screenfulosaurus bit set.)\n\n    6:05 AM, February 11, 2008\nDuncan said...\n\n    \n\nIt's always a trade off, but I think that the tenet of \"self documenting code\"\nis really important when you're working in a sizable team. In the older\nsections of our codebase it can take a long time to work out how some clever\nsuccinct piece of code works before it can be edited for some simple\nmaintenance. You recently advocated reading Fowler's Refactoring which pushes\nthis point throughout and yet this piece seems to me to say almost the\ncomplete opposite. I really like your essays and think that they lead to much\nhealth debate, but this latest one seems contradictory.\n\n    6:32 AM, February 11, 2008\nBenjamin Baril said...\n\n    \n\nHey Steve,\n\nYour ATOM feed for today is garbled with CSS style info.\n\nJust a heads up\n\n    6:41 AM, February 11, 2008\nEmmanuel said...\n\n    \n\nI'm not sure I should feel that enthousiatic about this article. Enthousiasm\nmake you look like noob. I've been reflecting for months an article like that.\nEverything seem to fall into place after reading it. I'm really pleased you\nwrote it. I wouldn't have reach this kind of masterpiece, not having your\nstyle. This the very true story of how a programmer grow. This is my story,\nI've gone by every state you describe from comment, to metadata and\nbureacraty. I wouldn't have suspected the parallel with 2-year-old Emily\ntemporal narrative. This will relax some tension, when i feel code is\nmonstruouly verbose with for loop indexes beeing iProdigiouslyLongLoopCount,\ncomments and so on. Thank you.\n\n    6:45 AM, February 11, 2008\nAdamIerymenko said...\n\n    \n\nJava definitely has a bad case of verboseitis and overengineering fever, but I\nagree with some of the comments that you've overstated your case a bit.\n\n    7:03 AM, February 11, 2008\nMarc A. Criley said...\n\n    \n\nStrong typing can, and should, be more than metadata.\n\n    7:04 AM, February 11, 2008\nbabo said...\n\n    \n\nWell done! Just a small note about static typing, actually Haskell's type\nsystem is quite close to an ideal state, where you are not forced to\nexplicitly state type in your code, but types are still there automagically.\n\n    7:06 AM, February 11, 2008\ngrant rettke said...\n\n    \n\nSupposedly teenagers brains work differently than adults:\n\nhttp://www.pbs.org/wgbh/pages/frontline/shows/teenbrain/work/\n\nI've met plenty of 30 somethings who think that they are invincible :)\n\n    8:03 AM, February 11, 2008\ngrant rettke said...\n\n    \n\nIf I had a purebred dog but I lost \"the paperwork\". I would still have a\n\"valid dog\" but no way of proving it was a purebred, at least without a non-\ntrivial effort on my part.\n\n    8:04 AM, February 11, 2008\ngrant rettke said...\n\n    \n\nRE: Well, we also know that static types are just metadata.\n\nThey're like pedigree paperwork: it might make a certain insecure personality\ntype happier about their dog, but the dog certainly doesn't care.\n================== True but the folks who invested the money in that dog\nprobably care!\n\n    8:05 AM, February 11, 2008\ngrant rettke said...\n\n    \n\nHaskell and OCaml provide type inference; but I guess you would categorize\nthat too as \"being forced\"?\n\n    8:06 AM, February 11, 2008\ngrant rettke said...\n\n    \n\nSteve you cover so many different points that alone could probably take up as\nmuch space as this single post. Move them out into different posts and give\nthem each the time that they deserve :)\n\n    8:07 AM, February 11, 2008\nDan Lewis said...\n\n    \n\nMaybe this is a n00b point of view, but bare code has no meaning. Why a piece\nof code exists or why it's written the way it is are left up to the\nmaintenance programmer's imagination. In the words of Bruce Lee, \"It is like a\nfinger pointing away to the moon. Don't concentrate on the finger, or you will\nmiss all the heavenly glory\"; but the code is all finger and no moon.\n\nMandating comments will also save you from the worst excesses of geniuses,\ngolfers, and optimizers.\n\nWhere I work, there is legacy code without legacy documentation. Now no one\njust knows how it works, and we're basically stuck at a French cafe, trying to\ninduce the language that we are on contract to extend.\n\n    8:11 AM, February 11, 2008\nUnknown said...\n\n    \n\nMy term for metadata addicts are IBM'ers. Since I've started looking at Ruby,\nI've put more focus on making my code readable instead of lots of comments.\n\n    8:14 AM, February 11, 2008\nUnknown said...\n\n    \n\nVery interesting. (The nitpicking comment that Simula was the first OO\nlanguage and it was static has been already been made... darn!) I would say\nI'm the typical lazy teenager who wants to enjoy the free sets of tests that\ncome with a nice compiler, instead of having to write them myself: i.e. I want\nsomebody else to take care of checking in the collection of pedigree dogs I\nneed to walk that nobody put a couple of ducks (and without going to each one\nand see if it walks like a duck and quacks like a duck...). Thats tends to be\nparticularly nasty, specially in \"production\". I have some appreciation for\nthe contract of types in a method declaration (I like to know if the method\nexpects a duck or a pedigree dog... they tend to be different), specially if\nI'm not the only one writing the code. So far, (with lots of generalization),\nstatic type languages tend to be faster than dynamic ones and type inferencing\nremoves much of the verbosity. On the other hand, the ability to modify allows\nlot of flexibility.\n\n    8:19 AM, February 11, 2008\nUnknown said...\n\n    \n\n>>On the other hand, the ability to modify the code at run time allows lot of\nflexibility, and you can do awesome things very quickly (or crash and burn\nfaster too)\n\n    8:24 AM, February 11, 2008\nMaxim Khailo said...\n\n    \n\nA hardcore experienced programmer does not cloud his mind with such dogma\n(static typing bad, dynamic typing better, etc). The greatest asset a senior\ndeveloper has is his ability to recognize a problem, recognize a good\nsolution, or if he has no experience in a good solution, think one out.\nThinking is your best asset.\n\nJust as there are times when commenting makes sense, there are times when\nstatic typing makes sense.\n\nStatic typing is like saying there is this box and you can only put this kind\nof thing in it. The box is labeled.\n\nDynamic typing is like saying we have these generic transparent boxes that you\nhave to look into to find out what is in there. or just remember where you put\neverything.\n\nYeah labelling boxes sucks but sometimes its very useful. Haskell has an auto\nlabeler which is even more useful.\n\nDifferent problems need different solutions and it takes a professional to see\nwhen and where to use different tools.\n\nThe dogma you talk about is from someone who has only solved a specific set of\nproblems, or from someone who was not smart enough to use the right tools.\n\nBut to know the right tools takes time. The best benefit to programmers is not\nruby, or dynamic languages, but just writing lots of code. By good teaching as\nwell (which we lack in USA). By writing code in static and dynamic languages.\n\nYour apparent frustration is the result of you not understanding this basic\npremise. That going from noob to rock star takes time.\n\nAll anger and frustration come from ignorance. I just hope this post does not\ndilute people who write in dynamic languages to think they are rock stars if\nthey are not.\n\nHMTL and Javascript are some of the most permissive languages for writing\ncode, but I would hardly argue someone who only writes in those is a rock\nstar.\n\n    8:59 AM, February 11, 2008\nbjkeefe said...\n\n    \n\nI'm kind of a n00b programmer, but it seems to me, when considering looking at\nother people's code, or when revisiting something I wrote long ago, that it's\na lot easier to filter out unwanted comments than it is to cause them to\nappear. In fact, I suspect 90% of the readers here have written a quick script\nto do just that.\n\nI grant a lot of comments are unhelpful, and some are even misleading. But\nthere's always the chance that the comments can provide an additional insight.\n\nIt has not been my happiness to work with lots of code written by really good\nprogrammers (my own included), so I say, err on the side of excessive\ncommenting, if such a choice actually has to be made.\n\n    10:11 AM, February 11, 2008\nHarold said...\n\n    \n\nre: the Haskell/OCaml type system idea:\n\nTwo problems:\n\n1) If you don't start declaring complex types, the compiler will start\ninferring data types that you can't begin to understand because of the\ncomplexity of the type. The type of a relatively simple function could easily\nbe longer than the code for that function. So you have to play the meta-data\ngame if you're in it for the type system.\n\n2) The type system still gets in your way. E.g. many Lisp functions accept\nsome value or nil (aka null) and just return nil on nil input. This is really\nhelpful when you want to propagate a non-error situation where some data\nshould be ignored. But in Haskell/Ocaml you need to declare a Nullable type.\nPolymorphic data types helps here, but then you with so many \"case\" statements\nto propagate null value that you write a meta-function to take a function ::\nString -> String and make it become Nullable String -> Nullable String, but\nthen you end up having to use that everywhere explicitly - ugh.\n\nSteel Bank Common Lisp shows the right way to do this: include static type\nchecking that tells you when you make a mistake but assumes that you know what\nyou're doing when the code is ambiguous.\n\n    10:29 AM, February 11, 2008\nrycamor said...\n\n    \n\nInteresting and provoking comments, Steve.\n\nOf course, no one will completely agree with you, but I think your post at the\nvery least leads to a productive discussion.\n\nIn terms of years-programming, I would be a teenager in your scale, but I did\nhappen to start programming a little later in life than most, having a little\nbackground in math and linguistics. Thus, my abilities lean more towards the\nlogical/database thing. But, I have been developing working code for 9 years\nas well as designing databases (I hate the term \"modelling databases\").\n\nWhen it comes to application code, I completely sympathize with your\nfrustration at the metadata addicts. In fact, I never had the patience to even\nbecome one of those temporarily (perhaps to my detriment).\n\nBut I think your analysis doesn't quite apply to relational database design.\nThe situation is a little more complex and confused by other issues. Most\npeople who call themselves \"data modellers\" have absorbed just barely enough\nof Database Design for Mere Mortals to be dangerous. DDMM is a decent book for\nbeginners, but hardly begins to describe the flexibility of the relational\nmodel. Secondly, there is the whole \"keeper of the tower\" syndrome that\nhappens with those who become experts at a specific product like Oracle or\nSybase.\n\nI found that after some more serious reading, such as the writings of CJ Date\nand Hugh Darwen, I had a completely different perspective on what is possible\nwith databases. (Besides the obvious weighty tomes, \"The Askew Wall\" and other\nshort texts by Darwen are *priceless*). In the end, I was able to produce\nsystems with a fraction of the effort I would have spent previously. Good\ndatabase design actually sped up the coding process. Expressiveness is what\nit's all about.\n\nI must stress that by \"good design\" I don't mean to mean the endless\ncommittees and power plays that occur in many corporate settings. I mean that\na) the relational model allows us to express some things much more concisely\nand clearly than can be managed with any sort of programming approach. But,\nprogrammers tend to ignore those capacities because they don't like logic to\nbe out of their hands. And I sympathize; I think programmers and database\ndesigners should be one and the same. b) with a little foresight there is no\nneed to follow the classic dual-model approach of handling the same logic in\nboth code and database. ORM is probably the biggest culprit there.\n\n    10:35 AM, February 11, 2008\nMichael said...\n\n    \n\nThis is where Perl6's planned optional static typing would be really useful.\nDon't type if you don't want to, but when you need it (for clariy or\nperformance) then type away.\n\n    11:21 AM, February 11, 2008\nAaron Davies said...\n\n    \n\nk4/q: the Finnegans Wake of programming languages? docs; examples; how a k4\nprogrammer writes C\n\n    11:43 AM, February 11, 2008\nJason Dusek said...\n\n    \n\nFrom one point of view, code does things, and since we don't need static types\nto say what the code does, we might as well do with out them. However, I want\nto do something besides say what my code does -- I want to say what the code\nshall not do. The first two hours of writing Python are fun, but then you\nstart writing asserts or writing comments like \"this function accepts a\nfunction returning foos\" -- much more verbose than static types.\n\nDynamic languages are suited for little more than big shell scripts. Their\nprominence is only the result of the failure of statically typed languages to\ninnovate (or to die a natural death).\n\nObject orientation and duck-typing are astrology -- they make one stupid and\nafraid of knowledge. Type annotations are replaced with naming conventions,\nmathematical concepts are supplanted by made-up programmer talk, logic is\nrejected in favor of rules of thumb. To suppose that there are valid ways of\nthinking outside of mathematics is heterodoxy -- it is the cause of all our\nproblems and the root of all our sins.\n\n    11:46 AM, February 11, 2008\nStefan Ciobaca said...\n\n    \n\nThere's actually a theoretical limitation to what you call < the typing system\nis 'wrong' >\n\nThe word you want is complete, and you can't get it. A type system is sound if\nwell-typed programs \"do not go wrong\". A type system is complete if any\nprogram that \"does not go wrong\" is well-typed.\n\nTurns out that you can't really create a complete and sound type system\nbecause that would solve the halting problem...\n\nOn the other hand, Haskell and Ocaml have sufficiently expressive type systems\nthat it is more likely you who is screwing up if the program doesn't\ntypecheck.\n\nThen again, for some dirty hacking, like interacting with stuff others wrote a\ndecade ago, a lesser sound type system could get out of the way. Maybe that is\nthe real reason C(++) still enjoys such success.\n\n    11:46 AM, February 11, 2008\nFouad Mardini said...\n\n    \n\nGreat Post! [OT] It looks like Steve has been doing some James Joyce reading\nlately. He refers to Finnegans Wake in the post, and I think the post's title\ncomes from Joyce's \"A portrait of the artist\"\n\n    11:52 AM, February 11, 2008\nBrian said...\n\n    \n\nOn your behalf, I've submitted a JSR to the java meta-data modeling committee to implement the @Annotation@Annotation( \"Dinosaur\" | \"Noob\" ), to be used as the penultimate filtering mechanism in your IDE of choice.\n\nAfter a beautiful, meticulous modeling process, with especially careful\nconsideration to backwards compatibility, it should be ready for inclusion in\nthe language by 2023.\n\n    12:19 PM, February 11, 2008\nZoom said...\n\n    \n\nIt sometimes seems to me that advocates of dynamic typing talks about writing\napplications that actually do stuff. Advocates of static typing talks about\nwriting API's that is easy to use. Maybe it is just me (static typing galore\nis my game) but I would rather use an API where the compiler can inform me\nthat the only thing the API can handle is instances of a class (or objects\nwith certain methods) beforehand rather than letting me prod it with unit\ntests until I get it right.\n\n    12:20 PM, February 11, 2008\nSteven Atkinson said...\n\n    \n\nIt would be interesting to program with a optionally typed language. My\nexperience is with C++, Smalltalk, Javascript, Ruby, and Lisp. I find that\nstrong types get in my way more often than lack of specifying types hinders\nme. I'd like to see what being able to specify types when you need to would be\nlike.\n\nThe debates would be furious.\n\nI've worked with programmers who insist on commenting every function with a\nboiler plate comment section duplicating everything that's in the signature.\nThey often also insist that each argument to a C++ function have an \"in\" or\n\"out\" comment. Apparently this is also not completely obvious already.\n\nThese programmers will insist that every type be specified. Then come the\n\"wrapper\" classes, the \"shims\", the \"proxies\", and the layers upon layer of\nnice little security blanket classes.\n\nBTW: I think you tried to bring too many concepts into your rant. Leaving out\ndata modeling would have helped condense the point, but maybe that would not\nhave stirred the pot as much.\n\n    1:15 PM, February 11, 2008\nAnonymous said...\n\n    \n\nThere was a comment on comp.lang.forth a few years ago along the lines of\n'everything except for binary code is just comments'\n\n    1:15 PM, February 11, 2008\nPaul W. Homer said...\n\n    \n\nYep. But I think your being unfair, some problems just lend themselves better\nto being strongly typed, some don't. It isn't a question of age or experience,\nit is what you are coding that matters (although when you are young, you fail\nto see this). Loosely typed sets of actions cut down on code, critical\ncomputations are always best strongly typed and very fragile. Mix and match to\nget the system built.\n\nPaul. http://theprogrammersparadox.blogspot.com\n\n    1:26 PM, February 11, 2008\nPhilipp Lenssen said...\n\n    \n\nVery interesting stuff and very readable.\n\nI think your \"programmer's evolution\" story only takes into account a certain\ntype of programmer -- perhaps the one who officially learns programming at\nuniversity. Myself, I've started out with overlong programs with hundreds of\nglobal variables, barely scope, and rarely comments. I didn't program to learn\nprogramming though, but program to get games done. (Games, on that note, offer\na good kind of direct visual feedback; bugs surface more quickly when say the\nenemy is suddenly leaving the screen within seconds instead of attacking the\nplayer ship. Compare this to how long it might take until you discover that\nthe File -> Export as ZIP is broken when an existing ZIP is write-protected or\nsomething.)\n\nI've learned since then. Still, today, when I try to get my heard around code\ndownloaded from somewhere, often the first thing I do is remove all comments.\nSomehow the only comments I can bare are one per function header. Once\ncomments are gone, it's easier to see the actual program complexity and flow,\nand you're less distracted. (Also, as we all know, comments can lie, which is\nbad when you're debugging.)\n\nAs with many things, perfect is the enemy of good. A pragmatic, goal-oriented\ncompromise goes along way in getting things done.\n\n    1:50 PM, February 11, 2008\nUnknown said...\n\n    \n\nA very interesting read. I guess you could me a novice programmer, and I have\nmixed feelings against static typing. It always seems to incur more effort\nthan the writing of code that actually does some work. Certainly it helps\nmodularise larger groups when they're working together, but then it needs to\nbe *maintained*. It becomes extremely difficult to change, and is very\ndifficult to debug. Personally I prefer languages like C, Perl and Python over\nover C++ and Java. It's unfortunate that recent languages with \"other\" modern\nconcepts, always take the object-oriented and typing concepts to the extreme.\n\nWhat I want is C with language supported lists, hashes, namespaces and\n\"container\" objects.\n\n    2:17 PM, February 11, 2008\nLucas Richter said...\n\n    \n\n<question> How do you know if you're metadata-addicted? </question>\n\n    2:58 PM, February 11, 2008\nsapphirepaw said...\n\n    \n\nI always used to wonder about the 'years of experience' requirements on job\nopenings. Paul Graham's assertion that it drives out general childishness (not\nnecessarily programming childishness) just didn't seem quite right.\n\n2.25 years of real developer/sysadmin work has given me enough experience to\nprove Graham wrong. It's not until you write an inscrutable, unmodifiable wad\nof closures that you understand moderation. Likewise with comments, static\ntypes, inheritance, magic methods or interfaces, and functions-as-data: until\nyou've abused it, you don't know how to use it. Companies require X experience\nin hopes that you won't waste their money on the abuse phase.\n\nAs for relational modeling, I've observed that a strong schema tends to be\ndefined in at least N+1 locations, where N is the number of programming\nlanguages that interface to it. Neither \"Column 'foo' cannot be null\" nor\n\"Duplicate entry '1' for key 1\" are acceptable error messages for end-users.\nYou end up with code to ensure you put the right thing in the DB, and that\ncode ends up knowing the schema.\n\nThe only way out is to write N interpreters for the database schema itself. I\nthink they're known as \"ORMs\" because it sounds better than \"Yes, we just\nwasted a bunch of time to automagically do stuff twice!\" So much for the\nperformance cult.\n\nI want an XML database with built-in revision control. Probably to abuse.\n\n    4:30 PM, February 11, 2008\nUnknown said...\n\n    \n\n1) If you don't start declaring complex types, the compiler will start\ninferring data types that you can't begin to understand because of the\ncomplexity of the type. The type of a relatively simple function could easily\nbe longer than the code for that function. So you have to play the meta-data\ngame if you're in it for the type system.\n\nUh... no? The compiler infers the most general type possible, but the only\ndifference between that and a type you may define would be a few class\nconstraints.\n\n2) The type system still gets in your way. E.g. many Lisp functions accept\nsome value or nil (aka null) and just return nil on nil input. This is really\nhelpful when you want to propagate a non-error situation where some data\nshould be ignored. But in Haskell/Ocaml you need to declare a Nullable type.\nPolymorphic data types helps here, but then you with so many \"case\" statements\nto propagate null value that you write a meta-function to take a function ::\nString -> String and make it become Nullable String -> Nullable String, but\nthen you end up having to use that everywhere explicitly - ugh.\n\nAaaand no again. That \"meta-function\" by the way would be fmap and it exists\nand the \"Nullable type\" would be \"Maybe\" and there are a thousand idioms for\nusing it cleanly, from using \"do-notation\" sugar for monads to using bind\noperators explicitly, to using applicatives. And the huge advantage here is no\nmore \"null pointer\" errors... ever! Seriously.\n\nThat said, I'm sorta with SY on annotations, which are ridiculous. But if you\ncan't specify reasonably well the type of a function, how can you say you have\nany idea what it does at all?\n\n    4:45 PM, February 11, 2008\nUnknown said...\n\n    \n\nNever let the facts get in the way of a heartfelt rant. But if you bothered to\nlook at some serious OCaml code (like the compiler sources, say), you'd see\nthat there is precious little static-type meta-data there. Type inference wins\nthe day and the sources are beautifully compact. People doing serious\nprogramming in the Hindley-Milner type system world don't suffer from\nexcessive meta-data, but do get irritated by know-it-alls calling them noobs.\n\n    6:58 PM, February 11, 2008\nVlad Patryshev said...\n\n    \n\nTactically, you are very right. Strategically... I don't know. You mix two\nthings together, strict typing in general, abuse of UML and class hierarchy,\nand overuse of strict typing where it is not necessary (I mean JavaScript).\n\nRegarding class structures - it's probably hard to force people that love\nbureaucracy not to fill their code with Managers, Handlers, Helpers, and the\nlike (none of these does any work, but they pass it around, like in real\nlife). But I'm afraid this anti-bureaucratic rant has nothing to do with the\nissue of modeling in general.\n\nI'll give you one example, an interview problem. Write a function f on 32-bit\nintegers that, applied twice, it negates the integer. f(f(n)) = -n.\n\nTry to solve it without any kind of model, by just applying randomly ad-hoc\nxors and shifts.\n\n    9:00 PM, February 11, 2008\nrycamor said...\n\n    \n\nSapphirecat is the perfect example of what I was talking about re: database\ndesign.\n\nThe only way out is to write N interpreters for the database schema itself.\n\nNo, that's just the default assumption of someone who hasn't really looked at\nthe possibilities. The only long-term way out of this insanity is to design\nsoftware that can derive at least *some* amount of intelligence by reflecting\non the database design itself. For now, we are limited because most\nintegration between programming language and DBMS is so clunky.\n\nEven so, designing libraries around Information_schema and DDL rather than\nhard-coding for specific entities take you a long way toward breaking out of\nthe cycle. Even in a few afternoons, I was able to come up with some\ninteresting approaches. I believe much more is possible with serious R&D. Of\ncourse, SQL itself mitigates against some of this by its screwed-up design.\nIt's time for a better relational language.\n\n    9:07 PM, February 11, 2008\nlahosken said...\n\n    \n\nI like using code reviews to find out where to put comments. Your code\nreviewer points at a section of code and says \"You did it wrong.\" Instead of\njust explaining that you did it right, add a comment explaining that\nrightness. If your code reviewer got confused, maybe future readers will, too.\n\nMaybe that suggests a strategy for enforcing types. After someone sends you a\nnastygram that your function blew up when they pass in a string, don't just\nwrite back a snarky note saying that the function of course takes a tuple of\nints. Add an assert istype. If one person was confused, probably other people\nwill be, too.\n\n    9:25 PM, February 11, 2008\nUnknown said...\n\n    \n\nHey Steve,\n\nThe code you've chosen to demonstrate your compressed style is a function from\na recursive descent parser. That's not really a fair example, because that one\npiece of information tells me almost everything I need to know about your\nfunction. Without reading a single line of code (or comments) I know the\nfunction's inputs, outputs, side effects, time complexity, engineering trade-\noffs, related literature, and even who it favors for president in 2008. Your\ncomments fill me in with the only information I don't yet have: what kind of\nconstructs are you actually parsing, and what is the meaning of those strange\ncontext variables you're being passed?\n\nSo in this case, it's easy to agree with you that experienced programmers (who\nwill be familiar with recursive descent parsers) don't need lots of comments\nto help them understand this function. But that only works here because you're\ndealing with a well-established pattern.\n\nThat's one observation to make about comments: they are always complementing\nsome assumed background that your readers have. Maybe you have a nice design\ndoc that you expect your readers to have read and understood. Maybe you're\nworking within an engineering culture where certain things are assumed to be\ncommon knowledge.\n\nI think that in many cases, storyboarding is a highly appropriate commenting\nstyle. One example is in sequences of really side-effecty code. Why is this\nfile getting deleted here instead of two steps later? How does your sequence\nof events help achieve consistency, idempotence, etc. in the case that the\nprogram is interrupted or something goes wrong?\n\nAnyway, I think terseness comes down to being a stylistic choice just as\ncomment verbosity is. You might find terseness more correlated with\nexperience, but here's an example of code from SQLite (written by the\n20-years-out-of-college D. Richard Hipp):\n\nhttp://www.sqlite.org/cvstrac/fileview?f=sqlite/src/os_unix.c&v=1.174\n\n    9:32 PM, February 11, 2008\ndavid [ketralnis] said...\n\n    \n\nPlease don't let anyone tell you to write shorter essays.\n\n    9:55 PM, February 11, 2008\nUnknown said...\n\n    \n\nComments should exist either to (a) document something in a way that can be\nextracted for users of the function/class/whatever, (b) why the code is doing\nwhat it's doing, or (c) explain some code that is particularly obscure. That\nsaid, and in the absence of pulling out each significant section of\nfunctionality from a routine into its own explanatorily-named subroutine,\nsingle-sentence comments that identify the purpose of the next chunk of code\nmake it much, much easier to find your way around a long function. The other\npiece of documentation that is generally not available to people is how\nmodules relate to each other. All of these things go to maintaining the code,\nwhich is some large percentage of the life of a piece of code. People who do\nnot document their code according to these rules either maintain their code\nthemselves, or don't write anything that will last.\n\n    11:21 PM, February 11, 2008\njosh said...\n\n    \n\nSorry Steve, way off base and needlessly inflammatory. Seniors don't comment\nbecause it conserves energy and time; basically they're lazy (and that's ok).\nThe urge to tell stories is deeply ingrained in all human beings. Your toddler\nexample only proves that it's a universal need that crosses all boundaries\nincluding age. Good heavens, this post itself is a story! Does this mean\nyou've reverted to being a 2-year old? No; it just means you're wrong about\nwhat story-telling does, or doesn't, imply.\n\n    12:06 AM, February 12, 2008\nScript Uncle said...\n\n    \n\nJust another short note while the comments are open. When it comes to dynamic\nversus static languages, my experience has been the following;\n\nI was dead-certain the lack of typing in JavaScript would completely kill me\nwhen I started out (some three years ago), and I don't know why it hasn't\n(yet), but I'm able to do moderately long (~5KLoC) projects in JavaScript only\nand still understand what I do, make other people understand what I do, and -\nmost odd - no perceived increase in errors. [OK, high to begin with, what? :)\n]\n\nAlso, something that one can prove true for hours, while drinking beer, proved\nto not be the case; No compulsory try-catch statements everywhere.\n\nI do not know why, but I've had the exact same experience as above. I only\ninsert try-catch'es in portions of code that I debug or when I'm trying to\nlearn something new, otherwise I have discovered I don't need it.\n\nAnd tacking another tack at explaining the higher productivity (for me) and\nwhy I'm really, really looking forward to server-side JavaScript (Jaxer,\nRESTful Rhino on Rails, et.c.),is that you _just_code_ . If there is a domain-\nspecific object you're tossing between function, you just _create_ it and\n_populate_ it. No interface, no abstract classes, you just solve the problem.\n\nAnd for some reason unknown to me, the code is still maintainable, readable\nand I get to the market quicker :)\n\n    12:37 AM, February 12, 2008\nBill said...\n\n    \n\nI just wanted to say: Great article. Thanks for sharing that.\n\n    2:43 AM, February 12, 2008\nbrassica napobrassica said...\n\n    \n\nWell, there's a similar underlying mechanism to any creative work, whether\ncoding, data modeling or drawing. Don't fix your creation on something unless\nyou're sure!\n\nProblems in the creative realm are generally unknown until the creation is\nfinished. Don't decide your algorithms, architecture, and data models until\nyou know everything: only then you can know how you want to build your code\nand data. And only then you can know what you really want to freeze. Freezing\nAPIs, data structures etc. usually help people communicate better with their\ncode: it's a guarantee that they don't need to look deeper but up to the API\nand that pays off by minimizing the other people's need to understand your\ncode. When you're sure you want to isolate the internals of some function,\nmodule or library from its users, that's a good time to model and abstract it\naway. But for most of the program that's just too heavy.\n\nAnalogously, the stronger the stroke in a sketch drawing, the more it removes\nfuture possibilities. And the longer you can keep your sketch unobtrusive and\nopen, the better result you get because you effectively postpone decisions\nuntil you know what you want to see in the final work.\n\n    3:40 AM, February 12, 2008\nUnknown said...\n\n    \n\nThis comment has been removed by the author.\n\n    5:40 AM, February 12, 2008\nUnknown said...\n\n    \n\nStevey,\n\nI see you're parsing JavaScript code in emacs (at least, it's what the example\ncode you posted suggests).\n\nI've been coding a lot of JavaScript the last two years and, very recently,\nI've started learning about elisp.\n\nIt didn't take long before I hacked together a bunch utilities in elisp, to\nhelp me with the development.\n\nWould it be possible that you share some (all?) of your elisp JavaScript\nhelpers/tools with us? That would probably help me, as well as a bunch of\nother people; both by improving my development speed and by teaching me about\nelisp.\n\nWhat do you think?\n\nArnaud\n\n    5:42 AM, February 12, 2008\nAlain Roy said...\n\n    \n\nDoes the length of your essays reflect the fact that your a noob at writing\nessays, or the fact that it takes a lot of space to communicate effectively?\n\n    6:16 AM, February 12, 2008\nRick DeNatale said...\n\n    \n\nAnother thought provoking item from Mr. Yegge.\n\nMy 1/2 cent\n\n    6:58 AM, February 12, 2008\nYour Correspondent said...\n\n    \n\nI liked the post. It covers the issues so well that it would still be valuable\neven if it were all wrong.\n\nThe blog is itself metadata. But also really funny. I laughed out loud.\n\nA lot of these issues are linguistic in the sense of being cultural. Somebody\nused to Chinese is going to be disoriented with English, and vica versa.\n\nOkay, not only cultural, but cognitive.\n\nWhich means that since people adapt to different systems the strengths and\nweaknesses of the system tend to become invisible.\n\nFish don't know the ocean exists, yet they are still constrained by the\nhydrodynamics of the situation.\n\n    7:16 AM, February 12, 2008\nStephan Westen said...\n\n    \n\nSomehow the idea of writing the meta data once and generating the rest of the\napplication out of it is a very appealing idea to a lot of people. Once in a\nwhile a new generation pops ups and tries again.\n\nProbably the 80/20 rules applies. You can probably generate 20% (CRUD), but\nthe biggest chunk of a regular application still requires manual coding. Not\nto mention tweaking the generated part for those nice exceptions that occur in\nthe real world.\n\n    7:42 AM, February 12, 2008\nKevin Fairchild said...\n\n    \n\nAnother great article, Steve. My favorite, though, is some of the comments.\nSome people just seem to overly personalize what is said.\n\nFor instance... The post mentioned that some people go overboard with schemas,\nmodeling, etc. But, no, that doesn't mean the post is saying that those\nprocesses aren't valuable. It just means that being excessive with it can be\ncounter-productive.\n\nAh, well. Obviously a good topic for discussion, though, since it seemed to\nhit a nerve.\n\n    7:54 AM, February 12, 2008\nbrian doll said...\n\n    \n\nReading these blog rants is fun, but reading the comments is hilarious!\n\nBravo Steve, for playing the verbose lightning rod role so wonderfully!\n\n    9:52 AM, February 12, 2008\nKevin McDonagh said...\n\n    \n\nDearie me. It's obviously been a while since you've had to work with other\npeople. Either that or your stuck in a mind set of heavy coding an you are\nsubjecting them to a world of torment.\n\nI agree with your analogy, there is a lot of maturity and concicness that\ncomes naturally through time. But that doesn't mean huge unreadable code.\n\nWith maturity should come the wisdom that you(and others) must be able to\nchange elements fast. Breaking your code into manageable readble chunks is the\nonly way to do this. But the flip side of maturity is that it can lead to bad\nhabits and preconcieved views.\n\nIf you regard anyone who writes considerate comments with readble formatting a\nspeccy teenage n00b, I'd suggest you may be turning into a bit of a tired old\nman.\n\n    9:54 AM, February 12, 2008\nkurtiss said...\n\n    \n\nSometimes I feel the same way about abstraction itself. Often times the\nmachinery involved in crafting an abstraction that doesn't require heavy\ncommenting to be legible adds the same sort of top-heavy, momentousness you\nattribute to model heavy code.\n\nThat you rightfully find certain kinds of metadata counter-productive,\nshouldn't imply that all metadata is bad.\n\nAfter all, everything above machine code is metadata, right? And if we admit\nthat high level languages are around for a purpose--that the linguistic fluff-\nstuff of human expression has indeed increased our capacity to engage with\ncomputers in ways before unthinkable--then we must admit that some metadata is\ngood.\n\nFurther, we should seek new kinds of metadata that lower barriers of speaking\nto computers. It takes an elementary education to understand the technical\n*concepts* that drive today's most popular software, but it takes so much more\nto understand the language and components used to implement those concepts. I\nsee that as a failing of language--an underdeveloped landscape of metadata.\n\n    11:31 AM, February 12, 2008\nUnknown said...\n\n    \n\nI think there is a lot of truth in the main point about over-modeling, and I\nthink the model/don't-model ought to often be a judgement call more often than\nit is.\n\nHowever, I think the choice of static typing is rarely for the noob psychology\nreasons that you propose.\n\nIf you have 2 million bucks worth of hardware, doing highly optimized work in\nC/C++, you can't switch to python. Doing this in python would require 10x as\nmany machines if not more, and years of rewriting.\n\nIf you want your language to dominate, it has to have performance first. It\ndoesn't have to make sense to you, but the history of software shows that\nperformance drives language decisions. A car that gets 8 miles to the gallon\nwill not sell, no matter how fun it is to build.\n\nKevin\n\n    4:18 PM, February 12, 2008\nRegina Obe said...\n\n    \n\nWhat irritates me most about over-commenting by noobs is that when they copy\nand paste, they copy the comment along and change the code. So now the\nmetadata is super bad because it not only gets in your way, but it doesn't\ndescribe the code its supposed to be metadata for. Bad comments are worse than\nno comments at all.\n\n    5:19 PM, February 12, 2008\nMitch said...\n\n    \n\nIf it's a complicated algorithm, a veteran programmer wants to see the whole\nthing on the screen\n\nBuy a big monitor! (I write code on one of these).\n\nIt has to be said: while you may be doing a lot better these days with\ncompressed code, you could probably do a bit better compressing your blog\nposts :)\n\n    8:24 PM, February 12, 2008\nEek said...\n\n    \n\n> Funny you should pick on database > data modeling. The idea behind it >is to\n> eliminate redundancy in data > and to represent it in a form > usable by\n> multiple applications for > a wide assortment of purposes. This > sort of\n> modeling is supposed to > improve flexibility in how data may > be used.\n> Compared to overcommenting > or static typing, database metadata > seems a\n> very different animal.\n\nIn one light, it is different. In another light, it is much the same: You're\nimposing some extra model constraints on the developer in order to support\nsome goal that is not the exact same as the programmer is working on.\n\n    7:22 AM, February 13, 2008\nMike said...\n\n    \n\n4,100 words? And you claim you \"cut stuff out\"?\n\nYeah, why put comments in your code? It's not as if there will be any bugs in\nit that other people will have to fix, years after you've moved on.\n\nI think Brainfck might be the best language for you.\n\n    8:03 AM, February 13, 2008\n1 Chat a Day said...\n\n    \n\nHmmm,\n\nnot bad. However, because of your very negative descriptions this is hard to\nforward to collegue noobs. It would jeopardize working relationships. Which is\na shame, they should read it.\n\nT.\n\n    8:16 AM, February 13, 2008\nWheat said...\n\n    \n\nThis comment has been removed by a blog administrator.\n\n    8:24 AM, February 13, 2008\nChris D said...\n\n    \n\nIf it's a really tricky, complex algorithm, the solution is not to remove all\nthe whitespace. The professional, mature thing is to add comments when\nsomething non-obvious is happening. We shouldn't be writing code as a\nchallenge to see who can understand it unaided. For example, if you see this\nin Perl:\n\n%x = map { $_ => 1 } @words; @words = keys %x;\n\nwithout a comment, you should fire, or at the very least yell at, whoever\nwrote it. (There are efficiency reasons for not writing that as well, but\nmainly it's a clarity issue.) To me, you seem to view complicated code as a\ndare: if I can understand it on my own, then maybe I meet your standards. If\nso, I think it's a rather childish thing to do.\n\nMaking code legible with selective commenting is a sign of craft and care, not\nimmaturity.\n\n    8:26 AM, February 13, 2008\nWheat said...\n\n    \n\nI still remember the first code maintain written by another developer, and\nthis comment:\n\n# insert a BR line break print br();\n\nRarely have I read such an eloquent burn of the enterprise mindset. Guys whose\ncode and data has 100% integrity but #$*@!$!-it there aren't big gapping holes\nin the entire approach or data structures.\n\nComing from 2 year old steps in Perl, then schemaless, dynamic object\npersistence metadata addled world of Zope (and the good ol' Zope Object\nDatabase), there is a balance that can take a long time to find between rush-\nand-implement and dynamic-everything-the-wazoo and \"we've got code so majyk\nthe Ruby guys get queasy\". Never having done anything serious in Java I never\nlearned interfaces. Attaching extensible metadata to classses is addicting. Of\ncourse in Python's zope.interface you describe interfaces to such an extent\nthat you can use them to imlement a data peristent strategy or autogenerate a\nwidget-based HTML form, so ...\n\nWhile explaining modern Zope recently I wrote a Python program I called the \"\nYegge Caveman Architecture\"\n\n:P\n\n    8:39 AM, February 13, 2008\nmattflo said...\n\n    \n\nIsn't the programming language just a model for executable machine\ninstructions? Why not write machine code?\n\n    8:53 AM, February 13, 2008\nSony Mathew said...\n\n    \n\nMeta-data is only one part (as used by IDEs - a great part in itself) -\ncontractual programming is the other great benefit of strongly Typed systems\nand will always be better because it helps contractually separate concerns of\na large problem domain and therefore manage complexity. Static systems also\nprovides for superb optimizations by a compiler.\n\nDangling off cliffs can occur at any age - it has more to do with the number\nof risks one takes - which as in all other real world cases decreases with\nage. Experience does prevent known risks - but well-known risks are often\npublic knowledge and as in other real world cases - Experience can be a\ndeterrent to taking risks.\n\nOver-commenting and over-modeling is a valid point, however, over-anything is\nalways bad.\n\nAn earlier blog on having \"continuous\" \"living\" systems was a good case for\ndynamic languages - however, even this can be managed with clusters of\nproperly-separated static systems.\n\n    11:37 AM, February 13, 2008\nSterling \"Chip\" Camden said...\n\n    \n\n\"Or you can spend years creating mountains of class hierarchies and volumes of\nUML in a heroic effort to tell people stories about all the great code you're\ngoing to write someday.\"\n\nI recently turned down an engagement because, even though the potential client\nhad a patented algorithm that he was going to make big bucks, he insisted that\neverything be modeled in UML first, that Java was the only language choice,\nand that data interchange must be in SOAP.\n\n    5:34 PM, February 13, 2008\nFrancis Ouseph said...\n\n    \n\nIf you have a purebred and you lose the paperwork aka documentation you still\nwould have a purebred. Agree but no one does bugfixes or enhancements on a\ndog. Say you want to leave your dog with your neighbor as you are going out.\nYou will certainly give your neignbour some information about the feed and\nfrequency etc etc.\n\nNowadays systems are huge and a one-man-army-veteran cannot write the whole\nsystem by himself. Even if he were able to pull this feat, I am sure it would\nbe impossible for him to compress the code into one page. So he better put\ncomments into what he writes.\n\nNo noob ever puts comments like. do{ //This loop is going to break here. On\nsecont thoughts I think it is a great fart. fart = false; //Please ont fart\ncount ++; //increment count while(fart)\n\nLooks nice only in movies\n\nOn the other noobs just write code (often shabby) without any comments. I was\nlike that in my early days. I still am.\n\n    10:11 PM, February 13, 2008\nDan_D said...\n\n    \n\nI don't know if I would consider myself a senior programmer or junior\nprogrammer but I've never been a fan of comments in code. I believe code\nshould be self-documenting i.e. the meaning should be obvious just by reading\nthe code (I think I've read this somwhere as well - Elements of Java Style\nmaybe?) So much so that I'll refactor one method into two when the method\nsignature doesn't obviously describe the behvaiour of that method. Although\nthis does contribute to code bloat I still think its better than writing in a\ncomment and distracting the reader from following the code flow. I only write\n(short, inline) comments when the code isn't intuitive. I have found that the\namount of white space I have in code has tended to reduce over time though,\nalthough I not really sure why this is.\n\n    1:32 AM, February 14, 2008\ntimocratic said...\n\n    \n\nJust because you haven't seen it doesn't make it so, Dan_D - some beginners\nreally do comment like that. Maybe you should just be glad you haven't\nencountered it. ;)\n\nPersonally I suspect it is a left over from learning \"best practices\" in\nschool, versus having some real world experience.\n\n    7:05 AM, February 14, 2008\nJohn Snelson said...\n\n    \n\nYour posts always give me plenty to think about. I recently read something of\nan opposite opinion to yours, comparing static types to tests where you\ncompare them to comments. Thought it might interest you.\n\n    9:24 AM, February 14, 2008\ncheriot said...\n\n    \n\nWhen you compare over commenting to static typing, I think you're glossing\nover a fundamental difference. The first reiterates information that's right\nin front of you while the latter places a copy of the information in a useful\nplace (the method signature) while the 'duplication' is several function calls\naway.\n\nI appreciate a argument for dynamic typing that doesn't rail against the 'we\nmust have tooling!' straw man.\n\n    11:15 AM, February 14, 2008\nBob Denny said...\n\n    \n\nI am a big fan of loosely typed languages. I've been programming continuously\nfor over 40 years. I am not a dinosaur stuck in the past, I keep up with the\ntools, languages, concepts, and religions. With that out of the way...\n\nComments need to appear when there is something important that the code\ndoesn't say. I agree that inexperienced programmers over-comment. Looking at\ntheir comments, you see it's mostly a repeat of what the code says. But\nsometimes you make decisions and take actions that are vital to know in the\nfuture when you're looking a t the code to maintain or adjust it. Without the\nbackground info leading up to the decision you run the risk of breaking your\nown code. Well, unless you have a photographic memory for info and decisions\nmaded yin years past.\n\n    12:44 PM, February 14, 2008\nUnknown said...\n\n    \n\nabsolute rubbish.\n\n    9:34 PM, February 14, 2008\nEvan said...\n\n    \n\nNice post, though after some digesting I think it's a roundabout way of\nsaying:\n\n1) Don't over-engineer. 2) It's easy to run wild with object hierarchies and\nover-engineer things.\n\nAlways use the right tool for the job. Static typing applies well to some\nproblems, and dynamic typing applies well to others. I've been a fan lately of\nmixing my C++ with scripting language code.\n\n    6:02 AM, February 15, 2008\nDave Sailer said...\n\n    \n\nIf we're talking about comments and not analyzing programming languages,\ndissecting the static-vs-dynamic typing philosophies, or wondering whether\nsoftware engineering is possible, then I have a comment.\n\nCode says \"how\". Comments say \"what\" and \"why\". Comments should be AT LEAST\none level of abstraction above the code. Comments (or documentation) ARE the\nsystem. Code implements it.\n\nI use the style I learned while working on a COBOL system designed and written\nby Arthur Anderson. Delightful, elegant, keeps comments out of the code too.\n\n// ------------------------ // name: foobar // purpose: Does this, that, etc.\n// by: Joy Full Coder // date: 2005-06-11 // in: Describes meaning of input.\n// out: Describes meaning of output. // notes: *Used only if needed.* // 1 -\nBlah, blah, blah. // 2 - Blah, blah, blah. // 3 - Blah, blah, blah. //\n------------------------ output foobar(input) // ---- 1 ---- code ... code //\n---- 2 ---- code ... code // ---- 3 ---- code ... code end\n\n    11:37 AM, February 15, 2008\njapporo said...\n\n    \n\nShould a team write for the least common denominator? ... I suspect it's a\ngood idea to encourage people to move their stories into design documents and\nleave them out of the code, since a junior programmer forced to work in a\ncompressed code base may well grow up faster.\n\nHey, what about us QA people? We've got to be able read your code too, you\nknow!\n\nOur job is to help find defects and being able to understand how things work\nby reading the code is very helpful. We can learn a modicum of coding skills\nbut we're not developers; please at least meet us half way by leaving enough\ncomments in to make the code intelligible.\n\n    7:41 PM, February 15, 2008\nMorgan Creighton said...\n\n    \n\nObligatory Pascal allusion: \"I have made this [letter] longer, because I have\nnot had the time to make it shorter.\"\n\nStevey wrote: \"This was an especially difficult entry to write.\"\n\nI'm glad, because it was painful for me to read. I had fancied myself as an\narchitect, but I find I might actually be a teenager. Hopefully, this dose of\nhumility is good for my soul.\n\nHowever, we are not paid just to \"get the job done.\" We are also paid to\ndeliver maintainable software. (On good projects, anyway.)\n\nThe examples of metadata that you malign might get in the way of banging out a\nquick solution. But they might also be indispensable for delivering a\nmaintainable system of large scope.\n\nPascal's unedited letter was quick and effective point-to-point communication.\nHowever, I'm sure he would have felt additional editing effort would have been\nworth it, if it had been a published book to be read by many.\n\nThe analogy I'm drawing is that metadata as you describe it (static typing,\ncomments, annotations) become more valuable as the number of people\ncollaborating on the project grows.\n\n    6:36 AM, February 16, 2008\nJohannes said...\n\n    \n\nI agree to most of what you say Stevey. Just one thing: Aren't the names of\nclasses, methods, parameters, variables, properties etc. also some kind of\nmetadata? At least they are not needed by the machine to run the program.\n\nFor me the question remains: What makes one type of metadata more valuable\nthan another?\n\n    8:00 AM, February 16, 2008\nUnknown said...\n\n    \n\nI wonder why are you using the continue variable instead of the catch/throw\nyou teach us the other week? Performance? :)\n\n    6:13 PM, February 17, 2008\nSteve Yegge said...\n\n    \n\nWell, we just got our first link-spam (I deleted it), so I'm turning off\ncomments. Thanks to everyone for playing!\n\n    10:10 PM, February 17, 2008\n\n<< Home\n\n## About Me\n\n    Name: Steve Yegge\n    Location: Kirkland, Washington, United States\n\nView my complete profile\n\n## Previous Posts\n\n  * Emergency Elisp\n  * Blogging Theory 201: Size Does Matter\n  * Code's Worst Enemy\n  * Boring Stevey Status Update\n  * Ten Tips for a (Slightly) Less Awful Resume\n  * Stevey's Tech News, Issue #1\n  * How To Make a Funny Talk Title Without Using The W...\n  * Rhino on Rails\n  * Rich Programmer Food\n  * That Old Marshmallow Maze Spell\n\nDiese Website verwendet Cookies von Google, um Dienste anzubieten und Zugriffe\nzu analysieren. Deine IP-Adresse und dein User-Agent werden zusammen mit\nMesswerten zur Leistung und Sicherheit f\u00fcr Google freigegeben. So k\u00f6nnen\nNutzungsstatistiken generiert, Missbrauchsf\u00e4lle erkannt und behoben und die\nQualit\u00e4t des Dienstes gew\u00e4hrleistet werden.Weitere InformationenOk\n\n", "frontpage": false}
