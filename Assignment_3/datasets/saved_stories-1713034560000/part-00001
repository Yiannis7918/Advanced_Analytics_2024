{"aid": "40022841", "title": "ZkSNARKs and ZkSTARKs: A Novel Verifiable Computation Model", "url": "https://illya.sh/blog/posts/zksnark-zkstark-verifiable-computation-model-blockchain/", "domain": "illya.sh", "votes": 2, "user": "iluxonchik", "posted_at": "2024-04-13 12:53:20", "comments": 0, "source_title": "zkSNARKs & zkSTARKs: A Novel Verifiable Computation Model", "source_text": "zkSNARKs & zkSTARKs: A Novel Verifiable Computation Model\n\nSkip to content\n\n>illya.sh/blog\n\n# zkSNARKs & zkSTARKs: A Novel Verifiable Computation Model\n\nPosted on:April 12, 2024 | at 08:24 PM\n\nIf you\u2019ve heard of blockchain, you\u2019ve likely heard of Zero-Knowledge Proofs\n(ZKP) and protocols build on top of them like zkSNARKs and zkSTARKs. You may\nhave also heard of zkLocus, which leverages these technologies to turn\ngeolocation data into a Real World Asset (RWA) on-chain, and enable private\nand verifiable geolocation sharing. The Ethereum roadmap is strongly focused\non integrating ZKP constructs into the core protocol. The Mina Blockchain is\nnearing the mainnet launch of programmable recursive zkSNARKs, while Polygon\nMaiden is using zkSTARKs to abstract the familiar von Neumann architecture\ninto a Zero-Knowledge Virtual Machine (ZKVM).\n\nIn this article, we will delve into the intricacies of zkSNARKs and zkSTARKs,\nexploring their potential to enable a novel realm of software on which we can\nbuild the technology of tomorrow. We will compare the Verifiable Computation\nModel (VCM) enabled by these ZKP constructs with the traditional model\nemployed by the Ethereum Virtual Machine (EVM), highlighting the limitations\nof the latter and the advantages of the former.\n\nWe\u2019re also going to expand on the VCM definition and break it down into two\ndistinct areas: the Linear Verifiable Computational Model (LVCM) and the\nConstant Verifiable Computational Model (CVCM). These are definitions that I\nhave conceived while formulating the value-proposition of Zero-Knowledge (ZK)\nprotocols like zkSNARKs and zkSTARKs from a practical perspective.\n\nThe LVCM is the one that the EVM uses, and it comes with limitations. The time\nit takes to verify a computation grows linearly with the number of\ninstructions in the smart contract. That means the more complex the contract,\nthe longer it takes to verify. We will explore how this limits the scalability\nof the EVM, and you will understand why ZKPs have been explicitly introduced\ninto the Ethereum roadmap.\n\nOn the other hand, the CVCM is the one used by zkSNARKs and zkSTARKs use, and\nit addresses the limitations of the EVM. While the time that it takes to\nperform a computation is still linear with the computation size, the time it\ntakes to verify it is constant, regardless of how complex the underlying\ncomputation is. Such a model is inherintely scalable, as it allows to chain\nseveral computations together and verifying them all at the same time, in a\nconstant time, cost, and size.\n\nBy breaking down the VCM into these two models, we are able to succintly\nhighlight the value proposition of zkSNARKs and zkSTARKs from a practial\nperspective\n\nThis article is written based on learnings from developing zkLocus - a\npioneering Zero-Knowledge, on-chain, cross-chain, and off-chain protocol,\noffering a disruptive paradigm in private and verifiable geolocation sharing.\nIt allows users to authenticate their presence in specific geographical areas\nwithout revealing exact coordinates. zkLocus brings geolocation data onto the\nblockchain. It offers native bridging, native rollup functionality, and\ninfinite proof compression. zkLocus is built on recursive zkSNARKs, making it\ninherently open to customization and extension.\n\nYou can find more about zkLocus at the following links:\n\n  * zklocus.dev - The official website of zkLocus. Here you can find the latest updates about zkLocus and contact information.\n  * GitHub/zkLocus - The GitHub repository of zkLocus. Here you can find the source code of zkLocus.\n  * x.com/zkLocus - The Twitter/X account of zkLocus. Here you can find the latest updates about zkLocus.\n  * zkLocus Whitepaper - The whitepaper of zkLocus. Here you can find a detailed description of zkLocus and its underlying technology.\n  * zkSafeZones Whitepaper - The whitepaper of zkSafeZones. Here you can find the whitepaper for our intiative aiming at safeguarding civilians in conflict zones, and sets the groundwork for enforcement of the law on-chain.\n  * contact@zklocus.dev - The email address of zkLocus. Here you can contact the zkLocus team.\n\n## Verifiable & Non-Verifiable Computing\n\nRecursive zkSNARKs and zkSTARKs enable a novel verifiable computation model\nthat is infinitely scalable and constant in time, cost, and size. But what\nexactly does it mean for a computation to be verifiable? How that model differ\nfrom traditional Web 2 applications written in languages like JavaScript,\nPython, or Java? Can we have a verifiable computation model that does not\nutilize Zero-Knowledge Proofs (ZKP)?\n\nIt\u2019s important to answer all of these and other questions in order to\nunderstand the value proposition of Zero-Knowledge Proof protocols like\nzkSNARKs and zkSTARKs, as well blockchains that are built on top of them, like\nMina Protocol. Throughout this section, we will explore the differences\nbetween \u201ctraditional\u201d non-verifed computation models and verifiable\ncomputation models, and later how zkSNARKs and zkSTARKs enable the latter.\n\n### Non-Verifiable Computation Model (NCM)\n\nIn a Non-Verifiable Computation Model (NCM), the computation is performed by a\nsingle or a group of entities, and the result is shared with other entities.\nThe other entities have no way of verifying that the computation was performed\ncorrectly. They must trust the entity that performed the computation. This\ntrust is often misplaced, as the entity may have an incentive to manipulate\nthe result of the computation in their favor.\n\nThe vast majority of computer programs are implemented under this model. In\norder to understand what that means, let\u2019s explore an example. Suppose you are\ngoing to implement a social networking platform, where users can post messages\nand interact with each other. You implement it using your programming language\nand framework of choice, such as Python & Django, JavaScript, NodeJS & React\nor Java & Spring. You deploy the application to a server, and users can access\nit through a web browser.\n\nYou pinky-promise to the users that you will not store their messages and that\nyou will not share their data with third-parties. However, there is nothing\nenforcing that. The users must trust you, and you may lie, whether\naccidentally or deliberately. Open-sourcing your product does not solve the\nproblem, as there is nothing ensuring that the deployed version of the\napplication is the same as the open-sourced one.\n\n### Verifiable Computation Model (VCM)\n\nContrasting with Non-Verifiable Computation Model is the Verifiable\nComputation Model (VCM). In this model, there is a way to prove that the\ncomputation was performed by exclusively executing a pre-defined set of\ninstructions. In other words, it is possible to prove that a particular piece\nof code was executed, without any tampering in the process.\n\nSmart contracts on blockchains like Ethereum, Mina, and Polygon are examples\nof applications that utilize the Verifiable Computation Model. The smart\ncontract contains instructions to execute on the blockchain state and updates\nto that state. For a smart contract execution to be accepted and applied on\nthe blockchain, the participants of the blockchain network must reach a\nconsensus that the execution was valid. This consensus is only reached if the\nexecution was performed correctly, precisely according to the instructions in\nthat smart contract and blockchain state.\n\nIf you were to implement your social networking platform using smart contracts\non the blockchain, your users would no longer need to trust you, but rather\nthe blockchain network. Since the network only accepts a smart contract\nexecution transaction if the instructions in that smart contract were executed\nverbatim, we can say that the computation is verifiable.\n\n## The Etherum Virtual Machine\u2019s (EVM) Verifiable Computation Model\n\nAs mentioned previosly, the EVM enables a Verifiable Computation Model, where\nthe execution of smart contracts, alongside their inputs (smart contract\nfunction arguments and existing blockchain state), outputs (blockchain state\nupdates) is cryptographically attested. This is achieved by having network\nparticipants (validators) re-execute the smart contract on their own machines\nand compare the result with the result of the original execution. If the\nresults match, the execution is considered valid and is applied to the\nblockchain state. If the results do not match, the execution is considered\ninvalid and is rejected. Anyone can verify whether a particular smart contract\nexecution was valid by re-executing the smart contract on their own machine\nand comparing the result with the result of the original execution.\n\nYou can think of it as a \u201cbrute-force\u201d approach at verifiable computation. In\norder to verify if a claimed smart contract execution is correct, you re-\nexecute it yourself and compare the result with the result of the claimed\nexecution. If the results match, the claimed execution is correct. If the\nresults do not match, the claimed execution is incorrect. If the smart\ncontract has 10 instructions, you\u2019ll need to re-execute those 10 instructions\non your own machine, if the smart contract has 100 instructions, you\u2019ll need\nto re-execute those 100 instructions on your own machine, and so on. This\nverification process needs to be performed by all validators in the network.\n\nA naive implementation of this verifiable computation model leaves the\nblockchain network vulnerable to a Denial of Service (DoS) attack. An attacker\ncan deploy a smart contract with a large number of instructions, forcing\nvalidators to re-execute those instructions, and thus slowing down or taking\ndown the network. Ethereum solves problem in two ways: by charging gas fees\nfor smart contract execution and by limiting the number of instructions in a\nsmart contract. The gas fees ensure that the attacker pays for the\ncomputational resources they consume, while the instruction limit ensures that\nthe attacker cannot consume an excessive amount of computational resources.\n\n### Public & Private Data On EVM\n\nThe EVM\u2019s Verifiable Computation Model is limited to public data. This means\nthat the inputs to a smart contract execution, the smart contract function\narguments, and the existing blockchain state must be public. This is because\nthe validators need to re-execute the smart contract on their own machines,\nand they cannot do that if the inputs are private. For example, if a smart\ncontract execution involves a private key or a secret value known only to the\ntransaction submitter, the validators cannot re-execute the smart contract on\ntheir own machines, as they do not have access to the private key or that\nvalue. This limitation makes it impossible to execute smart contracts that\ninvolve private data, such as personal information, financial information, and\nencryption keys.\n\n### Limitations\n\nThe Ethereum Virtual Machine\u2019s (EVM) Verifiable Computation Model has several\nlimitations:\n\n  * Limited Complexity: The most obvious limitation of the EVM\u2019s VCM is the limited size & time complexity of computer programs (smart contracts) whose execution can be verfied under the VCM. The strict gas fee limits make it impossible to execute complex programs on the EVM. For example, it is not possible to run a complex algorithm for several hours or days and submit the result of that execution to the blockchain. Examples of such algorithms include machine learning models, simulations, predictions and games.\n\n  * Limited Scalability: Due to the constraint of having to re-execute the entire smart contract on all validators\u2019 machines, the EVM\u2019s VCM scalability is limited. This is caused by the redundancy of the execution: not only the transaction submitter must execute the smart contract, but all validators must do so as well.\n\n  * Energy Inefficiency: The EVM\u2019s VCM is energy inefficient, as it requires all validators to re-execute the smart contract on their own machines. This is a waste of computational resources, as the smart contract execution is already performed by the transaction submitter. If we assume that the execution of a smart contract to have cost K energy units, then the total energy cost of the smart contract execution on the EVM is N * K + 1, where N is the number of validators, and 1 is the initial execution by the transaction submitter.\n\n  * Limited Privacy: In the EVM\u2019s VCM the computation is performed on public data. This means that all of the execution inputs, outputs, and intermediate states are publicly visible. This is a significant limitation, as it makes it impossible to perform computations on private data, such as personal information, financial information, and encryption keys.\n\n## zkSNARKs & zkSTARKs: A Novel Verifiable Computation Model\n\nZero-Knowledge Proofs (ZKP) enable one party (the prover) to prove to another\nparty (the verifier) that a statement is true, without revealing any\ninformation about the statement itself. zkSNARKs and zkSTARKs are two types of\nZero-Knowledge Proofs that are used in blockchain applications to enable a\nnovel verifiable computation model, which addresses the limitations of the\nEVM\u2019s Verifiable Computation Model.\n\n### zkSNARKs and zkSTARKs\n\nzkSNARKs and zkSTARKs are cryptographic protocols built using Zero-Knowledge\nProofs that enable a prover to prove to a verifier that a computation was\nperformed correctly, without revealing the computation itself. zkSNARKs and\nzkSTARKs are used in blockchain applications to enable a novel verifiable\ncomputation model, which is infinitely scalable, constant in time, cost, and\nsize, and private.\n\nWhile there are differences between zkSNARKs and zkSTARKs, they are of little\nrelevance for the purpose of this article. As such, we will use the term\nzkSNARKs and zkSTARKs interchangeably.\n\nFor a detailed and practial explanation of zkSNARKs consult my article\ncovering zkSNARKs. It iteratively explains the concept of zkSNARKs, starting\nfrom the basics of Zero-Knowledge Proofs(ZKP), then using this knowledge to\nexplain zkSNARKs, then diving into recursively composing zkSNARKs, and finally\nwith a practical implementation of a zkSNARK calculator using O1JS.\n\n### zkSNARKs & zkSTARKs: Observation Of A Computation\n\nUnlike in the EVM Verifiable Computation Model, where the validators re-\nexecute the smart contract on their own machines, in the zkSNARKs & zkSTARKs\nVerifiable Computation Model, the prover generates a proof that the\ncomputation was performed correctly, and the verifier verifies that proof. The\nverifier does not need to re-execute the computation on their own machine, as\nthe proof is sufficient to attest to the correctness of the computation,\nalongside all of its inputs and outputs.\n\nIn this sense, a zkSNARKs/zkSTARKs proof represents a cryptographic\nobservation of a computation. The prover generates the proof, and the verifier\nverifies the proof:\n\n  * The prover is the entity submitting the smart contract execution transaction onto the blockahin. It does so, by generating a proof of execution.\n  * The verifier is the network participant that validates the transactions submitted on-chain. It does so, by verifying the proof of the execution submitted by the prover.\n  * The proof is the cryptographic observation of the computation, generated by the prover. This proof encompasses the correct execution of the smart contract, alongside all of its inputs and outputs.\n  * The verification is the process of validating the proof, performed by a verifier or any other network participant. The verification can be performed in approximately constant time, cost, and size, regardless of the complexity of the underlying computation.\n\nAs such, zkSNARKs and zkSTARKs enable a VCM by producing a cryptographic proof\nof an ovservation of a computation, alongside all of its inputs and outputs.\nTo verify the correctness of the computation, it\u2019s not necessary to re-execute\nthe whole computation, but to only verify the proof of the observation of that\ncomputation. In general terms, verifying the proof is faster than generating\nthe proof.\n\n### Run Once, Prove Everywhere\n\nThe zkSNARKs & zkSTARKs Verifiable Computation Model is based on the principle\nof \u201crun once, prove everywhere\u201d. This means that the computation is performed\nonce by the prover, and the proof of that computation is verified by the\nverifiers. The prover does not need to re-execute the computation for each\nverifier, as the proof itself is sufficient to attest to the correctness of\nthe computation. This is in contrast to the EVM Verifiable Computation Model,\nwhere the computation is re-executed by all validators. Given that the\nverification of the proof is faster than the generation of the proof, this\nmodel brings several advantages over the EVM-based architecture.\n\n### Shifting The Workload To The Client-Side\n\nWhile in the EVM the workload is equally distributed between the participants\nof the consensus protocol, in the zkSNARKs & zkSTARKs Verifiable Computation\nModel the workload is shifted to the client-side (the prover). The vast\nmajority of the energy consumption happens on the client\u2019s/prover\u2019s side,\nduring the generation of proof of the observation of the computation.\n\n### Proof Of Everything\n\nProof of everything is a term coined by Will Cove, the Head of Community at\nMina Foundation. It enables a practial mental model for looking at the\nVerifiable Computation Model provided by zkSNARKs and zkSTARKs. The idea is\nthat users (clients) generate proofs of computations on their local devices,\nand then share those with the desired entities (verifiers). The data on which\nthe proofs are generated can remain fully private, without ever leaving the\nclient\u2019s device.\n\nWhen the zkSNARK/zkSTARK VCM with the blockchain, those proofs are shared with\nthe blockchain consensus participants. In the case of the Mina blockchain, you\ncan think of the blockchain as the verifier, and the clients submitting\ntransactions as the provers. Each proof is a cryptographic observation of a\ncomputation, alongside all of the inputs (both public and private) and changes\nto the on-chain state (outputs).\n\n### Recursive zkSNARKs and zkSTARKs\n\nWhile the concept of being able to produce an ovservation of a computation is\npowerful, it would be very limited if it was not possible to compose these\nobservations with one another. In practice this means enabling zkSNARKs and\nzkSTARKs to receive other zkSNARK and zkSTARK proofs as inputs, thus allowing\nto combine arbitrary computations with one another, and use the output of one\ncomputation as the input of another, while keeping still compressing all of\nthis computation into a single proof.\n\nUnderstanding the recursive aspect of zkSNARKs and zkSTARKs means\nunderstanding the Verifiable Computation Model enabled by them. An\nintrinsicate explanation of this powerful mechanism is outside of the scope of\nthis article, but it\u2019s covered in detail in my article on recursive zkSNARKs.\nI invite everyone eager to master these concepts and the practical mental\nmodel of ZKPs to read it.\n\n### Private Data As A First-Class Citizen\n\nIn the realm of Web3, privcy is of paramount importance. Web 3 is not about\ntaking over the existing Web 2 solutions of today, but rather about building\nthe solutions of tomorrow. Internet was never built for privacy, and in most\nexisting products privacy is treated as a feature, and often implemented as an\nafterthought. A big misconception is that blockchains are all about privacy,\nbut in reality, they are all about transparency, integrity and authenticity.\nIn fact, the applications on blockchains like Ethereum are more private than\n\u201ctraditional\u201d applications, not due to the blockchain techology itself, but\ndue to the hyper-public nature of all of the data that you store on it. Given\nthat every piece of information that you submit to the blockchain is public,\nand the fact the blockchain acts as a \u201cglobal database\u201d, building an\napplication in a manner that is not private by design is almost a guarantee of\nuse of that information for malicious purpuses, often with a moentary or\nprivacy cost to the user.\n\nThis requirement for public data is a inherent requrement of the Verifiable\nComputational Model employed by the EVM. Since the whole computation has to be\nre-run verbatim by the consensus protocol participants, those participants\nmust have access to all of the data that was used in the computation.\nVerifiable computation protocols engineered using ZKPs, like zkSNARKs and\nzkSTARKs have the concept of private inputs and public inputs. Both serve as\nintputs (arguments) to the computation, but while the public inputs are shared\nwith the verifiers, the private inputs are kept private to the prover. The\nverifier only needs to have access to the public inputs, not the private\ninputs, in order to verify the correctness of the computation. We can think of\nthe Verifiable Computation Model of EVM as one where all of the inputs to the\ncomputation are public. These aspects are covered in depth in my article on\nzkSNARKs.\n\n#### Private Data On The EVM\n\nAs discussed earlier, the EVM does not support private inputs to the\ncomputation. If an application on the EVM requires private data, they usually\nachieve this by deploying zkSNARK verifiers as a smart contract on the\nblockchain. This is what tools like ZoKrates do. This is also the manner by\nwhich Polygon Hermez L2 rolls-ups (compresses) transactions into a single\nproof, and then submits that proof to the Ethereum L1 blockchain.\n\nWhile it is possible to use zkSNARKs on the EVM, it is impractical to do so,\nas you are severely limited by the gas fees and the instruction limits. This\nis where zkSNARK-native blockchains like Mina Protocol disrupt with their\nvalue proposition.\n\n### It Ain\u2019t Nothin But A Polynomial Thang\n\nDo not get anxious if it takes you some time to gasp the concepts covered here\nfully. Having built zkLocus - a first of its kind solution for authenticated,\nprivate and programmable geolocation sharing off & on-chain, I can tell you\nfrom the first-hand experience, that as long as you continiously learn and\nchallenge your own ideas, you will eventually contruct the mental model which\nwill enable you to engineer disruptive solutions while you\u2019re taking a shower.\n\nZero-Knowledge based computation is very distinct from the programming\nlanguages modelled on the von Neumann architecture. When you are programming\nin languages like Solidity, JavaScript, Python, Java or Scala, you are\nessentially instructing your computer to store data in registers and perform\nmathematical operations on that data. You have constructs like if statements,\nwhich allow you to branch the execution based on the value of a variable, and\nloops, which allow you to repeat a block of code multiple times. In Zero-\nKnowledge proofs, there is no such thing as branching logic or loops. Instead,\nthe computation is represented as a polynomial, and the proof is generated by\nevaluating that polynomial at a specific point. The verifier then checks that\nthe polynomial was evaluated correctly, and that the result is consistent with\nthe inputs and outputs of the computation.At the core of this difference is\nthe fact that Zero-Knowledge Proofs are just polynomials.\n\n#### What Is A Polynomial? Is It The Same As An Equation?\n\nIt\u2019s important to not only understand what are polynomials, but also\nunderstand how they differ from mathematical equations. You likely immersed\ninto equations in high school maths (if you learned them on your own, big\nprops to you!!), but in this context it\u2019s likely that you learned how to solve\nthem without thinking too deeply about it.\n\nAn equation is a mathematical statement that asserts the equality of two\nexpressions. For example, 3x + 2 = 8 is an equation, where 3x + 2 is one\nexpression, and 8 is another expression. The goal is to find the value of x\nthat makes the equation true. In contrast, a polynomial is a mathematical\nexpression that consists of variables, coefficients, and exponents. For\nexample, 3x^2 + 2x + 1 is a polynomial, where x is the variable, 3, 2, and 1\nare the coefficients, and 2, 1, and 0 are the exponents. The polynomial is\nevaluated by substituting a value for the variable, and then performing the\nmathematical operations. For example, if we substitute x = 2 into the\npolynomial 3x^2 + 2x + 1, we get 3 * 2^2 + 2 * 2 + 1 = 3 * 4 + 2 * 2 + 1 = 12\n+ 4 + 1 = 17.\n\nIn the context of Zero-Knowledge proofs, computations are represented as\nsystems of polynomial equations, which are sets of polynomial equations that\nare solved together. These systems are deterministic and do not have the\nconcept of traditional control flow like loops or conditional branches.\nInstead, all possible paths of execution are computed, and the correct result\nis selected based on the inputs.\n\n#### Control Flow In Zero-Knowledge Proofs: Loops & Conditional Branches\n\nAs mentioned previously, Zero-Knowledge circuits are deterministic, which\nmeans that branching and dynamic structures and loops are not possible. Does\nthat mean that you can\u2019t have conditional logic or loops in Zero-Knowledge\nproofs? Not exactly. You can mimic the behavior of conditional logic and loops\nin Zero-Knowledge proofs, but the structure of the circuit has to be fixed:\n\n  * For conditional logic, you can\u2019t just execute one branch of the computation based on a condition. Instead, you have to compute both branches and then use the condition to select the correct result. This is often done using a multiplexer, a circuit element that takes a condition and two inputs, and outputs the value of one of the inputs based on the condition.\n\n  * For loops, you can\u2019t have a variable number of iterations, because the circuit size has to be fixed. Instead, you have to unroll the loop to a fixed number of iterations. If the maximum number of iterations is not known in advance, you have to set a limit and design the circuit to handle the maximum possible number of iterations.\n\nSo, while you can mimic the behavior of loops and conditional branches in\nZero-Knowledge proofs, it\u2019s not the same as in traditional programming\nlanguages. The computation has to be deterministic and the structure of the\ncircuit has to be fixed. In practice this means that you need to adapt your\nmental model and design your solution to respect the framework of Zero-\nKnowledge circuits, rather than trying to fit the Zero-Knowledge circuits into\nthe framework of traditional programming languages. Architecting and designing\nZero-Knowledge applications is extremely fun and rewarding. In my personal\nexperience of building a first-of-its kind authenticated & private geolocation\nprotocol zkLocus, I have found that I always manage to address every technical\nchallenge that I faced, and that I always come out of it with a better\nunderstanding of the technology and a more refined mental model of how to\nengineer solutions on top of it. Do not let the initial friction that you may\nface to discourage you.\n\n## Combining zkSNARKs & zkSTARKs With The Blockchain\n\nBlockchains excel as an authenticated, transparent, distributed, fault-\ntolerant and integirty-assured state machine and data storage layer. Changes\nto on-chain data are performed during state transitions, and state transitions\nare encoded in transactions. zkSNARKs and zkSTARKs excel at representing\nverifiable computation. You can combine both in a way where each blockchain\ntransaction is represented by a zkSNARK or zkSTARK proof. In the case of a\nsmart contract execution, this proof contains the proof of the observation of\nthe execution of the smart contract\u2019s code, alongside any changes to the on-\nchain state resulting from the execution of that smart contract. In such an\narchitecture, zkSNARK/zkSTARK proofs represent the execution layer, and the\nblockchain the data storage layer. The client submitting the transactions are\nthe prover, and the blockchain is the verifier.\n\nThe previous paragraph encompasses the core idea of how blockchains leveraging\nthe Verifiable Computation Model enabled by zkSNARKs and zkSTARKs operate. It\nalso provides an intuition on how Zero-Knowledge Applications (zkApps) built\non top of those architectures operate. But let\u2019s not just leave it at the\nintuition level. Developing a solid understanding of these concepts will\nenable you to construct a mental model which you can apply to novel scenarios,\nand engineer disruptive solutions. With this in mind, we will now explore how\nzkSNARKs and zkSTARKs are used in the Mina Protocol and Polygon Maiden\nblockchains, as well as analyze how zkLocus is using Mina and zkSNARKs to turn\ngeolocation data into a Real World Asset (RWA) on-chain, and enable private,\nverifiable and programmable geolocation sharing.\n\n### The Mina Protocol Blockchain\n\nThe Mina Protocol blockchain works, by combining zkSNARKs with the Ouroboros\nSamasika consensus protocol. When developing applications/smart contracts on\nMina, you are writing zkSNARKs circuits designed to represent an observation\nof a computation. You can think of Mina, as \u201clow-level\u201d zkSNARKs blockchain,\nwhere you are directly interacting with zkSNARKs circuits. This gives Mina the\nunique value proposition of flexibility and portability. By exposing and\nallowing to operate on and compose raw zkSNARKs proofs, it allows to you to\nfreely use those constructs without an opinianated abstraction on top. Given\nthat Mina operates on raw zkSNARKs, it means that those zkSNARKs can be used\nand integrated with systems outside of Mina. This is how zkLocus operates\nnatively on the Mina blockchain, but can also be used with other blockchains,\nor even in an off-chain environment, such as as with Web 2. Refer to the\narticle introducing zkLocus for more information.\n\nIn Mina, you write zkSNARKs in JavaScript/TypeScript, by using the O1JS\nframework, which acts as a Domain Specific Language (DSL). O1JS is based on\nSnarkJS, which is the lower-level implementaion of zkSNARKs in JavaScript. You\nencode the Zero-Knowledge and their constraints using the basic constructs\nprovided by O1JS, which later get compiled down to zkSNARKs. Those zkSNARKs\ncan then be either used directly on the Mina blockchain, or exported and used\nin other environments, including off-chain. You can find a practical guide on\nhow easy it is to write zkSNARKs in O1JS in my article covering zkSNARKs.\n\nIf you are keen on being up to date with the latest developments and projects\non Mina, comMINAty is a great Twitter/X acccount to follow. It\u2019s lead by the\nsame team behind zkok.io, where zkLocus is also listed.\n\n### zkLocus + Mina Protocol\n\nzkLocus is an application, a framework and a protocol, which leverages\nzkSNARKs to turn geolocation data into a Real World Asset (RWA) on-chain, and\nenable private, verifiable and programmable geolocation sharing. zkLocus is\nimplemented natively on the Mina blockchain, and this is where we are\ndeveloping $ZKL token - the native token of the zkLocus protocol, alongside\nits utility use-cases. At the same time, it\u2019s possible to use zkLocus with\nother blockchains, or even in an off-chain environment, such as with\ntraditional Web 2 applications. At the core of the architecture of zkLocus\nthere are two main components:\n\n  1. The raw zkSNARKs circuits (known as ZkPrograms in O1JS), on top of which zkLocus builds its application chain and execution logic. These zkSNARKs circuits are compatible with the Mina blockchain, but they can also be used independently, with other blockchains, or even in an off-chain environment. The zkSNARKs circuits are designed to represent the observation of a computation, alongside all of its inputs and outputs. The zkSNARKs circuits are written in JavaScript/TypeScript, using the O1JS framework, which acts as a Domain Specific Language (DSL) for zkSNARKs. The output of the execution of these zkSNARKs circuits is a zkSNARK proof, which can then be verified by anyone and have its public outputs extracted.\n\n  2. The smart contracts that are deployed on the Mina blockchain and serve as an interface between the raw zkSNARKs application chain of zkLocus and the Mina blockchain. These smart contracts are also written in JavaScript/TypeScript, using the O1JS framework, and it\u2019s trivial to integrate the raw zkSNARK proofs with them. Under the hood, the smart contracts are abstractions on top of the same ZkProgram primitives, adapted to be compatible with the execution layer offered by the Mina protocol.\n\nGiven the goal of offering geolocation as a Real World Asset (RWA) on-chain,\nwhile maintaining flexibility and portability, zkLocus found its perfect match\nwith Mina \ud83d\udc9c. While it\u2019s indeed possible to verify zkLocus proofs direcly in\nlanguages like JavaScript, TypeScript and Rust, as well as verify and use\nzkLocus proofs on other blockchains like Ethereum, the easiest way of\nintegrating zkLocus with other blockchain technologies could be through\nbridging. The reality is that verifying complex zkSNARK proofs on blockchains\nlike Ethereum will probably cross the gas limits, while also presenting\nchallenges for their direct integration.\n\n### The Polygon Maiden Blockchain\n\nPolygon Maiden is another blockchain that uses Zero-Knowledge Proofs at the\nexecution layer, by leveraging zkSTARKs to build a zkEVM with familiar x86\nassembly-like instructions. When writing smart contracts on Polygon Maiden,\nyou are not interacting with zkSTARKs directly, but instead writing assembly-\nlike instructions which operate as a virtual machine. The execution of that\nvirtual machine is \u201ccryptographically observed\u201d by zkSTARKs. Such virtual\nmachine constructs are referred to as a zero-knowledge virtual machine (zkVM).\n\nThe smart contract code that you write on Polygon Maiden would be similar to\nthe one that you would write in languages like Solidity, Python and\nJavaScript. The Polygon Maiden VM is turing-complete, and exposes you to the\nfamiliar flow control constructs like if statements and loops. The Polygon\nMaiden\u2019s VM can be thought of as a foundational layer, similar to WebAssembly\n(WASM). It\u2019s designed to provide a basic set of instructions that can be\nfurther abstracted. Just as WASM allows high-level languages like JavaScript\nto be compiled down to it, the Polygon Maiden\u2019s VM is designed to support\nhigher-level languages. This design enables developers to write code in\nfamiliar languages, which can then be compiled down to run on the Polygon\nMaiden\u2019s VM. The execution of a transaction involves a coordinated interaction\nbetween various components of the protocol.\n\n### What Is A Computer Program?\n\nIn order to build an ever deeper understanding of how blockchains with\nexecution layer based on Zero-Knowledge Proof constructs like zkSNARKs and\nzkSTARKs operate, let\u2019s analyze what a computer program is. At a more abstract\nlevel, a computer program is a set of instructions that a computer executes,\nwhile following a stric set of rules. Several computer programs can be\ncomposed together to form an even more abstract entity, which materializes\nitself as a product that solves a problem, by addressing a need. This level of\nthinking is extermely valuable when architecting solutions, but it may not be\nsufficient to fully gasp the intricacies of zkSNARKs and zkSTARKs.\n\nAt a more concrete level, a computer program is composed of the following 3\ncomponents:\n\n  1. The set of instructions to be executed.\n  2. The inputs (arguments) to the computation.\n  3. The outputs (results) of the computation.\n\nIn order to construct a Verifiable Computation Model, it is necessary to\ncryptographically \u201cobserve\u201d the execution of the computer program, alongside\nall of its inputs and outputs. As such, it\u2019s not sufficient to merely provide\na proof of the correct exeuction of the instructions, but also that that\nexecution was performed on specific inputs, and that the outputs are\nconsistent with the inputs and the execution of the instructions. This is\nprecisely how zkSNARKs and zkSTARKs operate. They provide a cryptographic\nobservation of the computation, alongside all of its inputs and outputs.\nVerifying the Zero-Knowledge Proof of a program execution, means also\nverifying the correctness of the inputs and outputs of that computation, as\nthey are all cryptographically linked with one another in the proof. In other\nwords, to generate zkSNARKs/zkSTARKs proof of an \u201cobservation of a\ncomputation\u201d means to produce a cryptographic proof that a specific set of\ninstructions (computer program/zero-knowledge circuit/smart contract) were\nexecuted, and that those instructions were executed on specific inputs, and\nthat the outputs of that computation are consistent with the inputs and the\nexecution of the instructions. Changing any of the inputs, outputs or the\ninstructions would result in an invalid proof.\n\n## zkSNARKs & zkSTARKs: Addressing The Limitations Of The EVM\u2019s VCM\n\nNow that we\u2019re equiped with a mental model of the means by which zkSNARKs and\nzkSTARKs operate, we are ready to understand how their unique properties\naddress the limitations of the EVM\u2019s Verifiable Computation Model.\n\n### Arbitrary Complexity\n\nThe EVM\u2019s Verifiable Computation Model is limited by the gas fees and the\ninstruction limits. This makes it impossible to execute complex programs on\nthe EVM. In contrast, zkSNARKs and zkSTARKs enable a novel verifiable\ncomputation model that is infinitely scalable and constant in time, cost, and\nsize. This means that you can execute complex algorithms on zkSNARKs and\nzkSTARKs, without being limited by the gas fees and the instruction limits.\nFor example, you can run a complex algorithm for several hours or days and\nsubmit the result of that execution to the blockchain. Examples of such\nalgorithms include machine learning models, simulations, predictions, and\ngames.\n\nThis is enabled by the fact that verifying a zkSNARKs/zkSTARKs proof takes\napproximately constant time, cost, and size, regardless of the complexity of\nthe underlying computation. This is in contrast to the EVM, where the\nverification of a smart contract execution takes time, cost, and size\nproportional to the complexity of the smart contract. In the section that\nfollows we will explore how this allows us to further refine the definition of\nour Verifiable Computation Model.\n\n### Infinite Scalability\n\nzkSNARKs and zkSTARKs provide a unique value proposition of infinite\nscalability. This is enabled by the recursive nature of zkSNARKs and zkSTARKs,\nwhich allows for a zkSNARK/zkSTARK circuit to receive other zkSNARK/zkSTARK\nproofs as inputs, and then use the outputs of that computation within its\nlogic. This allows for the composition of arbitrary computations, and the\ncompression of all of those computations into a single proof. This is in\ncontrast to the EVM, where the computation is re-executed by all validators,\nand the scalability is limited by the redundancy of the execution. In\npractice, this means that you can grab 1000 individual proofs, and compress\nthem all together into a single proof. That single proof (not referring to its\nmarital status, but rather numeric quantity) contains cryptographic\nobservation of the computation of all of those 1000 individual proofs,\nalongside all of their inputs and outputs. The time to verify that single\nproof is approximately the same as the time to verify a single proof. This is\nthe essence of infinite scalability.\n\n#### Layer 2 (L2) Solutions On Ethereum (Validiums)\n\nYou can now understand why most Layer 2 (L2) solutions on Ethereum are built\nusing zkSNARKs and zkSTARKs. They allow for the compression of multiple\ntransactions into a single proof, which can then be submitted to the Ethereum\nblockchain. This is how solutions like Polygon Hermez L2 roll-ups work. They\nprocess the transactions performing computations on their own side-chain, and\nthen produce compress multiple transactions into a single proof, and then\nsubmit that proof to the Ethereum L1 blockchain. In such a setup, the Ethereum\nL1 blockchain acts as a verifier, and the L2 side-chains acts as a prover.\nEthereum L1 becomes a verifier by having a smart contract that can verify the\nproof, and the L2 side-chain becomes a prover by generating the proof of the\nobservation of the computation. L2\u2019s that operate in this manner are known as\nvalidiums, since they validate the correct execution of the transactions and\nstate changes on their side-chain, and then store a cryptographic commitment\nto that execution on the Ethereum L1 blockchain. Such approaches at scaling\nEthereum, known as roll-ups, have been so successful that their ideas have\nbeen included into the roadmap of Ethereum.\n\n#### zkLocus As A Mina Roll-Up\n\nFollowing the perspective of infinite scalability, zkLocus can be seen as a\nroll-up on Mina. By having all of the computation performed off-chain, and\nthen integrating those computations with one another and compressing them into\na single proof, zkLocus effectively uses Mina for settlement and storage. Once\na geolocation proof is verified on Mina, it is stored on the blockchain, thus\nenabling the geolocation data to be used as a Real World Asset (RWA) on-chain.\nSince zkLocus focuses on rolling-up/compressing/combining computations\npretinent to its own logic (everything related to its functionality and\nfeatures), it\u2019s called an application-specific roll-up/application chain (app\nchain). This is in contrast to general-purpose roll-ups, which aim to compress\nall of the transactions on a blockchain into a single proof.\n\n### Energy Efficiency\n\nGiven the features of proof verification being approximately constant in time,\ncost, and size, regardless of the complexity of the underlying computation, as\nwell as the ability to compress multiple proofs into a single proof, zkSNARKs\nand zkSTARKs are energy efficient. This is in contrast to the EVM, where the\ncomputation is re-executed by all validators, and the energy cost of the\ncomputation is proportional to the number of validators and computational\nsteps (smart contract instructions). In practice, this means that the energy\ncost of verifying a zkSNARKs/zkSTARKs proof is approximately the same,\nregardless of the complexity of the underlying computation. This is a\nsignificant advantage, as it allows for the execution of complex algorithms on\nzkSNARKs and zkSTARKs, without incurring a significant energy cost.\n\n### Privacy\n\nAs discussed earlier, the EVM\u2019s Verifiable Computation Model is limited by the\nrequirement that all of the inputs to the computation are public. zkSNARKs and\nzkSTARKs proofs represent a cryptographic observation of the computation and\nsupport two types of inputs:\n\n  1. Public inputs - these are inputs to the computation that are used when generating the proofs, and are shared with the verifier(s). The verifier(s) then use these inputs to verify the correctness of the computation. As such, public inputs are used to generate the proof, and then to verify that same proof.\n  2. Private inputs - these are inputs to the computation that are used to generate the proofs, but are not shared with the verifier(s). The verifier(s) do not need to know the private inputs in order to verify the correctness of the computation. Private inputs remain known only to the prover, but not the verifier. In other words, these are arguments to the computation that are kept private to the prover (client), and are not shared with the verifier (blockchain/consensus participants). A private input to a computation is also referred to as a witness.\n\nThe support for private arguments/inputs offers a significant advantage, as it\nallows for the execution of computations on private data, such as personal\ninformation, financial information, and encryption keys. This is in contrast\nto the EVM, where the computation is performed on public data, and all of the\ninputs, outputs, and intermediate states are publicly visible.\n\n#### Secret Values On Ethereum\n\nWhile it is technically possible to have private inputs/secret values on\nEthereum, it is impractical and comes with limitations. The way you achieve it\nis by deploying zkSNARK verifiers as smart contracts on the blockchain. This\nis what tools like ZoKrates do. The impracticality and limitations come from\nthe fact that you are severely limited by the gas fees and the instruction\nlimits. Zero-Knowledge Proofs are polynomials and mathematical operations on\nthose polynomials. Verifying a proof takes a lot of computational steps. The\nEVM execution model\u2019s scope falls outside of these applications. This is where\nzkSNARK-native blockchains like Mina Protocol disrupt with their value\nproposition.\n\n## zkSNARKs & zkSTARKs: Beyond Blockchain\n\nzkSNARKs & zkSTARKs are frequently used in the context of blockchains, but\nthey do not have to be. Given the information we\u2019ve covered so far in this\narticle, the statement that zkSNARKs & zkSTARKs can exist outside the realm of\nblockchains should not come as a surprise. This is, however, something very\nimportant to understand, even at the risk of over-repeating it. The Verifiable\nComputational Model enabled by zkSNARKs & zkSTARKs is independent of the\nblockchain technology, in fact, most of the Zero-Knowledge mathematics predate\nthe blockchain technology. Although it was the developments in the blockchain\nspace that propelled the interest in ZKP at an exponential rate. As such, the\nblockchain is simply an environment where these Zero-Knowledge protocols\nflourish. Think about it this way: if we would like to prove computations to\none another we would end up to have to share these computations with one\nanother, alongside all of the shared state. To address this, we would end up\ncreating something like the blockchain.\n\n### zkLocus: Off-Chain Geolocation Sharing\n\nAs already mentioned, zkLocus can operate completely off-chain. In fact, the\ncore Zero-Knowledge circuits of zkLocus are designed as fully independent\nobservations of the computations, and thus can be operated on directly,\nwithout ever interacting with a blockchain. One of our ongoing integrations\ninvolves generating and verifying zkLocus proofs off-chain, and then bridging\npart of that data on-chain, while using other for subsequent off-chain\ncomputations.\n\n## Time Complexity of EVM vs zkSNARKs & zkSTARKs\n\nBefore we conclude, and now that we are equipped with a practical\nunderstanding of the novel Verifiable Computational model enabled by zkSNARKs\n& zkSTARKs, we will connect the concepts covered in this article to reason and\ncompare the time complexity of the VCM of the EVM and zkSNARKs & zkSTARKs. In\nthis process, we will further expand on the definition of VCM to clearly\ndistinguish the two models.\n\nThe discussion in this section will not be overlly technical, with the focus\nbeing not on absolute mathematical precision, but rather on providing a well-\nreasoned approximation, which you will find very useful when reasoning and\ncomparing the solutions.\n\n### Time Complexity of Executing The Computation\n\nThe time complexity of executing the computation is generally smaller in the\nEVM than in zkSNARKs & zkSTARKs. This is because in the EVM executing the\ncomputation is simply emulating the virtual machine instructions of the EVM.\nHere, we have familiar constructs like stack, memory, storage and control\nflow. The time complexity of executing the computation in the EVM is linearly\nproportional to the number of instructions executed by the smart contract, so\nwe can roughly approximate it to O(n), where n is the number of instructions\nexecuted by the smart contract.\n\nIn zkSNARKs and zkSTARKs, computations are represented as a set of arithmetic\nconstraints. The complexity is often proportional to the number of these\nconstraints because the prover needs to generate a proof that these\nconstraints hold. Therefore, in such systems, n' can be considered as the\nnumber of constraints. For zkSNARKs, the time complexity of generating the\nproof would be O(n'). For zkSTARKs, the time complexity of generating the\nproof would be O(log(n')).\n\nIt\u2019s important to note that the time complexity of producing the proofs also\ndepends on the size of the computation/input, which includes public inputs and\nany private data used in the computation. As mentioned at the start of this\nsection, we focus on practicality in lieu of detailed mathematical precision.\n\nIn practice, the time complexity of executing/proving the computation in EVM\nis generally smaller than in zkSNARKs & zkSTARKs. In other words, the client-\nside execution of the computation is faster in the EVM than in zkSNARKs &\nzkSTARKs. There is no direct mapping between the number of contraints that you\nwould need to represet a particular EVM computation in zkSNARKs & zkSTARKs,\nand n != n'.\n\n#### Time Complexity of Verifying The Computation\n\nIn the EVM the process of verifying a computation is symmetrical, i.e. the\nsame, to the process of executing that computation: in both cases the\ncomputation must be (re)executed verbatim. In ZK protocols of zkSNARKs and\nzkSTARKs, these processes are asymmetrical, i.e. different. The time\ncomplexity of verifying the correctness of a claimed computation is where\nzkSNARKs & zkSTARKs disrupt with their value proposition, by addressing the\nissue of scalability. In the context of blockchain, the computations are\nsubmitted via transactions. We say that a computation is claimed, when it has\nbeen submitted onto the blockchain (the mempool), but has not yet been\nverified by the consensus participants, i.e. that transaction has not yet been\nincluded in a block. The participants of the consensus protocol are the\nverifiers of the computation. In the EVM, the verifiers have to re-execute the\ncomputation, while in zkSNARKs & zkSTARKs, the verifiers only need to verify\nthe proof.\n\nThe time complexity of verifying a claimed computation on the EVM is drectly\nproportional to the number of instructions in the smart contract being\nexecuted (n), multiplied by the number of validators (v) that participate in\nthe consensus. As such, the time complexity of verifying a claimed computation\non the EVM is O(n * v). This is because these validators have to re-execute\nthe smart contract on their own machines.\n\nIn contrast, the time complexity of verifying a claimed zkSNARKs/zkSTARKs\ncomputation is approximately constant, regardless of the complexity of the\nunderlying computation, and as such we define this complexity to be of O(1).\nTo be more precise, each participating validator takes a constant time to\nverify any computation. If v' is the number of the validators participating in\nthe consensus, then the time complexity of verifying a claimed\nzkSNARKs/zkSTARKs computation is O(v'). This is because the verification of\nthe proof is performed in constant time, cost, and size, and does not depend\non the complexity of the computation.\n\nWhen analyzing time complexity, the low-level details are compressed into an\nexpression describes the growth of the computation as a function of the input\nsize. Given that in both of the cases, the number of validators is a constant,\nthe time complexity of verifying a claimed computation on the EVM is directly\nproportional to the number of instructions in the smart contract being\nexecuted, while the time complexity of verifying a claimed zkSNARKs/zkSTARKs\ncomputation is constant. As such, we can define the time complexity of\nverifying a claimed computation on the EVM as O(n), and the time complexity of\nverifying a claimed zkSNARKs/zkSTARKs computation as O(1).\n\nFrom this, we can futher refine our Verifiable Computational Model (VCM)\ndefinition to include the take into consideration the time complexity of\nverifying the correctness of the claimed computaion. As such, we will call the\nVerifiable Computational Model of the EVM Linear Verifiable Computational\nModel (LVCM), and the Verifiable Computational Model of zkSNARKs & zkSTARKs\nConstant Verifiable Computational Model (CVCM).\n\n### Linear Verifiable Computational Model (LVCM) of the EVM\n\nThe Linear Verifiable Computational Model (LVCM) of the EVM is defined by the\ntime complexity of verifying the correctness of the claimed computation being\ndirectly proportional to the number of instructions in the smart contract\nbeing executed. The time complexity of verifying a claimed computation on the\nEVM is O(n), where n is the number of instructions in the smart contract being\nexecuted. We call it linear because the time complexity grows linearly with\nthe number of instructions in the smart contract being executed. It can be\nvisualized as a straight line on a graph, where the x-axis represents the\nnumber of instructions in the smart contract being executed, and the y-axis\nrepresents the time complexity of verifying the correctness of the claimed\ncomputation:\n\n### Constant Verifiable Computational Model (CVCM) of zkSNARKs & zkSTARKs\n\nThe Constant Verifiable Computational Model (CVCM) of zkSNARKs & zkSTARKs is\ndefined by the time complexity of verifying the correctness of the claimed\ncomputation being constant. The time complexity of verifying a claimed\nzkSNARKs/zkSTARKs computation is O(1), regardless of the complexity of the\nunderlying computation. We call it constant because the time complexity is\nconstant and does not depend on the complexity of the computation. It can be\nvisualized as a horizontal line on a graph, where the x-axis represents the\nnumber of constraints in the circuit (equivalent to number of lines of code in\nthe smart contract) whose proof is being verified, and the y-axis represents\nthe time complexity of verifying the correctness of the claimed computation:\n\n## zkSafeZones - Blockchain & Zero-Knowledge Proofs For Humanity\n\nIn this article I have mentioned several times that Zero-Knowledge proofs\ncombined with public blockchains offer a unique architecture, which is\ninherently authenticated, trustless, transparent, fault-tolerant, and\nintegrity-assured. We can leverage these technologies to build a better future\nfor humanity and Planet Earth. This is one of our core missions at zkLocus -\nthe geolocation is just a start. Before we conclude, we will briefly examine\nhow zkSafeZones, which is our initiative upon the zkLocus framework, leverages\nZero-Knowledge Proofs and blockchain technology to safeguard civilians in\nconflict zones, and sets the groundwork for the automation of legal compliance\non-chain at a global scale.\n\nBy leveraging the privacy-preserving and verifiable computation capabilities\nof Zero-Knowledge Proofs, zkSafeZones enables civilians to securely and\nanonymously report their locations in war-torn areas, facilitating targeted\naid efforts and providing an unprecedented level of transparency and\naccountability in adhering to international humanitarian law.\n\nMoreover, the integration of smart contract technology with Zero-Knowledge\nProofs paves the way for automated enforcement of international agreements,\nallowing for the creation of self-executing contracts that trigger predefined\nlegal actions based on verified geolocation data. Beyond its immediate\napplication in conflict zones, the framework proposed in zkSafeZones has the\npotential to transform various domains where geolocation data plays a crucial\nrole, from supply chain management and delivery verification to legal proofs\nfor drone operations. As the international community grapples with the\ncomplexities of modern conflicts and the challenges of enforcing humanitarian\nlaws, initiatives like zkSafeZones practically demonstrate how the power of\nZKPs and blockchain can be used to solve important issues, by addressing them\nfrom a novel perspective.\n\nWe are proposing zkSafeZones to the United Nations (UN) and the International\nCommittee of the Red Cross (ICRC), and are actively seeking partnerships with\norganizations and individuals that share our vision of leveraging technology\nto create a more transparent, accountable, and humane world. If you are\ninterested in learning more about zkSafeZones or collaborating with us, please\nreach out to us at contact@zklocus.dev or on Twitter/X @zkLocus.\n\n## Conclusion\n\nIn conclusion, the novel Verifiable Computation Model enabled by zkSNARKs and\nzkSTARKs opens up a realm of possibilities that extends far beyond the\nconstraints of the EVM\u2019s model. By shifting the bulk of computation off-chain\nto the prover of the computation (client) and offering constant time\ncomplexity for verifying these proofs of computation on-chain, these Zero-\nKnowledge Protocols pave the way for infinitely scalable, privacy-preserving\napplications.\n\nAs we\u2019ve seen with zkLocus leveraging Mina\u2019s zkSNARK-based architecture to\nturn geolocation data into a trustless and programmable Real World Asset\n(RWA), the potential use cases are vast and disruptive. Yet the power of\nzkSNARKs and zkSTARKs is not limited to the blockchain context alone. These\ncryptographic techniques can be applied anywhere there\u2019s a need for verifiable\ncomputation and private inputs. For example, we can build AI survaillance\nsystems that fully respect privacy, and work on this is already being done in\nthe field of Zero-Knowledge Machile Learning (zkML).\n\nzkSafeZones is a practical example of how we can combine Zero-Knowledge Proof\nprotocols with the blockchain to solve important problems that still remain\nunaddressed by existing technology. By leveraging these approaches in the\nrealm of geolocation, as exemplified by zkLocus, we open up a transformative\npotential in tackling humanitarian challenges and automating the enforcement\nof international law. Just like how zkLocus turns geolocation into a\nprogrammable and trustless Real World Asset (RWA), zkSafeZones demonstrates\nhow we can harness the power of ZKPs and blockchains to safeguard civilians in\nconflict zones and create a more transparent, accountable, and humane world.\nBut it doesn\u2019t stop there. The integration of smart contract technology with\nZKPs paves the way for automated enforcement of international agreements,\nallowing for the creation of self-executing contracts that trigger predefined\nlegal actions based on verified data, starting with geolocation. This is an\nimportant step towards automating the enforcement of the law on-chain, and\nit\u2019s just the beginning. Our practical solution, which we are also proposing\nto the UN and the ICRC, is a testament to how we can harness these\ntechnologies to tackle critical global issues and create a better future for\neverybody.\n\nDiving into Zero-Knowledge Proofs requires adapting to a new mindset and\nworking within the constraints of the polynomial model rather than traditional\ncontrol flow. But as my experience building zkLocus has shown, every fricition\nthat you face will be met with a solution, and every solution will deepen your\nunderstanding of the technology. Before you know it, you\u2019ll be engineering\ndisruptive solutions while you\u2019re out on a walk, a drive or taking a shower.\n\nSo whether you\u2019re aiming to build atop a zkSNARK-powered blockchain like Mina,\nleverage zkSTARKs for scalable Layer 2 constructs, or utilize Zero-Knowledge\nProofs in an off-chain context, embrace the journey of learning. The mental\nmodels you construct will serve as a foundation for leveraging these\ntechnologies to build a digital future where trust, privacy, scalability and\ninteroperability are not features, but inherent properties of our solutions.\n\n## \u2728 zkLocus: Geolocation Real World Asset (RWA) For Web 3 \u2728\n\nThank you for taking your time to read this article. I sincerely hope that you\nfound it informative and that it has sparked your curiosity about Zero-\nKnowledge Proofs and their applications. If you have any questions, feedback,\nor would like to collaborate, please reach out to me at hello@illya.sh, or on\nTwitter/X @illyaGera.\n\nFor more information about zkLocus, you visit one of the following links:\n\n  * zklocus.dev - The official homepage of zkLocus. Here you can find the latest updates about zkLocus and contact information.\n  * GitHub/zkLocus - The GitHub repository of zkLocus. Here you can find the source code of zkLocus.\n  * x.com/zkLocus - The Twitter/X account of zkLocus. Here you can find the latest updates about zkLocus.\n  * zkLocus Whitepaper - The whitepaper of zkLocus. Here you can find a detailed description of zkLocus and its underlying technology.\n  * zkSafeZones Whitepaper - The whitepaper of zkSafeZones. Here you can find the whitepaper for our intiative aiming at safeguarding civilians in conflict zones, and sets the groundwork for enforcement of the law on-chain.\n  * contact@zklocus.dev - The email address of zkLocus. Here you can directly contact the zkLocus team.\n\n### Discuss \ud83d\udde3\ufe0f\n\nCurrently, the blog does not natively support comments. In the meanwhile, you\ncan discuss this blog post on:\n\n  * Twitter/X - \ud83d\ude80 zkSNARKs & zkSTARKs: A Novel Verifiable Computation Model \ud83d\ude80\n  * Reach out to me on Telegram at t.me/illya_gerasymchuk, or e-mail me at hello@illya.sh\n\n  * zero-knowledge\n  * blockchain\n  * zksnark\n  * zkstark\n  * zklocus\n  * zksafezones\n  * web3\n\nCopyright \u00a9 2024 | All rights reserved.\n\n", "frontpage": false}
