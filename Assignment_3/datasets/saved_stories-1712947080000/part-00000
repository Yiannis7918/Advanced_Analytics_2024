{"aid": "40011873", "title": "Mainstream languages I would use in production, in 2024", "url": "https://thetechenabler.substack.com/p/mainstream-languages-i-would-use", "domain": "thetechenabler.substack.com", "votes": 2, "user": "ingve", "posted_at": "2024-04-12 12:35:38", "comments": 0, "source_title": "Mainstream languages I would use in production, in 2024", "source_text": "Mainstream languages I would use in production, in 2024\n\n# The Tech Enabler\n\nShare this post\n\n#### Mainstream languages I would use in production, in 2024\n\nthetechenabler.substack.com\n\n#### Discover more from The Tech Enabler\n\nMy personal Substack for my role as a tech enabler inside a large media\ncompany. I write about work, culture, and programming in general. My current\nseries is all about tech trends and what I think teams should adopt or drop.\n\nContinue reading\n\nSign in\n\n# Mainstream languages I would use in production, in 2024\n\nNoah Hall\n\nApr 11, 2024\n\nShare this post\n\n#### Mainstream languages I would use in production, in 2024\n\nthetechenabler.substack.com\n\nShare\n\nI\u2019m a big programming language enthusiast, and the design of every language is\nso compelling to me. I love to see where languages differ, and how they\ninspire each other. But more than just the design, I\u2019m also passionate about\nbeing pragmatic and getting things done. This article is about which\nmainstream languages I would personally recommend for production purposes, and\nwhere I\u2019d use them.\n\nEvery language on this list is one I\u2019ve tried, and have read about enough to\nhave an opinion on. Some I have much more experience with, others I\u2019ve used\nmore passively. Your opinions may differ from mine, and that\u2019s totally fine!\nBy no means is this meant to be anything other than my personal opinions and\nexperiences. This is also not an exhaustive list - there are many other\nlanguages I would recommend, too. But the focus is on what I would personally\nchoose to use in production.\n\nSince this is a big post, I\u2019ve broken it up in a few sections:\n\n  * Picking a language\n\n  * My recommendations for the type of languages each type of developers should know\n\n  * A breakdown of each mainstream language I\u2019d recommend, and where I\u2019d use them\n\n    * TypeScript\n\n    * Python\n\n    * Go\n\n    * Rust\n\n    * Swift\n\n    * Kotlin\n\n    * SQL\n\n  * Niche languages (a follow up post will go in depth on this!)\n\n  * Conclusion\n\nIf you\u2019re reading in the email from Substack, you may want to open this in the\napp or the browser, since it\u2019s so long that it might not display the full\npost.\n\nSubscribe if you want to get a notification for the follow up post on niche\nlanguages, too.\n\nLet\u2019s get into it, with my advice on how to pick a language.\n\n##\n\nPicking a language\n\nPicking a language can be a big investment. A small project today might be a\nhuge project tomorrow, and it\u2019s painful to do a full rewrite from one language\nto another. That shouldn\u2019t prevent you choosing less common languages, though.\nJust be sure to get enough experience in your potential options to fairly make\nan assessment.\n\nSome questions I typically ask myself when starting a new production project:\n\n  1. How good is the language (solution) for what I\u2019m trying to build (problem)?\n\n  2. Will I spend more time dealing with the language than getting features out?\n\n  3. Do the libraries I need exist already?\n\n  4. Will whoever inherits this from me hate me for it?\n\n  5. How many people will be working with me on it and do they know the language already, or are they open to learning it?\n\nThe language doesn\u2019t need to pass all these questions, but it does make it\nmuch smoother to choose a reliable, well known language that you\u2019re\nknowledgeable in. If there is a language which is missing some things I might\nneed, I\u2019ll often make an experimental project where I can build and test\nlibraries or patterns.\n\n####\n\nWhat languages would I recommend learning?\n\nI recommend that developers have at least a couple of languages they\u2019re deeply\nfamiliar with, then some passing knowledge of others. Being familiar with more\nthan one language will help diversify your skills and patterns for solving\nproblems. While one language might currently use one particular approach,\nlanguage designers or package creators often take ideas from other languages.\n\nA developer\u2019s strongest language should probably be the one they work with\nmost frequently. From a career progression perspective, it should be the one\nthat makes it easiest to find a job they love. Different people are passionate\nabout different elements of their work. Some may be into language theory and\ndesign, so they\u2019d go towards niche languages. Others may be into building\nproducts they see users use, so might want to go for whatever language is\nbeing used in the local job market for big products. The ideal mix for me\npersonally, is a bit of both.\n\nFor context: I\u2019d normally fall into the fullstack and ops category, having\nwritten a lot of backend, frontend, compilers, tooling and script code1. I\u2019ve\ndone some mobile development, though the majority of it has been where the UI\nis web-rendered.\n\nI\u2019ve gone into below some specific recommendations for each developer\nspecialism I have recent (enough) experience with.\n\n####\n\nFrontend\n\nLanguages I recommend:\n\n  * JavaScript (and Web APIs)\n\n  * Whatever language your frontend code is in (e.g TypeScript)\n\n  * html/CSS\n\nIt doesn\u2019t matter if you use a language that compiles to JavaScript,\nunderstanding what APIs are available to different browsers, and how they\nwork, will increase the range of solutions available to you. Knowing\nJavaScript doesn\u2019t need to include things like prototypes, but focus on the\nmore directly useful: debugging performance, interacting with the DOM, using\nlocal storage, etc. The same goes for CSS and html. While some modern\nframeworks abstract away from the traditional structure of CSS, or how html is\ncreated, knowing how selectors work, or what html tags are appropriate for\nyour problem, is useful.\n\nI\u2019d also recommend having at least a passing understanding of the backend\nlanguages your projects use - this will make it easier for you to find answers\nto your questions, as well as design a project with the backend\u2019s architecture\nin mind.\n\n####\n\nBackend\n\nLanguages I recommend:\n\n  * One backend language (Go, Rust, TypeScript, Python)\n\n  * The concepts behind SQL\n\n  * An ops-specific language (e.g Bash, Python, HCL)\n\nWhile you may use ORMs or NoSQL databases, understanding the query patterns\nfrom SQL databases is pretty handy. Backend developers typically get involved\nin infrastructure related tasks, so knowing how Bash or HCL work is pretty\nhandy.\n\n####\n\nFullstack\n\nLanguages I recommend:\n\n  * One backend language (Go, Rust, TypeScript, Python)\n\n  * One frontend language (TypeScript)\n\n  * An ops-specific language (e.g Bash, Python, HCL)\n\nMy recommendation for a fullstack developer would also overlap with frontend\nand backend, but when it comes to languages: mastering a single backend\nlanguage and a frontend language will enable a developer to work effectively\nwith the whole stack in mind. What you want to avoid though is drifting too\nfar from each part of the stack \u2014 fullstack developers are most useful when\nthey\u2019re able to solve frontend problems in a frontend way, and backend\nproblems in a backend way. That\u2019s not to say that there\u2019s no overlap, though.\n\nBeing able to delve into the land of ops can be helpful too, for building with\ninfrastructure and CI in mind.\n\n####\n\nMobile\n\nLanguages I recommend:\n\n  * The language used primarily on your target mobile devices (Swift, Kotlin)\n\n  * The underlying language (e.g if you\u2019re using Swift, Obj-C, if you\u2019re using Kotlin, Java)\n\nUnderstanding your platform\u2019s ecosystem is very important, so you should know\nhow to debug and deploy whatever language you\u2019re using. Adhering to the visual\nstandards of your platform can be pretty important, too. I\u2019ve personally found\nit very useful to combine web frontend knowledge with mobile development -\nsometimes a solution can be prototyped quicker if you use web-rendered\ncontent. Other times, you\u2019ll want to go fully native to ensure good\nperformance and that platform-specific behaviours are followed.\n\nLike frontend developers, I\u2019d also recommend having at least a passing\nunderstanding of the backend languages your projects use - this will make it\neasier for you to find answers to your questions, as well as design a project\nwith the backend\u2019s architecture in mind.\n\n####\n\nEmbedded, data science, and others\n\nI don\u2019t have enough recent experience with these specifically to give\nrecommendations, but the general recommendation still applies: know a couple\nof languages deeply, with passing knowledge of techniques and patterns in\nothers.\n\nWhat about specific languages, though? I\u2019ve broken these up into mainstream\nlanguages, and niches languages. Mainstream languages either have already or\nare seeing a lot of adoption, and would be a good choice for developers in the\ncurrent ecosystem and job markets. Niche languages are those who either don\u2019t\nhave a lot of adoption currently, or generally aren\u2019t used as much, but still\nmay be worth looking at. Since this post ended up being so big, niche\nlanguages has been split off into a separate post that\u2019ll come out next week.\n\nRead on to find out why I specifically suggest these!\n\n#\n\nMainstream languages\n\nLet\u2019s revisit those questions from above, to see how mainstream languages will\ntypically answer them.\n\n  1. How good is the language (solution) for what I\u2019m trying to build (problem)?\n\n     * It\u2019s likely that the language is ready for your specific use case.\n\n  2. Will I spend more time dealing with the language than getting features out?\n\n     * There\u2019s likely to be fewer weird bugs or unexpected edge cases, with lots of documentation covering how to solve them.\n\n  3. Do the libraries I need exist already?\n\n     * The libraries you need are likely to exist.\n\n  4. Will whoever inherits this from me hate me for it?\n\n     * The old saying \u201cnobody ever got fired for choosing X\u201d applies here, where X is a well-adopted, stable, language.\n\n  5. How many people will be working with me on it and do they know the language already, or are they open to learning it?\n\n     * Many developers will be familiar with these languages.\n\nOverall, mainstream languages are a good choice for any production project.\n\nIf you\u2019re in a startup, mainstream languages will make it easier to get things\ndone quickly, reducing cost, and the talent pool is wider, making scaling the\nteam easier.\n\nIf you\u2019re in a big company, mainstream languages reduce friction when\ndifferent teams have to collaborate. Types and libraries can be shared,\nunfamiliar teams can contribute to other codebases, and when ownership\nchanges, the new owners can onboard more efficiently.\n\nI\u2019ll also go into performance. When you think about performance, it\u2019s\nimportant to consider two cases:\n\n  * The performance of normal code, i.e unoptmized code, that most developers will be writing the majority of the time.\n\n  * The performance of the hot path, i.e the most performance critical parts of the application, which may be specifically optimized to improve the overall application performance.\n\nI\u2019ve had a lot of experience debugging TypeScript, Python, Go, SQL and Rust\nperformance, but not much with Kotlin, Swift, so I\u2019ll mention it for those I\nhave personal experience with. For some numbers and stats, the TechEmpower\nbenchmarks and the Debian benchmark page are useful. The best data is the data\nthat comes from your real world usage, for the same reason why integration\ntests often catch more real world bugs than unit tests.\n\nSpeed is important for developer tools, particularly:\n\n  * If something is run frequently on every file change, it should be fast enough to not require a waiting time by the time the developer switches to their browser/terminal to check the output. If the tool is a compiler, iterative compiling (e.g only compiling the impacted files) can be a good way to get good perceived performance.\n\n  * Tests should not take so long to run that developers don\u2019t use them. They should run locally in a short amount of time. They should also match behaviours between platforms, and on CI.\n\nKnowing which mainstream language to use can be difficult. Let\u2019s jump right\ninto it, with TypeScript!\n\n###\n\nTypeScript\n\nEase of use: \ud83e\udd29\ud83e\udd29\ud83e\udd29 Activity of maintenance: \ud83e\udd29\ud83e\udd29\ud83e\udd29 Stability: \ud83e\udd29\ud83e\udd29\ud83e\udd29 Adopt/reconsider?\nAdopt Community: Large Job Market: Large Use in: Frontend, backend, tooling\n\nI\u2019ll discuss JavaScript with TypeScript here, though they are distinct\nlanguages with separate experiences. JavaScript had a default position as a\nleading language as soon as browsers standardised on it as their scripting\nlanguage. In the last couple of decades or so, it\u2019s moved to the backend,\nwhere developers have seen the benefits of being able to share a codebase\nbetween frontend and backend. As this happened, people wanted to have more\ncompiler help for writing code, and the winning way to do this was to add type\nsafety2. TypeScript and Flow came out roughly at the same time3, 10 years ago,\neach backed by a big company (Microsoft for TypeScript, Facebook for Flow).\nNow, though, the community has more or less landed on TypeScript, and\nJavaScript and TypeScript have (almost) become synonyms. There are some cases\nwhere JavaScript is explicitly chosen separately to TypeScript, but they\u2019re\nfew and far between. By the time that TypeScript was getting popular,\nJavaScript developers were already using tooling like Babel to write modern\nJavaScript that could compile to older runtimes, so using a compiler as part\nof the build step wasn\u2019t unfamiliar.\n\nThere was a space in this time for other languages, such as Elm, to provide\nsolutions to the problems that JavaScript developers felt, but as TypeScript\ndominated and provided developers with a good experience, interest in the\nalternative languages dropped off. Why learn a new language which may not be\ncompatible with your existing codebase, when you can just learn TypeScript and\nreuse your existing knowledge and code?\n\nThe dynamic between JavaScript and TypeScript is interesting. While TypeScript\nadds a bunch of type-related features, it doesn\u2019t add many other language\nfeatures over JavaScript. Loops, logic, functions, assignments all work the\nsame as in JavaScript. TypeScript\u2019s release schedules are all documented on\nGithub, so it\u2019s possible to keep up with what they\u2019re adding. ECMAScript4,\nJavaScript\u2019s formal definition, proposes and adopts features through community\ncontributions. Often, once these proposals are vetted enough to most likely be\nadopted by ECMAScript, they get added to TypeScript. This means that\nTypeScript generally follows the latest ECMAScript release, but deviates when\nit comes to features you\u2019d typically consider part of the type system. The\ndeviation is usually the addition of a feature, rather than removal or\nmodification though, which keeps TypeScript as a superset of JavaScript.\nTypeScript\u2019s compiler can even support type-checking in JavaScript through the\nuse of JSDoc comments, though the syntax for JSDoc types is a lot more awkward\nthan just TypeScript types.\n\nTypeScript\u2019s frontend community is somewhat fragmented, between all the\ndifferent modern frameworks. React, Angular, Vue and Svelte all see high\nusage. The concepts between them are mostly the same, but each framework\nimplements them differently. As opposed to writing HTML, CSS and JavaScript as\nseparate files and entities, these frameworks combine them together so that\nall the code for a specific component on your website is contained in one\nplace, usually in declarative style. This is a difference over the old ways of\nwriting JavaScript, where you\u2019d write jQuery in a separate file, to modify the\nDOM. There was a period where there\u2019d be a new framework or library being\nannounced very often, too often for developers to keep up with. This seems to\nhave settled down a bit, but I\u2019d also point out that most backend languages\nhave multiple frameworks, too5.\n\nAs a language, JavaScript is simple, and a mix of functional and object-\noriented. The addition of classes (as well as prototypes) has helped make the\nobject-oriented code become more approachable. It has modern features, like\nasync/await, without deviating too much from the original language spec. This\nmakes it an easy language to learn, without being too surprised by how it\nworks. The lack of a broad standard library continues to be a problem, with\nmany libraries being tiny co-dependent packages. TypeScript does broaden the\nlanguage with many more features at the type level, but it\u2019s not too crazy if\nyou stick to the normal levels of abstraction. The small overhead in both\nwriting code and running code makes it a good fit for functions-as-a-service.\nSharing types and utility functions have enabled server-side rendering setups\nwhere the logic may start on the backend, but gets continued on the frontend.\n\nSome particular downsides for TypeScript (and JavaScript) for me:\n\n  * Complex abstract or generic types often lead to hard-to-read types combined with even-harder-to-read errors.\n\n  * Types are compile-time only, but are often used as if they are active at runtime too (e.g when casting a value retrieved via JSON.parse).\n\n  * Running TypeScript without a compile step requires either slow loaders on Node (e.g ts-node), or using alternative TypeScript-first runtimes like Bun or Deno.\n\n  * The default tsconfig is too permissive to get the full benefits of type safety.\n\n  * JavaScript generally is overused, even in cases where other languages fit better.\n\n  * The standard library isn\u2019t big enough, and the community packaging approach is to have many tiny packages rather than larger collections.\n\n####\n\nWhere I\u2019d use TypeScript over JavaScript, Elm, or ReasonML for frontend\n\nTypeScript maps directly to JavaScript, which means it\u2019s predictable.\nFrameworks you choose might change how you interact with web APIs (e.g\ndeclarative frameworks, reactive programming, vs imperative), but compared to\na complete change in programming language, you\u2019re still able to map your code\nclosely to how browsers actually work. Higher level of abstractions (e.g Elm)\nmake this harder, though come with the benefit of not needing to know how\nbrowsers work as much.\n\nIf you\u2019re trying to make something unusual, performance critical, or have a\nshort deadline, TypeScript will make all of those easier. Unusual things are\neasier because there\u2019s probably other people who have done similar (or the\nsame) things before. TypeScript is good for performance critical tasks, since\nit\u2019s easier to predict the generated code and how it works. Debugging when you\nare two steps away from the compile target requires you to know the source\nlanguage, what it compiles to, and either JavaScript or WebAssembly. By\nsticking to TypeScript, you can predict what JavaScript is generated\ntrivially. If you have a short deadline, TypeScript has all the libraries you\nmight need.\n\nAll these apply to JavaScript, too. Where TypeScript beats JavaScript is that\nyou get the extra safety and security of types. The code is more maintainable,\nand easier to return to in the future. It\u2019s also possible to make bigger\nrefactors more comfortably. JSDoc can be an option for getting that experience\nwhile sticking to JavaScript, but the syntax for it is considerably worse than\nTypeScript. On the other hand, JSDoc does allow you to run your files directly\nin the browser, so you don\u2019t need a compile step, with the added bonus of\nslightly encouraging developers to write comments. Considering the speed of\nmodern compilers like esbuild though, I would favour the TypeScript developer\nexperience.\n\n####\n\nWhere I\u2019d use TypeScript over other backend languages\n\nBack when JavaScript started to be viable in production on the backend, the\nterm \u201cisomorphic\u201d was thrown out a lot. A scary looking word which just means\n\u201ccode that can run on the frontend and the backend\u201d, in the JavaScript world.\nWhile that initially applied to untyped code (JavaScript), I actually think\nsharing types is the more useful part of that. OpenAPI and other schemas can\ngenerate types for other languages, but starting with types-first often leads\nto better APIs in my experience. Being able to then have the client code reuse\nthe same types as the server is quite nice, though I do recommend still\nparsing the data from the server - don\u2019t trust anything if you want resilient\nsystems. To put this into practice, you\u2019d share type definitions but parse on\nthe boundaries, which would either give you an error or the object matching\nthe type definition.\n\nThe cognitive load for fullstack developers can be kept small if the frontend\nand the backend are the same language. Server runtimes like Node, Bun, Deno\nare fundamentally different from browsers, but the language and the syntax\nremains the same, which often means that a programming style or pattern\nadopted on either side of the stack can also be adapted for the other side.\nFor example, the event model of the DOM maps pretty well to route handling.\nMuch like handling user interactions on the frontend, backend services\ngenerally need to be async at the routing level to handle a lot of\nconnections, so it\u2019s a natural fit. For this reason, it\u2019s a great fit for when\na team is primarily made up of fullstack developers or mostly frontend\ndevelopers. If you\u2019re a fan of debug tooling, then you\u2019ll enjoy the fact that\nyour browser\u2019s developer tools can be used to debug a Node session.\n\nThe ability to server-side render TypeScript frameworks on the backend can\nhave good results on client-side performance and optimisations for single page\napps, too. This is a compelling reason to use TypeScript as the backend-for-\nfrontend, as a layer between your backend and your frontend.\n\nWhere backend TypeScript tends to fall down is a combination of performance,\nsome simple problems being hard, and the small standard library.\n\n##### Performance\n\nIn most cases, TypeScript frameworks fall into the middle of performance\nbenchmarks. It is possible to optimise TypeScript for high performance, but it\noften comes at a cost to the developer experience. That isn\u2019t as much the case\nfor languages like Rust or Go, which can maintain the conceptual abstractions\nof the language while also delivering on the performance side. So if you want\nperformance by default, Rust or Go might be a better option. Remember though\nthat it may be a premature optmization.\n\n##### Simple problems made hard\n\nIt\u2019s a bit of a mixed bag with TypeScript. Let\u2019s start with the package\necosystem. The JavaScript backend (and frontend) community mostly use npm for\npackages, which is simple to publish to and install into projects. However,\nthe way imports work is different depending on how the library is put\ntogether, and for a long time, in the main runtime in use (Node), using two\nlibraries which use the two main different import systems hasn\u2019t really been\neasy.\n\nMaintainers would need to put in quite a lot of work to make it compatible\nwith both, and most wouldn\u2019t do that. Some maintainers even dropped support\nfor the old style imports completely. This means that it\u2019s not too uncommon to\nstart a project, but halfway find out that a dependency you\u2019ve used for other\nprojects is not compatible with the current one. The error messages you get\ngiven are fairly cryptic unless you\u2019ve seen them before. The syntax also is\nonly subtly different between the two, if you\u2019ve only been using import. This\nis not the only problem with JavaScript, and it\u2019s not even the biggest problem\nwith the packaging ecosystem. Fortunately, other runtimes have led the way in\nmaking imports as simple as possible, and now loading both the new and old\nstyle packages has been merged to Node.\n\n##### Small standard library\n\nSome languages do have a small standard library, but often make up for it with\na large community maintained library (think Boost for C++). JavaScript\u2019s\npackage ecosystem has led to large fragmentation along the lines of the Unix\nprinciple do one thing and do it well. I\u2019m not 100% sure how it ended up like\nthat, though I do think that the ambition for smaller bundle sizes prior to\noptimising compilers had an impact. Ironically, this principle has probably\nled to larger bundle sizes since what could\u2019ve been a small self contained\nfunction now pulls in a bunch of other packages to avoid re-implementing\ntrivial things such as checking if a value is a number or not. A fun thing to\nconsider: if TypeScript was the default before these packages were created,\nthen there\u2019d be no need to implement type checks since they can (mostly) be\nmoved to the type level instead.\n\nWhat this means in practice is that projects often have extremely large\ndependency chains, on the scales of hundreds if not thousands. Installing and\nresolving these packages is slow, though great improvements have been made\nthere in recent years. But there\u2019s no way to vet all these dependencies, or\ntheir maintainers. As we\u2019ve seen recently, a library with few maintainers but\nmany dependants would be a perfect candidate for an attack. Tools like\ndependabot do help lessen the load of updating packages, or being aware of\nsecurity issues.\n\nCompare this to languages with a large standard library, like Python or Go,\nwhere it\u2019s more normal to have fewer dependencies, and it could be a valid\nconcern.\n\n####\n\nWhere I\u2019d use TypeScript for tooling\n\nWhen all your code is already in TypeScript, using TypeScript for scripts or\ntooling can reduce the cognitive load on developers.\n\nIf TypeScript is written in a way that is aware of the platform (e.g in the\nbrowser or through Node), then it\u2019s possible to write a tool in such a way\nthat it will work in both places. I\u2019ve used this for Derw\u2019s playground, where\nthe compiler has some feature detection to switch the implementation used\nbetween the browser and Node/Bun, so that the compiler runs in both places.\nWhile it\u2019s possible to compile other languages to JavaScript or WebAssembly,\nit\u2019s easiest if your code is already JavaScript or TypeScript. A great example\nof this being put into practice is the ability to run Visual Studio Code\neither locally or in the browser. If we ignore that the frontend of vscode is\njust DOM-based since it\u2019s all Electron, we can still consider the backend (i.e\nthe non-visual and non-interaction code) to be tooling - file manipulation and\nparsing are all standard practices in tooling.\n\nMy recommendation\n\nTypeScript is probably the most suitable language for frontend web code. It\nhas the broadest reach, the biggest community, and maps closest to the code\nthat actually runs in the browser. Backends-for-frontends also are a great fit\nfor TypeScript, though I would personally choose a separate language for the\nactual backend.\n\n###\n\nPython\n\nEase of use: \ud83e\udd29\ud83e\udd29 Activity of maintenance: \ud83e\udd29\ud83e\udd29\ud83e\udd29 Stability: \ud83e\udd29\ud83e\udd29\ud83e\udd29 Adopt/reconsider?\nAdopt Community: Large Job Market: Large Use in: Data science, Scripting,\nBackend, ML, AI\n\nPython is a language that I find to be great to have in your back pocket.\nWhenever there\u2019s a quick tool I think about making, Python is what I reach\nfor. The standard library is huge, with popular libraries following in line by\nproviding lots of functionality in fewer libraries. The migration from Python\n2 to 3 has gone down in infamy, but since then it\u2019s been a pretty stable\nlanguage with each release adding useful new features. Much like other\ndynamically typed languages, the tooling situation has improved to the point\nwhere tools like Black, autopep8, and Mypy to help improve the developer\nexperience.\n\nWhere Python does fall down though is the story around dependencies outside of\nthe standard library, and what was once a small language (syntax and built-ins\nwise) growing into having many complicated features. While Python has added\nvirtualenv support to the standard library for creating project-specific\nenvironments, actually working with dependencies is a bit chaotic. There\u2019s\npip, poetry, conda, and others. System-installed libraries complicate the\nstory further. Many syntax changes have substantially changed the language,\ntoo. Assignment expressions may look rather un-Pythonic for those who have\nmainly used older releases of Python. These reasons are why I only give it 2/3\nstar-eyes, despite the language being very simple to understand otherwise.\n\nThat said, a shining beacon of Python is the Python Enhancement Proposal\nprocess. Ideas are proposed via mailing list, discussed, then drafted into a\ndocument over which further debate happens. This trail of documentation helps\nusers understand how and why certain features came about, as well as how to\nuse them. Modern Python has many great quality of life features6, and running\nthe newer versions over early releases of 3, or the last release of 2, is a\nconsiderable quality of life improvement.\n\nPython\u2019s syntax has a reputation for being pseudo-code that can actually run,\nthanks to the preference for English words and whitespace for syntax. As a\nresult, it\u2019s used heavily in academia or for industries where code is a by-\nproduct of work, and not the main product. Python\u2019s diversity and flexibility\nhas lead to it becoming popular in many different fields, from typical web\nbackends, to AI/ML.\n\nA bunch of research has gone into speeding Python up, with the global\ninterpreter lock (GIL) no longer being required in some cases, making Python a\nbetter contender for high-performance applications.\n\n####\n\nWhere I\u2019d use Python for data science\n\nThe main direct competitors to Python for data science and AI include Julia\nand Matlab. Both of these have interop with Python, so leveraging Python code\nfrom them is easy. The majority of models and libraries for data science are\nreleased written in Python, so unless you have attachment to Julia or Matlab,\nwhy add a layer of complexity on top of your stack? The answer is due to\nPython\u2019s generalism: both Julia and Matlab are specialised for data science,\nand therefore have better built-ins and syntax for handling mathematics and\ndata. On the other hand, it\u2019s more likely that others parts of your stack may\nalready be using Python than Julia or Matlab, so using Python will make it\neasier not only to interact with models, but also interact with the business\nlogic.\n\n####\n\nWhere I\u2019d use Python for scripting and ops\n\nCommon alternative languages used for ops are Bash, perl, and JavaScript.\n\nWhile Bash and perl are both extremely powerful and concise, they can be\ndifficult to read. This factor is compounded when ops scripts are something\nthat are modified or used rarely. Python, on the other hand, is as readable as\na language can be. Some of the code to do standard operations is more\ncomplicated in Python (e.g piping a shell-builtin to another command).\nHowever, the standard library does have several options, such as os and\nshutils modules which provide helpers for common shell-style operations.\n\nBash and perl also have an advantage in that many Unix-like systems will\ninclude them by default, though making sure you use the right one and the\nright version is sometimes painful. For example, sh is sometimes bash,\nsometimes dash. Bash versions between Linux (5+) and Mac (3.2) are different\nby default. Different operating systems will also have different package\nmanagers and default libraries, so writing code in Python that runs cross-\nplatform can be more efficient. Mac no longer comes with Python, so that can\nbe an additional install - but it\u2019s not hard to install.\n\nSince JavaScript ends up being a defacto language for many developers, a lot\nof ops scripts have been written in JavaScript. Some interesting projects like\nzx (not to be confused with xz) and Bun\u2019s shell have made it easier to write\nshell-style code in JavaScript. Python has some advantages over JavaScript,\nlike the large standard library - it is likely that you\u2019ll be able to do most\nof what you want from Python directly rather than needing 3rd party\ndependencies. A good example of this is the flag and argument parser provided\nin the standard library.\n\n####\n\nWhere I\u2019d use Python for backend\n\nPython, like JavaScript, falls somewhere in the middle of the benchmarks when\nit comes to performance. Alternative runtimes like pypy are pretty fast, but\nnot all libraries (such as the C-based ones) are able to run under pypy as\nCPython.\n\nDjango provides a lot of functionality for web backends out of the box, but I\nwould personally stick to the smaller libraries like Flask or FastAPI. Python\nmakes for a great way to set up a minimal backend, such as microservices. A\nbig benefit to the microservices approach is that the hot path can be written\nin faster languages such as Go or Rust, but smaller, internal, or interactions\nwith data science code can be written in Python.\n\nWith the introduction of mypy and Python\u2019s type hints, maintaining large\nPython codebases has become considerably simpler. A distinction vs TypeScript\nis that all of Python\u2019s types are available at runtime, and mypy can be used\nas a normal library. This means that powerful frameworks can use type\ninformation to parse user input, or have custom error messages. Python has\ntypes directly in the language specification, whereas TypeScript has to be a\ndistinct language from JavaScript, though it\u2019s possible to compile TypeScript\nwithout running the typechecker. A downside of Python\u2019s approach is that types\nare entirely optional - running python main.py will not do any type checking.\nThis means if you\u2019re not running mypy manually, you might be running\nincorrectly typed code.\n\nDue to the state of dependency management, it\u2019s usually wise to run Python\nthat other machines will also run (e.g a server, other developers) to use\nDocker.\n\n####\n\nMy recommendation\n\nIf your role is not a software developer, Python is a great language for you.\nIt\u2019s simple yet powerful, it has an exhaustive standard library, and there\u2019s\ngreat 3rd-party libraries for most things you\u2019d want to do. It\u2019s also heavily\nused in the data science and AI world, so if you\u2019re working with those, it\u2019s a\ngreat choice. Rewriting Bash scripts over 30 lines to Python usually helps\nwith maintenance. If your role is a software developer, it\u2019s also a great fit.\nPython web apps are great for small to medium projects with low performance\nrequirements, though larger projects with performance concerns may need to\nlook into alternative runtimes (like Pypy), or moving code to C.\n\n###\n\nGo\n\nEase of use: \ud83e\udd29\ud83e\udd29\ud83e\udd29 Activity of maintenance: \ud83e\udd29\ud83e\udd29\ud83e\udd29 Stability: \ud83e\udd29\ud83e\udd29\ud83e\udd29 Adopt/reconsider?\nAdopt Community: Medium Job Market: Medium Use in: Scripting, Tooling, Backend\n\nGo fits into an interesting niche, essentially filling the role of Python for\ncases where Python would be too slow. The tooling story is excellent, with go-\nfmt, go test, go bench all providing inspiration for any modern language\u2019s\ntooling. The standard library is large and powerful, and the compiler is very\nfast. Deploying a Go app is very simple, with all the pains of older languages\nvanishing as cross-compiling and statically linked binaries are supported\nfirst-class. Go is such a fast language that some of the best tooling for\nother languages is built in Go (e.g esbuild).\n\nThe two big changes to Go in recent years are probably their solution for\ngenerics, and the packaging system. Originally, most Go developers would re-\nimplement a function for different data types over and over, usually only\nchanging the types or function calls. Generics were added which solve that\nproblem, as now a function can be made to work with arguments of many\ndifferent types. This is particularly useful for collections such as lists, as\nprior many standard functions that could be found in functional languages (e.g\nmap) were not supported. Go\u2019s old dependency system would essentially vendor\nlibraries into the project\u2019s repo. These days, Go has introduced a module\nsystem that simplifies this.\n\nGo\u2019s main downside for many people is the sparseness of language features.\nWhile many other languages quickly evolve or adopt new ideas, Go\u2019s process is\nlong and slow. For some, it is too slow. For others, the stability and\nsimplicity of the language is a selling point.\n\n####\n\nWhere I\u2019d use Go for backend\n\nGo is fast, easy to deploy, and flexible.\n\nGo fits nicely into the role of being a faster Python or JavaScript \u2014 easy and\nsimple to write, used heavily for backend code, but with higher default\nperformance. Writing a service in Go will usually mean it scales better with\nfewer resources than the Python or JavaScript equivalent, though that\u2019s not\nalways true. The type system isn\u2019t as flexible as some developers would like\nfor large systems, so deploying Go as a microservice probably makes most\nsense. The idea behind that recommendation is that the smaller the service is,\nthe less likely there is need to be many complicated abstractions or types.\n\nGo\u2019s lightweight threads, goroutines, provide a standard way of handling\nconcurrency as part of the language and standard library. While threading is\npossible in Python and JavaScript, it\u2019s not as trivial to have both IO and CPU\nthreading as it is in Go. That means Go is a better fit for high performance\nbackends that do a lot of IO and CPU processing.\n\nUnlike JavaScript, Go\u2019s standard and 3rd party libraries tend to be more than\na single function, so the dependency chain problem is less likely to occur.\nDeploying is relatively simple since Go apps are distributed as binaries,\nwhich can be cross compiled and statically linked. It\u2019s possible to produce\nbinaries for Node, Bun, Deno and Python, but none of them produce binaries as\nsmall as Go - as the beefy JavaScript/Python runtime needs to be shipped\nalongside the code.\n\n####\n\nWhere I\u2019d use Go for tooling\n\nGood developer tooling needs to be simple, logical, and fast.\n\nSimple and logical are mostly up the developer and language agnostic (as long\nas there\u2019s a unix flag / argument parser), though distributing Go is a good\nfactor into the simplicity. It\u2019s much easier to distribute a binary than it is\nto distribute a JavaScript or Python package if the user does not have the\nright version of the runtime installed. Once a binary is produced, it can then\nbe distributed where the users are: for example, esbuild\u2019s package on npm\ndownloads the right binary for the system, so JavaScript developers can use\nthe package manager they\u2019re most familiar with. If Python was used to write\nesbuild, then distributing it to JavaScript developers would involve more\nsteps.\n\nTests are normally best written in the language used for the main application,\nthough Go could be used to generate inputs for test cases. Fuzz testing is\nsupported in the standard library for Go, so using it to generate fuzz data\nwhich is then passed to another program can be useful for end-to-end API\ntesting. go test is Go\u2019s built-in test runner, which makes writing tests as\nsimple as installing Go - no need for any other packages.\n\nGo is fast enough by default that quick-reacting developer tools are a good\nfit. Watching files isn\u2019t something that is provided by the Go standard\nlibrary, but since dependency distribution in Go is simple (it is inlined to\nthe binary), then installing a 3rd party package isn\u2019t a big problem.\n\nMy recommendation\n\nGo is a great fit for high performance, simple applications. It\u2019s also found a\nplace in making tooling for other languages, such as esbuild for JavaScript.\n\n###\n\nRust\n\nEase of use: \ud83e\udd29 Activity of maintenance: \ud83e\udd29\ud83e\udd29\ud83e\udd29 Stability: \ud83e\udd29 Adopt/reconsider?\nAdopt Community: Medium Job Market: Small, but growing Use in: Low level,\nTooling, Compilers, Infrastructure\n\nRust is a fast-moving language which has been getting a huge amount of\nattention in recent years. As many legacy systems use languages vulnerable to\nmemory leaks, like C/C++, Rust directly addresses that problem, while still\nbeing very fast. To solve the problem of memory management, Rust introduces\nborrows and lifetimes \u2014 essentially, explicitly making the developer tell the\ncompiler how long different data needs to exist for. This is probably the most\ncomplicated idea in Rust, and can take a while to get your head around. The\nrest of Rust though will be familiar to anyone who has worked with a\ncombination of C-style syntax and functional-style features before.\n\nThe tooling situation is pretty good, too. Much like Go, there\u2019s a built-in\nway to do tests, formatting, and packages. This is a pattern you see in most\nmodern languages, especially when compared to the older alternatives they seek\nto replace (i.e C in this case).\n\nRust is promoted as a language that could be used in all kinds of places,\nthough in my experience, I see it best fitting for creating infrastructure,\ntooling, compilers, and low level native code. Web backends might fit it well\ntoo, though there is more work involved in writing Rust vs Go, for example,\nfor comparable results.\n\nWith big organisations like the US government and Google openly calling for\nmoving away from C/C++ to languages like Rust, no doubt it will become more\npopular. Large production systems, like Linux and Android, are already\nshipping Rust.\n\n####\n\nWhere I\u2019d use Rust for infrastructure, compilers, and tooling\n\nI take infrastructure here to mean the systems that your user-facing services\nare built on. So it includes purely internal backend systems, or code that\nruns as a process.\n\nRust as a language isn\u2019t simple, though parts of it are. What Rust does make\nsimple though is writing high-performance low-level code that prevents typical\nlow-level security problems for most code (with the exception of using\nunsafe). To write C code that doesn\u2019t accidentally give invalid memory access,\nyou\u2019d have to be better at writing memory-safe C than the majority of\nprofessional C developers and never make a mistake, while Rust removes that\ncategory of vulnerability. So while C is faster than Python or JavaScript,\nRust is also faster. While Python or JavaScript is less prone to memory\nproblems than C, Rust is also less prone. It is the best of both worlds. As a\nresult, using Rust when you need a combination of secure and fast code is a\ngreat choice.\n\nWhere Rust differs from Go is that Rust has more powerful abstractions, and\nbenchmarks a little better. Consider the situations where you\u2019d like to\nrepresent some complex data type, and the interactions they have. In Rust,\nerrors can be represented by a Result type. In Go, the normal pattern is to\nhave multiple return values, with an error that may be null. The Go version\nmakes it easy to neglect the error, whereas using a Result forces the\ndeveloper to handle the error case. Error handling is a pretty simple example,\nbut it applies elsewhere: Rust\u2019s workflow is more type-driven and functional,\nwhereas Go is more classic imperative. So if you\u2019re building something\ncomplex, Rust\u2019s type system may make it easier to represent.\n\nThese can be summed up as memory protection built into the language, and a\npowerful type system, but they don\u2019t come for free. Rust\u2019s code is\nconsiderably more complicated than the equivalent Go, TypeScript, or Python,\nso microservices where you\u2019d like to get a lot done in a short amount of time\nmight be better in those languages.\n\nMy recommendation\n\nIf you have a mission critical system which needs to be secure and fast, Rust\nis probably a great fit. I would probably use Rust for the infrastructure that\nother things are built upon, rather than entire systems. This would include\nstuff like operating systems, compilers, proxy servers, internal backends, and\ntooling. For simple web backend services, I\u2019d probably still go for\nGo/Python/TypeScript over Rust.\n\n###\n\nSwift\n\nEase of use: \ud83e\udd29\ud83e\udd29 Activity of maintenance: \ud83e\udd29\ud83e\udd29\ud83e\udd29 Stability: \ud83e\udd29\ud83e\udd29 Adopt/reconsider?\nAdopt Community: Medium Job Market: Medium Use in: App development\n\nObjective-C is a weird language, but I like how weird it is. I wouldn\u2019t want\nto work on a production project based entirely in it, though, and that\u2019s\nexactly what Swift solves. Swift is a modern language, mainly targeting iOS\ndevelopers, though it can be used elsewhere. With good integration into xcode,\nthe tools that iOS developers are familiar with can be reused. Instead of\nObjective-C\u2019s unusual syntax, Swift opts for a more typical C-style syntax\nwith classes and inheritance. There\u2019s interop between Swift and Objective-C,\nwhich means it\u2019s easy to reuse existing codebases and libraries. Another\nstrong aspect of Swift is that it\u2019s under active development, since Apple have\nheavily invested into it.\n\n####\n\nWhere I\u2019d use Swift for mobile developer\n\nBoth old and new projects for iOS can use Swift, and probably should. It\u2019s a\nmodern language compared to Objective-C, and has modern language features.\nThere\u2019s great integration with xcode, so building apps is almost as easy as\nweb frontends. Since Swift is being used for Apple\u2019s internal tooling and\nmobile apps, there\u2019s great support with lots of people already doing what you\nmight want to do. For the same reasons, I wouldn\u2019t use it for Android\ndevelopment unless your team is made up of only Swift developers. Kotlin has\nmore natural Android integrations.\n\nMy recommendation\n\nSwift is probably a better choice over Objective-C for iOS or OS X apps, and\nit\u2019s already more popular than Objective-C for that purpose. I personally\nwouldn\u2019t use it in other settings, though.\n\n###\n\nKotlin\n\nEase of use: \ud83e\udd29\ud83e\udd29 Activity of maintenance: \ud83e\udd29\ud83e\udd29\ud83e\udd29 Stability: \ud83e\udd29\ud83e\udd29 Adopt/reconsider?\nAdopt Community: Medium Job Market: Medium Use in: App development, Replacing\nlegacy Java\n\nMuch like Swift is to Objective-C, Kotlin is to Java. Kotlin helps address\nmany of the concerns developers have with Java, while providing a way to work\nwith Java codebases, and runs directly on the JVM. It\u2019s the default language\nby now for Android mobile development, so it\u2019s already here and established.\nIt can target native or JavaScript platforms too, and can be used on iOS.\n\nMany of the improvements are to do with syntax sugar, but some like type\ninference or nullable types actually influence how code is written, too.\n\n####\n\nWhere I\u2019d use Kotlin for mobile development\n\nBoth old and new projects for Android can use Kotlin, and probably should.\nIt\u2019s a modern language compared to Java, and has modern language features.\nThere\u2019s great integration with Android Studio, so building apps is almost as\neasy as web frontends. Since Kotlin is being used for Android\u2019s internal\ntooling and mobile apps, there\u2019s great support with lots of people already\ndoing what you might want to do. For the same reasons, I wouldn\u2019t use it for\niOS development unless your team is made up of only Kotlin developers. Swift\nhas more natural iOS integrations.\n\n####\n\nWhere I\u2019d use Kotlin to replace Java\n\nI\u2019d use it everywhere to replace Java. Java may have a larger hiring pool\nthough, as it\u2019s a long established language taught in many universities.\n\nMy recommendation\n\nKotlin is Google\u2019s recommended choice over Java for Android apps, and can be\nused to incrementally move away from Java for backend programs. I personally\nwouldn\u2019t use it in other settings, such as web frontend code, though. iOS code\nis probably better in Swift.\n\n##\n\nSQL\n\nEase of use: \ud83e\udd29\ud83e\udd29 Activity of maintenance: \ud83e\udd29\ud83e\udd29\ud83e\udd29 Stability: \ud83e\udd29\ud83e\udd29\ud83e\udd29 Adopt/reconsider?\nAdopt Community: Large Job Market: Medium Use in: Backend, Data stores\n\nWhile SQL might be specific to certain databases, the concepts it introduces\nare important. The idea of querying data through relations is a powerful one,\nand it applies to logging, metrics and analytics tools too. It\u2019s often an SQL-\nstyle language rather than directly SQL, but the ideas are the same.\n\nIf you are using a SQL database, then debugging is often related to\nperformance rather than logical bugs. Being able to drop down from your ORM to\nan SQL query directly can help optimise the hot path.\n\nMy recommendation\n\nIf you\u2019re doing backend data storage code, learn SQL, and the ideas behind it.\nYou might prefer a NoSQL database, but the concepts behind queries and making\nscalable safe transactions (e.g ACID) apply to many situations.\n\n#\n\nNiche languages\n\nNiche languages have the same considerations to take into place, but keep in\nmind the answers to them are probably all going to be more negative.\n\n  * How good is the language (solution) for what I\u2019m trying to build (problem)?\n\n    * It\u2019s more likely that the language isn\u2019t ready for your specific use case.\n\n  * Will I spend more time dealing with the language than getting features out?\n\n    * There\u2019s likely to be more weird bugs or unexpected edge cases.\n\n  * Do the libraries I need exist already?\n\n    * The libraries you need are less likely to exist.\n\n  * Will whoever inherits this from me hate me for it?\n\n    * Fewer people will be familiar with the language, fewer still with the unusual tricks you had to do to solve problems due to language or library limitations.\n\n  * How many people will be working with me on it and do they know the language already, or are they open to learning it?\n\n    * Learning a niche language isn\u2019t always on someone\u2019s to-do list.\n\nDoes that mean that you shouldn\u2019t use a niche language? No! But you should\ninvest more time in preparing before starting on a project. Conduct mini\nexperiments with smaller projects to identify the hardest problems. Build\nlibraries that are missing. Check if your team is onboard. Figure out the exit\nplan if the language turns out to not suit the problem. If it all looks too\nproblematic, stick to a mainstream language.\n\nIf you adopt a niche language at the right point, you might be able to ride\nthe wave as it becomes better and more widely adopted. On the other hand, it\u2019s\nentirely feasible that the wave you were ridding disappears, and you\u2019ll crash\ninto the sand.\n\nSince this post is so long, in-depth niche language coverage will be in a\nlater post.\n\n##\n\nConclusion\n\nWhen you\u2019re starting a new project, evaluate the language you choose in the\ncontext of what you\u2019re making, who it is for, and what you need to solve the\nbig problems you expect to face. Spend time learning the community, or making\nsmall prototypes which can be thrown away. Talk to people on your team or your\ncompany to understand what they value, and make a joint decision.\n\nTry to learn at least a couple of useful languages for your role. Have one\nlanguage which is your \u201ccomfort zone\u201d, and another which challenges you.\n\nI hope you found this post interesting! If so, feel free to sign up for more -\nincluding the follow up post to this one, where I\u2019ll go into more niche\nlanguages like Elixir, Elm, Lua, and Derw.\n\nShare\n\n1\n\nFor a more philosophical read on my love of programming languages, check out\nthis post on the Derw blog.\n\n2\n\nThere\u2019s also the Closure Compiler, by Google, which would give errors as a by-\nproduct of static analysis for performance reasons.\n\n3\n\nOne little trick I use: go to the LICENSE file on a Github repo, and look at\nthe history. Usually it is in the repo from the start, and rarely has had too\nmany changes. It\u2019s not always the case but it works most of the time.\n\n4\n\nECMAScript\u2019s working group, TC39, is composed of experts from many different\ncompanies and academia, and their meeting notes and agendas are all openly\navailable.\n\n5\n\nThough please, no more 3 line implementations of isEven that depends on isOdd\nthat depends on isNumber.\n\n6\n\nSimplest example: f-strings.\n\n### Subscribe to The Tech Enabler\n\nBy Noah Hall \u00b7 Launched 2 months ago\n\nMy personal Substack for my role as a tech enabler inside a large media\ncompany. I write about work, culture, and programming in general. My current\nseries is all about tech trends and what I think teams should adopt or drop.\n\nShare this post\n\n#### Mainstream languages I would use in production, in 2024\n\nthetechenabler.substack.com\n\nShare\n\nComments\n\nSoftware engineering practices I like, in 2024\n\nEvery couple of years in software development, the meta changes. Libraries and\nframeworks are rotated in and out of popularity, languages evolve and...\n\nFeb 27 \u2022\n\nNoah Hall\n\n9\n\nShare this post\n\n#### Software engineering practices I like, in 2024\n\nthetechenabler.substack.com\n\n4\n\nDevelopment devices for software engineers I like, in 2024\n\nWhat would I use everyday for software development? It's pretty much always a\nChromebook!\n\nMar 11 \u2022\n\nNoah Hall\n\n1\n\nShare this post\n\n#### Development devices for software engineers I like, in 2024\n\nthetechenabler.substack.com\n\nCooking multiple tasks without burning the meal\n\nHow I balance my workload, juggling many different types of tasks so that I\ncan get a lot of different things done.\n\nApr 1 \u2022\n\nNoah Hall\n\n2\n\nShare this post\n\n#### Cooking multiple tasks without burning the meal\n\nthetechenabler.substack.com\n\nReady for more?\n\n\u00a9 2024 Noah Hall\n\nPrivacy \u2219 Terms \u2219 Collection notice\n\nStart WritingGet the app\n\nSubstack is the home for great writing\n\nShare\n\n## Create your profile\n\n## Only paid subscribers can comment on this post\n\nAlready a paid subscriber? Sign in\n\n#### Check your email\n\nFor your security, we need to re-authenticate you.\n\nClick the link we sent to , or click here to sign in.\n\n", "frontpage": false}
