{"aid": "40028494", "title": "Can You Grok It \u2013 Hacking Together Your Own Dev Tunnel Service", "url": "https://0xda.de/blog/2024/04/can-you-grok-it/", "domain": "0xda.de", "votes": 2, "user": "0xdade", "posted_at": "2024-04-14 03:49:06", "comments": 0, "source_title": "Can You Grok It :: dade", "source_text": "Can You Grok It :: dade\n\n> cd /0xda.de/\n\n0xdade\n\nSeasonal Influencer. Python dev, security engineer, former red team, former\nSSD engineer. Hacker, rapper, writer. he/him\n\n16 minutes\n\n# Can You Grok It\n\nMy friend sent me a tunnel link where he had to manually set it up with socat\nand his nginx ingress controller in his k8s cluster. He made an offhand\ncomment about needing a better way to setup tunnels and it got me thinking.\nThis post is the result of a long night of hacking away at my own tunnel\nsolution.\n\nIf you want to jump into the nitty gritty of how it works, you can skip to\nRoll Your Own Tunnel. If you want to skip the nitty gritty and figure it out\nyourself, Putting It All Together is where you want to be.\n\n## Criteria\n\nI had a handful of criteria that I wanted to consider for a functional\nsolution.\n\n  1. I wanted it to run on my own infrastructure - I was likely going to be doing TLS termination at the public web server, since my development servers aren\u2019t going to be using publicly trusted TLS certificates.\n  2. I wanted the tunnels to be created under my own domain. I chose dev.0xda.de to be the parent of the tunnels \u2013 any new tunnel should be available underneath .dev.0xda.de.\n  3. I didn\u2019t want to leak the links to new tunnels automatically and invite automated scanning \u2013 dev services are often running in debug or development mode, which may leak sensitive information even in simple cases like a 404 response. This is an important distinction for one particular solution I looked at, which we\u2019ll cover in the next section.\n\nWith these criteria in mind, I looked at existing solutions. Unfortunately\nwhile looking for solutions I could potentially self host, I mostly was\nreading awesome-selfhosted which didn\u2019t seem to have a good section on\ntunnels. It turns out there\u2019s a whole separate list called awesome-tunneling,\nwhich has a handful of criteria that are somewhat similar to mine. But I\ndidn\u2019t know about this list until after I spent my whole night working on\nthis, so I won\u2019t really be touching on any items from that list.\n\n## Solutions I Considered\n\n### Ngrok\n\nI have been using ngrok off and on for years. It is okay \u2013 it\u2019s convenient to\nspin up tunnels quickly, and even the free tier allows you to reserve one\nstatic domain that you can reuse. This makes testing development of flows like\nOAuth2 login easier, especially on providers that restrict the redirect URI to\npublicly routable domains.\n\nTo get a custom domain, you have to use the $10/mo or $96/yr \u201cPersonal\u201d plan.\nThis is fairly reasonable, if I\u2019m being honest. But it doesn\u2019t meet my first\nrequirement \u2013 Ngrok controls the TLS termination before forwarding the request\nto my service. Ngrok can potentially see whatever I\u2019m developing, can\npotentially see secrets that leak in debug pages, etc. I have no reason to\nreally worry about this, but in the pursuit of my ideals, I moved on to\nanother option.\n\n### Tailscale Funnel\n\nI love Tailscale. I\u2019ve been a free tier user for over a year now, setting it\nup is incredibly easy, and I can use the Wireguard mesh network to easily\nconnect my phone to my home services while I\u2019m on the go. On top of this, I\ncan even use Tailscale to restrict my administrative ports on web servers,\nsuch that you have to either connect through my tailnet or connect through my\nbastion host.\n\nTailscale offers a feature called Funnel, which works similarly to ngrok as a\nway to route internet traffic into your local service. It doesn\u2019t meet the\nself-hosted criteria or hosting on my own domain, but I was already using\nTailscale so it was easy to test out.\n\nOne of the cool things about Tailscale Funnel is that it handles the TLS\ntermination on your device \u2013 this is an improvement over ngrok\u2019s basic proxy\nservice, since I know that the only people who can see the traffic are my\nlocal service and the client requesting it. But this comes with an important\ncaveat that I was surprised to learn about.\n\nWithin minutes of running my tailscale funnel, my Django service I was running\nfor testing was being bombarded by internet scanning noise. This was\nsurprising to me, but in hindsight it makes perfect sense.\n\nWithout too much detail about the Tailscale product, you have a \u201ctailnet\u201d\naddress of <unique-tailnet>.ts.net. For simplicity sake, let\u2019s say my tailnet\nis named ellingson-mineral.ts.net. This address can be used as the parent\ndomain of all devices on your tailnet, so you can access the Gibson by\nvisiting gibson.ellingson-mineral.ts.net from any device connected to your\ntailnet.\n\nRemember how I said that Tailscale funnel handles TLS termination on your\ndevice? Well in order to do that, your device has to control the keys for the\ncertificate. And since you want it to be publicly available, you need a\ncertificate that is trusted. So Tailscale fetches a certificate from\nLetsEncrypt for your host.\n\nSo the first time you set up a Tailscale funnel, your tailnet address shows up\nin Certificate Transparency Logs (CTL). A LOT of tailnet addresses are in CTL.\n\nThis could explain how my service started getting scanned minutes after being\nmade available online.\n\nWhile this service is really easy to use and really powerful for exposing\nservices indirectly, I think I\u2019m not a huge fan of it being immediately\navailable and scannable online, especially if it\u2019s a development service. It\nalso doesn\u2019t allow me to create tunnels with specific names \u2013 the tunnel will\nalways just be gibson.ellingson-mineral.ts.net.\n\n### VS Code Developer Tunnels\n\nI already use VS Code for most of my development, and they released a public\npreview of Dev Tunnels back in November 2023. This allows easily hooking up a\ndevelopment tunnel to a port on your local computer, allows persistent URLs\nfor as long as you need, and it\u2019s secure by default \u2013 the tunnels default to\nonly being accessible to your own Microsoft or Github account. This is\nespecially cool if you want to test things across your own devices, and it\ndoes appear to offer more granular access controls if you so desire them.\n\nEither way, this service is cool but it relies on the generosity of Microsoft,\ntunnels my traffic through their relays, and I can\u2019t really control the domain\nI want to use.\n\nI didn\u2019t spend a lot of time testing this, I\u2019ve used it before and it\u2019s okay.\nBut I really just like the idea of being able to send someone a link on my own\ndomain.\n\n## Roll Your Own Tunnel\n\nSo I was settling into rolling my own ngrok-like service. I spent maybe half\nan hour thinking about doing it with a simple HTTP application built with\nFastAPI that would broker a tunnel between clients and the server. I could\nfront the API with nginx and write a simple client. But as I started\nconsidering proxying all traffic through websockets, I realized I didn\u2019t need\nto write any of my own code to make this work.\n\nWhile looking around, I found a post by Vallard called \u201cmy own ngrok\u201d. This\nuses a simple nginx configuration and an ssh reverse proxy. These are both\nthings I\u2019ve used a great deal in the past. In Vallard\u2019s post, he uses a single\nreusable hostname, and a single port. This works great for simplicity, and for\nmost people this is probably more than enough. But I thought I could make it\njust a little bit better.\n\n### Wildcard Domains\n\nFirst I wanted to tackle the ability to have arbitrary subdomains for tunnels.\nSome years ago, I figured out that you can do wildcard server_name blocks in\nnginx while I was trying to bypass the Twitter ban on sharing links to\nddosecrets.com.\n\nTo make this work, we have to do a couple things.\n\n  1. Create a wildcard A record in your DNS zone. E.g. *.dev 10800 IN A 51.81.64.16 routes all subdomains of *.dev.0xda.de to the host that is serving this website.\n  2. Create a wildcard TLS certificate with Lets Encrypt \u2013 you\u2019ll want to make sure this can auto-renew, which will require some extra work on your part. We\u2019re not going to cover the auto-renewal in this post.\n  3. Create the following nginx config. This is loosely modified from Vallard\u2019s post referenced above, to account for my domain name and my wildcard server_name.\n\n    \n    \n    server { listen 443 ssl; listen [::]:443 ssl; server_name ~^(.*)\\.dev\\.0xda\\.de$; ssl_certificate /etc/letsencrypt/live/dev.0xda.de/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/dev.0xda.de/privkey.pem; location / { include proxy_params; proxy_pass http://localhost:7070; error_page 502 /no-tunnel.html; } location /no-tunnel.html { return 404 \"<center>No such tunnel...</center>\"; } }\n\nNow, we can have arbitrary tunnel names without leaking them to cert\ntransparency logs.\n\n### Enabling Multiple Simultaneous Tunnels\n\nOne major drawback with the configuration so far is that we can only setup one\ntunnel \u2013 our SSH reverse tunnel binds on port 7070, and our nginx config is\nrouting all traffic to that port.\n\nTo fix this, we\u2019re going to use a feature of ssh reverse tunnels that is\nprobably a little bit lesser known. See, of course you can proxy to TCP ports\nlike 7070. But you can also establish reverse proxies to a unix domain socket,\nwhich is just a file on disk.\n\nThis gives us a pretty cool capability to define a name for our tunnel on the\nclient and have that name be available on the server as a unix domain socket.\n\n    \n    \n    ssh user@example.com -R /tmp/test.dev.0xda.de.socket:127.0.0.1:8000\n\nThe important bit here is the /tmp/test.dev.0xda.de.socket. We define this on\nthe client, and it creates a file at /tmp/dev.0xda.de.socket on the server.\n\nWe can then combine this with a slight modification to our nginx server block\nto have nginx send traffic to the /tmp/test.dev.0xda.de.socket socket.\n\n    \n    \n    [...] location / { include proxy_params; proxy_pass /tmp/$host.socket; # this is the important change error_page 502 /no-tunnel.html; } [...]\n\nWe\u2019re making use of the $host variable in nginx to pass to a named socket on\ndisk. So if our request is to http://test.dev.0xda.de, then nginx will match\nthis server block and then pass the request to /tmp/test.dev.0xda.de.socket.\n\nThere\u2019s one glaring problem with this, though.\n\n### Linux Permissions\n\nWe\u2019re sshing to our server as our own user, but our nginx server workers are\nrunning as www-data. When our socket gets created, only our own user can\ninteract with it.\n\n    \n    \n    $ ls -la /tmp/test.dev.0xda.de.socket srw------- 1 dade dade 0 Apr 14 02:04 /tmp/test.dev.0xda.de.socket\n\nWe need to let www-data read and write to this socket. There are a handful of\nthings I tried, and the one that is probably the sketchiest is also the one I\nended up selecting. But let\u2019s take a look at the options first.\n\n#### Giving www-data ssh authorized_keys...\n\n... and then having my local tunnel command ssh into the www-data. This\nworked, sorta, but usually if I see www-data running ssh, or anything, really,\nI get pretty sketched out. And plus, the user\u2019s shell defaults to\n/usr/sbin/nologin \u2013 so the shell immediately terminates after ssh\nauthenticates.\n\n#### Make a group that my user and www-data belong to\n\nThis probably could work, but I was having trouble with it because whenever I\ntried to chown dade:grok /tmp/test.dev.0xda.de.socket, I was met with a\nOperation not permitted error. I suspect this is probably something we could\novercome, and is better than the alternative options if it does work, because\nwe can enable only our user and www-data to talk to the socket.\n\n#### chmod o+gw\n\nWhat I ultimately ended up doing is the dumbest possible solution. We can just\nrun chmod o+rw /tmp/test.dev.0xda.de.socket and allow any user, any process on\nthe server to communicate with this socket. Since ultimately I\u2019m granting the\ninternet read/write access to this socket anyways, I decided I was okay with\nthis for now. If I was in a shared hosting environment with other users, I\nmight reconsider \u2013 but in that scenario, I\u2019d also probably not be able to make\nthe nginx config changes necessary, so maybe that scenario is irrelevant.\n\nBut I don\u2019t want to have to run this every time I start the tunnel, that\u2019s\nannoying.\n\n### The world\u2019s sketchiest automation\n\nTo automatically run a command when we ssh in to establish the tunnel, we have\na bunch of options. We could set it up to run a non-interactive ssh session\nand run a pre-defined bash script, for instance. But for reasons I don\u2019t\nremember, this didn\u2019t really work well for me. We could also use our various\nshell rc files to attempt it whenever our shell starts up. But this also isn\u2019t\nmy favorite option, since I could start shells inside of screen or tmux, for\ninstance.\n\nInstead, I specifically only want to run this bit of code when I establish a\nnew ssh session. Enter my old persistence friend ~/.ssh/rc. This is an ssh-\nspecific configuration file that runs when you establish a new ssh connection\n\u2013 both for interactive logins as well as remote commands.\n\nOur na\u00efve solution for this can begin with the following:\n\n    \n    \n    chmod o+rw /tmp/*.dev.0xda.de.socket 2>/dev/null\n\nBut this runs every time, even when I don\u2019t specify a tunnel. It also blanket\nruns across all dev sockets in the tmp directory, rather than only running\nagainst the specific tunnel we\u2019re establishing with our ssh session.\n\nWhat we need is to pass the tunnel domain to the server, that way the process\non the server knows the exact domain name to use. This will also be helpful\nwhen we talk about cleaning up the tunnel afterwards.\n\nIn ssh, you can use an option called SendEnv to send an environment variable\nfrom the local environment to your remote environment. The sshd server must be\nconfigured to support this, and I\u2019m probably about to make some unix grey-\nbeards very angry with my next suggestion.\n\nOn my Ubuntu 20.04 server, sshd_config allows certain variables to be sent by\ndefault.\n\n    \n    \n    # Allow client to pass locale environment variables AcceptEnv LANG LC_*\n\nThat wildcard LC_* is our saving grace here. ANY environment variable that\nbegins withLC_ can be sent from a client to the server, should the client so\nchoose. So let\u2019s abuse that with a new variable called LC_GROKDOMAIN.\n\nSo now our ssh command to start the tunnel looks like this:\n\n    \n    \n    export LC_GROKDOMAIN=test.dev.0xda.de ssh dade@example.com -o SendEnv=LC_GROKDOMAIN -R /tmp/$LC_GROKDOMAIN.socket:127.0.0.1:8000\n\nAnd we can update our ~/.ssh/rc file to only run with this new information.\n\n    \n    \n    if [ -n \"$LC_GROKDOMAIN\" ]; then chmod o+rw /tmp/$LC_GROKDOMAIN.socket 2>/dev/null echo \"You can now visit https://$LC_GROKDOMAIN in your browser\" fi\n\n#### Cleaning up the socket\n\nNow that we have the automation setup to automatically give nginx the ability\nto read/write to our socket when we establish our ssh connection, we have one\nmore annoying thing that happens on the server to contend with. Cleaning up.\n\nWhen we\u2019re done with our socket, we want to remove the file from /tmp/ \u2013\notherwise if we try to reuse the socket next time, the forward will fail since\nthe file already exists.\n\nMy really hacky way to do this was to add a conditional block to my\n~/.bash_logout. This works well enough when I close the session when I\u2019m done\nwith it.\n\n    \n    \n    if [ -n \"$LC_GROKDOMAIN\" ]; then rm /tmp/$LC_GROKDOMAIN.socket 2>/dev/null fi\n\nNote: This unfortunately leaves the socket file hanging around in the event\nthat your ssh connection dies through anything other than a clean exit. There\nis almost certainly room for improvement here, but I was at the end of my\nknowledge for code that automatically gets executed in my ssh sessions.\nFailure to clean up the socket will result in the next attempt to establish\nthe tunnel failing until you remove the socket file and re-connect.\n\n### Streamlining the Client Experience\n\nOkay so far so good. We can run a single ssh command and have a new tunnel set\nup on our infrastructure, on our domain, and we haven\u2019t even introduced any\nnew code. We already had nginx, and we already had ssh. We can have as many\ntunnels as we can have unix domain sockets and nginx will handle routing\nrequests to the appropriate tunnel.\n\nBut the command is kind of clunky and not easy to use. We have to export the\ndomain variable, we have to write out a long ssh command, it\u2019s just not fun.\nLet\u2019s write a wrapper that simplifies things.\n\nConsider our current process for setting up a new tunnel:\n\n    \n    \n    export LC_GROKDOMAIN=test.dev.0xda.de ssh user@example.com -o SendEnv=LC_GROKDOMAIN -R /tmp/$LC_GROKDOMAIN.socket:127.0.0.1:8000\n\nDoing this manually also leaves LC_GROKDOMAIN hanging around in our shell,\nwhich might cause some confusion the next time we want to open a tunnel. It\u2019s\nalso just a lot to type out.\n\nWe want our interface to be simple. grok <port> [<name>] \u2013 port is required,\nand name is optional. We have to know what port to forward the traffic to, but\nwe don\u2019t necessarily have to designate a name.\n\nA simple bash script later, and we\u2019ve got exactly what we need.\n\n    \n    \n    #!/bin/bash grok() { TOP_LEVEL_DOMAIN=\"dev.0xda.de\" if [ -z \"$1\" ]; then echo \"Usage: grok <port> [<name>]\" return 1 fi local port=\"$1\" local name=\"$2\" if [ -z \"$name\" ]; then # Generate a random 12-digit hexadecimal string name=$(openssl rand -hex 6) fi echo \"Setting up ${name}.${TOP_LEVEL_DOMAIN}\" export LC_GROKDOMAIN=\"${name}.${TOP_LEVEL_DOMAIN}\" ssh user@example.com -o ControlPath=none -o SendEnv=LC_GROKDOMAIN -R /tmp/$LC_GROKDOMAIN.socket:127.0.0.1:$port } grok $@\n\nI put this in .local/bin/grok, which is in my path, and now I can just run\ngrok 8000 test. I also added in a feature that will generate a random 12 digit\nhexadecimal tunnel name if we don\u2019t specify one. I also explicitly disable\nControlPath in my command \u2013 I noticed that our tunnels don\u2019t reliably close if\nyou make use of ControlMaster at all.\n\n## Limitations\n\nThere are some limitations to this method that I feel are important to\naddress.\n\n  * If the socket stays behind on the remote host, our tunnel will fail next time and we have to manually connect in and delete it, then disconnect and reconnect our ssh session. (Technically we can do this with control sequences, but that\u2019s also a topic for a different time)\n  * Our current implementation keeps the interactive session open the whole time \u2013 it would be cool if we could skip the interactive session but keep the session open until we close it. Due to the first limitation, the interactive session is just more useful right now.\n  * This version of this project can\u2019t handle arbitrary TCP tunneling \u2013 the nginx block is in an http block. We can technically setup an arbitrary named TCP tunneling service, but that\u2019s definitely a topic for another day\n  * The HTTP logs for basic web servers can\u2019t distinguish between clients \u2013 E.g. python3 -m http.server 8080 results in all requests having a client IP of 127.0.0.1. I think this can be handled in the nginx config, but I haven\u2019t looked further into it yet.\n\n## Putting It All Together\n\nThis should be everything you need to replicate this configuration. Adjust\ndomain names and paths appropriately.\n\n(Remote) /etc/nginx/sites-available/dev.0xda.de.conf\n\n    \n    \n    server { listen 443 ssl; listen [::]:443 ssl; server_name ~^(.*)\\.dev\\.0xda\\.de$; ssl_certificate /etc/letsencrypt/live/dev.0xda.de/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/dev.0xda.de/privkey.pem; location / { include proxy_params; proxy_pass /tmp/$host.socket; error_page 502 /no-tunnel.html; } location /no-tunnel.html { return 404 \"<center>No such tunnel...</center>\"; } }\n\n(Remote) ~/.ssh/rc\n\n    \n    \n    if [ -n \"$LC_GROKDOMAIN\" ]; then chmod o+rw /tmp/$LC_GROKDOMAIN.socket 2>/dev/null echo \"You can now visit https://$LC_GROKDOMAIN in your browser\" fi\n\n(Remote) ~/.bash_logout\n\n    \n    \n    # rest of your config here ... if [ -n \"$LC_GROKDOMAIN\" ]; then rm /tmp/$LC_GROKDOMAIN.socket 2>/dev/null fi\n\n(Local) ~/.local/bin/grok \u2013 Make sure ~/.local/bin is in your $PATH\n\n    \n    \n    #!/bin/bash grok() { TOP_LEVEL_DOMAIN=\"dev.0xda.de\" if [ -z \"$1\" ]; then echo \"Usage: grok <port> [<name>]\" return 1 fi local port=\"$1\" local name=\"$2\" if [ -z \"$name\" ]; then # Generate a random 12-digit hexadecimal string name=$(openssl rand -hex 6) fi echo \"Setting up ${name}.${TOP_LEVEL_DOMAIN}\" export LC_GROKDOMAIN=\"${name}.${TOP_LEVEL_DOMAIN}\" ssh user@example.com -o ControlPath=none -o SendEnv=LC_GROKDOMAIN -R /tmp/$LC_GROKDOMAIN.socket:127.0.0.1:$port } grok $@\n\n## Conclusion\n\nI have been using this quite a bit since building it and the quirks definitely\nmake the experience a little less than ideal. But I also don\u2019t have to run any\nnew applications on my server, don\u2019t have new credentials to worry about, and\nit works well enough that it\u2019s easy for me to quickly send someone a\ncustomized link to a development tunnel.\n\nShould you use this? I\u2019m not sure, really. It feels kinda sketchy to pass the\nHost header directly to the filesystem, and I\u2019m not particularly happy with\ngiving the whole server read/write to the socket file either.\n\nBut it was fun to piece these two pieces of technology together in this\nsurprisingly useful way, using knowledge that isn\u2019t particularly arcane but\nalso isn\u2019t particularly common.\n\nPlease tweet me with ways you\u2019d improve this. You can also message me on\nBluesky (@0xda.de) or Mastodon (@dade@crime.st).\n\nSysadminSoftware DevelopmentLinux\n\n3407 Words\n\n2024-04-14 03:13 +0000\n\nDocker Desktop & WSL Randomly Breaks \u2192\n\n0xdade\n\nSeasonal Influencer. Python dev, security engineer, former red team, former\nSSD engineer. Hacker, rapper, writer. he/him\n\n\u00a9 2024 Privacy CC BY-NC 4.0\n\n", "frontpage": false}
