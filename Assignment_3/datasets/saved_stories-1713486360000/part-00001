{"aid": "40079186", "title": "A Philosophy of Software Design: My Take (and a Book Review)", "url": "https://blog.pragmaticengineer.com/a-philosophy-of-software-design-review/", "domain": "pragmaticengineer.com", "votes": 2, "user": "teleforce", "posted_at": "2024-04-18 18:24:23", "comments": 0, "source_title": "A Philosophy of Software Design: My Take (and a Book Review)", "source_text": "A Philosophy of Software Design: My Take (and a Book Review) - The Pragmatic\nEngineer\n\n### Menu\n\nClose\n\n  * Home\n  * Newsletter\n  * My Books\n  * Jobs Board\n  * Talent Collective\n  * Reading List\n  * Popular Articles\n  * Ethics statement\n  * Sponsoring\n  * Investing\n  * Now\n  * Contact me\n  * About\n  * The Tech Resume Book\n  * Mobile Apps at Scale Book\n  * RSS Feed\n  * twitter\n  * youtube\n  * linkedin\n  * Interview Preparation\n  * Templates\n  * Stats\n\nSubscribe\n\n  * Home\n  * Newsletter\n  * My Books\n  * Jobs Board\n  * Talent Collective\n  * Reading List\n  * Popular Articles\n  * Ethics statement\n  * Sponsoring\n  * Investing\n  * Now\n  * Contact me\n  * About\n  * The Tech Resume Book\n  * Mobile Apps at Scale Book\n  * RSS Feed\n  * twitter\n  * youtube\n  * linkedin\n  * Interview Preparation\n  * Templates\n  * Stats\n\n# A Philosophy of Software Design: My Take (and a Book Review)\n\nI was somewhat skeptical when starting to read a Philosophy of Software\nDesign, despite having it recommended by a friend. The book does a delightful\njob underselling itself. It is odd-shaped, published by a university press,\nand the preface mentions, \"At this point, you might be wondering: what makes\nme think I know all the answers about software design? To be honest, I don't.\"\n\nHowever, the fact that the book was written by someone who's been writing code\nfor decades, the university press being Stanford press, and the book covering\nlessons learned during the first software design class at Stanford gauged my\ninterest. Still, I wondered just how much I would learn about software design\nfrom experience partially distilled from a classroom - even if a Stanford\nclassroom. A lot, as it would turn out.\n\nThis post summarizes key takeaways of the book and my take on these\nprinciples, drawing from my professional and industry experience. If you're\ninterested in whether to read this book, my recommendation is that you\nprobably should, for a few reasons I list in my conclusion.\n\nNote that none of the below links are affiliate links or sponsored ones. See\nmy ethics statement on the lack of such links.\n\nInterested in a no-time-to-waste book video review? I made one, watch it on\nYouTube, then read further:\n\n## The problem with software architecture: it's not repeatable in the real\nworld. Or is it?\n\nThere is a significant difference between most books written on software\ndesign and John Ousterhout's one. It's repeatability. While almost all\nsoftware architecture books are based on real-world experiences of experienced\ndevelopers and consultants, those are not repeatable experiences. Those people\nsolved challenging problems using certain methods: but they did not have the\nopportunity to do the same with a different approach. Even my views on\nsoftware architecture are based on one-off projects and their aftermath.\n\nJohn, on the other hand, had the vantage point of having multiple teams solve\nthe same design problem during a semester, with him observing. He also had the\nluxury of repeating this experiment multiple times. With each repeat, he was\nable to both validate and tweak his observations.\n\nSo what is software design, according to John? He says it is a means to fight\ncomplexity.\n\n> The greatest limitation in writing software is our ability to understand the\n> systems we are creating. (...) The larger the program, and the more people\n> work on it, the more difficult it is to manager complexity. Good development\n> tools can help us deal with complexity. (...) But there is a limit to what\n> we can do with tools alone. (...) Simpler designs allow us to build larger\n> and more powerful systems before complexity becomes overwhelming.\n\nSo how, exactly, should we fight this complexity? By encapsulating complexity\nvia modular design and making code simple and obvious, like eliminating\nspecial cases or using consistent coding styles. The first part of the book\nfocuses on good, modular design practices, while the second part of the book\ntouches on techniques to make the code simple, as well as goes in-depth on\ncommenting best practices.\n\n## Solid recommendations I agree with\n\nTactical vs strategic coding: deciding when to invest for the longer-term\nisn't easy. Be aware if you are putting out a fire, or building for the long-\nterm. This observation matches my experience: \"hacking\" something together\nquickly, just to make it work, versus platformizing (making it reusable,\nextensible) is a tricky tradeoff to make. While this advice sounds simple, it\nis the one that requires experience and times of being burnt, to get it right.\nThe challenge here is similar to the software development dilemma of moving\nfast, without breaking things.\n\nDesigning things twice (Chapter 11) is a suggestion that hits close to home.\nThis is advice I've been suggesting to people to get better at designing\nsystems, well before I read this book.\n\nDeep vs shallow modules and smart usage of layers (Chapter 4 & 7) are\nchapters, where John notes how abstractions that have simple interfaces (deep\nmodules) but hide complex functionality help reduce the complexity of\nprograms. They do this better than shallow modules do - modules that have a\nsimple implementation, but complex interfaces. This was something I've not\ngiven much thought before, but it certainly rings true. The depth of a module\nis a concept I've previously not thought to use, but I'm adding it to my\ntoolset. Much of the book builds on this concept of module depth:\n\n  * It's more important for a module to have a simple interface than a simple implementation is a thought introduced in Chapter 8. While my experience confirms this - especially when talking about distributed systems and microservices. I did find logic and examples that John used to get here as interesting. For the theory, he builds on the logic that deep modules encourage information hiding and reduce complexity. For the practice, he takes examples from students implementing a class that manages files for a GUI text editor assignment. Students who chose a simple implementation, but complex interfaces - exposing the concept of lines - ran into far more trouble and complexity. They struggled more with this interface than those who went with a simple interface, with a complex implementation: a character-based interface.\n  * Layers should remove, not add complexity to a system (Chapter 7). The book refers to this as \"different layer, different abstraction,\" arguing against the usage of call-through methods or decorator classes. While I agree that pass-through layers add complexity to the system and are best avoided, my experience when working in production systems tells me it's not that simple. Working within one application or codebase this complexity is more trivial to spot and eliminate. However, when working with standalone services, it's a more labor-intensive and process. It is a good reminder to both resist the urge to build services that do too much wrapping, as well as to keep track of this kind of architecture debt.\n\nInformation hiding and information leakage (Chapter 5) is another take on what\ngood abstraction is and how efficient interfaces should behave. Those who have\ndesigned APIs have probably had first-hand experience with why leaking\ninformation beyond the bare minimum leads to tech- and architecture debt later\non. John also mentions a glaring example of bad API design: over-exposing\ninternals.\n\n  * Information leakage correlated to shallow classes was an interesting observation: the first of several based on the book not based on John's own experience, but about his analysis of the student's work. He noticed how students who divided their code into many, small classes, that were shallow, ended up with much duplicated logic, caused by information leakage.\n  * Generalizing leads to better information hiding. General-purpose/reusable modules are deeper - they have more complex internal logic, but simpler interfaces. Not surprising to anyone who's attempted to build more generic APIs. However, taking the previous argument further, it also means generality leads to better information hiding. Want to have simpler architecture? Consider generalizing components. The example of building a text editor during the semester is used to prove this point, with examples.\n\nTradeoffs when combining or separating implementations within modules or\ninterfaces (Chapter 9) is an interesting debate that I don't know of a single\nbest answer. We share this view with John, who also agrees the best solution\nwill be context-dependent. John collects a few rules of thumbs he suggests to\nuse when deciding to combine or separate. Combine when it makes for a simpler\ninterface, to reduce duplication or when implementations share\ndata/information. Separate general-purpose and special-purpose code.\n\nWhile all of the above is sensible, personally still prefer single-purpose\ninterfaces, even if that might leave some implementation separately, that\ncould technically be combined. In the case of microservices, an important\nguiding principle is to avoid separating services while they use/modify the\nsame data source. A larger service that is cohesive results in less complexity\nthan several smaller services, manipulating the same data source.\n\nThe importance of good and simple naming (Chapter 14) mirror my experience on\nhow simple names often mean simple functionality. Complex names - or\ndifficulty to name something - is usually a code or architecture smell. John\nmentions that consistent naming contributes to less complexity - something I\nwholeheartedly agree with.\n\n#### Newsletter\n\nSubscribe to my weekly newsletter for weekly articles with observations and\ndeep-dives about the software engineering industry. It's the #1 technology\nnewsletter on Substack and this is what people say about it.\n\n## Recommendations I don't necessarily agree with\n\nA strong stance against exceptions (Chapter 10) was an interesting read. John\nargues that exceptions introduce one of the worst sources of complexity and\nadvocates for writing code that needs no exceptions to run. This is a section\nthat seems to build on John's own experience, and him analyzing Windows APIs\nand does not bring classroom examples.\n\nFor backend systems, I view exceptions as a good thing: as long as they are\nthoroughly monitored and alerted on, targeting a zero exceptions policy. For\nclient-side software like mobile apps and desktop apps, I agree that\nexceptions make for more complex logic. In these cases, exception masking -\nand logging - that John suggests in Chapter 10 can be a good solution. He\nlists the option of deciding that it's fine to crash the application on an\nexception: which would not fly in areas like mobile development.\n\nCalling out event-driven programming as something that makes the code less\nobvious (Chapter 18) is an interesting take, that I would have hesitated to\nphrase as such. While event-driven programming is certainly more complex, due\nto no clear flow of control, in real-world scenarios, this is a necessity.\nBoth in the case of distributed systems, as well as multi-threaded\nenvironments, there is no other option. John's suggestion to add a comment for\nevent handlers doesn't cut it in my book. Instead, monitoring errors, alerting\n(for backend code) and logging, uploading, and analyzing logs (for client-side\napplications) is one way to stay on top of the system working correctly at all\ntimes. Much of modern programming, from messaging services to frameworks like\nFx is moving towards an asynchronous model, where dealing with this complexity\nis part of the job.\n\nJohn is quite in favor of writing comments, an approach I have less love for.\nThree chapters - chapters 12, 13, and 15 are dedicated to this topic, looking\nat it from different angles. In general, I like to think of inline comments\nbeing an invitation for refactoring. This is especially true for code that is\nwell-tested with unit and other automated tests. For junior engineers, the\nadvice of writing comments first (Chapter 15 on) is solid. The part I do agree\nwith John is how comments should describe things that aren't obvious from the\ncode (Chapter 13). After exchanging emails with John, we both agreed that if\nthere are important ideas that cannot be conveyed through the code, then\ncomments are appropriate for them. Still, I like to challenge the code\ninstead, asking if refactoring would help eliminate the need for a comment.\n\n## Topics I missed\n\nWhile the book does a good job covering architecture concepts when writing\ncode, there are several areas that it does not touch on. Most of these are\noutside the scope of the software design course itself. However, some\nreference to these would have been useful.\n\nWriting up, sharing, and debating design with other peers is a practice more\nand more common in tech companies. This includes both whiteboarding and\npresenting to a group of peers, as well as more formal RFC-like design\nprocesses. While it might be less applicable to the course John taught, it's a\npractice that comes with many benefits. These days, as shared editing and\ncommenting tools are more common, with editors like Google Docs and O365.\nSharing design ideas upfront and opening a debate using these tools is a great\nway to build more sturdy architecture. Especially when applying the \"design it\ntwice\" principle, and writing up alternative designs considered, and the\ntradeoffs why the other design was not chosen.\n\nTesting was absent from the book, save for the last part, mentioned at the end\nof the book, in 19.3, as part of software trends. In my view, good\narchitecture and testability go hand-in-hand and would have welcomed this\ntopic mentioned earlier. John dedicates discussing strategies to modify\nexisting code in-depth in Chapter 16. His two pieces of advice are on staying\nstrategic in modifying the design and maintaining the comments. This does not\nmatch my reality. The surest and safest way I know to modify existing code is\nto have tests. With tests in place, go ahead and make whatever change is\nnecessary - and sensible. If there are no tests, start by writing tests. If\nthere are tests, major refactors that wildly modify the existing design can\nalso fly - the tests should give a safety net to do so. And with tests in\nplace, comments become an afterthought: if there is a test for it, a comment\nis not that necessary. Note that after exchanging emails with John, he pointed\nout he focused the book on architecture, treating other topics deliberately\nout of scope.\n\n## Conclusion\n\nThe book is an easy read, thanks to its short sections and good bolding. It\nlends itself to both skimming through, and in-depth reading. The concepts are\nfresh and a welcome read. Most importantly, the book stays humble, does not\ntry to convince, but offers perspectives backed by easy to follow examples.\n\nI very much recommend the first half of the book - chapters 1-9 and chapter 14\n- for all software engineers to read, digest, and consider applying. Concepts\nlike depth of modules, layers adding complexity - or keeping complexity at bay\n- and information hiding are pragmatic tools to use when designing software.\nThe book offers a fresh take on the concept of abstractions, and nicely\ncomplements principles like simplicity, KISS (Keep it Simple, Stupid) and\nYAGNI (You Ain't Gonna Need It).\n\nThe book does leave a glaring gap on testing and how testability and good\narchitecture go hand in hand. I would recommend a book like Clean Code or\nWorking Effectively with Legacy Code to augment the topics written here.\nTechnical debt and architecture debt also don't get much mention or\ndiscussion, which is in contrast to my day to day work. It would be nice to\nsee a later version touch on these topics, as well.\n\nFor people who have less experience in software development, the remaining of\nthe book will also be practical. Naming is an especially useful section. The\nparts on writing comments before coding, and comments complimenting the code\nare decent strategies to start with. Those with more experience under their\nbelt my disagree with some of the recommendations. Still, they all present\ninteresting viewpoints, backed with examples. They also make for potentially\nsound advice to give, when mentoring less experienced engineers.\n\nThere are few books that discuss software design in a simple and approachable\nway, while leaving the reader novel and practical concepts to use. A\nPhilosophy of Software Design is a standout and recommended read for this\nreason. We need more resources to remind us not overcomplicate software\narchitecture. It will become complicated enough, module after module, layer\nafter layer.\n\n### Featured Pragmatic Engineer Jobs\n\n  * Director of Engineering at Synthesia. \u00a3180-250K. Remote (EU or UK).\n  * Senior Product Engineer (Backend) at Plain. \u00a375-110K + equity. Remote (Europe).\n  * Founding Engineer (Full-Stack) at Ethos. New York City.\n  * Senior Platform Infrastructure Engineer at Jack Henry. $130-280K. Remote (US).\n  * Senior Software Engineer at Tint. $140-250K. Remote (US or EU).\n  * Senior Software Engineer at Tally Health. $140-180K + equity. New York City or Remote (US).\n  * Senior Frontend Engineer at WellTheory. $130-150K + equity. Remote (Global).\n  * Senior Frontend Developer at ePilot. \u20ac70-100K. K\u00f6ln (Germany) or Remote (Germany).\n  * Senior Full Stack Engineer at ePilot. \u20ac70-100K. Remote (Germany).\n  * Senior Product Engineer, Frontend at Attio. \u00a390-125K + equity. Remote (Europe).\n  * Engineering Manager at Safi. Remote (UK).\n  * Staff Full Stack Engineer at POSH. $170-220K + equity. New York (US).\n\nThe above jobs score at least 9/12 on The Pragmatic Engineer Test. Browse more\nsenior engineer and engineering leadership roles with great engineering\ncultures, or add your own on The Pragmatic Engineer Job board and apply to\njoin The Pragmatic Engineer Talent Collective.\n\n#### The Software Engineer's Guidebook\n\nMy latest book, The Software Engineer's Guidebook is out. Here is what Tanya\nReilly, senior principal engineer and author of The Staff Engineer's Path says\nabout it:\n\n> \"From performance reviews to P95 latency, from team dynamics to testing,\n> Gergely demystifies all aspects of a software career. This book is well\n> named: it really does feel like the missing guidebook for the whole\n> industry.\"\n\nRead more reviews and Get the book here.\n\n#### Newsletter\n\nSubscribe to my weekly newsletter for engineering managers and senior\nengineers. It's the #1 technology newsletter on Substack.\n\nInterested in more? See popular articles and books I published.\n\n#### Gergely Orosz\n\nLast updated 27 October 2023. Originally published 18 Nov 2019.\n\nWriting The Pragmatic Engineer Newsletter and advisor at mobile.dev.\nPreviously at Uber, Microsoft, Skype, Skyscanner.\n\nAmsterdam, Netherlands\n\n#### Share this post\n\nTwitter Facebook\n\nby Gergely Orosz\n\n### Menu\n\nClose\n\n  * Home\n  * Newsletter\n  * My Books\n  * Jobs Board\n  * Talent Collective\n  * Reading List\n  * Popular Articles\n  * Ethics statement\n  * Sponsoring\n  * Investing\n  * Now\n  * Contact me\n  * About\n  * The Tech Resume Book\n  * Mobile Apps at Scale Book\n  * RSS Feed\n  * twitter\n  * youtube\n  * linkedin\n  * Interview Preparation\n  * Templates\n  * Stats\n\nSubscribe\n\n  * Home\n  * Newsletter\n  * My Books\n  * Jobs Board\n  * Talent Collective\n  * Reading List\n  * Popular Articles\n  * Ethics statement\n  * Sponsoring\n  * Investing\n  * Now\n  * Contact me\n  * About\n  * The Tech Resume Book\n  * Mobile Apps at Scale Book\n  * RSS Feed\n  * twitter\n  * youtube\n  * linkedin\n  * Interview Preparation\n  * Templates\n  * Stats\n\n  * Subscribe via email\n  * Subscribe in a reader\n\nThe Pragmatic Engineer \u00a9 2019\n\n## An Engineering Team where Everyone is a Leader\n\nHaving worked for a decade as an engineer at various companies, I noticed how\nmost teams in software often...\n\n## Working at Silicon Valley Companies - in Europe\n\nI've recently been talking with several other people working in the European\noffices of Silicon Valley tech...\n\n", "frontpage": false}
