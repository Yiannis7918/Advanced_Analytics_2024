{"aid": "40031206", "title": "Comparing Anti-Cheat Bypass and EDR Bypass", "url": "https://whiteknightlabs.com/2024/02/09/a-technical-deep-dive-comparing-anti-cheat-bypass-and-edr-bypass/", "domain": "whiteknightlabs.com", "votes": 1, "user": "Arteiii", "posted_at": "2024-04-14 14:16:46", "comments": 0, "source_title": "A Technical Deep Dive: Comparing Anti-Cheat Bypass and EDR Bypass", "source_text": "A Technical Deep Dive: Comparing Anti-Cheat Bypass and EDR Bypass | White Knight Labs\n\n877-864-4204\n\n  * Contact us\n\nSelect Page\n\n  * Home\n  * Services\n\n    * Penetration Testing\n\n      * Network Pen-Test\n      * Web App Pen-Test\n      * Mobile App Pen-Test\n      * Wireless Pen-Test\n      * Cloud Pen-Test\n    * Attack Simulation\n\n      * Red Team\n      * Social Testing\n      * Ransomware Attack\n      * Business Email Compromise\n    * Security Assessments\n\n      * VIP Home Security\n      * Password Audit\n      * Embedded Devices\n      * OSINT\n      * AD Security Assessment\n      * Dark Web Scanning\n      * Smart Contract Audit\n      * Business Email Compromise\n    * Incident Response\n    * Compliance and Advisory\n\n      * Framework Consulting\n      * Gap Assessments\n      * Compliance as a Service (CAAS)\n  * Training\n  * Resources\n\n    * Cyber Security FAQ\n    * Blog\n    * Partnerships\n    * About us\n    * Careers\n    * Contact\n  * News\n  * Contact us\n\n# A Technical Deep Dive: Comparing Anti-Cheat Bypass and EDR Bypass\n\nby Mark Lester Dampios | Feb 9, 2024 | Uncategorized\n\nIn the evolving landscape of digital security, two prominent challenges emerge\nthat pose significant threats to the integrity of online systems and user\ndata: anti-cheat bypass and EDR bypass. These concepts revolve around\ncircumventing protective measures designed to ensure fair play in the realm of\nonline gaming and to safeguard computer systems against malicious software,\nrespectively. This post will delve into the goals of anti-cheat bypass and EDR\nbypass, exploring the motivations behind these activities and their\nimplications, and will draw a distinction between legitimate security research\nand illicit activities.\n\nAspect| Anti-Cheat Bypass| EDR Bypass  \n---|---|---  \nTarget Environment| Gaming applications and platforms| General computing\nenvironments and systems  \nObjective| Evade detection in multiplayer games| Circumvent EDR software\ndetection  \nTechniques| Code injection, hooking, packet manipulation| Polymorphic malware,\nrootkits, code obfuscation  \nDetection Mechanisms| Heuristic analysis, behavior monitoring| Signature-based\ndetection, heuristics, sandboxing  \nImpact on Users| Unfair advantages in games, potential for game exploitation|\nCompromised system integrity, data theft, and malware infections  \nLegal Implications| Violation of terms of service in gaming platforms|\nUnlawful activities, data breaches, and legal consequences  \nEcosystem Impact| Degraded gaming experience, loss of revenue for developers|\nWidespread malware outbreaks, compromised user data  \nCountermeasures| Regular updates, server-side validation, player reporting|\nRegular EDR updates, intrusion detection systems, user education  \nQuick Comparison\n\n# Anti-Cheat Bypass\n\nAnti-cheat bypass refers to the process of evading or overcoming security\nmechanisms implemented in online games to detect and prevent cheating. The\nprimary goal of individuals attempting to bypass anti-cheat systems is to gain\nan unfair advantage over other players, disrupting the balance and integrity\nof the gaming experience. Cheating in online games can take various forms,\nincluding aimbots, wallhacks, speed hacks, and other modifications that\nprovide an unfair advantage.\n\n## Motivations Behind Anti-Cheat Bypass\n\nThe motivations behind individuals engaging in anti-cheat bypass activities\nare multifaceted. Some seek the thrill of outsmarting security systems, driven\nby the challenge of breaking through digital barriers. Others may be motivated\nby a desire for recognition within hacking communities or to monetize their\nexploits by selling cheat tools and services. In some cases, players may\nresort to cheating as a form of rebellion against perceived unfairness in the\ngaming environment.\n\n## Legitimate Security Research vs. Illicit Activities in Anti-Cheat Bypass\n\nIt is essential to distinguish between legitimate security research and\nillicit activities when discussing anti-cheat bypass. Ethical hackers may\nengage in responsible disclosure, helping game developers identify\nvulnerabilities and strengthen their anti-cheat measures. However, individuals\nwho exploit these vulnerabilities for personal gain or to disrupt online\ncommunities fall into the category of illicit actors, threatening the\nstability of online ecosystems.\n\n# EDR Bypass\n\nOn the other hand, EDR bypass involves evading or circumventing the detection\nmechanisms employed by EDR software to identify and neutralize malicious\nsoftware. Malware developers and cybercriminals employ various techniques to\ncreate and distribute malware that can go undetected by EDR programs, allowing\nthem to compromise systems, steal sensitive information, or launch other\nmalicious activities.\n\n## Motivations Behind EDR Bypass\n\nThe motivations behind EDR bypass are predominantly malicious, driven by the\ndesire to evade detection and ensure the successful deployment of malware.\nCybercriminals aim to compromise the security of individual users, businesses,\nand organizations for financial gain, espionage, or other nefarious purposes.\nThe constantly evolving nature of cybersecurity requires malware developers to\nstay one step ahead of security solutions, leading to a perpetual arms race\nbetween attackers and defenders.\n\n## Legitimate Security Research vs. Illicit Activities in EDR Bypass\n\nLegitimate security research and illicit activities in EDR bypass highlight a\nfine line between enhancing cybersecurity and exploiting vulnerabilities for\nmalicious purposes. Ethical researchers aim to strengthen security postures\nthrough responsible disclosure and adherence to legal frameworks, contrasting\nsharply with attackers who operate with malicious intent, outside legal\nboundaries. This dynamic underscores the critical need for continuous\ninvestment in security research and collaboration within the cybersecurity\ncommunity to stay ahead of evolving threats.\n\n# Anti-Cheat Bypass and EDR Bypass\n\nThe goals of anti-cheat bypass and EDR bypass differ in their focus and\nimpact. Anti-cheat bypass aims to undermine fair play in online gaming, while\nEDR bypass seeks to compromise the security of computer systems for malicious\npurposes. Distinguishing between legitimate security research and illicit\nactivities is crucial in addressing these challenges and fostering a secure\ndigital environment. As technology continues to advance, the need for\ninnovative and adaptive security measures becomes increasingly apparent to\ncounteract the persistent efforts of those seeking to exploit vulnerabilities\nfor their gain.\n\nIn the ever-evolving landscape of cybersecurity, the perpetual battle between\nattackers and defenders has given rise to sophisticated tools and techniques\non both sides. While anti-cheat bypass and EDR bypass both involve\ncircumventing security measures, they target different domains, with anti-\ncheat focusing on gaming environments and EDR on overall system protection.\n\nWindows API| Category| Anti-Cheat Bypass| EDR Bypass  \n---|---|---|---  \nExecution  \nCreateRemoteThread| Code Injection| X| X  \nVirtualAllocEx| Code Injection| X| X  \nWriteProcessMemory| Code Injection| X| X  \nCreateProcess| Process Creation| X| X  \nLoadLibrary| Dynamic Link Library (DLL) Load| X| X  \nShellExecute| Process Execution| X| X  \nPersistence  \nRegSetValueEx| Registry Modification| X  \nCreateService| Service Creation| X  \nChangeServiceConfig| Service Configuration| X  \nPrivilege Escalation  \nAdjustTokenPrivileges| Token Privilege Modification| X  \nOpenProcessToken| Token Manipulation| X  \nEnablePrivilege| Enable Specific Privilege| X  \nDefense Evasion and Anti-Analysis  \nNtQuerySystemInformation| System Information Query| X  \nNtSetInformationProcess| Process Information Setting| X  \nSetThreadContext| Thread Context Modification| X  \nZwUnmapViewOfSection| Memory Section Unmapping| X  \nOutputDebugString| Debug Output| X  \nComparison of Windows API Commonly Used in Bypass Techniques\n\n# Anti-Cheat Bypass Techniques\n\n## Code Injection and Hooking\n\nConsider a scenario where an attacker aims to gain an unfair advantage in an\nonline game by injecting custom DLLs into the game process. These DLLs may\ncontain cheats, such as aimbots or wallhacks, allowing the player to\nmanipulate the game environment and gain an upper hand.\n\n    \n    \n    #include <Windows.h> void InjectDLL(DWORD processId, const char* dllPath) { HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId); LPVOID dllPathAddr = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, MEM_COMMIT, PAGE_READWRITE); WriteProcessMemory(hProcess, dllPathAddr, dllPath, strlen(dllPath) + 1, NULL); LPVOID loadLibraryAddr = GetProcAddress(GetModuleHandle(\"kernel32.dll\"), \"LoadLibraryA\"); HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryAddr, dllPathAddr, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); VirtualFreeEx(hProcess, dllPathAddr, 0, MEM_RELEASE); CloseHandle(hProcess); } int main() { InjectDLL(1234, \"C:\\\\Path\\\\To\\\\Your\\\\Hack.dll\"); return 0; }\n\n## Function Hooking in Multiplayer Games\n\nIn the realm of multiplayer games, attackers may employ function hooking\ntechniques to intercept and modify functions responsible for player health or\nammunition. This manipulation can provide an illicit advantage by making the\nattacker\u2019s character invulnerable or granting infinite ammunition.\n\n    \n    \n    #include <Windows.h> #include <iostream> // Original function int OriginalFunction(int a, int b) { return a + b; } // Hooked function int HookedFunction(int a, int b) { std::cout << \"HookedFunction is called!\" << std::endl; return OriginalFunction(a, b); } int main() { // Replace the original function with the hooked function DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourAttach(&(PVOID&)OriginalFunction, HookedFunction); DetourTransactionCommit(); // Call the hooked function int result = OriginalFunction(10, 20); // Cleanup DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourDetach(&(PVOID&)OriginalFunction, HookedFunction); DetourTransactionCommit(); return 0; }\n\n## Packet Manipulation\n\nCheaters often manipulate network packets using tools like Scapy to alter the\ninformation sent between the game client and server. For instance, an attacker\ncould modify the coordinates of their character in the game world, creating\nthe illusion of teleportation or superhuman speed.\n\n    \n    \n    #include <WinSock2.h> int main() { // Initialize Winsock WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), &wsaData); // Create a socket SOCKET sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // Connect to the game server sockaddr_in serverAddr; serverAddr.sin_family = AF_INET; serverAddr.sin_port = htons(1234); inet_pton(AF_INET, \"127.0.0.1\", &serverAddr.sin_addr); connect(sock, (struct sockaddr*)&serverAddr, sizeof(serverAddr)); // Manipulate outgoing packet const char* modifiedData = \"ModifiedPacketData\"; send(sock, modifiedData, strlen(modifiedData), 0); // Cleanup closesocket(sock); WSACleanup(); return 0; }\n\n## Code Obfuscation\n\nTo avoid detection, cheat developers may employ code obfuscation techniques\nwhen creating game cheats. This involves transforming the cheat code into a\nmore complex and convoluted form, making it challenging for anti-cheat systems\nto recognize and analyze the malicious code.\n\n    \n    \n    // Example of basic code obfuscation void ObfuscatedFunction() { int a = 5; int b = 10; // Unnecessary instructions for obfuscation a = a + 1; b = b - 1; int result = a + b; // ... }\n\n# EDR Bypass Techniques\n\n## Polymorphic Malware\n\nImagine a scenario where a polymorphic malware variant is distributed through\na phishing campaign. The malware constantly mutates its code to evade\nsignature-based detection, making it difficult for traditional EDR solutions\nto recognize and block the malicious payload.\n\nThe example below is an application with the very same functionality but with\nnoticeable differences with opcodes. The sample demonstrates a lot of junk\ncodes between each jump to bypass signature scanning.\n\nBasic Polymorphism\n\n## Rootkit Techniques\n\nIn a real-world scenario, an advanced persistent threat (APT) may deploy a\nkernel-mode rootkit to hide its presence on compromised systems. This rootkit\noperates at a deep level within the operating system, making it challenging\nfor EDR solutions to detect and remove.\n\n    \n    \n    #include <ntddk.h> NTSTATUS MyNtQuerySystemInformation( SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength ) { NTSTATUS status = OriginalNtQuerySystemInformation( SystemInformationClass, SystemInformation, SystemInformationLength, ReturnLength ); // Modify SystemInformation to hide specific processes // ... return status; }\n    \n    \n    #include <Windows.h> BOOL HideFile(const wchar_t* filePath) { return SetFileAttributes(filePath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM); }\n\n# Additional Techniques\n\n## Exploiting Vulnerabilities\n\nThreat actors may exploit heap overflow vulnerabilities to compromise high-\nvalue targets. By manipulating memory allocation, attackers can execute\narbitrary code, bypassing traditional EDR defenses and gaining persistent\naccess to sensitive systems.\n\n    \n    \n    // Example of a heap overflow vulnerability #include <stdlib.h> void HeapOverflowVulnerability() { char* buffer = (char*)malloc(10); // Vulnerable code allowing heap overflow free(buffer); }\n\n## Shellcode Bypass Techniques\n\nIn real-world ransomware campaigns, attackers may use encoded shellcode to\nobfuscate their malicious payload. This encoding helps the ransomware evade\nsignature-based detection, allowing it to encrypt files and demand ransoms\nwithout immediate detection.\n\n    \n    \n    #include <Windows.h> int main() { // Encoded shellcode unsigned char encodedShellcode[] = { /* Encoded shellcode bytes */ }; // Allocate executable memory LPVOID execMem = VirtualAlloc(NULL, sizeof(encodedShellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); // Decode shellcode // ... // Copy decoded shellcode to executable memory memcpy(execMem, decodedShellcode, sizeof(decodedShellcode)); // Execute decoded shellcode ((void(*)())execMem)(); // Cleanup VirtualFree(execMem, 0, MEM_RELEASE); return 0; }\n\n## String Obfuscation\n\nMalware often employs string obfuscation techniques, such as XOR-ing strings,\nto avoid signature scans and heuristic analysis. By XOR-ing critical strings,\nattackers make it challenging for EDR solutions to identify specific patterns\nassociated with malware.\n\n    \n    \n    #include <iostream> #include <string> std::string xorString(const std::string& input, const std::string& key) { std::string result = input; for (size_t i = 0; i < input.size(); ++i) { result[i] = input[i] ^ key[i % key.size()]; } return result; } int main() { std::string encryptedString = \"YourEncryptedString\"; std::string decryptionKey = \"YourSecretKey\"; std::string decryptedString = xorString(encryptedString, decryptionKey); std::cout << \"Decrypted String: \" << decryptedString << std::endl; return 0; }\n\n## Anti-Debugging Techniques\n\nMalware campaigns frequently use anti-debugging techniques to thwart analysis\nby security researchers. This includes detecting the presence of a debugger,\ndynamically altering code behavior, and employing complex conditional\nbreakpoints to evade detection during analysis.\n\n    \n    \n    #include <windows.h> // Function to detect debugger presence bool isDebuggerPresent() { return IsDebuggerPresent(); } // Function with conditional breakpoints to hinder analysis void antiDebuggingFunction() { __asm { // Check if debugger is present call isDebuggerPresent test eax, eax jnz debuggerDetected // Normal code execution // ... jmp endAntiDebugging debuggerDetected: // Code to execute when debugger is detected // This can include anti-analysis measures // ... endAntiDebugging: } } int main() { // Main program logic // ... // Call the anti-debugging function antiDebuggingFunction(); return 0; }\n\n# Demo\n\nThe following demonstration compares a non-obfuscated versus an obfuscated DLL\nfor our sideloading attack on Notepad++ v8.5.4 and earlier with an EDR\ninstalled.\n\nThe video above shows that the EDR detected the malicious DLL. But let\u2019s see\nhow the EDR reacts to an obfuscated DLL.\n\n## Static Analysis\n\nIt is very easy to spot the DLL without obfuscation. We can see the direct\ncalls on the Windows API. Meanwhile, the obfuscated DLL does not directly\nreveal the Windows API calls on the first glance and needs deeper analysis.\n\nStatic Analysis \u2013 Non-Obfuscated DLL\n\nIn the obfuscated version, we have some XOR decryption happening first to get\nthe function names we are interested in. We then used GetModuleHandle and\nGetProcAddress to target the addresses of those functions. Lastly, we did\ntypedef declarations to the functions so that the compiler knows what type of\ncall and parameters are needed for those functions.\n\nStatic Analysis \u2013 Obfuscated DLL\n\n## XORed\n\nIn the obfuscated version, we cannot directly see the function names that we\nare interested in to call. This is because the application must decrypt the\ncorrect function names during runtime. Meanwhile, on the non-obfuscated\nversion, we can immediately see the WinAPIs that are possibly used by the DLL.\n\nXORed \u2013 Non-Obfuscated vs. Obfuscated\n\n# Conclusion\n\nIn the realm of cybersecurity, the comparison between anti-cheat bypass and\nEDR bypass highlights the diverse strategies employed by attackers to\ncircumvent security measures. While anti-cheat bypass primarily focuses on\nexploiting vulnerabilities in gaming environments, EDR bypass techniques\nextend their reach to compromise overall system security. Despite their\ndistinct targets, there are notable similarities in the underlying\nmethodologies employed by attackers in both domains. For instance, code\ninjection, obfuscation, and evasion of detection mechanisms are prevalent in\nboth anti-cheat and EDR bypass techniques. However, the specific nuances and\nchallenges associated with each domain necessitate tailored defense\nmechanisms.\n\nThe common thread of utilizing Windows API functions for execution,\npersistence, and privilege escalation underscores the interconnected nature of\nthese security challenges. As defenders continue to adapt and innovate,\nunderstanding these parallels and differences becomes essential for building\ncomprehensive security postures that safeguard diverse computing environments.\nBy recognizing the shared tactics and unique challenges presented by anti-\ncheat and EDR bypass techniques, cybersecurity professionals can better\nprepare for the ever-evolving landscape of digital threats.\n\n## Recent Posts\n\n  * Pivoting from Microsoft Cloud to On-Premise Machines\n  * Former Green Beret: \u201cWe Are in the Year 2024, and We Are in Full-Blown Cyber Warfare\u201d\n  * China\u2019s Volt Typhoon Found Lurking in Critical Infrastructure for Years\n  * A Technical Deep Dive: Comparing Anti-Cheat Bypass and EDR Bypass\n  * Straight Talk on Cybersecurity with Greg Hatcher\n\n## Recent Comments\n\nNo comments to show.\n\n## WKL SERVICES\n\n### Pen Testing\n\nNetwork Pen-Test\n\nWeb App Pen-Test\n\nMobile App Pen-Test\n\nWireless Pen-Test\n\nCloud Pen-Test\n\n### Assessment\n\nVIP Home Security\n\nPassword Audit\n\nEmbedded Devices\n\nOSINT\n\nAD Assessment\n\nDark Web Scanning\n\nSmart Contract Audit\n\n### Simulation and Emulation\n\nRed Team \u2013 Adversarial Emulation\n\nSocial Engineering Attack Simulation\n\nRansomware Attack Simulation\n\nBusiness Email Compromise\n\n### Compliance and Advisory\n\nFramework Consulting\n\nGAP Assessments\n\nCompliance -as-a-Service\n\n### Incident Response\n\nIncident Response\n\nCall 877-864-4204\n\nSend us a message\n\n  * Follow\n  * Follow\n\nCopyright \u00a9 2024 by White Knight Labs | All rights reserved\n\n", "frontpage": false}
