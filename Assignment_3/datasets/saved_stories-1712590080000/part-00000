{"aid": "39967864", "title": "MIPS Stacktrace: An Unexpected Journey", "url": "https://smeso.it/2024/03/02/mips-stacktrace-an-unexpected-journey.html", "domain": "smeso.it", "votes": 1, "user": "smeso", "posted_at": "2024-04-08 09:26:52", "comments": 0, "source_title": "smeso", "source_text": "smeso - MIPS stacktrace: an unexpected journey\n\n# smeso\n\ndefault high contrast dark\n\n# MIPS stacktrace: an unexpected journey\n\nPublished on 02/03/2024 in Technical, mips, embedded, glibc, gcc, stacktrace,\nC, assembly, backtrace, libgcc\n\nAutomatically receiving a stacktrace when your C program crashes isn't rocket\nscience. But this time it was more difficult than I expected. This is a short\nrecollection of the things I found out few years ago. This post assumes that\nthe reader has some basic knowledge about functions' calling conventions, CPU\nregisters, and assembly.\n\n# Some context\n\nA C program running on Linux was randomly crashing on one specific embedded\ndevice deployed on the other side of the world. The device architecture was\nMIPS32. We needed a system to asynchronously receive reports with as much\ndetails as possible (i.e. a stacktrace). The device was using glibc, ideally\nwe wanted a solution that could also work with other standard libraries (e.g.\nmusl and uClibc) but even a non-portable solution was okay, at least to fix\nthis one problem. Using external dependencies, especially if they were large,\nwasn't an option.\n\n# The simple solution\n\nglibc already has backtrace(3) and backtrace_symbols_fd(3). They are easy to\nuse and they will certainly work very well! glibc simply calls libgcc. Any\ncode I\u2019ll ever write will never understand the code generated by GCC better\nthan libgcc!\n\nWell, this may be true when you are on x86_64, but on some other architectures\nlike MIPS32 those functions don't work at all.\n\n# Some notes on MIPS\n\nJust in case you are not too familiar with MIPS, I wanted to add some notes\nabout how it works with gcc on Linux.\n\n  * The return address of the current function is stored in the $ra register\n  * When entering a new function the \"old\" return address is pushed onto the stack and is the last thing just before the start of the stack frame of the new function.\n\nTo reconstruct the stack trace we need to recover all the return addresses in\nsequence. We can start from $ra and then go backwards, pulling the return\naddresses from the end of each stack frame.\n\n# The problem\n\nIt turns out that backtrace(3) does the same thing that too many blog posts on\nthe Internet recommend to do: unwind the stack using the frame pointer\nregister to figure out the position of the previous function's return address.\nThis makes perfect sense, the frame pointer (aka $fp or $30 on MIPS) is\nusually a register designed to help debuggers to refer to local variables and\nother information stored on the stack (e.g. the previous function return\naddress) using constant offsets. In theory, while the stack pointer (aka $sp)\nalways points at the top of the stack, the $fp should point at the beginning\nof the current stack frame and should not move from there. If you want to\nretrieve the return address using the $sp, you need to know how much stuff you\nput on your stack since you entered the current stack frame, this depends on:\nwhat function you are in, how many automatic variables this functions is\nusing, what type are those functions, and how many bytes do those types use.\nIt would be very inconvenient to work with the $sp during debug, so we are\nvery lucky to have the $fp! Using the $fp we can always retrieve the return\naddress of the previous function without any complex operation! The offset\nbetween the $fp and the return address is the same constant for all functions\nin all programs!\n\n... Or is it?\n\nWell... it turns out it isn't.\n\nIn fact, when using GCC on Linux on MIPS32, the frame pointer just works\nexactly like another stack pointer: it's completely useless! I'm not 100% sure\nabout the reason behind this choice, but I think it could be related to the\nfact that, on architectures with (relatively) small registers, it would be\ndifficult to reference the top of the stack using a real $fp, but still it\nsounds like the wrong thing to do.\n\nThe funniest thing is that, backtrace(3) implementation from libgcc seems to\nignore how gcc works in this context and it just returns random values.\n\n# The real solution\n\nWe can get rid of the $fp completely and just work with $sp, but how can we\nfigure out the correct offset to use with $sp for any function?\n\nYou may not like the answer (or maybe you will) but the only way to know where\nthe beginning of the stack frame is... is to jump into the actual code of the\nfunction and parse the opcodes to figure out how much $sp was decremented by\nthe compiler.\n\nHere is one way to do it:\n\n    \n    \n    #include <link.h> #include <sys/ucontext.h> static inline void my_backtrace(ucontext_t* c) { unsigned long *ra; unsigned long *fp; unsigned long *sp; size_t ra_offset; size_t stack_size; int reached_start = 0; int first_time = 1; pc = (unsigned long*)(unsigned long)c->uc_mcontext.pc; ra = (unsigned long*)(unsigned long)c->uc_mcontext.gregs[31]; fp = (unsigned long*)(unsigned long)c->uc_mcontext.gregs[30]; sp = (unsigned long*)(unsigned long)c->uc_mcontext.gregs[29]; print(pc - 1); print(ra - 1); while (!reached_start) { int using_fp = 0; ra_offset = 0; stack_size = 0; for (unsigned long* addr = ra; (ra_offset == 0 || stack_size == 0) && !reached_start; --addr) { switch (*addr & 0xffff0000) { case 0x27bd0000: // found addiu sp, sp, stack_size stack_size = abs((short)(*addr & 0xffff)); break; case 0xafbf0000: // found sw ra, ra_offset(sp) ra_offset = (short)(*addr & 0xffff); break; case 0x03a00000: if (0x03a0f000 == (*addr & 0xffffff00)) { // found pseudo instruction move fp, sp using_fp = 1; } break; case 0x03e00000: if (0x03e00025 == *addr) { // found move zero,ra // so we found the start reached_start = 1; } break; default: break; } } if (!ra_offset) { break; } if (using_fp && first_time) { sp = fp; } first_time = 0; ra = *(unsigned long**)((unsigned long)sp + ra_offset); if (using_fp) { sp = *(unsigned long**)((unsigned long)sp + ra_offset - 4); } else { sp = (unsigned long*)((unsigned long)sp + stack_size); } print(ra - 1); } }\n\n# Symbolizing the addresses\n\nIt would be nice to be able to translate the addresses, that we just found, to\nactual function names. This isn't usually the funniest thing to do, but after\nwhat we just did, it seems trivial. We can use dl_iterate_phdr(3) to look into\nevery loaded shared object. Once we found the shared object that contains our\naddress, we can walk through its ELF sections and look at its .symtab to find\nthe function name.\n\nHere is an example of how to do it:\n\n    \n    \n    struct file_match { const char *file; void *address; void *base; }; static int find_matching_file(struct dl_phdr_info *info, size_t size, void *data) { struct file_match *match = data; long n; const ElfW(Phdr) *phdr; /* This code is modeled from Gfind_proc_info-lsb.c:callback() from libunwind */ ElfW(Addr) load_base = info->dlpi_addr; phdr = info->dlpi_phdr; for (n = info->dlpi_phnum; --n >= 0; phdr++) { if (phdr->p_type == PT_LOAD) { ElfW(Addr) vaddr = phdr->p_vaddr + load_base; if (match->address >= vaddr && match->address < vaddr + phdr->p_memsz) { match->file = info->dlpi_name; match->base = info->dlpi_addr; } } } return 0; } static inline void symbolize(const char* progname, void* addr) { struct file_match match = { .address = addr }; dl_iterate_phdr(find_matching_file, &match); if (match.file && strlen(match.file)) { fprintf(stderr, \" %s(+%p)\\n\", match.file, addr - match.base); } else { fprintf(stderr, \" %s\\n\", progname); } fflush(stderr); }\n\nWouldn't it be cool if we also retrieved the source file name and the line? To\ndo that we need to use the information provided in the .debug_line section\nusing the DWARF format. To use as little space as possible DWARF doesn\u2019t\nsimply store a list of address-to-line mappings. It stores a line number\nprogram, which is a serialized finite state machine that can be used to find\nout line numbers and more. Parsing DWARF is left as an exercise for the\nreader. Alternatively we can manually invoke addr2line.\n\n# Conclusion\n\nIn the end the bug was found and fixed and everyone lived happily ever after.\n\nI learned, once again, that features/bugs can sometime happen in your most\ntrusted dependency and one should never refrain from doubting the correctness\nof the most respected software.\n\nI also learned, once again, that the Internet is full of misleading\ninformation and blog posts written with authority by people that never\nactually tried to do the things that they talk about. As of today if you try\nto lookup information about the frame pointer on MIPS32 it will be very hard\nto find any mention at all of the issues outlined in this post. So, never\ntrust a blog post! Not even this one! Your combination of compiler and libc\nmight behave differently and have different, new, exciting issues that will\nruin your day!\n\n\u27e8\u27e8 previousnext \u27e9\u27e9\n\nShare on:\n\n  * LinkedIn\n  * Hacker News\n  * Twitter\n  * Reddit\n  * Facebook\n  * E-Mail\n\nThis site and its contents are licensed under the Creative Commons by-as 4.0\nInternational License, unless stated otherwise. Code is licensed under the\nApache License 2.0, unless stated otherwise. Generated with Pelican. Icons by\nFont Awesome. Theme based on simplenice.\n\n", "frontpage": false}
