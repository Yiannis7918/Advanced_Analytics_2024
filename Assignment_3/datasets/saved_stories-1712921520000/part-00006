{"aid": "40008934", "title": "Abstract Methods and NotImplementedError in Ruby", "url": "https://nithinbekal.com/posts/abstract-methods-notimplementederror-ruby/", "domain": "nithinbekal.com", "votes": 3, "user": "nithinbekal", "posted_at": "2024-04-12 02:44:58", "comments": 0, "source_title": "Abstract methods and NotImplementedError in Ruby", "source_text": "Abstract methods and NotImplementedError in Ruby\n\nNithin Bekal About\n\n# Abstract methods and NotImplementedError in Ruby\n\n09 Apr 2024\n\nRuby\u2019s NotImplementedError exception is often used as a placeholder in\nabstract classes for methods that should be implemented by subclasses. But did\nyou know that this is not how this exception class was intended to be used?\n\n## How is it commonly (mis)used?\n\nLet\u2019s start with an example of a common usage pattern of NotImplementedError.\nWe have a BaseSetting class, and we want to convey that anyone subclassing\nthis should implement a to_html method.\n\n    \n    \n    class BaseSetting def to_html raise NotImplementedError end end class Text < BaseSetting def to_html \"<input type='text'>\" end end class Number < BaseSetting # Forgot to implement to_html end TextSetting.new.to_html #=> \"<input type='text'>\" NumberSetting.new.to_html #=> \ud83d\udca5 NotImplementedError\n\nIn the above case, the Text setting class already implements to_html, If we\u2019re\nintroducing a new Number setting class, we\u2019re letting ourselves know to\nimplement the to_html by raising the exception at runtime. You should only see\nthis exception when you test the feature locally, or run your automated tests,\nand should never reach production.\n\n## What is NotImplementedError actually meant for?\n\nNotImplementedError is raised when a feature isn\u2019t available on the current\nplatform. An example of this is Process.fork. JRuby doesn\u2019t support fork, so\ncalling that method will raise this exception. Here\u2019s what the docs have to\nsay about it:\n\n> Raised when a feature is not implemented on the current platform. For\n> example, methods depending on the fsync or fork system calls may raise this\n> exception if the underlying operating system or Ruby runtime does not\n> support them.\n\n## Another reason to avoid it\n\nIf the semantics of this exception haven\u2019t convinced you to avoid it, here\u2019s\nanother example. The convert_to_html method tries calling to_html but provides\na fallback in a rescue block. What do you think happens when we call this with\na number setting?\n\n    \n    \n    def convert_to_html(setting) setting.to_html rescue => e # do_some_exception_logging(e) \"<input type='#{setting.class.name.downcase}'>\" end convert_to_html(Number.new)\n\nIf you run the above code, you will still see that NotImplementedError will be\nraised. This is because rescue => e assumes that you are rescuing an exception\nthat inherits from StandardError. NotImplementedError inherits from\nScriptError, which in turn inherits from Exception.\n\nSince StandardError is not in this inheritance chain, the rescue doen\u2019t handle\nthis exception. The only way to rescue this is to specify one of\nNotImplementedError, ScriptError or Exception like this:\n\n    \n    \n    rescue NotImplementedError => e\n\nExceptions raised by abstract methods aren\u2019t really meant to be rescued like\nthis, so it\u2019s not a huge problem. However, it is important to understand\nRuby\u2019s exception handling behavior when choosing which exception class to use.\n\n## Python\u2019s NotImplementedError\n\nIf this is not how it is meant to be used, why is this so widely used? One\nexplanation could be that python has an exception of the same name, which is\nactually intended for abstract methods:\n\n> This exception is derived from RuntimeError. In user defined base classes,\n> abstract methods should raise this exception when they require derived\n> classes to override the method, or while the class is being developed to\n> indicate that the real implementation still needs to be added.\n\n## Alternative approaches\n\nThere are quite a few different patterns that you could follow, if you wanted\nto avoid raising NotImplementedError. I\u2019ll list a few common patterns that\ncome to mind.\n\n### 1\\. Provide a default implementation\n\nWhen possible, provide a default implementation in the base class instead of\nraising an exception. This eliminates the risk breaking things in production\nbecause we accidentally missed an implementation. For instance, we could\nreplace the BaseSetting#to_html method like this:\n\n    \n    \n    class BaseSetting def to_html \"<input type='#{self.class.name.downcase}'>\" end end\n\nAn example of this approach is the way activerecord infers table names from\nmodel names. If the activerecord model is called Post, it assumes that the\ntable is called posts, but also lets you override this by explicitly setting\nthe table name like this:\n\n    \n    \n    class Post < ApplicationRecord self.table_name = 'articles' end\n\nThis way, you only need an implementation when you\u2019re deviating from a\nconvention that you\u2019ve established.\n\n### 2\\. Explicitly raise with a message\n\nProviding a default implementation might not be practical in more complex\nscenarios. If you need an abstract method to raises an exception, the simplest\noption is to raise with a clear error message that tells you what you need to\ndo to fix it.\n\n    \n    \n    class Base def foo raise \"#{self.class} must implement the method #{__method__}\" end end\n\nIf the intention of the exception is to remind us to implement a method,\nthere\u2019s no better way than to tell us the exact steps to do this.\n\n### 3\\. Create a custom exception\n\nAnother simple alternative is to define your own exception that inherits from\nStandardError and raise that instead. This approach was favored when the\ngraphql-ruby gem moved away from NotImplementedError.\n\n    \n    \n    class BaseSetting class MethodNotImplemented < StandardError; end def to_html raise MethodNotImplemented end end\n\nUpdate: Michael Kohl has an interesting suggestion for naming this exception:\n\n> Smalltalk had the idiom of implementing abstract methods with the body self\n> subclassResponsibility which raises an error. So I generally use\n> SubclassResponsibility as my exception name for abstract methods.\n\n### 4\\. Raise NoMethodError\n\nAnother alternative is to raise NoMethodError instead. This class inherits\nfrom StandardError, so rescue clauses will also work as expected. Saying that\na class doesn\u2019t respond to the method is closer to what we\u2019re trying to convey\nanyway. This is the approach preferred in the Hanami framework.\n\n    \n    \n    class BaseSetting def to_html raise NoMethodError, \"You must implement #{self.class}#to_html\" end end\n\n### 5\\. Write tests\n\nIn many cases where you have a base class and multiple implementations, you\nmight need to maintain a list of subclasses. For instance, take the following\ncase where we have a Setting base class, and a factory method that needs to\nknow which implementation to instantiate:\n\n    \n    \n    class Setting SETTING_CLASSES = { \"text\" => TextSetting, \"number\" => NumberSetting, } def self.for(type) SETTING_CLASSES[type].new end end\n\nSince we already have a list of subclasses, it\u2019s easier to omit the abstract\nmethod, and instead write a test that ensures that each of them responds to a\nthe method.\n\n    \n    \n    test \"all setting types respond to to_html\" do Setting::SETTING_CLASSES.each_value do |setting_class| assert setting_class.new.respond_to?(:to_html), \"#{setting_class} should implement to_html method.\" end end\n\n### 6\\. Sorbet\n\nNot everyone in the Ruby community is convinced by static type checkers, but\nfor more complex codebases, Sorbet is a fantastic choice. Here\u2019s what the\nabove base class will look like if we added sorbet signatures:\n\n    \n    \n    class Base extend T::Helpers abstract! sig { abstract.returns(String) } def foo; end end\n\nWith the above setup in place, running the typechecker using srb typecheck\nwill tell you which subclasses need to implement which abstract methods.\n\nSorbet is gradually typed, so if you\u2019re not a fan of type signatures, you can\njust add signatures for these kinds of classes without changing anything else.\nIt is also extremely fast, so you can get the feedback in a couple of seconds.\nWith its excellent editor integrations, you won\u2019t even need to run the command\nmanually to see the typechecker results.\n\nUpdate: Ironically, Sorbet uses NotImplementedError internally (see here) when\nyou define abstract methods! Thanks Ufuk for pointing this out!\n\n## Closing thoughts\n\nAlthough we\u2019ve looked at a few altenatives to raising NotImplementedError, I\nwant to note that if raising this exception is working well for your codebase,\nthere\u2019s no need to go back and replace everything.\n\nMost people know what to do when they encounter this exception, so maybe it\u2019s\nfine to use the pattern that everyone is familiar with. However, if you want\nto change their minds, you can always send them a link to this post. ;)\n\nUpdate: After writing this post, I found this proposal on the Ruby bug tracker\nto introduce a new exception class to replace NotImplementedError.\n\nTags: ruby\n\nHi, I\u2019m Nithin! This is my blog about programming. Ruby is my programming\nlanguage of choice and the topic of most of my articles here, but I\noccasionally also write about Elixir, and sometimes about the books I read.\nYou can use the atom feed if you wish to subscribe to this blog or follow me\non Mastodon.\n\nPosts About\n\n\u00ab Copilot and Neovim\n\nPowered by Jekyll. Get this theme here.\n\n", "frontpage": true}
