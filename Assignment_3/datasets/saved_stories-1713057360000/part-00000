{"aid": "40025281", "title": "For Go programmers, a cheap CGo pattern to give Jia Tan a headache", "url": "https://gist.github.com/christoofar/880b4bcf3018f4681bb71bfdf1c16a6a", "domain": "gist.github.com", "votes": 4, "user": "CanaryLayout", "posted_at": "2024-04-13 19:14:37", "comments": 0, "source_title": "Wrapping a C library call in a defensive Go routine", "source_text": "Wrapping a C library call in a defensive Go routine \u00b7 GitHub\n\nSkip to content\n\nSign in Sign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nInstantly share code, notes, and snippets.\n\n# christoofar/main.md\n\nLast active April 13, 2024 20:35\n\nShow Gist options\n\n  * Download ZIP\n\n  * Star 0 You must be signed in to star a gist\n  * Fork 0 You must be signed in to fork a gist\n\n  *     * Learn more about clone URLs\n\n  * Save christoofar/880b4bcf3018f4681bb71bfdf1c16a6a to your computer and use it in GitHub Desktop.\n\n  * Learn more about clone URLs\n\nSave christoofar/880b4bcf3018f4681bb71bfdf1c16a6a to your computer and use it\nin GitHub Desktop.\n\nDownload ZIP\n\nWrapping a C library call in a defensive Go routine\n\nRaw\n\nmain.md\n\nI've been thinking a lot about this as a CGo/gccgo dev: \"What can a HLL\nprogrammer do against the likes of Jia Tan? They're attacking from the\nfoundation software.\"\n\nI'm not settled on this one but wrapping calls to C libs in goroutines\nprobably would raise the difficultly level of a direct hijack on your own Go\ncode, as the rapid context switches and unpredictability introduced on where\nthe Go runtime will move the jump calls happens.\n\nAfter 129,000 lines of asm, here is printf(\"Hello World\") in Go down at the\nbottom:\n\nNow, let's see what happens when we do this:\n\n    \n    \n    func main() { hello := \"Hello world!\" go func() { print(hello) }() time.Sleep(1*time.Second) }\n\nNow we're asking the Go runtime to activate concurrency and main itself gets\nsplit into two compact parts with an anonymous function that disappears into\nthe goroutine ecosphere (to get this to fit I'm stripping symbols):\n\nNotice how nice and compact the goroutine is! Not many things you can do here\nbut try to intercept the ret and call instructions, but you will need to also\nmake sure the runtime stack cleanup happens or things will start to go\ncrashycrashy.\n\nSo now let's make a C lib call but push it down into a goroutine wrapper, yet\nmake it synchronous. And for fun, the data to the function will be passed via\na channel, which brings in the communication/sync areas of the runtime with\nits maze of runtime functions. And since we're here, let's make it a full Go\nwrapper, with two channels and a goroutine bridge, and a done signaler.\n\n    \n    \n    package main // #include <stdio.h> // #include <stdlib.h> // void printFromC(const char* str) { // printf(\"Received C string: %s\\n\", str); // } import \"C\" import \"unsafe\" func main() { myPrint(\"Hello from Go!\") } func myPrint(hellostring string) { // Protect the C library call from Jia Tan and the NSA sendchan := make(chan string) recvchan := make(chan string) done := make(chan bool) go func(sender chan string, receiver chan string){ // This chan is send-only go func(receive <-chan string) { // This one is recv-only callCPrint(receive) done <- true }(receiver) go func() { strToSend := <- sender receiver <- strToSend close(sender) return }() }(sendchan, recvchan) sendchan <- hellostring <-done return } func callCPrint(str <-chan string) { cStr := C.CString(<-str) defer C.free(unsafe.Pointer(cStr)) // Deallocate memory when done C.printFromC(cStr) }\n\nThe main() in asm representation gets shorter\n\nBut now there is some real fun going on in myPrint() as it's acting as a\ntraffic cop moving the string along its way into the chaos of pthread, with\nits context switches and semaphores. myPrint is split by the compiler into 6\nasm functions (one for each launch context and its anonymous function), to\nallow for their dynamic reallocation to the runtime.\n\nThat goes on for pages.\n\ncallCPrint then has a thunk going on, which can't get back its data to myPrint\nwithout going back through the runtime maze.\n\nI'm still not sold on this approach but I'm definitely willing to change my\nown behavior to make these creeps go away if the difficulty is raised high\nenough. And throwing CGo calls through a goroutine bridge still makes readable\ncode to me.\n\nAuthor\n\n###\n\nchristoofar commented Apr 13, 2024 \u2022\n\nAdvantages to this approach:\n\n  * Code is still readable\n  * The Go runtime itself is baked into the binary statically, and it is large and very complex, weighing in at two Commodore-64s.\n  * This wrapper approach style at least gives you a place to inspect \"weirdness\" from C library returns and to clear memory in one place.\n  * You can break the data up in the wrapper myPrint() and then resync it right before the C call, then again in the reverse direction for the return. Probably a good idea to make a different receiver func that's also in a goroutine, that chans the data back to myPrint() who's waiting for it.\n  * Traditional security techniques to obfuscate in-memory data are not affected by this. For instance if the string is a credit card number, I can use a PRNG and rotate the bits (not the bytes) N number of times before sending it through the goroutine bridge, then add a fourth channel that sends the number of rotations through some easy calculation, say the positive or negative distance from a constant), then reverse the operation right before the C call. This will force the attacker to deal with the runtime and navigate through it to nail down an inject point, which is going to be very tough in the compact code inside the final goroutine, so there is no choice but to deal with the async introduced by pthread.\n  * You can check for and clear any \"surprise globals\" in an easier spot (above, in the myPrint wrapper) that C libraries could leave behind (or nuke them at the C return to avoid traveling back through the runtime).\n\nDisadvantages to this approach:\n\n  * Longer to code it\n  * A single parameter C call rarely happens, so you will probably have to wrap and thunk Go structs and get the pointers correct and use more channels to split the data up. For each split you will be making 2 more channels.\n  * The Go runtime is hefty; making it a bad choice for very small and resource-constrained microcontrollers. Above that level the runtime performance is acceptable.\n  * For stream processing in Go to C libraries you will probably have to set up another wrapper on top of this simple one if the underlying C library supports a change of behavior mid-flight. For instance, watching TV through the C function and you want to signal a change in the stream source without tearing down and reconstructing the bridges. You would have to do this anyway if the C library doesn't support that feature but you want the users of your Go wrapper to have it by hiding the tear-down and rebuild of the stream.\n\nAuthor\n\n###\n\nchristoofar commented Apr 13, 2024 \u2022\n\nWhy this approach would frustrate Jia Tan:\n\nEven if you wield the power of your own in-memory DASM utility and you have\ncaptured LD_AUDIT to read up the load, this does not give you a cop-out to\navoid the complexity of the decision-making in the Go runtime.\n\nFor starters:\n\n  * Go routines have their own independent context. They're usually written out as anonymous functions so their asm is easy to locate, but on which CPU thread much less the eternal runtime context it will get called out (and even from which stack) is far less obvious. That's why Go programmers debug with delve.\n\n  * Go routines have a compact structure. The gostack area is very small which allows the Go runtime to make its reallocation movements very fast. Spinning up process threads is slow and tedious. In Go, creating a timeline independent task is quick. You can even do simple things to really foul up Jia Tan such as this:\n\n    \n    \n    func whenDoILaunch() { for i := 0; i<callAsyncTimes() ;i++ { i += randomizer() // returns *int go func() { if *i == 0 { go launchfunc() } }(&i) } }\n\nIt's nonsense code, but still fast. This runtime trick gives Jia Tan some\nnasty work: he has no choice but to travel everywhere to find where the\nlauncher context in the runtime is, forcing him to refocusing into your\nlauncher, where the goroutine stacks are packed tight.\n\nSo what are some gaps?\n\nBiggest of all is the Go garbage management. For the most secure data you\nreally must clear values and any other scratch data structures immediately\nafter use. You can emit out your results to a buffered channel, but it's not\nthat great of an idea to leave it to another goroutine to the cleanup, as that\nsets up another jump with pointer context passing that can be patched out.\n\nSo, I think this method of just putting a go routine moat around C libraries,\ntaking the hit of immediately clearing memory and relying on minimal channel\nbuffer sizes is probably the safest way to do unsafe code in CGo.\n\nSign up for free to join this conversation on GitHub. Already have an account?\nSign in to comment\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": true}
