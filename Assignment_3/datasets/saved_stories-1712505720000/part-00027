{"aid": "39959417", "title": "One logging API to rule them all", "url": "https://github.com/theogravity/loglayer", "domain": "github.com/theogravity", "votes": 1, "user": "keepamovin", "posted_at": "2024-04-07 09:03:54", "comments": 0, "source_title": "GitHub - theogravity/loglayer: An abstraction for logging libraries (bunyan / winston / pino / roarr / electron-log / etc) that exposes a dev-friendly API to help you write logs better", "source_text": "GitHub - theogravity/loglayer: An abstraction for logging libraries (bunyan /\nwinston / pino / roarr / electron-log / etc) that exposes a dev-friendly API\nto help you write logs better\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\ntheogravity / loglayer Public\n\ngenerated from theogravity/boilerplate-typescript-old\n\n  * Notifications\n  * Fork 3\n  * Star 55\n\nAn abstraction for logging libraries (bunyan / winston / pino / roarr /\nelectron-log / etc) that exposes a dev-friendly API to help you write logs\nbetter\n\n### License\n\nMIT license\n\n55 stars 3 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# theogravity/loglayer\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n1 Branch\n\n10 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\ntheogravityUpdate README.md8e9b0a7 \u00b7\n\n## History\n\n33 Commits  \n  \n### .circleci\n\n|\n\n### .circleci\n\n| [skip ci] Add CI config  \n  \n### livetests\n\n|\n\n### livetests\n\n| Make withContext() chainable (#1)  \n  \n### src\n\n|\n\n### src\n\n| Add HookShouldSendToLoggerParams type  \n  \n### .changelog.js\n\n|\n\n### .changelog.js\n\n| Initial commit  \n  \n### .eslintignore\n\n|\n\n### .eslintignore\n\n| Initial commit  \n  \n### .eslintrc.js\n\n|\n\n### .eslintrc.js\n\n| First version  \n  \n### .gitattributes\n\n|\n\n### .gitattributes\n\n| Initial commit  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| Initial commit  \n  \n### .npmignore\n\n|\n\n### .npmignore\n\n| [skip ci] v1.5.0  \n  \n### .prettierrc\n\n|\n\n### .prettierrc\n\n| Initial commit  \n  \n### .version-bump.js\n\n|\n\n### .version-bump.js\n\n| Initial commit  \n  \n### CHANGELOG.md\n\n|\n\n### CHANGELOG.md\n\n| Add HookShouldSendToLoggerParams type  \n  \n### CONTRIBUTING.md\n\n|\n\n### CONTRIBUTING.md\n\n| Initial commit  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| Initial commit  \n  \n### README.md\n\n|\n\n### README.md\n\n| Update README.md  \n  \n### jest.config.js\n\n|\n\n### jest.config.js\n\n| Add consoleDebug option (#7)  \n  \n### package-lock.json\n\n|\n\n### package-lock.json\n\n| Add logLevel to onBeforeDataOut hook  \n  \n### package.json\n\n|\n\n### package.json\n\n| Add HookShouldSendToLoggerParams type  \n  \n### tsconfig.json\n\n|\n\n### tsconfig.json\n\n| First version  \n  \n## Repository files navigation\n\n# loglayer\n\nStandardize the way you write logs with the loglayer abstraction using your\nexisting logging library (bunyan / winston / pino / roarr / electron-log /\netc).\n\nSpend less time from having to define your logs and spend more writing them.\n\n  * Switch between different logging libraries if you do not like the one you use without changing your entire codebase.\n\n    * Starting off with console and want to switch to bunyan later? You can with little effort!\n  * Intuitive API with no dependencies.\n  * Written in typescript.\n  * Installation instructions for each logging library.\n  * Unit tested with various logging libraries.\n\nWithout loglayer, how does one define a log entry?\n\n    \n    \n    // is it like this? winston.info('my message', { some: 'data' }) // or like this? bunyan.info({ some: 'data' }, 'my message')\n\nHow does one work with errors?\n\n    \n    \n    // is it like this? Is err the field for errors? roarr.error({ err: new Error('test') }) // Do I need to serialize it first? roarr.error({ err: serialize(new Error('test')) })\n\nWith loglayer, stop worrying about details, and write logs!\n\n    \n    \n    logLayer .withMetadata({ some: 'data'}) .withError(new Error('test')) .info('my message')\n\nloglayer is a wrapper around logging libraries to provide a consistent way to\nspecify context, metadata, and errors.\n\n# Table of Contents\n\n  * Installation\n  * Example installations\n\n    * console\n    * pino\n    * bunyan\n    * winston\n    * roarr\n    * electron-log\n  * Example integration\n  * API\n\n    * Constructor\n\n      * Configuration options\n\n        * Supported log library types\n        * Serializing errors\n        * Data output options\n    * Child logger\n    * Hooks\n\n      * Set / update hooks outside of configuration\n      * Modify / create object data before being sent to the logging library\n      * Conditionally send or not send an entry to the logging library\n    * Disable / enable logging\n    * Logging messages\n    * Including a prefix with each log message\n\n      * Via configuration\n      * Create a child logger with the prefix\n    * Including context with each log message\n\n      * Getting context\n    * Logging metadata\n\n      * With a message\n      * Standalone\n    * Logging errors\n\n      * With a message\n      * Standalone\n    * Get the attached logger library instance\n  * Mocking for tests\n  * Running tests\n\n## Installation\n\n$ npm i loglayer\n\n## Example installations\n\n### console\n\n    \n    \n    import { LoggerType, LogLayer } from 'loglayer' const log = new LogLayer({ logger: { instance: console, type: LoggerType.CONSOLE, }, })\n\n### pino\n\npino docs\n\n    \n    \n    import pino, { P } from 'pino' import { LogLayer, LoggerType } from 'loglayer' const p = pino({ level: 'trace' }) const log = new LogLayer<P.Logger>({ logger: { instance: p, type: LoggerType.PINO, }, })\n\n### bunyan\n\nbunyan docs\n\nbunyan requires an error serializer to be defined to handle errors.\n\n    \n    \n    import bunyan from 'bunyan' import { LogLayer, LoggerType } from 'loglayer' const b = bunyan.createLogger({ name: 'test-logger', // Show all log levels level: 'trace', // We've defined that bunyan will transform Error types // under the `err` field serializers: { err: bunyan.stdSerializers.err }, }) const log = new LogLayer({ logger: { instance: b, type: LoggerType.BUNYAN, }, error: { // Make sure that loglayer is sending errors under the err field to bunyan fieldName: 'err' } })\n\n### winston\n\nwinston docs\n\n    \n    \n    import winston from 'winston' import { LogLayer, LoggerType } from 'loglayer' import { serializeError } from 'serialize-error' const w = winston.createLogger({}) const log = new LogLayer<winston.Logger>({ logger: { instance: w as unknown as LoggerLibrary, type: LoggerType.WINSTON, }, error: { serializer: serializeError, }, })\n\n### roarr\n\nroarr docs\n\n  * roarr requires an error serializer as it does not serialize errors on its own.\n  * By default, roarr logging is disabled, and must be enabled via these roarr instructions.\n\n    \n    \n    import { LogLayer, LoggerType } from 'loglayer' import { Roarr as r, Logger } from 'roarr' import { serializeError } from 'serialize-error' const log = new LogLayer<Logger>({ logger: { instance: r.Roarr, type: LoggerType.ROARR, }, error: { serializer: serializeError, }, })\n\n### electron-log\n\nYou can use electron-log with LogLayer in your electron app for logging.\n\nelectron-log docs\n\n    \n    \n    // Main process logger import log from 'electron-log/src/main'; // or Renderer process logger // import log from 'electron-log/src/renderer'; const logger = new LogLayer({ logger: { instance: log, type: LoggerType.ELECTRON_LOG, }, });\n\n## Example integration\n\nUsing express and pino:\n\n    \n    \n    import express from 'express' import pino from 'pino' import { LogLayer, LoggerType } from 'loglayer' // We only need to create the logging library instance once const p = pino({ level: 'trace' }) const app = express() const port = 3000 // Define logging middleware app.use((req, res, next) => { req.log = new LogLayer({ logger: { instance: p, type: LoggerType.PINO } // Add a request id for each new request }).withContext({ // generate a random id reqId: Math.floor(Math.random() * 100000).toString(10), // let's also add in some additional details about the server env: 'prod' }) next(); }) app.get('/', (req, res) => { // Log the message req.log.info('sending hello world response') res.send('Hello World!') }) app.listen(port, () => { console.log(`Example app listening at http://localhost:${port}`) })\n\n## API\n\n### Constructor\n\nnew LogLayer<LoggerInstanceType = LoggerLibrary, ErrorType = any>(config:\nLogLayerConfig)\n\nGenerics (all are optional):\n\n  * LoggerInstanceType: A definition that implements log info / warn / error / trace / debug methods.\n\n    * Used for returning the proper type in the getLoggerInstance() method.\n  * ErrorType: A type that represents the Error type. Used with the serializer and error methods. Defaults to any.\n\n#### Configuration options\n\n    \n    \n    interface LogLayerConfig { /** * Set to false to drop all log input and stop sending to the logging * library. * * Can be re-enabled with `enableLogging()`. * * Default is `true`. */ enabled?: boolean /** * If set to true, will also output messages via console logging before * sending to the logging library. * * Useful for troubleshooting a logging library / transports * to ensure logs are still being created when the underlying * does not print anything. */ consoleDebug?: boolean /** * The prefix to prepend to all log messages */ prefix?: string logger: { /** * The instance of the logging library to send log data and messages to */ instance: ExternalLogger /** * The instance type of the logging library being used */ type: LoggerType } error?: { /** * A function that takes in an incoming Error type and transforms it into an object. * Used in the event that the logging library does not natively support serialization of errors. */ serializer?: ErrorSerializerType /** * Logging libraries may require a specific field name for errors so it knows * how to parse them. * * Default is 'err'. */ fieldName?: string /** * If true, always copy error.message if available as a log message along * with providing the error data to the logging library. * * Can be overridden individually by setting `copyMsg: false` in the `onlyError()` * call. * * Default is false. */ copyMsgOnOnlyError?: boolean } context?: { /** * If specified, will set the context object to a specific field * instead of flattening the data alongside the error and message. * * Default is context data will be flattened. */ fieldName?: string } metadata?: { /** * If specified, will set the metadata data to a specific field * instead of flattening the data alongside the error and message. * * Default is metadata will be flattened. */ fieldName?: string } hooks?: { /** * Called after the assembly of the data object that contains * the metadata / context / error data before being sent to the destination logging * library. * * - The shape of `data` varies depending on your `fieldName` configuration * for metadata / context / error. The metadata / context / error data is a *shallow* clone. * - If data was not found for assembly, `undefined` is used as the `data` input. * - You can also create your own object and return it to be sent to the logging library. * * @param Object [params.data] The object containing metadata / context / error data. This is `undefined` if there is no object with data. * @param LogLevel [params.logLevel] The log level of the data. * * @returns [Object] The object to be sent to the destination logging * library or null / undefined to not pass an object through. */ onBeforeDataOut?: HookAssembledDataFn /** * Called before the data is sent to the logger. Return false to omit sending * to the logger. Useful for isolating specific log messages for debugging / troubleshooting. * * @param MessageDataType[] messages An array of message data that corresponds to what was entered in * info(...messages), warn(...messages), error(...messages), debug(...messages), etc. * @param Object [data] The data object that contains the context / metadata / error data. This is `undefined` if there is no data. If `onBeforeDataOut` was defined, uses the data processed from it. * * @returns [boolean] If true, sends data to the logger, if false does not. */ shouldSendToLogger?: HookShouldSendToLoggerFn } }\n\n##### Supported log library types\n\nConfig option: logger.type\n\nUse the other value for log libraries not supported here. loglayer may or may\nnot work with it.\n\n    \n    \n    enum LoggerType { OTHER = 'other', WINSTON = 'winston', ROARR = 'roarr', PINO = 'pino', BUNYAN = 'bunyan', CONSOLE = 'console', }\n\n##### Serializing errors\n\nConfig option: error.serializer\n\nBy default, loglayer will pass error objects directly to the logging library\nas-is.\n\nSome logging libraries do not have support for serializing errors, and as a\nresult, the error may not be displayed in a log.\n\nIf you use such a library, you can define a function that transforms an error,\nwhich is in the format of:\n\ntype ErrorSerializerType = (err) => Record<string, any> | string\n\nFor example:\n\n    \n    \n    import { LoggerType, LogLayer } from 'loglayer' const log = new LogLayer({ logger: { instance: console, type: LoggerType.CONSOLE, }, error: { serializer: (err) => { // Can be an object or string return JSON.stringify(err) } } })\n\n##### Data output options\n\nBy default, loglayer will flatten context and metadata into a single object\nbefore sending it to the logging library.\n\nFor example:\n\n    \n    \n    log.withContext({ reqId: '1234' }) log.withMetadata({ hasRole: true, hasPermission: false }).info('checking permissions')\n\nWill result in a log entry in most logging libraries:\n\n    \n    \n    { \"level\": 30, \"time\": 1638138422796, \"hostname\": \"local\", \"msg\": \"checking permissions\", \"hasRole\": true, \"hasPermission\": false, \"reqId\": 1234 }\n\nSome developers prefer a separation of their context and metadata into\ndedicated fields.\n\nYou can do this via the config options, context.fieldName and\nmetadata.fieldName:\n\n    \n    \n    const log = new LogLayer({ ..., metadata: { // we'll put our metadata into a field called metadata fieldName: 'metadata' }, context: { // we'll put our context into a field called context fieldName: 'context' } })\n\nThe same log commands would now be formatted as:\n\n    \n    \n    { \"level\": 30, \"time\": 1638138422796, \"hostname\": \"local\", \"msg\": \"checking permissions\", \"metadata\": { \"hasRole\": true, \"hasPermission\": false }, \"context\": { \"reqId\": 1234 } }\n\n### Child logger\n\nLogLayer#child()\n\nYou can create a child logger, which will copy the configuration you used for\ncreating the parent, along with the existing context data.\n\nThe copied context data is a shallow copy.\n\n    \n    \n    const parentLog = new LogLayer(<config>).withContext({ some: 'data' }) // Creates a new LogLayer with <config> copied over and the context const childLog = parentLog.child()\n\n### Hooks\n\n#### Set / update hooks outside of configuration\n\nLogLayer#setHooks(hooks: LogLayerHooksConfig)\n\nUpdate hook callback definitions. This is an alternative to the hooks config\noption. Only hooks defined will be replaced.\n\n#### Modify / create object data before being sent to the logging library\n\n(data?: Record<string, any>) => Record<string, any> | null | undefined\n\nThe callback onBeforeDataOut can be used to modify the data object that\ncontains the context / metadata / error data or create a custom object before\nit is sent out to the logging library.\n\n    \n    \n    import { LoggerType, LogLayer, HookAssembledDataFn } from 'loglayer' const onBeforeDataOut: HookAssembledDataFn = (data) => { if (data) { data.modified = true } return data } const log = new LogLayer({ ... hooks: { onBeforeDataOut, } }) log.withContext({ test: 'data' }).info('this is a test message')\n    \n    \n    { \"test\": \"data\", \"modified\": true, \"msg\": \"this is a test message\" }\n\n#### Conditionally send or not send an entry to the logging library\n\n(params: { messages: MessageDataType[], logLevel: LogLevel, data?: Data }) =>\nboolean\n\nThe callback shouldSendToLogger is called before the data is sent to the\nlogger. Return false to omit sending to the logger. Useful for isolating\nspecific log messages for debugging / troubleshooting.\n\nParameters\n\n  * messages: The parameters sent via info(), warn(), error(), debug(), etc. Most will use messages[0]. This data is copied from the original.\n  * [data]: The data object that contains the context / metadata / error data. This is null if there is no data. If onBeforeDataOut was defined, uses the data processed from it.\n\n    \n    \n    import { LoggerType, LogLayer, HookAssembledDataFn } from 'loglayer' const shouldSendToLogger: boolean = ({ messages }) => { // Define custom logic here (ex: regex) to determine if the log should be sent out or not // Read the first parameter of info() / warn() / error() / debug() / etc if (messages[0] === 'do not send out') { return false; } return true; } const log = new LogLayer({ ... hooks: { shouldSendToLogger, } }) // Will not send the log entry to the logger log.info('do not send out')\n\n### Disable / enable logging\n\n  * LogLayer#enableLogging(): LogLayer\n  * LogLayer#disableLogging(): LogLayer\n\n### Logging messages\n\n  * LogLayer#info(...messages: MessageDataType[]): void\n  * LogLayer#warn(...messages: MessageDataType[]): void\n  * LogLayer#error(...messages: MessageDataType[]): void\n  * LogLayer#debug(...messages: MessageDataType[]): void\n  * LogLayer#trace(...messages: MessageDataType[]): void\n\ntype MessageDataType = string | number | null | undefined\n\nYour logging library may or may not support passing multiple parameters. See\nyour logging library's documentation for more details.\n\n    \n    \n    // Can be a single message log.info('this is a message') // Or passed through multiple parameters to be interepreted by your logging library. // For example, in roarr, the subsequent parameters after the first are for sprintf interpretation only. // Other libraries do nothing with additional parameters. log.info('request id: %s', id)\n\n### Including a prefix with each log message\n\n#### Via configuration\n\n    \n    \n    const log = new LogLayer({ prefix: '[testing]' })\n\n#### Create a child logger with the prefix\n\nLogLayer#withPrefix(prefix: string): LogLayer\n\nThis calls LogLayer#child() with prefix set as part of the configuration.\n\n    \n    \n    const parentLog = new LogLayer(<config>) const childLog = parentLog.withPrefix('[testing]') // The message will be \"[testing] this is a request\" childLog.info('this is a request')\n\n### Including context with each log message\n\nLogLayer#withContext(data: Record<string, any>): LogLayer\n\n  * This adds or replaces context data to be included with each log entry.\n  * Can be chained with other methods.\n\n    \n    \n    log.withContext({ requestId: 1234 }) // Your logging library will now include the context data // as part of its logging output log.info('this is a request')\n\nOutput from pino:\n\n    \n    \n    { \"level\": 30, \"time\": 1638146872750, \"pid\": 38300, \"hostname\": \"local\", \"requestId\": 1234, \"msg\": \"this is a request\" }\n\n#### Getting context\n\n    \n    \n    log.withContext({ requestId: 1234 }) // Should return { requestId: 1234 } const context = log.getContext()\n\n### Logging metadata\n\n#### With a message\n\nLogLayer#withMetadata(data: Record<string, any>): ILogBuilder\n\nUse this if you want to log data that is specific to the message only.\n\n  * This method must be chained with a log message method.\n  * This method can be chained with withError() to include an error with the metadata.\n\n    \n    \n    log.withMetadata({ some: 'data' }).info('this is a message that includes metadata')\n\n#### Standalone\n\nLogLayer#metadataOnly(data: Record<string, any>, logLevel: LogLevel = 'info'):\nvoid\n\nUse this if you want to only log metadata without including a message.\n\n    \n    \n    // Default log level is 'info' log.metadataOnly({ some: 'data' }) // Adjust log level log.metadataOnly({ some: 'data' }, LogLevel.warn)\n\n### Logging errors\n\n  * If the error.serializer config is not used, then it will be the job of the logging library to handle serialization.\n\n    * If you are not seeing errors logged:\n\n      * Make sure the logging library's log level is configured to print an error log level.\n      * The logging library may not serialize errors out of the box and must be configured, or a serializer must be defined with loglayer so that it can serialize it before sending it to the logging library.\n  * The error.fieldName config is used to determine the field name to attach the error to when sending to the logging library.\n\n    * The default field name used is err.\n\n#### With a message\n\nLogLayer#withError(error: Error): ILogBuilder\n\nUse this to include an error object with your message.\n\n  * This method must be chained with a log message method.\n  * This method can be chained with withMetadata() to include metadata alongside the error.\n\n    \n    \n    // You can use any log level you want log.withError(new Error('error')).error('this is a message that includes an error')\n\n#### Standalone\n\nLogLayer#errorOnly(error: Error, opts?: OnlyErrorOpts): void\n\nOptions:\n\n    \n    \n    interface OnlyErrorOpts { /** * Sets the log level of the error */ logLevel?: LogLevel /** * If `true`, copies the `error.message` if available to the logger library's * message property. * * If the config option `error.copyMsgOnOnlyError` is enabled, this property * can be set to `false` to disable the behavior for this specific log entry. */ copyMsg?: boolean }\n\nUse this if you want to only log metadata without including a message.\n\n    \n    \n    // Default log level is 'error' log.errorOnly(new Error('test')) // Adjust log level log.errorOnly(new Error('test'), { level: LogLevel.warn }) // Include the error message as part of the logging library's message field // This may be redundant as the error message value will still be included // as part of the message itself log.errorOnly(new Error('test'), { copyMsg: true }) // If the loglayer instance has `error.copyMsgOnOnlyError = true` and you // want to disable copying the message for a single line, explicitly // define copyMessage with false log.errorOnly(new Error('test'), { copyMsg: false })\n\n### Get the attached logger library instance\n\nLogLayer#getLoggerInstance()\n\nReturns back the backing logger used in the event you need to call methods\nspecific to that logging library.\n\n## Mocking for tests\n\nRather than having to define your own mocks for loglayer, we have a mock class\nyou can use for your tests:\n\n    \n    \n    import { MockLogLayer } from 'loglayer' // You can use the MockLogLayer in place of LogLayer // so nothing will log\n\n## Running tests\n\n$ npm run test:ci\n\n## About\n\nAn abstraction for logging libraries (bunyan / winston / pino / roarr /\nelectron-log / etc) that exposes a dev-friendly API to help you write logs\nbetter\n\n### Topics\n\nelectron nodejs javascript typescript log logger structure logging winston\nbunyan standard abstraction logging-library pino roarr\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\nActivity\n\n### Stars\n\n55 stars\n\n### Watchers\n\n3 watching\n\n### Forks\n\n3 forks\n\nReport repository\n\n## Releases\n\n10 tags\n\n## Packages 0\n\nNo packages published\n\n## Languages\n\n  * TypeScript 93.3%\n  * JavaScript 4.2%\n  * Shell 2.5%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
