{"aid": "39958836", "title": "KDL: A Cuddly Document Language", "url": "https://kdl.dev/", "domain": "kdl.dev", "votes": 1, "user": "rapnie", "posted_at": "2024-04-07 07:12:45", "comments": 0, "source_title": "The KDL Document Language", "source_text": "The KDL Document Language\n\nKDL is a small, pleasing document language with xml-like semantics that looks\nlike you're invoking a bunch of CLI commands! It's meant to be used both as a\nserialization format and a configuration language, much like JSON, YAML, or\nXML. It looks like this:\n\n    \n    \n    package { name \"my-pkg\" version \"1.2.3\" dependencies { // Nodes can have standalone values as well as // key/value pairs. lodash \"^3.2.1\" optional=true alias=\"underscore\" } scripts { // \"Raw\" and multi-line strings are supported. build r#\" echo \"foo\" node -c \"console.log('hello, world!');\" echo \"foo\" > some-file.txt \"# } // `\\` breaks up a single node across multiple lines. the-matrix 1 2 3 \\ 4 5 6 \\ 7 8 9 // \"Slashdash\" comments operate at the node level, // with just `/-`. /-this-is-commented { this \"entire\" \"node\" { \"is\" \"gone\" } } }\n\nThere's a living specification, as well as various implementations. You can\nalso check out the FAQ to answer all your burning questions!\n\nIn addition to a spec for KDL itself, there are also standard specs for a KDL\nQuery Language based on CSS selectors, and a KDL Schema Language loosely based\non JSON Schema.\n\nThe language is based on SDLang, with a number of modifications and\nclarifications on its syntax and behavior.\n\nThe current version of the KDL spec is 1.0.0.\n\nPlay with it in your browser!\n\n## Overview\n\n### Basics\n\nA KDL node is a node name, followed by zero or more \"arguments\", and children.\n\n    \n    \n    title \"Hello, World\"\n\nYou can also have multiple values in a single node!\n\n    \n    \n    bookmarks 12 15 188 1234\n\nNodes can have properties.\n\n    \n    \n    author \"Alex Monad\" email=\"alex@example.com\" active=true\n\nAnd they can have nested child nodes, too!\n\n    \n    \n    contents { section \"First section\" { paragraph \"This is the first paragraph\" paragraph \"This is the second paragraph\" } }\n\nNodes without children are terminated by a newline, a semicolon, or the end of\na file stream:\n\n    \n    \n    node1; node2; node3;\n\n### Values\n\nKDL supports 4 data types:\n\n  * Strings: \"hello world\"\n  * Numbers: 123.45\n  * Booleans: true and false\n  * Null: null\n\n#### Strings\n\nIt supports two different formats for string input: escaped and raw.\n\n    \n    \n    node \"this\\nhas\\tescapes\" other r\"C:\\Users\\zkat\\\"\n\nBoth types of string can be multiline as-is, without a different syntax:\n\n    \n    \n    string \"my multiline value\"\n\nAnd for raw strings, you can add any number of # after the r and the last \" to\ndisambiguate literal \" characters:\n\n    \n    \n    other-raw r#\"hello\"world\"#\n\n#### Numbers\n\nThere's 4 ways to represent numbers in KDL. KDL does not prescribe any\nrepresentation for these numbers, and it's entirely up to individual\nimplementations whether to represent all numbers with a single type, or to\nhave different representations for different forms.\n\nKDL has regular decimal-radix numbers, with optional decimal part, as well as\nan optional exponent.\n\n    \n    \n    num 1.234e-42\n\nAnd using the appropriate prefix, you can also enter hexadecimal, octal, and\nbinary literals:\n\n    \n    \n    my-hex 0xdeadbeef my-octal 0o755 my-binary 0b10101101\n\nFinally, all numbers can have underscores to help readability:\n\n    \n    \n    bignum 1_000_000\n\n### Comments\n\nKDL supports C-style comments, both line-based and multiline. Multiline\ncomments can be nested.\n\n    \n    \n    // C style /* C style multiline */ tag /*foo=true*/ bar=false /*/* hello */*/\n\nOn top of that, KDL supports /- \"slashdash\" comments, which can be used to\ncomment out individual nodes, arguments, or children:\n\n    \n    \n    // This entire node and its children are all commented out. /-mynode \"foo\" key=1 { a b c } mynode /-\"commented\" \"not commented\" /-key=\"value\" /-{ a b }\n\n### Type Annotations\n\nKDL supports type annotations on both values and nodes. These can be\narbitrary, but can be used by individual implementations or use-cases to\nconstrain KDL's basic types. A number of type names are also reserved to have\nspecific meanings.\n\n    \n    \n    numbers (u8)10 (i32)20 myfloat=(f32)1.5 { strings (uuid)\"123e4567-e89b-12d3-a456-426614174000\" (date)\"2021-02-03\" filter=(regex)r\"$\\d+\" (author)person name=\"Alex\" }\n\n### More Details\n\n    \n    \n    // Nodes can be separated into multiple lines title \\ \"Some title\" // Files must be utf8 encoded! smile \"\ud83d\ude01\" // Instead of anonymous nodes, nodes and properties can be wrapped // in \"\" for arbitrary node names. \"!@#$@$%Q#$%~@!40\" \"1.2.3\" \"!!!!!\"=true // The following is a legal bare identifier: foo123~!@#$%^&*.:'|?+ \"weeee\" // And you can also use unicode! \u30ce\u30fc\u30c9 \u304a\u540d\u524d=\"\u261c(\u309a\u30ee\u309a\u261c)\" // kdl specifically allows properties and values to be // interspersed with each other, much like CLI commands. foo bar=true \"baz\" quux=false 1 2 3\n\n## Implementations\n\n  * Rust: kdl-rs, knuffel (latter includes derive macro), and kaydle (serde-based)\n  * JavaScript: kdljs, @virtualstate/kdl (query only, JSX based)\n  * Ruby: kdl-rb\n  * Dart: kdl-dart\n  * Java: kdl4j\n  * PHP: kdl-php\n  * Python: kdl-py, cuddle, ckdl\n  * Elixir: kuddle\n  * XSLT: xml2kdl\n  * Haskell: Hustle\n  * .NET: Kadlet\n  * C: ckdl\n  * C++: kdlpp (part of ckdl, requires C++20)\n  * OCaml: ocaml-kdl\n  * Nim: kdl-nim\n  * Common Lisp: kdlcl\n  * Go: gokdl, kdl-go\n  * Swift: kdl-swift\n  * Crystal: kdl-cr\n  * Lua: kdlua\n\n## Editor Support\n\n  * VS Code\n  * Sublime Text\n  * Intellij IDEA\n  * vim\n\n## Design and Discussion\n\nKDL is still extremely new, and discussion about the format should happen over\non the discussions page in the Github repo. Feel free to jump in and give us\nyour 2 cents!\n\n## Design Principles\n\n  1. Maintainability\n  2. Flexibility\n  3. Cognitive simplicity and Learnability\n  4. Ease of de/serialization\n  5. Ease of implementation\n\n## Compatibility with JSON and XML\n\nThere are two specifications for writing KDL that can be losslessly translated\nbetween it and JSON or XML. These specifications define a stricter subset of\nKDL that, even if not entirely idiomatic, is still valid and fits into the\ndata models of the other two languages:\n\n  * JSON in KDL\n  * XML in KDL\n\n## FAQ\n\n#### How do you pronounce KDL?\n\nSame as \"cuddle\".\n\n#### Why yet another document language?\n\nBecause nothing out there felt quite right. The closest one I found was\nSDLang, but that had some design choices I disagreed with.\n\n#### Ok, then, why not SDLang?\n\nSDLang is designed for use cases that are not interesting to me, but are very\nrelevant to the D-lang community. KDL is very similar in many ways, but is\ndifferent in the following ways:\n\n  * The grammar and expected semantics are well-defined and specified.\n  * There is only one \"number\" type. KDL does not prescribe representations.\n  * Slashdash (/-) comments are great and useful!\n  * I am not interested in having first-class date types, and SDLang's are very non-standard.\n  * Values and properties can be interspersed with each other, rather than one having to follow the other.\n  * KDL does not have a first-class binary data type. Just use strings with base64.\n  * All strings in KDL are multi-line, and raw strings are written with Rust-style syntax (r\"foo\"), instead of backticks.\n  * KDL identifiers can use UTF-8 and are much more lax about symbols than SDLang.\n  * KDL does not support \"anonymous\" nodes.\n  * Instead, KDL supports arbitrary identifiers for node names and attribute names, meaning you can use arbitrary strings for those: \"123\" \"value\"=1 is a valid node, for example. This makes it easier to use KDL for representing arbitrary key/value pairs.\n\n#### Have you seen that one XKCD comic about standards?\n\nYes. I have. Please stop linking me to it.\n\n#### What about YAML?\n\nYAML is a great, widespread language. Unlike KDL, which is node-based (like\nXML or HTML), it's based on map and array data structures, which can provide\nan easier serialization experience in some cases.\n\nAt the same time, YAML can be ambiguous about what types the data written into\nit is. There's also a persistent issue where very large YAML files become\nunmanageable, especially due to the significant indentation feature.\n\nKDL is designed to avoid these particular pitfalls by always being explicit\nabout types, and having clearly-delimited scope (and the ability to auto-\nindent/auto-format). Syntax errors are easier to catch, and large files are\n(hopefully!) much more manageable.\n\n#### What about JSON?\n\nJSON is a great serialization language, but it can be very difficult to use as\na human configuration language. This is largely due to its very specific, very\nstrict syntax, as well as its lack of support for comments.\n\nKDL, on the other hand, has great comment support, and has a much more\nforgiving syntax without being so flexible as to allow certain classes of\nunfortunate mistakes. It also has much more flexibility around how to\nrepresent data.\n\nIf you need to interoperate with a service that consumes or emits JSON, or for\nsome other reason have need to write \"JSON in KDL\", we have JiK, an official\nmicrosyntax for losslessly encoding JSON.\n\n#### What about TOML?\n\nIt nests very poorly. It doesn't fare well with large files.\n\n#### What about XML?\n\nXML is actually pretty fantastic, and has long been a standard for data\nexchange across many industries. At the same time, XML is known to be very\nverbose, and editing it involves writing (and updating) matching tags. Another\nlarge pitfall with XML is its lack of direct support for arbitrary string\nkey/value pairs, so what would be a simple foo: x in some languages has to be\nrepresented as <entry name=\"foo\" value=\"x\" /> or something similar. XML also\nfunctions great as a markup language. That is, it is easy to intersperse with\ntext, like HTML.\n\nKDL, just like XML, is a node/element-based language, but with much more\nlightweight syntax. It also adds the ability to apply anonymous values\ndirectly to a node, rather than as children. That is, nodename 1 2 3 instead\nof <element><child>1</child><child>2</child>(etc)</element>. This can make it\nmuch more manageable and readable as a human configuration language, and is\nalso less verbose when exchanging documents across APIs!\n\nFinally, KDL is not a markup language. XML or HTML do a much better job of\n\"marking up\" a text document with special tags, although KDL can still be\nuseful for templating engines that want to be more strict about text\nfragments.\n\nIf you need to interoperate with a service that consumes or emits XML, or for\nsome other reason have need to write \"XML in KDL\", we have XiK, an official\nmicrosyntax for losslessly encoding XML.\n\n", "frontpage": false}
