{"aid": "39959253", "title": "Expose Platform APls over Wrapping Them", "url": "https://blog.jim-nielsen.com/2024/expose-platform-apis-over-wrapping-them/", "domain": "jim-nielsen.com", "votes": 1, "user": "saeedesmaili", "posted_at": "2024-04-07 08:29:05", "comments": 0, "source_title": "Expose Platform APIs Over Wrapping Them", "source_text": "Expose Platform APIs Over Wrapping Them - Jim Nielsen\u2019s Blog\n\nJim Nielsen\u2019s Blog\n\n# Expose Platform APIs Over Wrapping Them\n\n2024-04-01\n\nFrom Kent C. Dodds\u2019 article about why he won\u2019t be using Next.js:\n\n> One of the primary differences between enzyme and Testing Library is that\n> while enzyme gave you a wrapper with a bunch of (overly) helpful (dangerous)\n> utilities for interacting with rendered elements, Testing Library gave you\n> the elements themselves. To boil that down to a principle, I would say that\n> instead of wrapping the platform APIs, Testing Library exposed the platform\n> APIs.\n\nI\u2019ve been recently working in a Next.js app and a lot of Kent\u2019s critiques have\nresonated with my own experience, particularly this insight about how some\nAPIs wrap platform ones rather than exposing them.\n\nFor example, one thing I struggled with as a n00b to Next is putting metadata\nin an HTML document. If you want a <meta> tag in your HTML, Next has a bespoke\n(typed) API dedicated to it.\n\nI understand why that is the case, given how Next works as an app/routing\nframework which dynamically updates document metadata as you move from page to\npage. Lots of front-end frameworks have similar APIs.\n\nHowever, I prefer writing code as close as possible to how it will be run,\nwhich means staying as close as possible to platform APIs.\n\nWhy? For one, standardized APIs make it easy to shift from one tool to another\nwhile remaining productive. If I switch from tool A to tool B, it\u2019d be a pain\nto relearn that <div> is written as <divv>.\n\nAdditionally, you don\u2019t solely write code. You also run it and debug it. When\nI open my webpage and there\u2019s a 1:1 correspondence between the <meta> tags I\nsee in the devtools and the <meta> tags I see in my code, I can move quickly\nin debugging issues and trusting in the correctness of my code.\n\nIn other words, the closer the code that\u2019s written is to the code that\u2019s run,\nthe faster I can move with trust and confidence. However, when I require\ndocumentation as an intermediary between what I see in the devtools and what I\nsee in my code, I move slower and with less trust that I\u2019ve both understood\nand implemented correctly what is documented.\n\nWith Next, what I write compiles to HTML which is what the browser runs. With\nplain HTML, what I write is what the browser runs. It\u2019s weird to say writing\nplain HTML is \u201ccloser to the metal\u201d but here we are ha!\n\nThat said, again, I realize why these kinds of APIs exist in client-side\napp/routing frameworks. But with Next in particular, I\u2019ve encountered a lot of\nfriction taking my base understanding of HTML APIs and translating them to\nNext\u2019s APIs. Allow me a specific example.\n\n## An Example: The Metadata API\n\nThe basic premise of Next\u2019s metadata API starts with the idea that, in order\nto get some <meta> tags, you use the key/value pairs of a JS object to\ngenerate the name and content values of a <meta> tag. For example:\n\n    \n    \n    export const metadata = { generator: 'Next.js', applicationName: 'Next.js', referrer: 'origin-when-cross-origin', }\n\nWill result in:\n\n    \n    \n    <meta name=\"generator\" content=\"Next.js\" /> <meta name=\"application-name\" content=\"Next.js\" /> <meta name=\"referrer\" content=\"origin-when-cross-origin\" />\n\nSimple enough, right? camelCased keywords in JavaScript translate to their\nhyphenated counterparts, that\u2019s all pretty standard web API stuff.\n\nBut what about when you have a <meta> tag that doesn\u2019t conform to this simple\none-key-to-one-value mapping? For example, let\u2019s say you want the keywords\nmeta tag which can have multiple values (a comma-delimited list of words):\n\n    \n    \n    <meta name=\"keywords\" content=\"Next.js,React,JavaScript\" />\n\nWhat\u2019s the API for that? Well, given the key/value JS object pattern of the\nprevious examples, you might think something like this:\n\n    \n    \n    export const metadata = { keywords: 'Next.js,React,JavaScript' }\n\nMinus a few special cases, that\u2019s how Remix does it. But not in Next.\nAccording to the docs, it\u2019s this:\n\n    \n    \n    export const metadata = { keywords: ['Next.js', 'React', 'JavaScript'], }\n\n\u201cAh ok, so it\u2019s not just key/value pairing where value is a string. It can be\na more complex data type. I guess that makes sense.\u201d I say to myself.\n\nSo what about other meta tags, like the ones whose content is a list of\nkey/value pairs? For example, this tag:\n\n    \n    \n    <meta name=\"format-detection\" content=\"telephone=no, address=no, email=no\" />\n\nHow would you do that with a JS object? Initially you might think:\n\n    \n    \n    export const metadata = { formatDetection: 'telephone=no, address=no, email=no' }\n\nBut after what we saw with keywords, you might think:\n\n    \n    \n    export const metadata = { formatDetection: ['telephone=no', 'address=no', 'email=no'] }\n\nBut this one is yet another data type. In this case, content is now expressed\nas a nested object with more key/value pairs:\n\n    \n    \n    export const metadata = { formatDetection: { email: false, address: false, telephone: false, }, }\n\nTo round this out, let\u2019s look at one more example under the \u201cBasic fields\u201d\nsection of the docs.\n\n    \n    \n    export const metadata = { authors: [ { name: 'Seb' }, { name: 'Josh', url: 'https://nextjs.org' } ], }\n\nThis configuration will produce <meta> tags and a link tag.\n\n    \n    \n    <meta name=\"author\" content=\"Seb\" /> <meta name=\"author\" content=\"Josh\" /> <link rel=\"author\" href=\"https://nextjs.org\" />\n\n\u201cAh oh, so the metadata keyword export isn\u2019t solely for creating <meta> tags.\nIt\u2019ll also produce <link> tags. Got it.\u201d I tell myself.\n\nSo, by solely looking at the \u201cBasics\u201d part of the docs, I\u2019ve come to realize\nthat to produce <meta> tags in my HTML I should use the metadata keyword\nexport which is an object of key/value pairs where value can be a string, an\narray, an object, or even an array of objects! All of which will produce\n<meta> tags or <link> tags.\n\nOk, I think I got it.\n\n## Not So Fast: A Detour to Viewport\n\nWhile you might think of the viewport meta tags as part of the metadata API,\nthey\u2019re not. Or rather, they were but got deprecated in Next 14.\n\n> Deprecated: The viewport option in metadata is deprecated as of Next.js 14.\n> Please use the viewport configuration instead.\n\n[insert joke here about how the <meta> tag in HTML is never gonna give you up,\nnever gonna let you down, never gonna deprecate and desert you]\n\nOk so viewport has its own configuration API. How does it work?\n\nLet's say I want a viewport tag:\n\n    \n    \n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\" />\n\nWhat\u2019s the code for that? Given our knowledge of the metadata API, maybe we\ncan guess it.\n\nSince it gets its own named export, viewport, I assume the content part of the\ntag will represent the key/value pairs of the object?\n\nAnd yes, that\u2019s about right. Here's the code to get that tag:\n\n    \n    \n    export const viewport = { width: 'device-width', initialScale: 1, maximumScale: 1, userScalable: false, }\n\nOk, I guess that kinda makes sense. false = no and all, but I see what\u2019s going\non.\n\nBut the viewport export also handles other tags, not just <meta\nname=\"viewport\">. Theme color is also under there. You want this tag?\n\n    \n    \n    <meta name=\"theme-color\" content=\"black\" />\n\nYou might\u2019ve thought it\u2019s this:\n\n    \n    \n    export const metadata = { themeColor: 'black' }`\n\nBut according to the docs it's part of the viewport named export:\n\n    \n    \n    export const viewport = { themeColor: 'black' }\n\nAnd what if you want multiple theme color meta tags?\n\n    \n    \n    <meta name=\"theme-color\" media=\"(prefers-color-scheme: light)\" content=\"cyan\" /> <meta name=\"theme-color\" media=\"(prefers-color-scheme: dark)\" content=\"black\" />\n\nWell that\u2019s the viewport named export but instead of a string you give it an\narray of objects:\n\n    \n    \n    export const viewport = { themeColor: [ { media: '(prefers-color-scheme: light)', color: 'cyan' }, { media: '(prefers-color-scheme: dark)', color: 'black' }, ], }\n\nOk, I guess this all kind of makes sense \u2014 in its own self-consistent way, but\nnot necessarily in the context of the broader web platform APIs...\n\n## Back to Our Regularly Scheduled Programming: Next\u2019s Metadata API\n\nOk so, given everything covered above, let\u2019s play a little game. I give you\nsome HTML and you see if you can guess its corresponding API in Next. Ready?\n\n    \n    \n    <link rel=\"canonical\" href=\"https://acme.com\" /> <link rel=\"alternate\" hreflang=\"en-US\" href=\"https://acme.com/en-US\" /> <link rel=\"alternate\" hreflang=\"de-DE\" href=\"https://acme.com/de-DE\" /> <meta property=\"og:image\" content=\"https://acme.com/og-image.png\" />\n\nGo ahead, I\u2019ll give you a second. See if you can guess it...\n\nHave you tried? I\u2019ll keep waiting...\n\nGot it?\n\nOk, here\u2019s the answer:\n\n    \n    \n    export const metadata = { metadataBase: new URL('https://acme.com'), alternates: { canonical: '/', languages: { 'en-US': '/en-US', 'de-DE': '/de-DE', }, }, openGraph: { images: '/og-image.png', }, }\n\nThat\u2019s it. That\u2019s what will produce the HTML snippet I gave you. Apparently\nthere\u2019s a whole \u201cconvenience\u201d API for prefixing metadata fields with fully\nqualified URLs.\n\nYou\u2019ve heard of CSS-in-JS? Well this is HTML-in-JS. If you wish every HTML API\nwas just a (typed) JavaScript API, this would be right up your alley. No more\nremembering how to do something in HTML. There\u2019s a JS API for that.\n\nAnd again, I get it. Given the goals of Next as a framework, I understand why\nthis exists. But there\u2019s definitely a learning curve that\u2019s feels divergent to\nthe HTML pillar of the web.\n\nContrast that, for one moment, with something like this which (if you know the\nHTML APIs) requires no referencing docs:\n\n    \n    \n    const baseUrl = 'https://acme.com'; export const head = ` <link rel=\"canonical\" href=\"${baseUrl}\" /> <link rel=\"alternate\" hreflang=\"en-US\" href=\"${baseUrl}/en-US\" /> <link rel=\"alternate\" hreflang=\"de-DE\" href=\"${baseUrl}/de-DE\" /> <meta property=\"og:image\" content=\"${baseUrl}/og-image.png\" /> `;\n\nI know, I know. There\u2019s tradeoffs here. But I think what I'm trying to get at\nis what I expressed earlier: there\u2019s a clear, immediate correspondence in this\ncase between the code I write and what the browser runs. Plus this knowledge\nis transferable. This is why, to Kent\u2019s point, I prefer exposed platform APIs\nover wrapped ones.\n\n## Conclusion\n\nI only briefly covered parts of Next\u2019s metadata API. If you look closer at the\ndocs, you\u2019ll see APIs for generating <meta> tags related to open graph,\nrobots, icons, theme color, manifest, twitter, viewport, verification, apple\nweb app, alternates, app links, archives, assets, bookmarks, category, and\nmore.\n\nPlus there\u2019s all the stuff that you can use in \u201cvanilla\u201d HTML but that\u2019s\nunsupported in the metadata API in Next.\n\nThis whole post might seem like an attempt to crap on Next. It\u2019s not. As Kent\nstates in his original article:\n\n> Your tool choice matters much less than your skill at using the tool to\n> accomplish your desired outcome\n\nI agree.\n\nBut I am trying to work through articulating why I prefer tools that expose\nunderlying platform APIs over wrapping them in their own bespoke permutations.\n\nIt reminds me of this note I took from an article from the folks building\nHTMX:\n\n> Whenever a problem can be solved by native HTML elements, the longevity of\n> the code improves tremendously as a result. This is a much less alienating\n> way to learn web development, because the bulk of your knowledge will remain\n> relevant as long as HTML does.\n\nWell said.\n\nComment? Reply via: Email, Mastodon, or Twitter.\n\n", "frontpage": false}
