{"aid": "40020343", "title": "Program Synthesis", "url": "https://en.wikipedia.org/wiki/Program_synthesis", "domain": "wikipedia.org", "votes": 4, "user": "downboots", "posted_at": "2024-04-13 03:52:05", "comments": 0, "source_title": "Program synthesis", "source_text": "Program synthesis - Wikipedia\n\nJump to content\n\nSearch\n\n# Program synthesis\n\n  * \u0627\u0644\u0639\u0631\u0628\u064a\u0629\n  * Fran\u00e7ais\n  * \ud55c\uad6d\uc5b4\n  * \u65e5\u672c\u8a9e\n\nEdit links\n\nFrom Wikipedia, the free encyclopedia\n\nIn computer science, program synthesis is the task to construct a program that\nprovably satisfies a given high-level formal specification. In contrast to\nprogram verification, the program is to be constructed rather than given;\nhowever, both fields make use of formal proof techniques, and both comprise\napproaches of different degrees of automation. In contrast to automatic\nprogramming techniques, specifications in program synthesis are usually non-\nalgorithmic statements in an appropriate logical calculus.^[1]\n\nThe primary application of program synthesis is to relieve the programmer of\nthe burden of writing correct, efficient code that satisfies a specification.\nHowever, program synthesis also has applications to superoptimization and\ninference of loop invariants.^[2]\n\n## Origin[edit]\n\nDuring the Summer Institute of Symbolic Logic at Cornell University in 1957,\nAlonzo Church defined the problem to synthesize a circuit from mathematical\nrequirements.^[3] Even though the work only refers to circuits and not\nprograms, the work is considered to be one of the earliest descriptions of\nprogram synthesis and some researchers refer to program synthesis as \"Church's\nProblem\". In the 1960s, a similar idea for an \"automatic programmer\" was\nexplored by researchers in artificial intelligence.^[citation needed]\n\nSince then, various research communities considered the problem of program\nsynthesis. Notable works include the 1969 automata-theoretic approach by B\u00fcchi\nand Landweber,^[4] and the works by Manna and Waldinger (c. 1980). The\ndevelopment of modern high-level programming languages can also be understood\nas a form of program synthesis.\n\n## 21st century developments[edit]\n\nThis section needs expansion with: a more detailed overview of contemporary\napproaches. You can help by adding to it. (December 2022)  \n---  \n  \nThe early 21st century has seen a surge of practical interest in the idea of\nprogram synthesis in the formal verification community and related fields.\nArmando Solar-Lezama showed that it is possible to encode program synthesis\nproblems in Boolean logic and use algorithms for the Boolean satisfiability\nproblem to automatically find programs.^[5]\n\n### Syntax-guided synthesis[edit]\n\nIn 2013, a unified framework for program synthesis problems called Syntax-\nguided Synthesis (stylized SyGuS) was proposed by researchers at UPenn, UC\nBerkeley, and MIT.^[6] The input to a SyGuS algorithm consists of a logical\nspecification along with a context-free grammar of expressions that constrains\nthe syntax of valid solutions.^[7] For example, to synthesize a function f\nthat returns the maximum of two integers, the logical specification might look\nlike this:\n\n(f(x,y) = x \u2228 f(x,y) = y) \u2227 f(x,y) \u2265 x \u2227 f(x,y) \u2265 y\n\nand the grammar might be:\n\n    \n    \n    <Exp> ::= x | y | 0 | 1 | <Exp> + <Exp> | ite(<Cond>, <Exp>, <Exp>) <Cond> ::= <Exp> <= <Exp>\n\nwhere \"ite\" stands for \"if-then-else\". The expression\n\n    \n    \n    ite(x <= y, y, x)\n\nwould be a valid solution, because it conforms to the grammar and the\nspecification.\n\nFrom 2014 through 2019, the yearly Syntax-Guided Synthesis Competition (or\nSyGuS-Comp) compared the different algorithms for program synthesis in a\ncompetitive event.^[8] The competition used a standardized input format,\nSyGuS-IF, based on SMT-Lib 2. For example, the following SyGuS-IF encodes the\nproblem of synthesizing the maximum of two integers (as presented above):\n\n    \n    \n    (set-logic LIA) (synth-fun f ((x Int) (y Int)) Int ((i Int) (c Int) (b Bool)) ((i Int (c x y (+ i i) (ite b i i))) (c Int (0 1)) (b Bool ((<= i i))))) (declare-var x Int) (declare-var y Int) (constraint (>= (f x y) x)) (constraint (>= (f x y) y)) (constraint (or (= (f x y) x) (= (f x y) y))) (check-synth)\n\nA compliant solver might return the following output:\n\n    \n    \n    ((define-fun f ((x Int) (y Int)) Int (ite (<= x y) y x)))\n\n## The framework of Manna and Waldinger[edit]\n\nNon-clausal resolution rules (unifying substitutions not shown)Nr| Assertions|\nGoals| Program| Origin  \n---|---|---|---|---  \n51  \n52  \n53| s  \n54| t  \n55| Resolve(51,52)  \n56| s| Resolve(52,53)  \n57| s| Resolve(53,52)  \n58| p ? s : t| Resolve(53,54)  \n  \nThe framework of Manna and Waldinger, published in 1980,^[9]^[10] starts from\na user-given first-order specification formula. For that formula, a proof is\nconstructed, thereby also synthesizing a functional program from unifying\nsubstitutions.\n\nThe framework is presented in a table layout, the columns containing:\n\n  * A line number (\"Nr\") for reference purposes\n  * Formulas that already have been established, including axioms and preconditions, (\"Assertions\")\n  * Formulas still to be proven, including postconditions, (\"Goals\"),^[note 1]\n  * Terms denoting a valid output value (\"Program\")^[note 2]\n  * A justification for the current line (\"Origin\")\n\nInitially, background knowledge, pre-conditions, and post-conditions are\nentered into the table. After that, appropriate proof rules are applied\nmanually. The framework has been designed to enhance human readability of\nintermediate formulas: contrary to classical resolution, it does not require\nclausal normal form, but allows one to reason with formulas of arbitrary\nstructure and containing any junctors (\"non-clausal resolution\"). The proof is\ncomplete when has been derived in the Goals column, or, equivalently, in the\nAssertions column. Programs obtained by this approach are guaranteed to\nsatisfy the specification formula started from; in this sense they are correct\nby construction.^[11] Only a minimalist, yet Turing-complete,^[12] purely\nfunctional programming language, consisting of conditional, recursion, and\narithmetic and other operators^[note 3] is supported. Case studies performed\nwithin this framework synthesized algorithms to compute e.g. division,\nremainder,^[13] square root,^[14] term unification,^[15] answers to relational\ndatabase queries^[16] and several sorting algorithms.^[17]^[18]\n\n### Proof rules[edit]\n\nProof rules include:\n\n  * Non-clausal resolution (see table).\n\n    For example, line 55 is obtained by resolving Assertion formulas from 51 and from 52 which both share some common subformula . The resolvent is formed as the disjunction of , with replaced by , and , with replaced by . This resolvent logically follows from the conjunction of and . More generally, and need to have only two unifiable subformulas and , respectively; their resolvent is then formed from and as before, where is the most general unifier of and . This rule generalizes resolution of clauses.^[19]\n    Program terms of parent formulas are combined as shown in line 58 to form the output of the resolvent. In the general case, is applied to the latter also. Since the subformula appears in the output, care must be taken to resolve only on subformulas corresponding to computable properties.\n\n  * Logical transformations.\n\n    For example, can be transformed to ) in Assertions as well as in Goals, since both are equivalent.\n\n  * Splitting of conjunctive assertions and of disjunctive goals.\n\n    An example is shown in lines 11 to 13 of the toy example below.\n\n  * Structural induction.\n\n    This rule allows for synthesis of recursive functions. For a given pre- and postcondition \"Given such that , find such that \", and an appropriate user-given well-ordering of the domain of , it is always sound to add an Assertion \"\".^[20] Resolving with this assertion can introduce a recursive call to in the Program term.\n    An example is given in Manna, Waldinger (1980), p.108-111, where an algorithm to compute quotient and remainder of two given integers is synthesized, using the well-order defined by (p.110).\n\nMurray has shown these rules to be complete for first-order logic.^[21] In\n1986, Manna and Waldinger added generalized E-resolution and paramodulation\nrules to handle also equality;^[22] later, these rules turned out to be\nincomplete (but nevertheless sound).^[23]\n\n### Example[edit]\n\nExample synthesis of maximum functionNr| Assertions| Goals| Program| Origin  \n---|---|---|---|---  \n1| Axiom  \n2| Axiom  \n3| Axiom  \n10| M| Specification  \n11| M| Distr(10)  \n12| M| Split(11)  \n13| M| Split(11)  \n14| x| Resolve(12,1)  \n15| x| Resolve(14,2)  \n16| x| Resolve(15,3)  \n17| y| Resolve(13,1)  \n18| y| Resolve(17,2)  \n19| x<y ? y : x| Resolve(18,16)  \n  \nAs a toy example, a functional program to compute the maximum of two numbers\nand can be derived as follows.^[citation needed]\n\nStarting from the requirement description \"The maximum is larger than or equal\nto any given number, and is one of the given numbers\", the first-order formula\nis obtained as its formal translation. This formula is to be proved. By\nreverse Skolemization,^[note 4] the specification in line 10 is obtained, an\nupper- and lower-case letter denoting a variable and a Skolem constant,\nrespectively.\n\nAfter applying a transformation rule for the distributive law in line 11, the\nproof goal is a disjunction, and hence can be split into two cases, viz. lines\n12 and 13.\n\nTurning to the first case, resolving line 12 with the axiom in line 1 leads to\ninstantiation of the program variable in line 14. Intuitively, the last\nconjunct of line 12 prescribes the value that must take in this case.\nFormally, the non-clausal resolution rule shown in line 57 above is applied to\nlines 12 and 1, with\n\n  * p being the common instance x=x of A=A and x=M, obtained by syntactically unifying the latter formulas,\n  * F[p] being true \u2227 x=x, obtained from instantiated line 1 (appropriately padded to make the context F[\u22c5] around p visible), and\n  * G[p] being x \u2264 x \u2227 y \u2264 x \u2227 x = x, obtained from instantiated line 12,\n\nyielding true \u2227 false) \u2227 (x \u2264 x \u2227 y \u2264 x \u2227 true, which simplifies to .\n\nIn a similar way, line 14 yields line 15 and then line 16 by resolution. Also,\nthe second case, in line 13, is handled similarly, yielding eventually line\n18.\n\nIn a last step, both cases (i.e. lines 16 and 18) are joined, using the\nresolution rule from line 58; to make that rule applicable, the preparatory\nstep 15\u219216 was needed. Intuitively, line 18 could be read as \"in case , the\noutput is valid (with respect to the original specification), while line 15\nsays \"in case , the output is valid; the step 15\u219216 established that both\ncases 16 and 18 are complementary.^[note 5] Since both line 16 and 18 comes\nwith a program term, a conditional expression results in the program column.\nSince the goal formula has been derived, the proof is done, and the program\ncolumn of the \"\" line contains the program.\n\n## See also[edit]\n\n  * Inductive programming\n  * Metaprogramming\n  * Program derivation\n  * Natural language programming\n  * Reactive synthesis\n\n## Notes[edit]\n\n  1. ^ The distinction \"Assertions\" / \"Goals\" is for convenience only; following the paradigm of proof by contradiction, a Goal is equivalent to an assertion .\n  2. ^ When and is the Goal formula and the Program term in a line, respectively, then in all cases where holds, is a valid output of the program to be synthesized. This invariant is maintained by all proof rules. An Assertion formula usually is not associated with a Program term.\n  3. ^ Only the conditional operator (?:) is supported from the beginning. However, arbitrary new operators and relations can be added by providing their properties as axioms. In the toy example below, only the properties of and that are actually needed in the proof have been axiomatized, in line 1 to 3.\n  4. ^ While ordinary Skolemization preserves satisfiability, reverse Skolemization, i.e. replacing universally quantified variables by functions, preserves validity.\n  5. ^ Axiom 3 was needed for that; in fact, if wasn't a total order, no maximum could be computed for uncomparable inputs .\n\n## References[edit]\n\n  1. ^ Basin, D.; Deville, Y.; Flener, P.; Hamfelt, A.; Fischer Nilsson, J. (2004). \"Synthesis of programs in computational logic\". In M. Bruynooghe and K.-K. Lau (ed.). Program Development in Computational Logic. LNCS. Vol. 3049. Springer. pp. 30\u201365. CiteSeerX 10.1.1.62.4976.\n  2. ^ (Alur, Singh & Fisman) harv error: no target: CITEREFAlurSinghFisman (help)\n  3. ^ Alonzo Church (1957). \"Applications of recursive arithmetic to the problem of circuit synthesis\". Summaries of the Summer Institute of Symbolic Logic. 1: 3\u201350.\n  4. ^ Richard B\u00fcchi, Lawrence Landweber (Apr 1969). \"Solving Sequential Conditions by Finite-State Strategies\". Transactions of the American Mathematical Society. 138: 295\u2013311. doi:10.2307/1994916. JSTOR 1994916.\n  5. ^ Solar-Lezama, Armando (2008). Program synthesis by sketching (PDF) (Ph.D.). University of California, Berkeley.\n  6. ^ Alur, Rajeev; al., et (2013). \"Syntax-guided Synthesis\". Proceedings of Formal Methods in Computer-Aided Design. IEEE. p. 8.\n  7. ^ David, Cristina; Kroening, Daniel (2017-10-13). \"Program synthesis: challenges and opportunities\". Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences. 375 (2104): 20150403. doi:10.1098/rsta.2015.0403. ISSN 1364-503X. PMC 5597726. PMID 28871052.\n  8. ^ SyGuS-Comp (Syntax-Guided Synthesis Competition)\n  9. ^ Zohar Manna, Richard Waldinger (Jan 1980). \"A Deductive Approach to Program Synthesis\". ACM Transactions on Programming Languages and Systems. 2: 90\u2013121. doi:10.1145/357084.357090. S2CID 14770735.\n  10. ^ Zohar Manna and Richard Waldinger (Dec 1978). A Deductive Approach to Program Synthesis (PDF) (Technical Note). SRI International. Archived (PDF) from the original on January 27, 2021.\n  11. ^ See Manna, Waldinger (1980), p.100 for correctness of the resolution rules.\n  12. ^ Boyer, Robert S.; Moore, J. Strother (May 1983). A Mechanical Proof of the Turing Completeness of Pure Lisp (PDF) (Technical report). Institute for Computing Science, University of Texas at Austin. 37. Archived (PDF) from the original on 22 September 2017.\n  13. ^ Manna, Waldinger (1980), p.108-111\n  14. ^ Zohar Manna and Richard Waldinger (Aug 1987). \"The Origin of a Binary-Search Paradigm\". Science of Computer Programming. 9 (1): 37\u201383. doi:10.1016/0167-6423(87)90025-6.\n  15. ^ Daniele Nardi (1989). \"Formal Synthesis of a Unification Algorithm by the Deductive-Tableau Method\". Journal of Logic Programming. 7: 1\u201343. doi:10.1016/0743-1066(89)90008-3.\n  16. ^ Daniele Nardi and Riccardo Rosati (1992). \"Deductive Synthesis of Programs for Query Answering\". In Kung-Kiu Lau and Tim Clement (ed.). International Workshop on Logic Program Synthesis and Transformation (LOPSTR). Workshops in Computing. Springer. pp. 15\u201329. doi:10.1007/978-1-4471-3560-9_2.\n  17. ^ Jonathan Traugott (1986). \"Deductive Synthesis of Sorting Programs\". Proceedings of the International Conference on Automated Deduction. LNCS. Vol. 230. Springer. pp. 641\u2013660.\n  18. ^ Jonathan Traugott (Jun 1989). \"Deductive Synthesis of Sorting Programs\". Journal of Symbolic Computation. 7 (6): 533\u2013572. doi:10.1016/S0747-7171(89)80040-9.\n  19. ^ Manna, Waldinger (1980), p.99\n  20. ^ Manna, Waldinger (1980), p.104\n  21. ^ Manna, Waldinger (1980), p.103, referring to: Neil V. Murray (Feb 1979). A Proof Procedure for Quantifier-Free Non-Clausal First Order Logic (Technical report). Syracuse Univ. 2-79.\n  22. ^ Zohar Manna, Richard Waldinger (Jan 1986). \"Special Relations in Automated Deduction\". Journal of the ACM. 33: 1\u201359. doi:10.1145/4904.4905. S2CID 15140138.\n  23. ^ Zohar Manna, Richard Waldinger (1992). \"The Special-Relations Rules are Incomplete\". Proc. CADE 11. LNCS. Vol. 607. Springer. pp. 492\u2013506.\n\n  * Alur, Rajeev; Singh, Rishabh; Fisman, Dana; Solar-Lezama, Armando (2018-11-20). \"Search-based program synthesis\". Communications of the ACM. 61 (12): 84\u201393. doi:10.1145/3208071. ISSN 0001-0782.\n  * Zohar Manna, Richard Waldinger (1975). \"Knowledge and Reasoning in Program Synthesis\". Artificial Intelligence. 6 (2): 175\u2013208. doi:10.1016/0004-3702(75)90008-9.\n\nRetrieved from\n\"https://en.wikipedia.org/w/index.php?title=Program_synthesis&oldid=1185150452\"\n\nCategory:\n\n  * Programming paradigms\n\nHidden categories:\n\n  * Harv and Sfn no-target errors\n  * All articles with unsourced statements\n  * Articles with unsourced statements from June 2010\n  * Articles to be expanded from December 2022\n  * All articles to be expanded\n  * Articles using small message boxes\n  * Articles with unsourced statements from May 2016\n\n  * This page was last edited on 14 November 2023, at 22:02 (UTC).\n  * Text is available under the Creative Commons Attribution-ShareAlike License 4.0; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia\u00ae is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.\n\n  * Privacy policy\n  * About Wikipedia\n  * Disclaimers\n  * Contact Wikipedia\n  * Code of Conduct\n  * Developers\n  * Statistics\n  * Cookie statement\n  * Mobile view\n  * Edit preview settings\n\n", "frontpage": true}
