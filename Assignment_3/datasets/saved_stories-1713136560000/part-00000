{"aid": "40032619", "title": "Revealed: The Software Scalability Game", "url": "https://slissner.com/posts/the-software-scalability-game/", "domain": "slissner.com", "votes": 1, "user": "slissner", "posted_at": "2024-04-14 17:14:23", "comments": 0, "source_title": "Revealed: The software scalability game | Samuel Lissner", "source_text": "Revealed: The software scalability game | Samuel Lissner\n\nSamuel Lissner\n\nSoftware Architecture Scalability\n\n# Revealed: The software scalability game\n\nSoftware scalability isn't just a fancy engineering exercise. It's a game\nwhere businesses need to level up. And if you can\u2019t figure out how to play the\ngame, you\u2019ll probably never succeed to move your architecture to the next\nlevel.\n\nSamuel Lissner 14 Apr, 2024 \u2013 3 min read\n\nPicture from Samuel Lissner\n\n## The Game\n\nShopify served 1.27 Million requests per second during Black Friday. Their\nmain monolith is one of the oldest, largest Rails codebases on the planet. It\nis under continuous development since at least 2006, with over 2.8 million\nlines of Ruby code and 500,000 commits.\n\nSeeing this magnitude, software scalability isn\u2019t just a fancy engineering\nexercise. It\u2019s a game where businesses need to level up. And if you can\u2019t\nfigure out how to play the game, you\u2019ll probably never succeed to move your\narchitecture to the next level.\n\nThe game is played in levels. And at each level, you acquire new skills and\nnew points of leverage that you can use to move ahead.\n\nLet\u2019s pull back the curtain see how the game is played.\n\n## Level 1: The monolith\n\nA single deployable application.\n\nEven a single monolithic instance of, say nodejs, can already handle up to\nhundreds requests per second.\n\nSet a load balancer in front of a handful instances, and you should be able to\nserve thousands of requests per second.\n\nFor most small and medium businesses, this type of application should be\nalready good enough. A starting company should not even consider other forms\nof architecture unless its customer base grows.\n\nAs a rule of thumb, you should almost always start with a monolith. And\ntherefore, the first \u201clevel up\u201d advice is: DO NOT level up unless you really\nneed it!\n\n## Level 2: The modulith\n\nA single deployable application composed of loosely coupled modules.\n\nModulithic architectures are easy to deploy, yet better to maintain than a\nmonolith. For big companies or smaller enterprise applications, a modulith is\nthe way to go.\n\nHow to level \ud83c\udd99: Break up the monolith into separate domain modules which do\nnot depend on each other. Safeguard that boundaries without making exceptions\nwith Gradle, the archunit library or others. Have a look at Spring Modulith,\nif you are a Spring user. Communicate between the modules with the help of\nSpring domain events or other event-based architecture.\n\n## Level 3: Microservices\n\nMicroservices consists of multiple deployable software assets that scale\nindependently according to their need. A microservice should do \u201cone thing\nright\u201d (which means a domain!) and may come with a separate data storage.\n\nWhile you can achieve superior scalability with microservices, orchestration\ncomes at the cost of higher complexity.\n\nHow to level \ud83c\udd99: Before even thinking about a Microservices architecture, make\nsure you have reached level 2. You should have established clear model of\ndomain boundaries. It is much easier to break up a well-defined modulith than\na messy, entangled monolith. You should really hit a wall with your modulithic\nscalability constraints before escalating to the next step.\n\nIn essence, the modulith architecture is the blueprint of the microservices\narchitecture. It is easier to scale out to microservices if the structures are\nwell established.\n\n## Bonus Level 4: Cloud native planet scale\n\nA few huge corporate, notably, FAANG and other planet scale companies have\nreached a level where \u201ceverything scales\u201d.\n\nHow to level \ud83c\udd99: Make sure your application landscape is cloud-native. Every\nasset in the architecture should be scalable. As the architect you probably\nhave to shift to a data-driven approach to observe your architecture.\n\nCongratulations! You have mastered the scalability game \ud83d\ude04\n\nFrom now on it should be obvious that the choice of scale depends on your\nbusiness needs. If you work in FAANG \u201cwill it scale?\u201d is a legitimate\nquestion. If you work in a startup without customers yet, maybe it\u2019s\npremature.\n\nThat being said, optimize for adaptability rather than scalability. It is much\neasier to level up understandable code scalable than the other way around.\n\nOlder post\n\n## Be that good ancestor\n\nLegacy code is often associated with being something bad. However, legacy\nsoftware is often a valuable asset for businesses. When touching legacy code\nwith the due respect it deserves, it ultimately leads to tough questions: will\nwe ourselves be that good ancestor to others?\n\nLike what you read? Receive updates when posts are published.\n\n### Samuel Lissner\n\nHi, I am Samuel \u2013 a Senior Software Developer with 7+ years of experience.\n\n2024 \u00a9 Samuel Lissner. All Right Reserved. Published with Hugo and Akio.\n\nData protection\n\nWe would like to use cookies to improve the experience of this web site.\n\n", "frontpage": false}
