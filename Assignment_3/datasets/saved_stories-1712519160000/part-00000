{"aid": "39960740", "title": "Depot Build API: build Docker images as a service", "url": "https://depot.dev/blog/docker-build-api", "domain": "depot.dev", "votes": 2, "user": "kylegalbraith", "posted_at": "2024-04-07 13:45:10", "comments": 0, "source_title": "Depot Build API: build Docker images as a service", "source_text": "Depot Build API: build Docker images as a service\n\nWe use cookies to understand how people use Depot.\n\n\ud83d\ude80 All of the performance of Depot, now for GitHub Actions Runners!\n\nDepot\n\nSign InSign Up\n\n\u2190 All Posts\n\n# Depot Build API: build Docker images as a service\n\nWritten by\n\nKyle Galbraith\n\nPublished on\n\n4 March 2024\n\nShare\n\nShare on TwitterShare on LinkedInShare on Hacker News\n\nThis article walks you through how to use Depot's API within your own code to\nset up projects and run your Docker builds as a service on Depot's\ninfrastructure.\n\nThis article walks you through how to use Depot's API within your own code to\nset up projects and run your Docker builds as a service on Depot's\ninfrastructure.\n\nDepot is a remote container build service that makes your Docker image builds\nup to 40x faster. Try out Depot locally, in your existing CI workflow, or with\nour API. Get Started \u2192\n\nBuilding a Docker image requires a high level of permissions in the\nenvironment where that build is happening. You have to sandbox the build so\nthat any escape from the Docker image build doesn't impact other resources\nrunning nearby.\n\nIf you need to build Docker images for untrusted code or code that you don't\nown, the risk is much higher. Building Docker containers on behalf of your\nusers is a complex problem that has a large security surface area. It's also\ntypically not the core value proposition of your product or service.\nOptimizing builds for performance, handling Docker layer caching, securing the\nunderlying infrastructure, and maintaining BuildKit are all problems that\narise when you start building Docker images on behalf of your users.\n\nWe take all those problems off your plate with Depot.\n\nWe've built Depot to be the fastest remote container build service, optimized\nto build any Docker image up to 40x faster. It's a drop-in replacement for\ndocker build, with our own depot build CLI. You can leverage Depot locally and\ninside of your existing CI environment.\n\nIn this article, however, we highlight the Depot Build API that solves this\nexact use case. Build any Docker image on behalf of your users with our API\nand never have to think about managing your own build infrastructure again.\n\nKeep reading to learn more about how Depot Build API works and how you can\nintegrate it, including detailed code examples and a reference repo.\n\n## Depot Build API solves the hassle of managing Docker builds yourself\n\nThe use case for Depot Build API is any service that takes in a Dockerfile\nfrom its users, builds the container, and then does something with the\nDockerized app. Here are some examples of use cases that we often see:\n\n  * running Kubernetes as a service for customers\n  * building customer containers and deploying them to their own infrastructure\n  * building customer containers and deploying them to cloud infrastructure like AWS ECS, Google Cloud Run, Fly.io, etc.\n\nHistorically, there hasn't been a good option for handling the middle portion\nof this process: building the image. You've had to resort to hacks like\ncommitting a Dockerfile (that hasn't changed) to Git just to trigger a CI\nworkflow that builds your image, and then pulling the image afterward. This\ntreats CI builders like GitHub Actions as APIs, which they weren't designed\nas.\n\nOr you've had to stand up a full build infrastructure setup that runs\nBuildKit, or its equivalent, inside your own product or service. This incurs a\nmassive maintenance footprint and cost for a feature that isn't in your core\nvalue proposition.\n\nWouldn't it be cool if there were an API that could just build a Docker\ncontainer? That's why we created the Depot Build API. With it, you can send\nyour Dockerfile and build context to our remote build service and leverage our\nbuilder infrastructure to run your build.\n\nDepot Build API handles the entire build for you from optimizing the transfer\nof the build, building the image as fast as possible, persisting and managing\ncache, to ultimately returning the built image to you or pushing it to your\nregistry.\n\n## Try out Depot's API to run a simple Docker build as a service\n\nHere's an example showing how to use Depot Build API to build Docker images\nfrom your own code. We've made some simplifying assumptions so that this\ntutorial can focus only on interacting with the APIs. First, you'll just be\nrunning the Docker container on your local machine, without a deployment\npipeline. And second, you'll run a simple \u201cHello World\u201d application.\n\nYou'll be interacting with these APIs through our Node.js SDK. You can check\nout our documentation for the Node.js SDK to see the specific usage examples\nfor each API call. We've also provided an example repo to go along with this\ntutorial. You can clone the repo locally or fork it if you want to build off\nthe API calls in this example.\n\nOur example repo contains the following files:\n\n  * A Dockerfile representing a basic Docker build that needs to be performed for a simple Node.js application.\n  * The example Node.js application lives in the app/directory.\n  * The src/ directory contains examples of how to call different Depot API endpoints.\n  * list-projects.js\n  * create-project.js\n  * delete-project.js\n  * create-build.js\n\n## Steps to run the tutorial\n\n### Step 1: Set up your organization within Depot\n\nTo get started with Depot, sign up for a 7-day free trial. Afterward, you can\ncreate an organization and name it whatever you prefer.\n\nAfter creating your organization, you may be prompted to create a new project.\nIgnore this and click away from this menu for now, as we'll do that later\nthrough the API. After doing this, you should see something like the following\nin your Depot dashboard.\n\nNext, create an API token to use with subsequent API calls. Click Settings in\nthe menu, then scroll down to the API Tokens section. Type test-token (or any\nother name you prefer) into the Description field and click Create token.\n\nAfterward, you'll see a new token created. Be sure to copy this token to your\nclipboard and save it somewhere before leaving the page, as you won't be able\nto see it again.\n\nNow, set this token as the DEPOT_TOKEN environment variable in your shell with\nthe command below, as the Node.js scripts below will look here to authorize\nany API requests.\n\n    \n    \n    export DEPOT_TOKEN=<your org token>\n\n### Step 2: Download the Depot CLI\n\nYou will also need to install the Depot CLI to run the build. To install the\nCLI, run the following command and follow the prompts afterward:\n\n    \n    \n    curl -L https://depot.dev/install-cli.sh | sh\n\nIf you're on a Mac, you also have the option to install with Homebrew:\n\n    \n    \n    brew install depot/tap/depot\n\n### Step 3: Use the CoreService to create and configure your Depot project\n\nAt this point, you've created your new Depot account, created a test\norganization, and exported a test organization token that you can use to query\nthe API. Now, you're ready to begin interacting with the API.\n\nIf you haven't done so already, clone or fork the repository for this\ntutorial. Inside the src directory are various examples of calling the Depot\nBuild API. Starting with list-projects.js, you can call\nProjectService.listProjects() to list projects in your organization:\n\n    \n    \n    const {depot} = require('@depot/sdk-node') const headers = { Authorization: `Bearer ${process.env.DEPOT_TOKEN}`, } async function listProjects() { const result = await depot.core.v1.ProjectService.listProjects({}, {headers}) console.log(result.projects) } listProjects()\n\nYou can see that this script uses the DEPOT_TOKEN that you exported earlier\nfor authentication, calls ProjectService.listProjects(), and then logs in your\nDepot organization. You can run this with node:\n\n    \n    \n    node ./src/list-projects.js\n\nAt this point, you haven't created any projects, so you should get back an\nempty list. This is also apparent by looking at your Depot account dashboard.\n\nNow, you can use the ProjectService.createProject() API call in create-\nproject.js to create a project.\n\n    \n    \n    const {depot} = require('@depot/sdk-node') const headers = { Authorization: `Bearer ${process.env.DEPOT_TOKEN}`, } async function createProject(project_name, organization_id) { const result = await depot.core.v1.ProjectService.createProject( { name: project_name, regionId: 'us-east-1', cachePolicy: {keepBytes: 50 * 1024 * 1024 * 1024, keepDays: 14}, // 50GB and 14 days }, {headers}, ) console.log(result.project) } const args = process.argv.slice(2) const project_name = args[0] createProject(project_name)\n\nThis takes the project name as a command line argument and then configures a\nnew Depot project using the default parameters shown. You can choose what to\ncall your Depot project with the project-name argument. Once you have decided\non your project name, create a project with the following command:\n\n    \n    \n    node ./src/create-project.js <project-name>\n\nYou will get back some information about the newly created project, like the\nfollowing. Pay special attention to the projectId, as you will use that later\nto create a build inside your project.\n\n    \n    \n    _Project { projectId: 'krt0wtn195', organizationId: '3d1h48dqlh', name: 'test-project', regionId: 'us-east-1', createdAt: Timestamp { seconds: 1708021346n, nanos: 83000000 }, cachePolicy: _CachePolicy { keepBytes: 53687091200n, keepDays: 14 } }\n\nYou can now see this project with the ProjectService.listProjects() API call\nfrom before to see your newly created project. You can also see this project\npopulated in your Depot dashboard, with new options and settings inside of it.\n\nThere is also a delete-projects.jsscript in the tutorial repository that\nallows you to supply a project ID and delete a project through the API.\nHowever, we won't use it in this tutorial.\n\n    \n    \n    const {depot} = require('@depot/sdk-node') const headers = { Authorization: `Bearer ${process.env.DEPOT_TOKEN}`, } async function deleteProject(project_id) { await depot.core.v1.ProjectService.deleteProject( { projectId: project_id, }, {headers}, ) } const args = process.argv.slice(2) const project_id = args[0] deleteProject(project_id)\n\n#### Note on cache isolation when creating projects\n\nIn Depot, a project is a set of builders plus an NVMe cache disk for each\narchitecture you build for.\n\nWe strongly recommend having a dedicated project for each entity on your side\nthat's equivalent to a customer organization. This way, each of your customers\nwill have dedicated cache storage and builder machines, which together\nmaximize cache effectiveness and guarantee that there won't be any cache\npoisoning.\n\n### Step 4: Use the BuildService to build your Docker image\n\nAfter you've configured your Depot organization and project, it's now time to\nrun a Docker image build on Depot via the Build API.\n\nFor this build, you'll supply the Dockerfile below, which installs a base\nimage of Node and then copies the \u201cHello World\u201d Node.js file into the Docker\nimage.\n\n    \n    \n    FROM node:18-alpine WORKDIR /app COPY app/ . CMD [\"node\", \"hello-world.js\"]\n\nThe simplest way to offload your build from Node is to create a build via the\nDepot Build API and pass that build token to our depot build CLI. The\nBuildService API allows you to provision a build in a given project via the\ncreateBuild endpoint. You can then take the build ID and build token from that\nresponse to the Depot CLI to orchestrate your build in our infrastructure.\n\nCreating the build is shown below in the create-build.js file.\n\n    \n    \n    const {depot} = require('@depot/sdk-node') const {exec} = require('child_process') const headers = { Authorization: `Bearer ${process.env.DEPOT_TOKEN}`, } async function runBuild(projectID) { const result = await depot.build.v1.BuildService.createBuild( { projectId: projectID, }, {headers}, ) /* Execute Depot CLI binary to run build using the build ID and build token that were generated by the createBuild API call. */ exec( 'depot build --load .', { env: { DEPOT_PROJECT_ID: projectID, DEPOT_BUILD_ID: result.buildId, DEPOT_TOKEN: result.buildToken, }, }, (error, stdout, stderr) => { if (error) { console.error(`Error executing the binary: ${error}`) return } console.log(`stdout:${stdout}`) console.error(`stderr:${stderr}`) }, ) } const args = process.argv.slice(2) const projectID = args[0] runBuild(projectID)\n\nTo run this, you just need to feed in the project ID from before as a command-\nline argument.\n\n    \n    \n    node ./src/create-build.js <project-id>\n\nAfterward, you should see the output of the Depot CLI running the build. You\nshould also see the build running in your Depot dashboard in the Projects\nsection.\n\nThe logs for this build, including what happened at each step in the build,\ncan be viewed in the build details view.\n\n### Step 5: Run your Docker container\n\nBecause of the --load flag in the depot build command, the Docker image will\nbe pulled back and loaded into your local Docker daemon. You should be able to\nview this with the following Docker command:\n\n    \n    \n    docker image ls\n\nHere is an example output after running this command:\n\n    \n    \n    REPOSITORY TAG IMAGE ID CREATED SIZE <none> <none> 23d2e8d0d798 16 seconds ago 132MB\n\nYou can then run this simple \u201cHello World\u201d Docker image that was built on\nDepot's infrastructure with the following command, using the image ID from the\nprevious command:\n\n    \n    \n    docker run <image-id>\n\n## Advanced: using BuildKitService\n\nIf you were following along, you just used the Depot API's ProjectService to\ncreate a new project, the BuildService to provision a build, and the Depot CLI\nto orchestrate the build on your behalf.\n\nThis is the workflow we recommend to almost everybody as it is far less\ncomplex than interacting with BuildKit directly and pushes all the\norchestration down to the Depot CLI. However, for those currently interacting\ndirectly with BuildKit, we also provide a BuildKitService to leverage Depot's\ninfrastructure for your existing BuildKit builds.\n\nThe BuildKitService complements the BuildService. You'll still use\nCreateBuild(), but instead of using the Depot CLI to execute the build (which\nhides all of BuildKit's complexity), you'll be using the BuildKit client to\nexecute the build (which exposes all of BuildKit's functionality). This is the\nsame client docker buildx build uses behind the scenes.\n\nThe BuildKitService provides getEndpoint(), reportHealth(), and\nreleaseEndpoint() as API calls. getEndpoint() provides the endpoint for the\nDepot infrastructure created after running createBuild() from the\nBuildService. The endpoint is fed into the BuildKit client so that the build\nhappens on Depot's infrastructure.\n\nWe also require you to call reportHealth() every five minutes to let us know\nyou're still using Depot infrastructure for the build. Otherwise, we assume\nyou're done and clean up the resources. After your BuildKit build is finished,\nyou can call releaseEndpoint(), which releases Depot's infrastructure.\n\nWe have an example Go application walking through how to interact with a\nBuildKit endpoint directly.\n\nIn order to understand more about the inner workings of BuildKit, you can\ncheck out our BuildKit in depth article.\n\n## Outsource your Docker builds efficiently, securely, and reliably\n\nAt this point, you've seen how to interact with Depot's API to run your Docker\nbuilds without all of the headaches of managing your own infrastructure or\ninteracting directly with BuildKit. Instead, you can rely on Depot's remote\nbuilders, which support x86 and ARM architectures and come with 16 vCPUs, 32\nGB memory, and a 50+ GB NVMe cache disk.\n\nAs you build on this example for your own real-world use cases, you can also\naccess Depot's infrastructure directly from the Depot CLI, which serves as a\ndrop-in replacement for docker build, docker buildx build, and docker buildx\nbake commands.\n\nLearn more about how Depot's infrastructure works behind the scenes or reach\nout to us with any questions about how you could set up your own reliable,\nscalable, and secure Docker building workflows without having to manage the\ninfrastructure.\n\n## Related Articles\n\n  * BuildKit in depth: Docker's build engine explained\n  * Buildx bake deep dive: Bake all your images with one command\n\nBuild 40x faster\n\nGet started for free \u2192\n\nDepot\n\nProduct\n\nPricing\n\nSecurity\n\nDockerfile Explorer\n\nDrop Week\n\ndepot.ai\n\nSupport\n\nDocumentation\n\nSupport\n\nDiscord 26 online\n\nSystem Status\n\nCompany\n\nAbout\n\nBlog\n\nChangelog\n\nContact Us\n\nBrand Assets\n\n\u00a9 2024 Depot Technologies Inc.\n\nTerms of ServicePrivacy PolicyCookies\n\nDepot GitHub accountDepot Discord communityDepot Twitter accountDepot LinkedIn\naccount\n\n", "frontpage": false}
