{"aid": "39965087", "title": "Kuto, a Reverse JavaScript Bundler", "url": "https://samthor.au/2024/kuto/", "domain": "samthor.au", "votes": 11, "user": "bpierre", "posted_at": "2024-04-08 00:17:01", "comments": 0, "source_title": "Kuto, a reverse JS bundler", "source_text": "Kuto, a reverse JS bundler\n\nSam Thorogood March 2024\n\nHome About Archive Twitter\n\n# Kuto, a reverse JS bundler\n\nKuto is a novel approach to shipping code on the web. It lets you re-use code\na client already has for shipping updates.\n\nFor a 'real-world' site with ~3mb of JS, updating the React dependency\nresulted in:\n\n  * 71% smaller download\n  * 28% faster start time (on a ~5yo old phone, a Pixel 3).\n\n...vs a single bundle, or any case where all the code is invalidated.\n\nNote that Kuto works really well on the final ESM bundles of real sites or\napps, but probably not libraries themselves, even though Kuto's output will be\nvalid. Kuto also works as a predictable 'chunk' generator for large bundles.\n\nIf this is interesting to you\u2014do you have too much JavaScript?\u2014then do the\nthing, and do a Kuto on your code. (Is Kuto a verb? Who knows. I'm trying it\nout.) \u2702\ufe0f\n\n## How does it work?\n\nInstead of focusing on minifying output or anything idempotent, Kuto takes a\ndifferent route.\n\n  1. On the first build:\n\n     * Kuto splits source JS into a 'main' part, and a normally larger 'corpus' of code which has no side effects.\n     * This corpus can be cached forever, and a hashed timestamp is included in its output name.\n\n  2. On every further build:\n\n     * Kuto still splits out the source JS\n     * It identifies code from any existing corpus that can be used to 'satisfy' the source JS\n\n       * Each corpus will either stay the same or shrink as functions, statements etc change\n     * Any code that cannot be satisfied is put into a brand new corpus, which can also be cached forever.\n\nThis is a little complicated. Here's a gif video:\n\nKuto will build an additional corpus when something changes\n\nAfter each build, you're likely to generate another corpus with changed code.\n(This will eventually be an issue with fragmentation, more on this later.)\n\n## Why does it work?\n\nEach corpus, once fetched by a client, can be cached forever. However, on\nevery build, that corpus may shrink in size. New clients will get the smaller\nversion. (Kuto's corpuses have a hashed timestamp, and you do have to set up\nyour webserver to send the right headers here).\n\nBut...this breaks all we know about caching responses on the web! I've changed\nan immutable file! \ud83e\udd2f\n\nThe result is that older clients will have bigger files, and newer clients\nwill have smaller ones, even for the same filename. But that bigger file\nsimply has now-deprecated code. Kuto's primary thesis is that disk I/O to load\na slightly bigger file than you need is faster than compling anew.\n\n(Note that at least v8-based browsers cache the bytecode of the source, which\nprovides the speed benefit. If you were compiling anew every time, Kuto\nwouldn't help.)\n\nAside the remarkably bonkers way this leverages your browser, Kuto also\nbasically performs code-splitting in a completely predictable, useful and\nautomated fashion. Other bundlers either require you to:\n\n  * (not codesplit an output bundle at all)\n  * explicitly mark dependencies to be put into their own bundle\n  * put code in bundles on (effectively) random boundaries, just trying to restrict the size of each 'chunk'.\n\n## No really, how does it work?\n\nThe above explanation was fairly high-level. At a lower level, Kuto looks for\ncode with no side effects to include in its corpuses, and it uses circular\ndependencies to ensure they're safe to call.\n\n### No Side Effects\n\nTurns out, defining a function has no side effects. No, really! The definition\nof a function does nothing except creates a variable:\n\n    \n    \n    function foo() { console.info(`Side effect`); }\n\nSince foo isn't actually called, and we declare it in a module scope, nothing\nhappens. Until we run foo, it might as well be:\n\n    \n    \n    function foo() { // Blah blah blah blah, I'm Schr\u00f6dinger's function }\n\nKuto takes this theory to the extreme, putting classes into the same form, and\neven arbitrary statements. We *hand wave* can hoist statements to be within a\nfunction.\n\n### Circular Dependencies\n\nEach corpus contains silo'ed^ functions which reference back to the main file\nin order to work out their dependencies. A good way to see this is to check\nout Kuto itself and run its \"./release.sh\" script, which builds Kuto itself\nthis way.\n\nFor a trivial site that appends a custom element to your page, where the\ncustom element has changed and been rebuilt, this might look like:\n\n    \n    \n    // main.js import { _1 } from './main.kt-abc.js'; import { _2 } from './main.kt-def.js'; 1_(); export { _2 }; // main.kt-abc.js import { _2 } from './main.js'; export var _1 = function setupSite() { const element = new _2(); document.body.append(element); } // main.kt-def.js export var _2 = class MyElement extends HTMLElement { /* ... */ };\n\nThis all looks awkward...and it is, but the output isn't really meant for\nhuman consumption, but we benefit from ESM's \"seen as a bug\" feature of\ncircular dependencies.\n\n^Kuto will in future reference between corpuses\n\n## Should I use this?\n\nMaybe!\n\nKuto is new, and while the science says it works, it's a bit weird. And as\nI've mentioned above, it works really well on:\n\n  * single bundle output sites\n  * that have a large JS bundle (maybe >1mb?)\n  * ...which are made up of lots of top-level ESM code, such as functions and classes\n\nYou will need to:\n\n  * use a regular bundler first\n  * keep or have access to your old build artifacts\u2014Kuto doesn't know what you already shipped by magic \ud83e\ude84\n  * trade off a slightly larger first load for a better update experience\n\nThe other issue with this is that more and more browsers are moving to a world\nwhere cache is regularly evicted. If your visitors don't have your site\ncached, then Kuto is pointless\u2014every load is slightly more expensive for an\nupdate that never happens. YMMV.\n\nRegardless, the tool emits a few statistics, including how much overhead the\ninitial load costing you, and what % of code is able to be identifed as having\n\"no side effects\" and put into a corpus. And to be clear, running Kuto on tiny\ncodebases has no benefit\u2014the 'cost' of parsing a few kb of JS is trivial, even\nfor potato phones. \ud83e\udd54\n\nSo you can experiment and see if it works for you. My view is that Kuto will\nhelp for enterprise apps (because the JS is bloated, and no-one really cares)\nor social media (because power users come so often).\n\n### Fragmentation\n\nKuto generates multiple files over time. Right now, it actually only uses the\ntop 4 (by size) previous bundles, although this is configurable by flag. This\nis...not very good, and I'm yet to come up with a good automatic metric as to\nwhen to 'clean up' vs 're-use'.\n\nConsider this though: if you just don't provide Kuto with historic bundles,\nit... obviously can't use them. So you can decide whether that typo fix\ngenerating a 100-byte file is worth it for the next build.\n\n## Why Only 28% Faster?\n\nIgnoring some of the possible downsides, there's a big question for me at\nplay. My test case above showed 71% reduction in size, but only 28% increase\nin speed. \ud83e\udd14\n\nI have a suspicion that v8's assembly of a bunch of module code is still quite\ncostly. Yes, it's great that huge chunks of static code can be outsourced and\ncached forever, but in the end, your website still needs to assemble it all\ntogether.\n\n## An Ask\n\nI would love to hear from you if Kuto makes a material difference to the way\nyou bundle and update your code, even in just a theoretical test environment.\nPlease feel free to contact me, including filing a GitHub issue, if you can\ngive me some sweet, sweet numbers.\n\n## Thanks\n\nThanks for reading! Kuto has been incredibly interesting to build, yet\nhonestly it's only taken me a few days of full-time engineering to make it\nwork. It's been an idea I've been noodling on for a few years, and I'm really\nproud to have it come to fruition. \ud83c\udf47\n\n", "frontpage": true}
