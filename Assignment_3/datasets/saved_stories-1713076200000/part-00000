{"aid": "40027565", "title": "Raw Linux Threads via System Calls (2015)", "url": "https://nullprogram.com/blog/2015/05/15/", "domain": "nullprogram.com", "votes": 3, "user": "iafisher", "posted_at": "2024-04-14 00:28:57", "comments": 0, "source_title": "Raw Linux Threads via System Calls", "source_text": "Raw Linux Threads via System Calls\n\n## Raw Linux Threads via System Calls\n\nMay 15, 2015\n\nnullprogram.com/blog/2015/05/15/\n\nThis article has been translated into Japanese. This article has been\ntranslated into Chinese.\n\nThis article has a followup.\n\nLinux has an elegant and beautiful design when it comes to threads: threads\nare nothing more than processes that share a virtual address space and file\ndescriptor table. Threads spawned by a process are additional child processes\nof the main \u201cthread\u2019s\u201d parent process. They\u2019re manipulated through the same\nprocess management system calls, eliminating the need for a separate set of\nthread-related system calls. It\u2019s elegant in the same way file descriptors are\nelegant.\n\nNormally on Unix-like systems, processes are created with fork(). The new\nprocess gets its own address space and file descriptor table that starts as a\ncopy of the original. (Linux uses copy-on-write to do this part efficiently.)\nHowever, this is too high level for creating threads, so Linux has a separate\nclone() system call. It works just like fork() except that it accepts a number\nof flags to adjust its behavior, primarily to share parts of the parent\u2019s\nexecution context with the child.\n\nIt\u2019s so simple that it takes less than 15 instructions to spawn a thread with\nits own stack, no libraries needed, and no need to call Pthreads! In this\narticle I\u2019ll demonstrate how to do this on x86-64. All of the code with be\nwritten in NASM syntax since, IMHO, it\u2019s by far the best (see: nasm-mode).\n\nI\u2019ve put the complete demo here if you want to see it all at once:\n\n  * Pure assembly, library-free Linux threading demo\n\n### An x86-64 Primer\n\nI want you to be able to follow along even if you aren\u2019t familiar with x86_64\nassembly, so here\u2019s a short primer of the relevant pieces. If you already know\nx86-64 assembly, feel free to skip to the next section.\n\nx86-64 has 16 64-bit general purpose registers, primarily used to manipulate\nintegers, including memory addresses. There are many more registers than this\nwith more specific purposes, but we won\u2019t need them for threading.\n\n  * rsp : stack pointer\n  * rbp : \u201cbase\u201d pointer (still used in debugging and profiling)\n  * rax rbx rcx rdx : general purpose (notice: a, b, c, d)\n  * rdi rsi : \u201cdestination\u201d and \u201csource\u201d, now meaningless names\n  * r8 r9 r10 r11 r12 r13 r14 r15 : added for x86-64\n\nThe \u201cr\u201d prefix indicates that they\u2019re 64-bit registers. It won\u2019t be relevant\nin this article, but the same name prefixed with \u201ce\u201d indicates the lower\n32-bits of these same registers, and no prefix indicates the lowest 16 bits.\nThis is because x86 was originally a 16-bit architecture, extended to 32-bits,\nthen to 64-bits. Historically each of of these registers had a specific,\nunique purpose, but on x86-64 they\u2019re almost completely interchangeable.\n\nThere\u2019s also a \u201crip\u201d instruction pointer register that conceptually walks\nalong the machine instructions as they\u2019re being executed, but, unlike the\nother registers, it can only be manipulated indirectly. Remember that data and\ncode live in the same address space, so rip is not much different than any\nother data pointer.\n\n#### The Stack\n\nThe rsp register points to the \u201ctop\u201d of the call stack. The stack keeps track\nof who called the current function, in addition to local variables and other\nfunction state (a stack frame). I put \u201ctop\u201d in quotes because the stack\nactually grows downward on x86 towards lower addresses, so the stack pointer\npoints to the lowest address on the stack. This piece of information is\ncritical when talking about threads, since we\u2019ll be allocating our own stacks.\n\nThe stack is also sometimes used to pass arguments to another function. This\nhappens much less frequently on x86-64, especially with the System V ABI used\nby Linux, where the first 6 arguments are passed via registers. The return\nvalue is passed back via rax. When calling another function function,\ninteger/pointer arguments are passed in these registers in this order:\n\n  * rdi, rsi, rdx, rcx, r8, r9\n\nSo, for example, to perform a function call like foo(1, 2, 3), store 1, 2 and\n3 in rdi, rsi, and rdx, then call the function. The mov instruction stores the\nsource (second) operand in its destination (first) operand. The call\ninstruction pushes the current value of rip onto the stack, then sets rip\n(jumps) to the address of the target function. When the callee is ready to\nreturn, it uses the ret instruction to pop the original rip value off the\nstack and back into rip, returning control to the caller.\n\n    \n    \n    mov rdi, 1 mov rsi, 2 mov rdx, 3 call foo\n\nCalled functions must preserve the contents of these registers (the same value\nmust be stored when the function returns):\n\n  * rbx, rsp, rbp, r12, r13, r14, r15\n\n#### System Calls\n\nWhen making a system call, the argument registers are slightly different.\nNotice rcx has been changed to r10.\n\n  * rdi, rsi, rdx, r10, r8, r9\n\nEach system call has an integer identifying it. This number is different on\neach platform, but, in Linux\u2019s case, it will never change. Instead of call,\nrax is set to the number of the desired system call and the syscall\ninstruction makes the request to the OS kernel. Prior to x86-64, this was done\nwith an old-fashioned interrupt. Because interrupts are slow, a special,\nstatically-positioned \u201cvsyscall\u201d page (now deprecated as a security hazard),\nlater vDSO, is provided to allow certain system calls to be made as function\ncalls. We\u2019ll only need the syscall instruction in this article.\n\nSo, for example, the write() system call has this C prototype.\n\n    \n    \n    ssize_t write(int fd, const void *buf, size_t count);\n\nOn x86-64, the write() system call is at the top of the system call table as\ncall 1 (read() is 0). Standard output is file descriptor 1 by default\n(standard input is 0). The following bit of code will write 10 bytes of data\nfrom the memory address buffer (a symbol defined elsewhere in the assembly\nprogram) to standard output. The number of bytes written, or -1 for error,\nwill be returned in rax.\n\n    \n    \n    mov rdi, 1 ; fd mov rsi, buffer mov rdx, 10 ; 10 bytes mov rax, 1 ; SYS_write syscall\n\n#### Effective Addresses\n\nThere\u2019s one last thing you need to know: registers often hold a memory address\n(i.e. a pointer), and you need a way to read the data behind that address. In\nNASM syntax, wrap the register in brackets (e.g. [rax]), which, if you\u2019re\nfamiliar with C, would be the same as dereferencing the pointer.\n\nThese bracket expressions, called an effective address, may be limited\nmathematical expressions to offset that base address entirely within a single\ninstruction. This expression can include another register (index), a power-of-\ntwo scalar (bit shift), and an immediate signed offset. For example, [rax +\nrdx*8 + 12]. If rax is a pointer to a struct, and rdx is an array index to an\nelement in array on that struct, only a single instruction is needed to read\nthat element. NASM is smart enough to allow the assembly programmer to break\nthis mold a little bit with more complex expressions, so long as it can reduce\nit to the [base + index*2^exp + offset] form.\n\nThe details of addressing aren\u2019t important this for this article, so don\u2019t\nworry too much about it if that didn\u2019t make sense.\n\n### Allocating a Stack\n\nThreads share everything except for registers, a stack, and thread-local\nstorage (TLS). The OS and underlying hardware will automatically ensure that\nregisters are per-thread. Since it\u2019s not essential, I won\u2019t cover thread-local\nstorage in this article. In practice, the stack is often used for thread-local\ndata anyway. The leaves the stack, and before we can span a new thread, we\nneed to allocate a stack, which is nothing more than a memory buffer.\n\nThe trivial way to do this would be to reserve some fixed .bss (zero-\ninitialized) storage for threads in the executable itself, but I want to do it\nthe Right Way and allocate the stack dynamically, just as Pthreads, or any\nother threading library, would. Otherwise the application would be limited to\na compile-time fixed number of threads.\n\nYou can\u2019t just read from and write to arbitrary addresses in virtual memory,\nyou first have to ask the kernel to allocate pages. There are two system calls\nthis on Linux to do this:\n\n  * brk(): Extends (or shrinks) the heap of a running process, typically located somewhere shortly after the .bss segment. Many allocators will do this for small or initial allocations. This is a less optimal choice for thread stacks because the stacks will be very near other important data, near other stacks, and lack a guard page (by default). It would be somewhat easier for an attacker to exploit a buffer overflow. A guard page is a locked-down page just past the absolute end of the stack that will trigger a segmentation fault on a stack overflow, rather than allow a stack overflow to trash other memory undetected. A guard page could still be created manually with mprotect(). Also, there\u2019s also no room for these stacks to grow.\n\n  * mmap(): Use an anonymous mapping to allocate a contiguous set of pages at some randomized memory location. As we\u2019ll see, you can even tell the kernel specifically that you\u2019re going to use this memory as a stack. Also, this is simpler than using brk() anyway.\n\nOn x86-64, mmap() is system call 9. I\u2019ll define a function to allocate a stack\nwith this C prototype.\n\n    \n    \n    void *stack_create(void);\n\nThe mmap() system call takes 6 arguments, but when creating an anonymous\nmemory map the last two arguments are ignored. For our purposes, it looks like\nthis C prototype.\n\n    \n    \n    void *mmap(void *addr, size_t length, int prot, int flags);\n\nFor flags, we\u2019ll choose a private, anonymous mapping that, being a stack,\ngrows downward. Even with that last flag, the system call will still return\nthe bottom address of the mapping, which will be important to remember later.\nIt\u2019s just a simple matter of setting the arguments in the registers and making\nthe system call.\n\n    \n    \n    %define SYS_mmap 9 %define STACK_SIZE (4096 * 1024) ; 4 MB stack_create: mov rdi, 0 mov rsi, STACK_SIZE mov rdx, PROT_WRITE | PROT_READ mov r10, MAP_ANONYMOUS | MAP_PRIVATE | MAP_GROWSDOWN mov rax, SYS_mmap syscall ret\n\nNow we can allocate new stacks (or stack-sized buffers) as needed.\n\n### Spawning a Thread\n\nSpawning a thread is so simple that it doesn\u2019t even require a branch\ninstruction! It\u2019s a call to clone() with two arguments: clone flags and a\npointer to the new thread\u2019s stack. It\u2019s important to note that, as in many\ncases, the glibc wrapper function has the arguments in a different order than\nthe system call. With the set of flags we\u2019re using, it takes two arguments.\n\n    \n    \n    long sys_clone(unsigned long flags, void *child_stack);\n\nOur thread spawning function will have this C prototype. It takes a function\nas its argument and starts the thread running that function.\n\n    \n    \n    long thread_create(void (*)(void));\n\nThe function pointer argument is passed via rdi, per the ABI. Store this for\nsafekeeping on the stack (push) in preparation for calling stack_create().\nWhen it returns, the address of the low end of stack will be in rax.\n\n    \n    \n    thread_create: push rdi call stack_create lea rsi, [rax + STACK_SIZE - 8] pop qword [rsi] mov rdi, CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | \\ CLONE_PARENT | CLONE_THREAD | CLONE_IO mov rax, SYS_clone syscall ret\n\nThe second argument to clone() is a pointer to the high address of the stack\n(specifically, just above the stack). So we need to add STACK_SIZE to rax to\nget the high end. This is done with the lea instruction: load effective\naddress. Despite the brackets, it doesn\u2019t actually read memory at that\naddress, but instead stores the address in the destination register (rsi).\nI\u2019ve moved it back by 8 bytes because I\u2019m going to place the thread function\npointer at the \u201ctop\u201d of the new stack in the next instruction. You\u2019ll see why\nin a moment.\n\nRemember that the function pointer was pushed onto the stack for safekeeping.\nThis is popped off the current stack and written to that reserved space on the\nnew stack.\n\nAs you can see, it takes a lot of flags to create a thread with clone(). Most\nthings aren\u2019t shared with the callee by default, so lots of options need to be\nenabled. See the clone(2) man page for full details on these flags.\n\n  * CLONE_THREAD: Put the new process in the same thread group.\n  * CLONE_VM: Runs in the same virtual memory space.\n  * CLONE_PARENT: Share a parent with the callee.\n  * CLONE_SIGHAND: Share signal handlers.\n  * CLONE_FS, CLONE_FILES, CLONE_IO: Share filesystem information.\n\nA new thread will be created and the syscall will return in each of the two\nthreads at the same instruction, exactly like fork(). All registers will be\nidentical between the threads, except for rax, which will be 0 in the new\nthread, and rsp which has the same value as rsi in the new thread (the pointer\nto the new stack).\n\nNow here\u2019s the really cool part, and the reason branching isn\u2019t needed.\nThere\u2019s no reason to check rax to determine if we are the original thread (in\nwhich case we return to the caller) or if we\u2019re the new thread (in which case\nwe jump to the thread function). Remember how we seeded the new stack with the\nthread function? When the new thread returns (ret), it will jump to the thread\nfunction with a completely empty stack. The original thread, using the\noriginal stack, will return to the caller.\n\nThe value returned by thread_create() is the process ID of the new thread,\nwhich is essentially the thread object (e.g. Pthread\u2019s pthread_t).\n\n### Cleaning Up\n\nThe thread function has to be careful not to return (ret) since there\u2019s\nnowhere to return. It will fall off the stack and terminate the program with a\nsegmentation fault. Remember that threads are just processes? It must use the\nexit() syscall to terminate. This won\u2019t terminate the other threads.\n\n    \n    \n    %define SYS_exit 60 exit: mov rax, SYS_exit syscall\n\nBefore exiting, it should free its stack with the munmap() system call, so\nthat no resources are leaked by the terminated thread. The equivalent of\npthread_join() by the main parent would be to use the wait4() system call on\nthe thread process.\n\n### More Exploration\n\nIf you found this interesting, be sure to check out the full demo link at the\ntop of this article. Now with the ability to spawn threads, it\u2019s a great\nopportunity to explore and experiment with x86\u2019s synchronization primitives,\nsuch as the lock instruction prefix, xadd, and compare-and-exchange (cmpxchg).\nI\u2019ll discuss these in a future article.\n\n  * x86\n  * linux\n  * c\n  * tutorial\n\nHave a comment on this article? Start a discussion in my public inbox by\nsending an email to ~skeeto/public-inbox@lists.sr.ht [mailing list etiquette]\n, or see existing discussions.\n\nThis post has archived comments.\n\n# null program\n\n## Chris Wellons\n\nwellons@nullprogram.com (PGP)\n\n~skeeto/public-inbox@lists.sr.ht (view)\n\nAll information on this blog, unless otherwise noted, is hereby released into\nthe public domain, with no rights reserved.\n\n", "frontpage": false}
