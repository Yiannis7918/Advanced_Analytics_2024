{"aid": "40088103", "title": "Azure Cosmos DB design patterns \u2013 Part 9: Schema versioning", "url": "https://devblogs.microsoft.com/cosmosdb/azure-cosmos-db-design-patterns-part-9-schema-versioning/", "domain": "microsoft.com", "votes": 1, "user": "jaydestro", "posted_at": "2024-04-19 15:33:28", "comments": 0, "source_title": "Azure Cosmos DB design patterns \u2013 Part 9: Schema versioning", "source_text": "Azure Cosmos DB design patterns \u2013 Part 9: Schema versioning - Azure Cosmos DB\nBlog\n\nSkip to main content\n\nMicrosoft\n\nCosmosdb\n\nCosmosdb\n\n  * Light\n  * Dark\n\nLogin\n\n# Azure Cosmos DB design patterns \u2013 Part 9: Schema versioning\n\nJay Gordon\n\nApril 19th, 20240 0\n\nWelcome to Part 9 of our Azure Cosmos DB Design Patterns series, focusing on\nSchema Versioning. This edition is particularly useful for those new to NoSQL\ndatabases or looking to understand Azure Cosmos DB\u2019s unique capabilities.\nHere, we will explore how schema versioning can help manage and evolve your\ndatabase schema efficiently, drawing on real-world applications and specific\npatterns. By the end of this post, you\u2019ll have a clear roadmap for\nimplementing schema versioning in your projects, ensuring your database keeps\npace with application development without downtime or data corruption.\n\nWe have expanded the reach of our Azure Cosmos DB Design Patterns, once shared\nonly on a case-by-case basis, by launching a dedicated GitHub repository. This\nrepository highlights a variety of examples that demonstrate the\nimplementation of specific design patterns, tailored to help you tackle design\nchallenges in Azure Cosmos DB projects. Each entry in our blog series delves\ninto one pattern, complete with a sample application featured in the\nrepository. Our goal is to make these powerful insights more accessible,\nhelping you enhance your projects efficiently. Enjoy exploring these patterns,\nand we hope you find the series both informative and useful.\n\nHere is a list of the previous posts in this series:\n\n  * Part 1: Attribute Array\n  * Part 2: Data Binning\n  * Part 3: Distributed counter\n  * Part 4: Global distributed lock\n  * Part 5: Document versioning\n  * Part 6: Event sourcing\n  * Part 7: Materialized views\n  * Part 8: Preallocation\n\n# Azure Cosmos DB design pattern: Schema versioning\n\n### What is Schema Versioning?\n\nSchema versioning is the process of tracking changes in the database schema\nover time. In the context of NoSQL databases like Azure Cosmos DB, schema\nversioning involves adding a field, typically named SchemaVersion, to each\ndocument. This field indicates the version of the schema that the document\nconforms to. If a document lacks this field, it is treated as conforming to\nthe original schema version.\n\nSchema versioning helps in:\n\n  * Minimizing Disruptions: Changes can be made incrementally without affecting existing operations.\n  * Preserving Data Integrity: Ensures that data conforms to expected schema definitions, preventing errors and inconsistencies.\n  * Facilitating Evolution: Allows the database to evolve alongside application changes smoothly.\n\n## Implementing Schema Versioning in Azure Cosmos DB\n\n### Step 1: Define Your Versioning Strategy\n\nBefore implementing schema versioning, decide on the versioning format and how\ngranular the versions need to be. A simple numerical increment (1, 2, 3...) or\nsemantic versioning (1.0, 1.1, 2.0...) could be used depending on the\ncomplexity of the changes.\n\n### Step 2: Modify Your Application Logic\n\nUpdate your application logic to include the SchemaVersion field in each new\ndocument written to Cosmos DB. Ensure that every write operation either\nspecifies the current schema version or relies on default values defined in\nyour database model.\n\n    \n    \n    var document = new { id = \"unique-id\", SchemaVersion = \"1.0\", data = // your data here }; await container.CreateItemAsync(document);\n\n### Step 3: Handling Data Reads\n\nWhen reading data, your application should check the SchemaVersion of each\ndocument and process it accordingly. Implement logic to handle documents\naccording to their schema version or convert them to the latest version format\nas needed.\n\n    \n    \n    if (document.SchemaVersion == \"1.0\") { // Handle version 1.0 specific logic } else if (document.SchemaVersion == \"2.0\") { // Handle version 2.0 specific logic }\n\n### Step 4: Data Migration\n\nFor documents that are in older versions, you might need to perform migrations\nto update them to the latest schema. This can be done lazily (on access) or as\na batch process, depending on your application needs and the volume of data.\n\n    \n    \n    // Example of a lazy migration approach if (document.SchemaVersion == \"1.0\") { document = MigrateToVersion2(document); document.SchemaVersion = \"2.0\"; await container.UpsertItemAsync(document); } private static dynamic MigrateToVersion2(dynamic doc) { // Migration logic here return doc; }\n\nThese C# examples demonstrate how to manage schema versioning within an Azure\nCosmos DB application using the .NET SDK. Be sure to replace placeholders and\ntypes as appropriate for your specific application context.\n\n## The Scenario:\n\nAs organizations grow and adapt, so do their data structures. In this section,\nwe will discuss how schema versioning plays a crucial role in managing these\nchanges efficiently, particularly using Azure Cosmos DB.\n\n### The Need for Schema Versioning\n\nConsider a data-intensive application that must evolve to include more\ndetailed user data, transaction histories, and interaction logs. As new\nfeatures are introduced, the document schema in the database must be updated\nto reflect these new data types and relationships.\n\n### Implementing Schema Versioning\n\nWith Azure Cosmos DB, implementing schema versioning involves adding a\nSchemaVersion field to each document, which denotes the version of the schema\nit adheres to. This approach allows applications to handle documents\ndifferently based on their version, facilitating a smooth transition as\nschemas evolve.\n\n### Structuring Schema Changes\n\n  1. Initial Schema (Version 1.0):\n\n     * Contains essential fields such as userID, transactionDate, amount.\n  2. Revised Schema (Version 2.0):\n\n     * Adds new fields like transactionHistory, userInteractionLogs.\n     * Modifications to userID to support new authentication methods.\n\nEach schema change is well-documented, and the transition between them is\nmanaged through version checks in the application logic.\n\n### Documentation and Release Notes\n\nFor every schema update, detailed release notes are maintained. These notes\ntypically include:\n\n  * Changes Made: Description of new fields added or modified.\n  * Rationale: Reasons behind these changes, such as accommodating new features or improving performance.\n  * Impact Analysis: How the changes affect existing operations and data, and any necessary actions to adapt to the new schema.\n\n### Sample Release Note Entry\n\n    \n    \n    ## Version 2.0 Release Notes - March 20XX ### Changes Made: - New fields: `transactionHistory`, `userInteractionLogs` added. - Updated `userID` to support multiple authentication types. ### Rationale: - To provide a more comprehensive view of user activities and enhance security measures. ### Impact: - Documents created with the new schema will utilize these fields. Older documents remain compatible but will operate under Version 1.0.\n\n## Sample Implementation:\n\n### Case Study:\n\nWide World Importers operates an online store with its data stored in Azure\nCosmos DB for NoSQL. Initially, their cart object was structured simply to\naccommodate straightforward product orders. Below is an example of the initial\nCart and CartItem class definitions and how they were represented in Azure\nCosmos DB:\n\nInitial Cart Class:\n\n    \n    \n    public class Cart { [JsonProperty(\"id\")] public string Id { get; set; } = Guid.NewGuid().ToString(); public string SessionId { get; set; } = Guid.NewGuid().ToString(); public int CustomerId { get; set; } public List<CartItem>? Items { get; set;} } public class CartItem { public string ProductName { get; set; } = \"\"; public int Quantity { get; set; } }\n\nCorresponding JSON Document in Azure Cosmos DB:\n\n    \n    \n    { \"id\": \"194d7453-d9db-496b-834b-7b2db408e4be\", \"SessionId\": \"98f5621e-b1af-44f1-815c-f4aac728c4d4\", \"CustomerId\": 741, \"Items\": [ {\"ProductName\": \"Product 23\", \"Quantity\": 4}, {\"ProductName\": \"Product 16\", \"Quantity\": 3} ] }\n\n#### Updating the Schema\n\nFeedback indicated a need to track special order details for products. To\navoid updating all cart items unnecessarily, a SchemaVersion field was added\nto the cart object to manage changes efficiently.\n\nUpdated CartWithVersion Class:\n\n    \n    \n    public class CartWithVersion { [JsonProperty(\"id\")] public string Id { get; set; } = Guid.NewGuid().ToString(); public string SessionId { get; set; } = Guid.NewGuid().ToString(); public long CustomerId { get; set; } public List<CartItemWithSpecialOrder>? Items { get; set;} public int SchemaVersion = 2; } public class CartItemWithSpecialOrder : CartItem { public bool IsSpecialOrder { get; set; } = false; public string? SpecialOrderNotes { get; set; } }\n\nUpdated JSON Document in Cosmos DB:\n\n    \n    \n    { \"SchemaVersion\": 2, \"id\": \"9baf08d2-e119-46a1-92d7-d94ee59d7270\", \"SessionId\": \"39306d1b-d8d8-424a-aa8b-800df123cb3c\", \"CustomerId\": 827, \"Items\": [ { \"ProductName\": \"Product 4\", \"Quantity\": 2, \"IsSpecialOrder\": false, \"SpecialOrderNotes\": null }, { \"ProductName\": \"Product 22\", \"Quantity\": 2, \"IsSpecialOrder\": true, \"SpecialOrderNotes\": \"Special Order Details for Product 22\" }, { \"ProductName\": \"Product 15\", \"Quantity\": 3, \"IsSpecialOrder\": true, \"SpecialOrderNotes\": \"Special Order Details for Product 15\" } ] }\n\n#### Managing Schema Versions\n\nIt is beneficial to document schema updates comprehensively. Here is a\nhypothetical schema.md document to track these changes:\n\nFilename: schema.md\n\n    \n    \n    ## Schema Updates: | Version | Notes | |---------|-----------------------------------------------| | 2 | Added special order details to cart items | | 1 | Original release |\n\n#### Implementing in the Application\n\nOn the application side, handling the schema version allows developers to\nrender UI components conditionally based on whether the cart includes special\norders:\n\nSnippet from the Application Code:\n\n    \n    \n    public class Cart { [JsonProperty(\"id\")] public string Id { get; set; } = Guid.NewGuid().ToString(); public string SessionId { get; set; } = Guid.NewGuid().ToString(); public long CustomerId { get; set; } public List<CartItemWithSpecialOrder>? Items { get; set;} public int? SchemaVersion { get; set; } public bool HasSpecialOrders() { return this.Items.Any(x => x.IsSpecialOrder); } }\n\nRendering Conditional UI Based on Schema Version:\n\n    \n    \n    @foreach (Cart cart in Model.Carts){ <section data-id=\"@cart.Id\"> <p><strong>Customer: </strong>@cart.CustomerId</p> <table> <thead> <tr> @if(cart.SchemaVersion != null){ <th>Schema Version</th> } <th>Product Name</th> <th>Quantity</th> @if (cart.HasSpecialOrders()){ <th>Special Order Notes</th> } </tr> </thead> <tbody> @foreach (var item in cart.Items) { <tr> @if(cart.SchemaVersion != null){ <td>@cart.SchemaVersion</td> } <td>@item.ProductName</td> <td>@item.Quantity</td> @if (cart.HasSpecialOrders() && item.IsSpecialOrder){ <td>@item.SpecialOrderNotes</td> } else { <td></td> } </tr> } </tbody> </table> </section> }\n\nBy adopting a schema versioning pattern is essential for effectively managing\ndatabase schema changes. By embedding a SchemaVersion field within each\ndocument, applications can support multiple schema versions seamlessly,\nensuring smooth transitions and minimizing disruptions during schema\nevolution. This approach not only maintains backward compatibility and\nsimplifies maintenance but also enhances data integrity and facilitates easier\ndebugging. Implementing structured versioning rules, maintaining detailed\ndocumentation for each schema iteration, and adapting application logic to\naccommodate these changes are crucial strategies for achieving robust and\nscalable database architecture.\n\n## Getting Started with Azure Cosmos DB Design Patterns\n\nYou can review the sample code by visiting the Schema validation design\npattern on GitHub. You can also try this out for yourself by visiting the\nAzure Cosmos DB Design Patterns GitHub repo and cloning or forking it. Then\nrun locally or from Codespaces in GitHub. If you are new to Azure Cosmos DB,\nwe have you covered with a free Azure Cosmos DB account for 30 days, no credit\ncard needed. If you want more time, you can extend the free period. You can\neven upgrade too.\n\nSign up for your free Azure Cosmos DB account at aka.ms/trycosmosdb.\n\nExplore this and the other design patterns and see how Azure Cosmos DB can\nenhance your application development and data modeling efforts. Whether you\nare an experienced developer or just getting started, the free trial allows\nyou to discover the benefits firsthand.\n\nTo get started with Azure Cosmos DB Design Patterns, follow these steps:\n\n  1. Visit the GitHub repository and explore the various design patterns and best practices provided.\n  2. Clone or download the repository to access the sample code and documentation.\n  3. Review the README files and documentation for each design pattern to understand when and how to apply them to your Azure Cosmos DB projects.\n  4. Experiment with the sample code and adapt it to your specific use cases.\n\n### About Azure Cosmos DB\n\nAzure Cosmos DB is a fully managed and serverless distributed database for\nmodern app development, with SLA-backed speed and availability, automatic and\ninstant scalability, and support for open-source PostgreSQL, MongoDB, and\nApache Cassandra. Try Azure Cosmos DB for free here. To stay in the loop on\nAzure Cosmos DB updates, follow us on X, YouTube, and LinkedIn.\n\n### Jay Gordon Senior Program Manager, Azure Cosmos DB\n\nFollow\n\nPosted in Azure Cosmos DB for NoSQLTagged Azure Cosmos DB Azure Cosmos DB Best\nPractices Design Patterns\n\n### Read next\n\nReduce TCO with Azure Cosmos DB for MongoDB\n\nAzure Cosmos DB for MongoDB is a fully managed MongoDB compatible cloud\ndatabase service. Built on top of a proprietary engine to provide scale,\nperformance and ...\n\nAbinav Rameesh April 12, 2024\n\n0 comment\n\nOptimize Your Azure Cosmos DB Costs with New Reserved Capacity Tiers\n\nCommit to a reservation for Azure Cosmos DB resources using Azure Cosmos DB\nreserved capacity to save money. Starting with our new 100 RU/s option, any\ncustomer can ...\n\nRodrigo Souza April 11, 2024\n\n0 comment\n\n## 0 comments\n\n### Leave a commentCancel reply\n\nLog in to start the discussion.\n\n##### Code Block\n\nFeedback\n\nYour Privacy Choices Consumer Health Privacy\n\nNotifications\n\n", "frontpage": false}
