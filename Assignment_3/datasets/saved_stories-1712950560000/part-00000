{"aid": "40012627", "title": "Xargs is the inverse function of echo", "url": "https://dhashe.com/xargs-is-the-inverse-function-of-echo.html", "domain": "dhashe.com", "votes": 2, "user": "dhashe", "posted_at": "2024-04-12 13:34:18", "comments": 0, "source_title": "xargs is the inverse function of echo", "source_text": "xargs is the inverse function of echo\n\n# David Hashe | Personal website and blog\n\n# xargs is the inverse function of echo\n\nPublished: Fri 12 April 2024 By David Hashe\n\nIn Blog.\n\nxargs is a particularly confusing unix command. I want to share my trick for\nunderstanding how it works.\n\nLet's look at the abbreviated tldr output for xargs:\n\n    \n    \n    $ tldr xargs xargs - Run a command using the input data as arguments: {{arguments_source}} | xargs {{command}}\n\nSo, for example, if you had a file named files_to_delete with the contents\nbelow:\n\n    \n    \n    obsolete_note.md yucky_recipe.pdf cringe_tiktok.mov\n\nThen you could run the following line to delete each of the files ^1:\n\n    \n    \n    $ cat files_to_delete | xargs rm\n\nWhich reduces to the following command:\n\n    \n    \n    $ rm obsolete_note.md yucky_recipe.pdf cringe_tiktok.mov\n\nThis is a general pattern that shows up in a lot of contexts when writing\nshell pipelines. And as you might expect, this is because xargs implements a\nnecessary and fundamental operation in shell scripting: converting input data\nfrom stdin to cmdline args.\n\nFor context, there are two separate and equally important ways to pass input\nto a unix program: stdin and cmdline args ^2. Sometimes, a program's cmdline\nargs determine what it expects on stdin. And in general, programs can have\nquite complex behavior with respect to their input. But the basic differences\nbetween the two input sources are:\n\n  * stdin is an infinite text stream for ongoing input\n  * cmdline args is a fixed text array of start-of-program input\n\nHere's a generic example of how to pass input to a command within a pipeline\n^3:\n\n    \n    \n    $ echo $STDIN_DATA | $CMD $ARGS_DATA # $CMD may need to be given input via $STDIN_DATA and/or $ARGS_DATA\n\nFor most programs, it is obvious what the cmdline args are, because they are\nwritten out in the pipeline. The tricky part of xargs is that it dynamically\nconstructs the cmdline args for the program it calls based on its own stdin.\n\nIn our earlier example, xargs dynamically constructed the call rm obsolete_note.md yucky_recipe.pdf cringe_tiktok.mov based on its stdin. We couldn't tell what the arguments to rm would be based on the original pipeline text cat files_to_delete | xargs rm.\n\nInterestingly, the echo command implements exactly the opposite operation to\nxargs in shell scripting: converting input data from cmdline args to stdin:\n\n    \n    \n    $ tldr echo echo - Print a text message. Note: quotes are optional: echo \"{{Hello World}}\"\n\nBoth xargs and echo show up frequently in shell pipelines. I think that echo\nis less confusing because the mental model of shell pipelines is of self-\ncontained commands passing their output forward to the next command, and echo\nis just a command that directly generates output from cmdline args. For\nexample:\n\n    \n    \n    $ echo $ARGS | command_plus_args | command_plus_args # echo naturally fits into the pipeline mental model as a source of data over stdin $ command_plus_args | xargs $CMD | command_plus_args # xargs does something weird and unexpected by dynamically constructing a command in the middle of the pipeline\n\nSee how xargs breaks the mental model by constructing a command dynamically at\nruntime based on the previous link in the chain, which is counter-intuitive.\n\nBut this is also why xargs is so powerful. Shell pipelines only pass data\nthrough stdin/stdout, but many unix programs require input via cmdline args,\nand xargs makes it possible to use those programs within a pipeline.\n\nAnd so now we can state the trick for understanding xargs, which was also the\ntitle of this post: xargs is the inverse function of echo.\n\n  * echo is a function that maps cmdline args to stdin\n  * xargs is a function that maps stdin to cmdline args\n  * xargs echo is an identity function because echo $DATA | xargs echo | $CMD is equivalent to echo $DATA | $CMD\n  * echo $DATA | xargs $CMD is another identity function because it is equivalent to $CMD $DATA\n\nIn fact, without any arguments, xargs defaults to behaving like xargs echo\nbecause defaulting to an identity function is a sensible thing to do.\n\nSo, in order to remember what xargs does, just think about what echo does, and\nremember that xargs performs the inverse.\n\nThank you to Eliot Robson for providing feedback on drafts of this post. All\nmistakes are my own.\n\n  1. I am aware that this is a useless use of cat. \u21a9\n\n  2. There is also the environment, but it is uncommon to explicitly use that in shell pipelines. \u21a9\n\n  3. Note that $STDIN_DATA is the cmdline args for echo but the stdin for $CMD. Also note that we could have replaced echo with a heredoc. \u21a9\n\n## social\n\n  * atom feed\n  * github\n  * linkedin\n\nProudly powered by Pelican, which takes great advantage of Python.\n\nThe theme is by Smashing Magazine, thanks!\n\n", "frontpage": false}
