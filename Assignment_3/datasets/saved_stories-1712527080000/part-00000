{"aid": "39961577", "title": "A case in API ergonomics for ordered containers", "url": "http://bannalia.blogspot.com/2024/04/a-case-in-api-ergonomics-for-ordered.html", "domain": "bannalia.blogspot.com", "votes": 1, "user": "ibobev", "posted_at": "2024-04-07 15:56:28", "comments": 0, "source_title": "A case in API ergonomics for ordered containers", "source_text": "Bannalia: trivial notes on themes diverse: A case in API ergonomics for\nordered containers\n\n# Bannalia: trivial notes on themes diverse\n\n## Thursday, April 4, 2024\n\n### A case in API ergonomics for ordered containers\n\nSuppose we have a std::set<int> and would like to retrieve the elements\nbetween values a and b, both inclusive. This task is served by operations\nstd::set::lower_bound and std::set::upper_bound:\n\n    \n    \n    std::set<int> x=...;\n    \n    // elements in [a,b] auto first = x.lower_bound(a); auto last = x.upper_bound(b);\n    \n    while(first != last) std::cout<< *first++ <<\" \";\n\nWhy do we use lower_bound for the first iterator and upper_bound for the\nsecond? The well-known STL convention is that a range of elements is\ndetermined by two iterators first and last, where first points to the first\nelement of the range and last points to the position right after the last\nelement. This is done so that empty ranges can be handled without special\nprovisions (first == last).\n\nNow, with this convention in mind and considering that\n\n  * lower_bound(a) returns an iterator to the first element not less than a,\n  * upper_bound(b) returns an iterator to the first element greater than b,\n\nwe can convince ourselves that the code above is indeed correct. The\nsituations where one or both of the interval endpoints are not inclusive can\nalso be handled:\n\n    \n    \n    // elements in [a,b) auto first = x.lower_bound(a); auto last = x.lower_bound(b); // elements in (a,b] auto first = x.upper_bound(a); auto last = x.upper_bound(b); // elements in (a,b) auto first = x.upper_bound(a); auto last = x.lower_bound(b);\n\nbut getting them right requires some thinking.\n\nBoost.MultiIndex introduces the operation range to handle this type of\nqueries:\n\n    \n    \n    template<typename LowerBounder,typename UpperBounder> std::pair<iterator,iterator> range(LowerBounder lower, UpperBounder upper);\n\nlower and upper are user-provided predicates that determine whether an element\nis not to the left and not to the right of the considered interval,\nrespectively. The formal specification of LowerBounder and UpperBounder is\nquite impenetrable, but using this facility, in particular in combination with\nBoost.Lambda2, is actually straightforward:\n\n    \n    \n    // equivalent to std::set<int> boost::multi_index_container<int> x=...;\n    \n    using namespace boost::lambda2;\n    \n    // [a,b] auto [first, last] = x.range(_1 >= a, _1 <= b); // [a,b) auto [first, last] = x.range(_1 >= a, _1 < b); // (a,b] auto [first, last] = x.range(_1 > a, _1 <= b); // (a,b) auto [first, last] = x.range(_1 > a, _1 < b);\n\nThe resulting code is much easier to read and to get right in the first place,\nand is also more efficient than two separate calls to [lower|upper]_bound\n(because the two internal rb-tree top-to-bottom traversals can be partially\njoined in the implementation of range). Just as importantly, range handles\nsituations such as this:\n\n    \n    \n    int a = 5; int b = 2; // note a > b\n    \n    // elements in [a,b] auto first = x.lower_bound(a); auto last = x.upper_bound(b);\n    \n    // undefined behavior while(first != last) std::cout<< *first++ <<\" \";\n\nWhen a > b, first may be strictly to the right of last, and consequently the\nwhile loop will crash or never terminate. range, on the other hand, handles\nthe situation gracefully and returns an empty range.\n\nWe have seen an example of how API design can help reduce programming errors\nand increase efficiency by providing higher-level facilities that model and\nencapsulate scenarios otherwise served by a combination of lower-level\noperations. It may be interesting to have range-like operations introduced for\nstandard associative containers.\n\nPosted by\n\nJoaqu\u00edn M L\u00f3pez Mu\u00f1oz at\n\n1:16 PM\n\n#### No comments :\n\n#### Post a Comment\n\nOlder Post Home\n\nSubscribe to: Post Comments ( Atom )\n\n## About Me\n\nJoaqu\u00edn M L\u00f3pez Mu\u00f1oz\n\nView my complete profile\n\n## Blog Archive\n\n  * 2024 ( 1 )\n\n    * April ( 1 )\n\n      * A case in API ergonomics for ordered containers\n\n  * 2023 ( 3 )\n\n    * October ( 1 )\n    * August ( 1 )\n    * July ( 1 )\n\n  * 2022 ( 5 )\n\n    * November ( 1 )\n    * October ( 1 )\n    * June ( 1 )\n    * March ( 1 )\n    * January ( 1 )\n\n  * 2016 ( 6 )\n\n    * September ( 2 )\n    * July ( 1 )\n    * February ( 1 )\n    * January ( 2 )\n\n  * 2015 ( 11 )\n\n    * December ( 1 )\n    * November ( 1 )\n    * September ( 1 )\n    * August ( 1 )\n    * July ( 1 )\n    * June ( 4 )\n    * May ( 1 )\n    * January ( 1 )\n\n  * 2014 ( 15 )\n\n    * May ( 4 )\n    * April ( 3 )\n    * March ( 4 )\n    * January ( 4 )\n\n  * 2013 ( 10 )\n\n    * December ( 2 )\n    * November ( 4 )\n    * October ( 4 )\n\n  * 2009 ( 4 )\n\n    * June ( 1 )\n    * March ( 3 )\n\n  * 2008 ( 77 )\n\n    * November ( 7 )\n    * October ( 8 )\n    * September ( 8 )\n    * August ( 2 )\n    * July ( 8 )\n    * June ( 8 )\n    * May ( 7 )\n    * April ( 7 )\n    * March ( 7 )\n    * February ( 7 )\n    * January ( 8 )\n\n  * 2007 ( 21 )\n\n    * December ( 7 )\n    * November ( 8 )\n    * October ( 6 )\n\n## Subscribe via email\n\n## Subscribe\n\nSubscribe to Bannalia\n\nTheme images by merrymoonmary. Powered by Blogger.\n\nDiese Website verwendet Cookies von Google, um Dienste anzubieten und Zugriffe\nzu analysieren. Deine IP-Adresse und dein User-Agent werden zusammen mit\nMesswerten zur Leistung und Sicherheit f\u00fcr Google freigegeben. So k\u00f6nnen\nNutzungsstatistiken generiert, Missbrauchsf\u00e4lle erkannt und behoben und die\nQualit\u00e4t des Dienstes gew\u00e4hrleistet werden.Weitere InformationenOk\n\n", "frontpage": false}
