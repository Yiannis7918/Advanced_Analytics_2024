{"aid": "40026892", "title": "My useless philosophical ramblings about the ecology of PLs(and OOP is not Java)", "url": "https://angeloceccato.com/post/philosophical-ramblings-about-ecology-programming-languages-and-OOP-not-java/", "domain": "angeloceccato.com", "votes": 1, "user": "angelochecked", "posted_at": "2024-04-13 22:48:24", "comments": 0, "source_title": "My useless philosophical ramblings about the ecology of programming languages (and OOP is not Java)", "source_text": "My useless philosophical ramblings about the ecology of programming languages\n(and OOP is not Java)\n\n# My useless philosophical ramblings about the ecology of programming\nlanguages (and OOP is not Java)\n\n## Premise\n\nI wanted to write this post to share, formalize, and expel my hopeless brain\nreveries about programming languages. Sometimes, as a hobby, I explore\nprogramming languages of different natures, and by doing this, I started to\nhave an ethereal vision of what programming languages are.\n\nKeep in mind that I'm not an academic. My approach is pretty raw. I like to\nback up my points with sources, but I can't promise 100% accuracy. Still, I\nhope to convey the overall picture I have in mind.\n\nI firmly believe that getting feedback from others is crucial for refining our\nideas.\n\nI'm not 100% sure about this vision yet. I've put together my thoughts,\nspeculations, criticisms, controversial ideas, and perhaps not enough informed\nmusings to try and make sense of them. I've compiled them here in what I hope\nis a coherent manner.\n\nSo, you don't expect to leave here satisfied, because I don't either.\n\n## Fanciful comparison of programming languages with life, the universe, and\neverything: anthropology, sociology, economics, biology, ecology... music.\n\nWhen I start thinking about \"the evolution of programming languages,\" my mind\nsails, travels, surpasses the sky, and crosses space... then a planet appears,\na planet of strange creatures...\n\nThis topic sparks my imagination. I ponder the vague similarities between PLs,\necology, food chain, and natural selection.\n\nBut PLs are fundamentally human constructs; I've always considered them\ninfluenced by the same social dynamics as other human creations. Therefore,\nthe animal analogy may not be entirely fitting.\n\nI don't want to write the Brief, Incomplete, and Mostly Wrong History of\nProgramming Languages again.\n\nThe vision I'm trying to share here became more concrete when I saw a\ndelightful analogy to the music together with the programming languages\nhistory.\n\nPLs, like natural languages, are the people who speak them. And they influence\ntheir evolution. They are communities, cultures, and collective knowledge\ntransferred from user to user, depending on the use cases and problems the\nlanguage aims to solve.\n\nI also argue that the concepts of software construction evolved similarly,\noften in conjunction with the PL utilized. I believe that a form of Cargo Cult\nrevolves around PLs and paradigms. People can have ideas and strong opinions\nbased on their experiences in jobs, school, hobbies, literature consumed,\npeople encountered, good or bad situations that happened, and emotions\ninvolved in doing something. Intriguing visions are the three tribes of\nprogramming and JavaScript tribalism.\n\nIn essence, I think the users' beliefs found the evolution of PLs. So, today,\nthe programming languages we use reflect the beliefs of past users and\ncreators, shaping our software concepts. At this juncture, solving a\nparticular use case forces us to use a specific PL, which can sometimes lead\nus into what resembles an echo chamber.\n\nWhy did you start playing a particular instrument?\n\nWhich bands do you follow?\n\nWhat is your favorite song genre? And why?\n\nIf you're seeking a more profound insight into the evolution of programming\nlanguages, you might find the following resources useful:\n\n  * The Evolutionary Ecology of Technology: The Case of Programming Languages\n  * Modelling the Evolution of Programming Languages\n  * Programming Languages Genealogical Tree\n\n## Object-oriented programming is not so obvious!\n\nToday, OOP is one of the most fanatical taboos in my small programming\nexperience.\n\nI have mixed feelings about OOP. Don't get me wrong; I enjoy organizing my\ncode in an OO style, but I often find myself dissatisfied with my own design:\nSometimes, OOP feels unintuitive, paradoxically different from the real world,\neasy to make wrong, boilerplate, overly subjective, and hammered. Too often,\nmy thoughts and discussions veer into philosophical territory. Sometimes, I\nbelieve simple data and functions work better. Also, there are times when I\nthink an interface would be very appropriate, but others don't like using\nclasses.\n\nThis is clearly a skill issue. I don't know enough about OOP. I can accept\nthat, but my frustration with OOP isn't just about my lack of skills. I\nconsistently struggle when discussing the well-known object-oriented\nprogramming paradigm with others. Too often, discussions about OOP miss the\nmark, diverting around interpretable principles, better naming, programming\nlanguages, language features, and past ideas.\n\nFew discussions and sources I have found on my path don't continue to leave me\nunsatisfied and uncertain every time. I discover or re-discover something new\nevery year in my quest for understanding. Furthermore, The more I examine this\nparadigm with people, the more I notice a common thread, but I also come\nacross numerous conflicting ideas and strong opinions.\n\n### The Simula vs Smalltalk Diatribe\n\nThere's a narrative about the history of OOP, often revolving around Simula,\nSmalltalk, and the ideas of Alan Kay. Beneficial resources on this topic:\nWikipedia, Alan Kay Did Not Invent Objects and Alan Kay definition of Object\nOriented, after reading this material and other similar, I began to ponder\nwhether was the high-level vision of OOP in the past, the today's perspective\ndiffers once more. And, like natural languages, we can't control it.\n\nSome high-level ideas I find are:\n\n  * Objects are similar to experts and collaborators(*) - I appreciate this definition because it emphasizes the concept of locality and encapsulation and is empirical rather than mathematical. Writing software is often like crafting rather than mathematics, but unfortunately, this vision complicates my hopeless pursuit of frame OOP.\n  * OOP means only messaging - Sometimes it's similar to the previous, but I'm not sure; here, Small Talk, Erlang, Elixir, and the Actor Model are often mentioned.\n  * Model real-life things with Classes and Inheritance - I don't entirely agree with this vision. I believe that OOP aims to model our business or real-world domain, but the real world is unrepresentable one-way, and inheritance is the worst tool for this task! Too many materials on the internet sponsor this vision (1, 2... ).\n  * OOP is Clean Code - I've encountered situations where we changed code for OOP reasons. However, I thought the old way was more in line with my unsure perspective of OOP principles. Still, I liked the clarity of the new approach and supported using it.\n  * Java - Another perspective I've observed is that some equate OOP with Java. I don't think that Java represents the definitive OOP approach. PLs are human creations, tools, and technology at our disposal. They are agnostic to human philosophies or mental exercises. They're simply collections of isolable PL features that carry the biases of their creators and community. I'm saying that doing Java well simply means doing Java well. OOP can be used in many places; what distinguishes the OO approach in languages like R, JavaScript, Perl 6, Racket, and Lua? Too often, I've encountered the misconception that true OOP is restricted solely to static types and static classes. But why? Is it to support the IDE's IntelliSense features?\n  * OOP is Design Patterns.\n  * Others? Mixes of the above?\n\n### Liskov and Inheritance are contagious virus\n\nThere are many forms of polymorphism; the most known are:\n\n  * Ad-hoc polymorphism - often exemplified by Haskell's type classes and overloading, provides distinct function implementations for different types.\n  * Parametric polymorphism - often exemplified by generics, allows functions and types to work with other types without knowing them upfront.\n  * Subtype polymorphism - one type is substitutable with its subtypes. Subtype polymorphism is where OOP shines.\n  * Trivia: Uiwa has a super exciting form of polymorphism!\n\nIn my view, the difference between inheritance and interfaces is significant.\nWhile both involve subtyping, the distinction is profound for me. Sometimes, I\nthink about an alternative world where OOP avoided inheritance altogether. My\nbrain has a lot of problems with inheritance. Firstly, our human contextual\nhierarchical representation of reality doesn't match the object-oriented\nrepresentation. Secondly, hierarchies can be overly situational. When they\ngrow large, they become complex, difficult to dismantle, and understanding\nwhat each parent class does can be overwhelmed by cognitive load. Finally,\neven with basic interfaces, I have a constant and subtle fear of breaking the\nLiskov substitution principle. Yet, hierarchies compound this complexity by\nsharing data and behaviors, potentially creating confusion with indirection\nbetween overridden methods in child and parent classes, they add another level\nof entropy to this challenge.\n\n\"Anything that can go wrong will go wrong.\", The Murphy's law is so true. How\noften have you encountered scenarios resembling the square/rettangle problem\nor the penguin problem?\n\nI love simple interfaces.\n\nHowever, you're unable to achieve the same tasks without inheritance.\n\nWhy not?\n\n    \n    \n    // js with inheritance class Father { constructor(aProperty){ this.aProperty = aProperty } doFizz(){ console.log(\"fizz\") } } class Child extends Father { constructor(aProperty){ super(aProperty) } doBuzz(){ super.doSomething() console.log(\"different\") } }\n    \n    \n    // js with delegation class Father { constructor(aProperty){ this.aProperty = aProperty } doFizz(){ console.log(\"fizz\") } } class Child { constructor(aProperty, father){ this.father = father } doFizz(){ this.father.doFizz(); } doBuzz(){ this.doFizz(); console.log(\"different\") } } const child = new Child(new Father(aProperty)); child.doFizz() child.doBuzz()\n\nYeah, delegation can be quite tedious and repetitive. But, sometimes, it's\nsimply a matter of language capabilities. For instance, Go, Kotlin, Crystal,\nand Raku offer intriguing approaches to delegation.\n\n    \n    \n    # crystal with delegate class Father getter a_property : String def initialize(a_property : String) @a_property = a_property end def do_fizz puts \"fizz\" end end class Child def initialize(@father : Father) end delegate :do_fizz, to @father def do_buzz do_fizz puts \"different\" end end child = Child.new(Father.new(\"value\")) child.do_fizz child.do_buzz\n    \n    \n    // kotlin with 'by' interface Fizzator { fun doFizz() } class Father(val aProperty: String) : Fizzator { override fun doFizz() { println(\"fizz\") } } class Child(father: Father) : Fizzator by father { fun doBuzz() { doFizz() println(\"different\") } } fun main() { val child = Child(Father(\"property\")) child.doFizz() child.doBuzz() }\n    \n    \n    # raku with 'handle' class Father { has $.a-property; method do-fizz { say \"fizz\"; } } class Child { has Father $.father handles <do-fizz>; method do-buzz { self.do-fizz; say \"different\"; } } my $father = Father.new(:a-property(\"value\")); my $child = Child.new(:father($father)); $child.do-fizz; $child.do-buzz;\n    \n    \n    // golang with its interfaces type Father struct { aProperty string } func (f *Father) doFizz() { fmt.Println(\"fizz\") } type Child struct { Father } func (c *Child) doBuzz() { c.doFizz() fmt.Println(\"different\") } func main() { child := Child{Father{aProperty: \"value\"}} child.doFizz() child.doBuzz() }\n\nIndeed, there's no silver bullet, but as I carry my beliefs, I harbor a strong\nbias against inheritance.\n\nAlso, the conventional viewpoint doesn't classify Golang as an OO language.\nHowever, if \"OOP is not so obvious,\" the Golang categorization is not so\nobvious either. Does Go have subtyping?\n\n### Guidelines for Addressing Entropy and Power\n\nGRASP, SOLID, Law of Delimiter, Liskov substitution principle, Composition\nover Inheritance, Abstraction Principle, Coupling and Cohesion, Leaky\nabstraction, Port and Adapters Architecture, CQS, Anemic Domain Model, DDD...\nI'm starting to see OOP not as a precise manual but as a set of guidelines for\nnavigating the complexity of software development. Sometimes, ambiguity and\ninterpretability, as seen in legal matters, can actually be features that\ncontribute to flexibility.\n\n#### Extendibility\n\nAs developers, we often work to ensure our code can quickly adapt to changes\nin the real world. However, I feel that even when we prioritize\nmaintainability and extendibility, coding acts as a means to document and\nformalize our contextual knowledge, enabling us to revisit and reactivate our\nunderstanding of the problem in the future. Focusing solely on extending the\ncode can sometimes lead to a situation where everything is extendable. Still,\nwe struggle to manage our cognitive load caused by widespread context and\nexcessive generalization. I think this captures the essence of Cohesion.\n\nA Time ago, I was fascinated by an article titled \"The Unreasonable\nEffectiveness of Julia,\" which introduced me to the Expression Problem that\nreminds me of the Open-close-Principle. This article explored the challenge of\nextending a book of recipes and ingredients, raising the question of how much\nof the book would need to be modified when adding a new recipe or ingredient.\n\nHowever, I lack sufficient experience with Julia and Multiple Dispatch to\ncomprehend its advantages fully. At times, I feel that the capabilities of a\nlanguage can surpass the limitations of other languages that lack those\nfeatures.\n\n#### Performance\n\nAlso, I read that there are situations when OOP guidelines may not suit\nspecific domains that prioritize technical details over adaptability or\nunderstandability. Encapsulation and Abstraction might not work well in such\ncases, leading to a practice where code isn't viewed as representative of the\nreal-world domain. Instead, code and data are treated merely for their\ncapacity to manage bytes, cache, and cycles. This approach is known as data-\noriented design.\n\nThe first principle: Data is not the problem domain:\n\n> For some, it would seem that data-oriented design is the antithesis of most\n> other programming paradigms because data-oriented design is a technique that\n> does not readily allow the problem domain to enter into the software so\n> readily. It does not recognise the concept of an object in any way, as data\n> is consistently without meaning, whereas the abstraction heavy paradigms try\n> to pretend the computer and its data do not exist at every turn, abstracting\n> away the idea that there are bytes, or CPU pipelines, or other hardware\n> features. The data-oriented design approach doesn't build the real world\n> problem into the code. This could be seen as a failing of the data-oriented\n> approach by veteran object-oriented developers, as many examples of the\n> success of object-oriented design come from being able to bring the human\n> concepts to the machine, then in this middle ground, a solution can be\n> written in this language that is understandable by both human and computer.\n> The data-oriented approach gives up some of the human readability by leaving\n> the problem domain in the design document, but stops the machine from having\n> to handle human concepts at any level by just that same action.\n\n#### Simple Data and Simple Functions\n\nAdditionally, sometimes, I feel that using simple data and simple functions,\norganizing the problem domain within immutable data structures, and\nenvisioning our domain rules as data transformations can be more practical.\nI've often felt too forced by OOP's inclination to link behavior and data,\nleading me to create complex object chimeras influenced by my subjective view\nof the real world when a simple dictionary would have enough.\n\nPrinciples of Data-Oriented Programming (to not confuse with data-oriented\ndesign)\n\nI don't believe it's directly comparable to data-centric, or database-centric\nor data-driven architecture, or whatever you name it (why all this similar\nnames?). I mean where interfaces and the entire software are derived and\ncoupled to a large data structure, such as the database schema. That poses\nchallenges when we must customize detailed implementations or change this\nstructure, which can significantly affect the whole system. However, I\nrecognize that overuse of this approach poses a dilemma for the Anemic Domain\nModel.\n\n### ok\n\nI'm arguing that OOP is not as obvious. If I haven't convinced you try with:\n\n  * People Don\u2019t Understand OOP\n  * Why is Object-Oriented Programming Bad?\n  * Why extends is evil\n  * Is Inheritance That Evil?\n  * OOP vs. type classes - ideology\n\n## Functional programming is not so obvious, either!\n\n### Programming languages are experiments\n\nAfter reading A decade of developing a programming language, I started\npondering: programming languages are incredibly complex beasts that evolve\nover time, carrying the weight of tough trade-offs and decisions made during\ntheir creation. Essentially, all the languages we use today are just\nexperiments by their creators. Even those creators can't fully foresee how\ntheir language design will impact the software made with it. And thanks to the\nLindy effect, we're still dealing with tech from the '70s and '90s.\n\nToday, mature programming languages can present subtle issues at their core,\nsuch as null.\n\nOne day, while chatting with a friend who's really into functional\nprogramming, we started talking about OOP. The conversation shifted toward OOP\nliterature, which mainly focuses on tackling the challenges and problems of\nOOP itself. Several design patterns remedy absent language features, while its\nprinciples act to circumvent issues originating from OOP itself.\n\nI have mixed feelings about this statement and agree that OOP isn't so obvious\nat times. To me, OOP provides guidelines for navigating an intrinsically\nproblematic territory. FP, instead, sets up a safe zone where problems like\nimmutable rectangle/square, unhandled exceptions, illegal state, global\nstate... just do not exist. However, many of these guidelines remain super\nvaluable!\n\n### Functional Programming! what?\n\nWhat exactly is functional programming? I ask because numerous languages are\nlabeled as \"Functional,\" but their style and developer experience vary\nsignificantly. I know little about Lisp, APL, Haskell, OCaml, Prolog,\nErlang...\n\nIt's interesting to learn about the perspective of a developer deeply familiar\nwith Haskell and how significant the differences were to them when\nencountering OCaml, despite both languages sharing the same roots: 8 months of\nOCaml after 8 years of Haskell in production.\n\nSo, what is functional programming?\n\nI rely on the insights of Richard Felman, who has offered compelling arguments\non this matter.\n\nThe Essence of Functional Programming by Richard Feldman\n\n\"Maybe FP has always been vaguely shared understanding of relate ideas\"\n\nThis reminds me of my previous section about OOP. However, in the realm of FP,\nin my experience, the emphasis often shifts towards language features rather\nthan what I would term \"guidelines\".\n\n  * ADT\n  * Filter, Map, Reduce\n  * Referential transparency\n  * (exhaustive) Pattern Matching\n  * \"Function friendly\" Language Ergonomics\n  * High order functions\n  * Recursion\n  * Type Classes\n  * Module Functors\n  * Immutability\n  * Managed Side Effect\n  * Pure function\n  * Category Theory\n  * Laziness\n  * Parametric Polymorphism and others\n  * Other?...\n\nRichard argues that there are no mandatory features for FP, but the essence of\nwhat he calls the functional style includes exclusively:\n\n  * Avoiding mutation\n  * Avoiding side effects\n\nLearning a bit about Elm and Haskell broadened my perspective. I discovered\nsolutions and possibilities I had never encountered before, and I was\nfascinated by the absence of problems that I frequently encountered when\nworking with Java and JavaScript.\n\nI was once again surprised when I encountered the same sensation while\nexperimenting with Rust. But Rust is not an FP language. (it's also debated\nwhether Rust adheres to OOP, but it's better to keep this topic apart...).\n\nThis Richard's talk helped me grasp and formalize this feeling better:\n\nFunctional Programming for Pragmatists\n\nSubstantially, can limitations and restrictions be liberating? FP style may\nrestrict the power of the PL, like side effects and mutability, but features\ncommonly present in FP languages bring some perks like better tools, easier\ntesting, less thinking, and smoother refactorings. Constraining the language\nsimplifies software, especially when low-level control isn't required. The\ntrade-off is about adding little noise to simple tasks while facilitating\ncomplex ones.\n\nI like what Felman says in \"Why Isn't Functional Programming the Norm?\" Java\ndidn't become popular just because it was OO; it was valuable at the time(and\na bit sponsored). FP isn't just about Haskell or Lisp... It's about how\nprogramming languages naturally evolve by adding new features and dropping the\nless valuable ones (like inheritance, maybe! :P).\n\n## Conclusion: In the end it doesn't even matter\n\nSo, programming languages are basically experiments influenced by what others\nbefore us believed. Both object-oriented programming and functional\nprogramming can be not so obvious.\n\nIn the end, the programming language we use doesn't really matter. We have\nlittle control over most of the tools we use daily because we can't alter the\nworld's current trajectory, the software industry, or things like the lindy\neffect or Jevons paradox are pretty inevitable.\n\nIn the end, what matters most is agreeing on what works for us and making\nteamwork smooth. As people, we should focus on what we can control and find\nthe best solution for the job without getting too stuck on our own opinions.\n\nI enjoy learning programming languages; each new thing gives me a fresh\nperspective. But in the end, my goal is to deliver value to my users by\ncreating working software. What pays off is always collaboration, having a\nshared way of communication with colleagues, simplicity, combating entropy,\nand avoiding unnecessary solutions. Writing code is only one small part of our\njob.\n\nThe perfect programming language doesn't exist, or if it does, in each case,\nwe should be capable of using it with simplicity.\n\nWriting this post gives me a similar feeling to when I watched these talks:\n\n  * The Mess We Are in\n  * Is Software Engineering Still an Oxymoron? \u2022 Alan Kay\n\nI attempted to articulate my vague thoughts here. Please give me feedback on\nwhether this post is coherent!\n\nIf you are interested, explore these particular programming languages:\n\n  * Typst\n  * Nu\n  * Uiua\n  * Inko\n  * Roc\n\nBye!\n\n#### interesting Articles and Resources:\n\n    \n    \n    Programming Languages Evolution: - 3 tribes of programming: https://josephg.com/blog/3-tribes/ - JavaScript's Dependency Problem: https://danthedev.com/javascripts-dependency-problem/ - The Evolutionary Ecology of Technology: The Case of Programming Languages: https://www.dsi.unive.it/PhilCS2015/Slides/PhilCS_Crafa.pdf - Modelling the Evolution of Programming Languages: https://www.researchgate.net/publication/282905754_Modelling_the_Evolution_of_Programming_Languages - I made a family tree of all the world's languages: https://www.reddit.com/r/languagelearningjerk/comments/uppnpy/i_made_a_family_tree_of_all_the_worlds_languages/ - Band family trees: https://www.reddit.com/r/ClassicRock/comments/wtkumq/the_yardbirds_family_tree_how_all_these_bands_are - A Brief, Incomplete, and Mostly Wrong History of Programming Languages: http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html - Sketchpad: A Man-Machine Graphical Communication System: http://www.bitsavers.org/pdf/mit/tx-2/Sketchpad_TR296_Jan63.pdf - Towards a conceptual history of programming languages - Types: http://www.cs.unibo.it/~martini/TALKS/martini-LIP.pdf - The Next 700 Programming Language: https://www.cs.cmu.edu/~crary/819-f09/Landin66.pdf - Guido van Rossum about biological systems metaphor of languages: https://youtu.be/-DVyjdw4t9I?t=1528 - Programming languages genealogical tree: https://github.com/stereobooster/programming-languages-genealogical-tree?tab=readme-ov-file - Genealogical tree of programming languages by wikipedia: https://upload.wikimedia.org/wikipedia/commons/2/25/Genealogical_tree_of_programming_languages.svg - A History of Programming Languages for 2 Voices(David Nolen and Michael Bernstein): https://www.youtube.com/watch?v=J3C79CDqeW4 - Dictionary of Programming Languages: http://cgibin.erols.com/ziring/cgi-bin/cep/cep.pl Object Oriented Programming: - A Solution to the Square-Rectangle Problem: https://aip.vse.cz/pdfs/aip/2016/01/03.pdf - Object-Oriented Thinking in the Data-Centric World: https://www.schibsted.pl/blog/object-oriented-thinking-in-the-data-centric-world/ - Anemic Domain Model: https://martinfowler.com/bliki/AnemicDomainModel.html - Abstraction Considered Harmful: https://bravenewgeek.com/abstraction-considered-harmful/ - Leaky abstraction: https://en.wikipedia.org/wiki/Leaky_abstraction - Cohesion and Coupling - the difference: https://enterprisecraftsmanship.com/posts/cohesion-coupling-difference/ - Replace Delegation with Inheritance: https://refactoring.guru/replace-delegation-with-inheritance - Categorisation, Comparison and Cases - Einar H\u00f8st - https://www.youtube.com/watch?v=LNi0vy7GAaI - Polymorphism haskell wiki - https://wiki.haskell.org/Polymorphism - \"The Power of Abstraction\" with Prof. Barbara Liskov - https://www.youtube.com/watch?v=dtZ-o96bH9A - Why extends is evil - https://web.archive.org/web/20160305173913/https://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html - If I implement an Interface, is it called an Inheritance? - https://softwareengineering.stackexchange.com/questions/316893/if-i-implement-an-interface-is-it-called-an-inheritance - does go have subtyping?: https://journal.stuffwithstuff.com/2023/10/19/does-go-have-subtyping/ - Object-oriented Programming and Modeling the Real World - https://johan.im/writings/object-oriented-programming-and-modeling-the-real-world/ - Joe Armstrong interviews Alan Kay: https://www.youtube.com/watch?v=fhOHn9TClXY - Why you Can't Control Language: https://smartergerman.com/blog/why-you-cant-and-shouldnt-control-language/ - L'arte perduta di pensare ad oggetti, by Matteo Vaccari: https://www.youtube.com/watch?v=jO6Z3wOdfWc - Dr. Alan Kay on the Meaning of \u201cObject-Oriented Programming\u201d: https://www.purl.org/stefan_ram/pub/doc_kay_oop_en - Open issues in OOP: https://pure.au.dk/ws/portalfiles/portal/22469430/OpenIssuesInOO.pdf - The unreasonable effectiveness of the Julia programming language: https://arstechnica.com/science/2020/10/the-unreasonable-effectiveness-of-the-julia-programming-language/ - Extensibility for the Masses - https://www.cs.utexas.edu/~wcook/Drafts/2012/ecoop2012.pdf - Expression problem: https://wiki.c2.com/?ExpressionProblem - The Expression Problem and its solutions: https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions/ - More thoughts on the Expression Problem in Haskell: https://eli.thegreenplace.net/2018/more-thoughts-on-the-expression-problem-in-haskell/ - Steve Jobs explains object-oriented programming: https://www.edibleapple.com/2011/10/29/steve-jobs-explains-object-oriented-programming/ - Introduction to Object Oriented Programming to https://www.cs.utexas.edu/users/mitra/csSpring2017/cs303/lectures/oop.html - What To Know Before Debating Type Systems - https://ovid.github.io/articles/what-to-know-before-debating-type-systems.html - Alan Kay Did Not Invent Objects: https://www.hillelwayne.com/post/alan-kay/ - Data Oriented Design, Data is not the problem domain: https://www.dataorienteddesign.com/dodmain/node3.html#SECTION00320000000000000000 - Principles of Data-Oriented Programming: https://blog.klipse.tech/dop/2022/06/22/principles-of-dop.html - OOP Design Dilemma - Data and Beheviour: https://softwareengineering.stackexchange.com/questions/234527/zero-behavior-objects-in-oop-my-design-dilemma - People Don\u2019t Understand OOP - https://blog.sigma-star.io/2024/01/people-dont-understand-oop/ - Why is Object-Oriented Programming Bad? https://ovid.github.io/articles/why-is-object-oriented-programming-bad.html - Object-Oriented Programming is Bad: https://www.youtube.com/watch?v=QM1iUe6IofM - Is Inheritance That Evil?: https://thevaluable.dev/guide-inheritance-oop/ Functional Programming: - Functional Design Patterns - Scott Wlaschin: https://www.youtube.com/watch?v=srQt1NAHYC0&t=251s - OOP vs Typeclasses - Ideology: https://alexn.org/blog/2022/05/13/oop-vs-type-classes-part-1-ideology/ - 8 months of OCaml after 8 years of Haskell in production: https://dev.to/chshersh/8-months-of-ocaml-after-8-years-of-haskell-in-production-h96 - The essence of functional programming by Richard Feldman: https://www.youtube.com/watch?v=l0ruvPCQh9I - The Roc Programming Language with Richard Feldman (and what FP is) - https://adspthepodcast.com/2023/11/24/Episode-157.html - Why Isn't Functional Programming the Norm? \u2013 Richard Feldman: https://www.youtube.com/watch?v=QyJZzq0v7Z4 - Are Design Patterns Missing Language Features: https://wiki.c2.com/?AreDesignPatternsMissingLanguageFeatures Other: - The Rust I Wanted Had No Future - https://graydon2.dreamwidth.org/307291.html - A decade of developing a programming language: https://yorickpeterse.com/articles/a-decade-of-developing-a-programming-language/ - The Mess We Are n: https://www.youtube.com/watch?v=lKXe3HUG2l4&t=1925s - Is Software Engineering Still an Oxymoron? \u2022 Alan Kay: https://www.youtube.com/watch?v=D43PlUr1x_E - Features of a dream programming language: https://magnemg.eu/features-of-a-dream-programming-language-3rd-draft - The World's Most Maintainable Programming Language: http://lambda-the-ultimate.org/node/1483#comment-17093 - The Perfect Programming Language: https://www.youtube.com/watch?v=yiiDFRs62lQ - Four Stages of Competence: https://en.wikipedia.org/wiki/Four_stages_of_competence - The Fullstack conundrum and the commoditization of web development: https://blog.nukemberg.com/post/the-fullstack-conundrum/ Object in various languages: - Classes and object in Racket: https://docs.racket-lang.org/guide/classes.html - Subtype in Racket: https://docs.racket-lang.org/ts-guide/types.html#%28part._.Subtyping%29 - Objects in ocaml: https://v2.ocaml.org/manual/objectexamples.html, https://ocaml.org/docs/objects - When should objects be used in OCaml?: https://stackoverflow.com/questions/10779283/when-should-objects-be-used-in-ocaml - Objects in Raku: https://docs.raku.org/language/objects - Objects in Simula: https://courses.cs.washington.edu/courses/cse505/97au/oo/simula.html - Effiel Type System: https://staffwww.dcs.shef.ac.uk/people/A.Simons/research/papers/eiffeltype.pdf - About Eiffel origins: https://news.ycombinator.com/item?id=22282160 - Objects in squeak: https://web.archive.org/web/20230503063351/https://web.cecs.pdx.edu/~harry/musings/SmalltalkOverview.html#Basic%20OOP%20Concepts%20and%20Terminology\n\n  * type: post\n  * author : Angelo Ceccato (AngeloChecked)\n  * links:\n\n    * Object Oriented Programming is Bad\n    * People Don\u2019t Understand OOP\n  * tags:\n\n    * Cognitive Bias\n    * Functional Programming\n    * Learning\n    * Object Oriented Programming\n    * Programming Languages\n\n\u00a9 2024 Angelo Ceccato. Created with Lume, powered by Antv-G6, heavy inspired\nby Digital Gardeners and a bit by my previous theme: Mainroad.\n\nMenu:\n\n  * Posts\n  * Graph\n  * About Me\n\nSocial:\n\n  * twitter\n  * mastodon\n  * linkedin\n  * github\n  * mail\n\n", "frontpage": false}
