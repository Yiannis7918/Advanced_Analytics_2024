{"aid": "40025809", "title": "Show HN: UnityReduxMiddleware", "url": "https://github.com/Garume/Unity-Redux-Middleware", "domain": "github.com/garume", "votes": 1, "user": "garume", "posted_at": "2024-04-13 20:32:09", "comments": 0, "source_title": "GitHub - Garume/Unity-Redux-Middleware: Unity Redux Middleware enhances AppUI Redux in Unity with domain-specific middleware and R3 for reactive extensions.", "source_text": "GitHub - Garume/Unity-Redux-Middleware: Unity Redux Middleware enhances AppUI\nRedux in Unity with domain-specific middleware and R3 for reactive extensions.\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nGarume / Unity-Redux-Middleware Public\n\n  * Notifications\n  * Fork 0\n  * Star 1\n\nUnity Redux Middleware enhances AppUI Redux in Unity with domain-specific\nmiddleware and R3 for reactive extensions.\n\n### License\n\nMIT license\n\n1 star 0 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# Garume/Unity-Redux-Middleware\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n2 Branches\n\n3 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nGarumeversion up to 0.1.0ea27cff \u00b7\n\n## History\n\n23 Commits  \n  \n### Assets\n\n|\n\n### Assets\n\n| version up to 0.1.0  \n  \n### Packages\n\n|\n\n### Packages\n\n| [add] epic tests  \n  \n### ProjectSettings\n\n|\n\n### ProjectSettings\n\n| [add] middleware base system and observable system (epic)  \n  \n### docs\n\n|\n\n### docs\n\n| [add] readme  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| [add] middleware base system and observable system (epic)  \n  \n### LICENSE.md\n\n|\n\n### LICENSE.md\n\n| [add] middleware base system and observable system (epic)  \n  \n### README.md\n\n|\n\n### README.md\n\n| Update README.md to support jp link  \n  \n### README_JA.md\n\n|\n\n### README_JA.md\n\n| [add] readme  \n  \n## Repository files navigation\n\n# Unity Redux Middleware\n\nUnityReduxMiddleware provides middleware for adding logic processing to\nUnity.AppUI.Redux. It can also be integrated with R3 to add processes that can\nbe written in Rx.\n\n\u65e5\u672c\u8a9e\u7248 README\n\n## Overview\n\nUnity.AppUI.Redux is supposed to be based on a state management library\ndeveloped in Javascript. However, AppUI.Redux does not have the middleware\nfunctionality of the original library. By using this middleware, it is\npossible to insert processing before and after dispatch.\n\nThis library adds this middleware to AppUI.Redux.\n\nNote: This is not an explanation of AppUI.Redux.\n\n## Setup\n\n### Requirements\n\n  * Unity 2022.3 or higher\n\n### Installation ### 1.\n\n  1. select Window > Package Manager\n  2. Select the \"+\" button > Add package from git URL\n  3. Enter the following URL\n\n    \n    \n    https://github.com/Garume/Unity-Redux-Middleware.git?path=/Assets/UnityReducMiddleware\n\nOr open Packages/manifest.json and add the following to the dependencies block\n\n    \n    \n    { \"dependencies\": { \"com.garume.unity-redux-middleware\": \"https://github.com/Garume/Unity-Redux-Middleware.git?path=/Assets/UnityReducMiddleware\" } }\n\n### Demonstration\n\nCreate LoggerMiddleware that outputs logs before and after dispatch.\n\n    \n    \n    using UnityEngine; using UnityReduxMiddleware; public class LoggerMiddleware { public static MiddlewareDelegate Create() { return store => next => async (action, token) => { var appName = action.type.Split('/')[0]; // get appName from action. Debug.Log(store.GetState()[appName]); // log the current state. await next(action, token); // call the next middleware. If there is no next middleware, dispatch is called. Debug.Log(store.GetState()[appName]); // output the state after dispatch to the log. }; } }\n\nLet's apply the LoggerMiddleware we created.\n\n    \n    \n    using Unity.AppUI.Redux; using UnityReduxMiddleware; public class Sample { public void Main() { var store = new MiddlewareStore(); // Use MiddlewareStore instead of Store when using Middleware. store.AddMiddleware(LoggerMiddleware.Create()); // Add LoggerMiddleware. store.CreateSlice(Actions.AppName, new AppState(),. builder => builder.Add(Actions.Increment, IncrementReducer)); // Create the slice. store.Dispatch(Actions.IncrementAction.Invoke()); // dispatch the action. } public AppState IncrementReducer(AppState state, Action action) { return state with { Count = state.Count + 1 }; } public record AppState { public int Count { get; set; } } public static class Actions { public const string AppName = \"app\"; public const string Increment = AppName + \"/Action1\"; public static readonly ActionCreator IncrementAction = Store.CreateAction(Increment); } }\n\nIf you run this, you will get the following results. (It is recommended to run\nthis using TestRunner.)\n\n    \n    \n    Debug.Log() \u2193 dispatch // State is updated \u2193 Debug.Log()\n\nAs a result, we were able to add processing before and after dispatch.\n\n## Middleware\n\n### Concepts\n\nThe Middleware design philosophy is based on the Redux philosophy. Please\ncheck Redux for more information.\n\nThe following is a brief explanation.\n\nNormal dispatch processing only passes the Action to the Reducer.\n\nhttps://www.infinijith.com/blog/redux/redux-middleware\n\nAdding Middleware allows for side effects and asynchronous processing between\ndispatch and Reducer. This allows logic to be confined to the domain layer.\n\nhttps://www.infinijith.com/blog/redux/redux-middleware\n\nIn addition, the middleware is independent of each other and loosely coupled,\nmaking it easy to test.\n\n### How to create Middleware\n\nWhen creating Middleware, use MiddlewareDelegate as the return value. Call\nawait(action,token) in the delegate to proceed to the next Middleware.\n\n    \n    \n    public static MiddlewareDelegate Create() { return store => next => async (action, token) => { await next(action, token); // Call the next middleware. }; }\n\nIf there is no next middleware, it is dispatched using the current action and\nthe State is updated. Conditional branching can also be done by action.\n\nFor example, if you want to execute a process when the actionType is\n\"App/Increment\", do the following.\n\n    \n    \n    public static MiddlewareDelegate Create() { return store => next => async (action, token) => { if (action.type == \"App/Increment\") { // Processing to be added } await next(action, token); // Call the next middleware. }; }\n\nDo not forget to execute await(action,token) at this time.\n\n### Execution order\n\nYou can add multiple pieces of middleware.\n\nThey are executed in the order in which they are added.\n\n    \n    \n    var store = new MiddlewareStore(); store.AddMiddleware(TestMiddleware1.Create()); store.AddMiddleware(TestMiddleware2.Create()); store.AddMiddleware(TestMiddleware3.Create()); ...\n\nFor example, when added like this, the Action is passed as follows\n\n    \n    \n    TestMiddleware1 \u2193 TestMiddleware2 \u2193 TestMiddleware3\n\n### Exception Handling\n\nMiddlewareStore does not include try/catch middleware.\n\nInstead, ExceptionMiddleware, a try/catch middleware, is included.\n\nBasically, it is recommended to add this middleware first.\n\n    \n    \n    var store = new MiddlewareStore(); store.AddMiddleware(ExceptionMiddleware.Create()); store.AddMiddleware(TestMiddleware.Create()); ...\n\nThe ExceptionMiddleware rethrows all exceptions except\nOperationCanceledException. If you prefer a different behavior, please create\nit accordingly.\n\n### Asynchronous Processing\n\nMiddleware has a basic design that allows the use of Tasks for asynchronous\nprocessing. Accordingly, an asynchronous method version of Dispatch is also\nprovided.\n\n    \n    \n    void Dispatch(Action action) void Dispatch(string actionType) void Dispatch<T>(string actionType, T payload) async Task DispatchAsync(Action action, CancellationToken token = default) async Task DispatchAsync(string actionType, CancellationToken token = default) async Task DispatchAsync<T>(string actionType, T payload, CancellationToken token = default)\n\n### Tests\n\nUnity-Redux-Middleware/Assets/UnityReduxMiddleware/Tests /Runtime.\n\n## Epic\n\nEpic allows Observable to be handled.\n\nNote: R3 setup is required.\n\n### Concepts\n\nRefer to redux-observable.\n\nEpic is a function that takes an Observable and returns an Observable.\n\nIn redux-observable, this is called \"Actions in, actions out.\n\nhttps://makeitnew.io/epic-reactive-programming-with-redux-observable-\neff4d3fb952f\n\nEpic's ability to handle Actions as streams allows for the use of a rich set\nof operators. This makes it possible to easily write processes that would be\ndifficult in middleware.\n\nAlso, unlike Middleware, Epic cannot insert processing before dispatch.\nInstead, Epic itself can issue new Actions.\n\n### Setup.\n\nR3 setup is required. Please refer to the following for installation.\nhttps://github.com/Cysharp/R3?tab=readme-ov-file#unity\n\nAfter successful installation, Epic features will be activated.\n\n### Demo\n\nFirst, let's create Epic that outputs a State when an Action is sent.\n\nSince we also need a State to create Epic, we will also create an AppState.\nEpic can be created from Epic.Create<TState>().\n\n    \n    \n    public static Epic<AppState> CreateEpic() { return Epic.Create<AppState>((action, state) => { return action.Do(_ => Debug.Log($\"State: {state.CurrentValue}\")); // Outputs the current State }); } public record AppState { public int Count { get; set; } }\n\nNext, create a MiddlewareStore that will use Epic. At the same time, create\nEpicMiddleware to run Epic. Unlike normal middleware, this middleware needs to\nbe Run to be associated with Epic after it is added.\n\n    \n    \n    public void Main() { var store = new MiddlewareStore(); var epicMiddleware = EpicMiddleware.Default<AppState>(); // Create the epic middleware. store.CreateSlice(\"app\", new AppState(), builder => { builder.Add(Actions.Increment, IncrementReducer); // Tie the action type to the reducer. }); // Create a slice. store.AddMiddleware(epicMiddleware.Create()); // Add epic middleware. epicMiddleware.Run(CreateEpic()); // Run epic. Store.Dispatch(Actions.IncrementAction.Invoke()); // Dispatch the action. } public AppState IncrementReducer(AppState state, Action action) { return state with { Count = state.Count + 1 }; } public static class Actions { public const string AppName = \"app\"; public const string Increment = AppName + \"/Increment\"; public const string IncrementRequest = AppName + \"/IncrementRequest\"; public static readonly ActionCreator IncrementAction = Store.CreateAction(Increment); }\n\nIf you run this, you should get the following results. (We recommend using\nTestRunner.)\n\n! alt text\n\nNext, let's create an Epic that converts a specific\nActionIncrementActionRequest into an ActionIncrementAction when it is\nreceived. Epic can be combined, so use it as needed.\n\n    \n    \n    public void Main() { var store = new MiddlewareStore(); var epicMiddleware = EpicMiddleware.Default<AppState>(); // Create the epic middleware. store.CreateSlice(\"app\", new AppState(), builder => { builder.Add(Actions.Increment, IncrementReducer); // Tie the action type to the reducer. }); // Create a slice. store.AddMiddleware(epicMiddleware.Create()); // Add epic middleware. epicMiddleware.Run(CreateEpic()); // Run epic. store.Dispatch(Actions.IncrementRequest); // Dispatch the action. Debug.Log(store.GetState<AppState>(Actions.AppName)); // Log the result. } public static Epic<AppState> CreateEpic() { var epic1 = Epic.Create<AppState>((action, state) => { return action.Do(_ => Debug.Log($\"State: {state.CurrentValue}\")); }); var epic2 = Epic.Create<AppState>((action, state) => { return action.Where(x => x.type == Actions.IncrementRequest) .Select(_ => Actions.IncrementAction.Invoke()); }); return Epic.Combine(epic1, epic2); }\n\nIf you run this, you will get the following results\n\n! alt text\n\n## How to create Epic\n\nTo create Epic as usual, use the following.\n\n    \n    \n    Epic<TState> Epic.Create<TState> Create<TState,TDependency> Epic.\n\nExtension methods string and ActionCreator are provided for filtering by\nAction. For example, you can write the following.\n\n    \n    \n    ActionCreator actionCreator = Store.CreateAction(\"App/Increment\"); actionCreator.CreateEpic<AppState>((action, state) => { return action.Do(_ => Debug.Log($\"State: {state.CurrentValue}\")); // Execute only the Action of \"App/Increment\". }); string actionType = \"App/Increment\"; actionType.CreateEpic<AppState>((action, state) => { return action.Do(_ => Debug.Log($\"State: {state.CurrentValue}\")); // Execute only the Action of \"App/Increment\". });\n\n## Operators\n\nWe provide operators that are useful for adding processing.\n\n### OfAction\n\nOnly the Action passed as an argument is passed through.\n\n### Dispatch\n\nDispatch with the Action passed as argument.\n\n## Combine\n\nThe following two methods are provided to combine Epic.\n\n    \n    \n    Epic.Combine<TState>() Epicbuilder\n\nEpicbuilder can be used as follows\n\n    \n    \n    private Epic<ApiMockState> RootEpic() { var builder = Epic.CreateBuilder<ApiMockState>(); Actions.SendRequest.CreateEpic<ApiMockState>((action, state) => action.Do(Debug.Log).Dispatch(Actions.SendAction.Invoke(\"Requesting...\")) ).AddTo(ref builder); Actions.SendRequest.CreateEpic<ApiMockState>((action, state) => action.Delay(TimeSpan.FromSeconds(2)) .Dispatch(Actions.SendAction.Invoke(\"Hello, Unity!\")) ).AddTo(ref builder); return builder.Build(); }\n\n## About\n\nUnity Redux Middleware enhances AppUI Redux in Unity with domain-specific\nmiddleware and R3 for reactive extensions.\n\n### Topics\n\nredux redux-observable unity redux-middleware appui\n\n### Resources\n\nReadme\n\n### License\n\nMIT license\n\nActivity\n\n### Stars\n\n1 star\n\n### Watchers\n\n1 watching\n\n### Forks\n\n0 forks\n\nReport repository\n\n## Releases 3\n\nv0.1.0 Latest\n\nApr 13, 2024\n\n\\+ 2 releases\n\n## Packages 0\n\nNo packages published\n\n## Languages\n\n  * C# 100.0%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
