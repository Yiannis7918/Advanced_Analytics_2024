{"aid": "40084644", "title": "Authenticate_by: Prevent timing-based enumeration of users", "url": "https://a-chacon.com/en/ruby/rails/security/2024/04/18/authenticate-by-for-prevent-timing-based-enumeration-in-rails.html", "domain": "a-chacon.com", "votes": 1, "user": "unripe_syntax", "posted_at": "2024-04-19 08:59:54", "comments": 0, "source_title": "authenticate_by: Prevent timing-based enumeration of users.", "source_text": "authenticate_by: Prevent timing-based enumeration of users.\n\n# authenticate_by: Prevent timing-based enumeration of users.\n\nAndr\u00e9s\n\n\u2022\n\n18 April 2024\n\n#Ruby #Rails #Security\n\nWith the introduction of authenticate_by in Rails 7.1, we can now prevent\nenumeration attacks based on response times.\n\nLet\u2019s say we have a simple endpoint in our Rails application for our users to\nenter the platform:\n\n    \n    \n    def create user = User.find_by(email: params[:email].downcase) if user && user.authenticate(params[:password]) log_in user redirect_to user else flash.now[:danger] = 'Combinaci\u00f3n de email/password incorrecta' render 'new' end end\n\nThe above code looks good, is functional, and you have probably followed a\nvery similar logic for the logins you have programmed so far. But it has a\nsecurity problem: the conditional if will not take the same response time if\nthe user does not exist or if the user exists, but the password is not\ncorrect.\n\n## Time-based enumeration attacks.\n\nAn enumeration attack based on response times is what I showed above. An\nattacker will be able to test emails by brute force and will be able to tell\nwhen an email exists or not in our database by analyzing the response times of\nour web application or rather of the http request.\n\nA very simple example using the above code would give us response times like\nthis:\n\nIn blue would be the failed login attempts with users and passwords that are\nnot correct. In red would be the attempts where the user does exist, but we do\nnot know the password. As we can see, the differences in response times are\nremarkable.\n\nIf we were in the position of an attacker and we tried 1000 emails, where most\nof the responses are between 20 and 30 ms, but only one gives us 200 ms of\nresponse, then we would know that we found something there.\n\n## authenticate_by\n\nIn Rails 7.1 a new method called authenticate_by was introduced in order to\nprevent this type of attack vector in our Rails applications by responding\nwith a similar time if the user exists or not in our database.\n\nBefore authenticate_by:\n\n    \n    \n    User.find_by(email: \".....\")&.authenticate(\"...\")\n\nAfter authenticate_by:\n\n    \n    \n    User.authenticate_by(email: \"....\", password: \"...\")\n\nNow, if we take this back to our previous example, then our code might look\nlike this:\n\n    \n    \n    def create if user = User.authenticate_by(email: params[:email], password: params[:password]) log_in user redirect_to '/home' else flash[:notice] = 'Combinaci\u00f3n de email/password incorrecta' p 'HERE' redirect_to root_path end end\n\nPerforming the same tests from the browser we have these samples in terms of\nresponse times:\n\n.\n\nAnd as we can see, both requests with emails that exist and those that do not\nexist in our database respond with similar times (215..245 ms) making it\nimpossible to enumerate accounts by response time.\n\nThis is in a best case scenario, this method does not handle all the business\nlogic and may in certain cases such as if you want to control failed login\nattempts on an account you add code that produces a noticeable time difference\nand again an enumeration attack based on response times may occur.\n\n## And, how does authenticate_by work?\n\nFor the curious, authenticate_by has a not very complex definition, where the\nkey lies in the if on line 45:\n\n    \n    \n    if record = find_by(attributes.except(*passwords.keys)) record if passwords.count { |name, value| record.public_send(:\"authenticate_#{name}\", value) } == passwords.size else self.new(passwords) nil end\n\nWhat it does here is very similar to what was done before with\nCustomer.find_by(email: \"....\")&.authenticate(\"...\"), but in the case that the\nuser is not found, that is in the else block, it calls the new method to\ngenerate a new instance of the class passing as parameters the passwords that\nare being used in the login attempt. This forces that even though no record\nwas found the passwords must still be encrypted, which results in a similar\nresponse time as if the record was found and the passwords had to be encrypted\nto compare the hashes.\n\n## Conclusions\n\nTo conclude, it is important to note that, as PR author mentions,\nauthenticate_by does not guarantee that the authentication time is always\nconstant, especially if the username column is not backed by an index.\nRegardless, this addition represents a great advancement for our applications\nby avoiding the possibility of time-based enumeration attacks. Ultimately, it\nprovides us with an additional layer of security in a critical aspect of our\nweb applications.\n\nHappy Coding!\n\n\u00ab Exploring the Possibilities of WebAssembly: Ruby in the Browser\n\n\ud83d\udc77 Contratame / Hire me \ud83d\udc77\n\n", "frontpage": false}
