{"aid": "40016413", "title": "ULIDs and Primary Keys", "url": "https://blog.daveallie.com/ulid-primary-keys", "domain": "daveallie.com", "votes": 4, "user": "hu3", "posted_at": "2024-04-12 18:56:25", "comments": 0, "source_title": "ULIDs and Primary Keys", "source_text": "ULIDs and Primary Keys | Dave Allie\n\nDave Allie\n\n# ULIDs and Primary Keys\n\nBy Dave Allie Published Feb 16, 2022 \u2022 6 min read\n\ndatabase\n\npostgresql\n\nWhen it comes to picking the type for your database's primary keys, there are\na few divided camps. When making this decision for Visibuild I had to choose\nbetween the simplicity of sequential IDs and the longevity/future benefits of\nnon-sequential IDs. I chose non-sequential IDs to make it easier to deal with\nsharding and regional databases in the future. Out of the many flavours of\nnon-sequential IDs I chose ULIDs.\n\nHere's how I got there.\n\n##\n\nlink\n\nUUID\n\nLet's start where most people do, with UUIDs.\n\nUUIDs (universally unique identifiers) are 128-bit labels typically\nrepresented as a hexadecimal string broken up into 5 sections containing 32\nbits, 16 bits, 16 bits, 16 bits, and 48 bits respectively.\n\nHere's an example:\n\nWithin the UUID standard (which you can read about in RFC 4122), there are 5\ndifferent versions of that same 128-bit label. The differences between the\nversions are which inputs are required to generate the UUID and the structure\nof the bits that are output.\n\nVersion 1 requires knowledge of the computer's MAC address to generate the\nlabel. Version 2 is only guaranteed to be unique if at most one is generated\nper computer about every 7 minutes. Versions 3 and 5, are deterministic based\non the supplied input. This leaves only version 4 as a suitable choice for\nscalable, non-deterministic UUIDs.\n\n###\n\nlink\n\nUUIDv4\n\nWhen people say UUID they're almost always referring to UUIDv4. It's the most\nprevalent and widely supported UUID standard, even the example UUID given\nabove is a UUIDv4. As UUIDv4 is based solely on randomness, it is extremely\nportable and can be used with very little prior knowledge about the state of\nthe system.\n\nUUIDv4 are composed of 122 bits of randomness, and 6 bits of version/variant\nidentification.\n\n    \n    \n    6a4a2677-404d-411c-bf7b-3db64825c4ad\n\ninfo_outline\n\nClick the \"Regenerate\" button to see a few different UUIDv4.\n\nThe only non-random sections of a UUDv4 are the version and variant. The\nversion is represented by 4 bits and is always set to 4 for UUIDv4, you can\nsee it highlighted as the first orange nibble above. The variant is\nrepresented by 2 bits and is set to 2 for the UUIDv4 standard, you can see it\nhighlighted as the second orange nibble above.\n\ninfo_outline\n\nThe variant is only the first 2 bits of the second highlighted nibble. While\nthe remaining 2 are random, meaning the value of that nibble can be 8 (1000),\n9 (1001), a (1010), or b (1011)\n\n###\n\nlink\n\nUUIDv7\n\nWhile there are only 5 UUID variants in the RFC, there's a draft that includes\n3 new ones: UUIDv6, UUIDv7, and UUIDv8.\n\nThe three new versions are all based on a similar structure of a combination\nof time bits in the most significant positions, followed by random bits. The\ndifference between the three is which kind of clock is used to generate the\ntime bits. Version 7 from the draft is using Unix Epoch time, making it the\nlikely candidate for adoption in the future.\n\nEven within version 7, there are a few different ways to represent the time.\nDifferent levels of sub-second precision can be used, but the more precise in\ntime you get, the fewer random bits you'll be able to use. Let's take a look\nat the millisecond precision setup of UUIDv7.\n\nWith the millisecond precision setup, there are 48 bits of time, 6 bits of\nversion/variant, 12 bits for a monotonic sequence, and 62 bits of randomness.\n\n    \n    \n    066198be-72c2-7000-be03-48624a3197bc\n\nUUIDv7 always dedicates the first 36 bits to the seconds of the timestamp, and\nthen a variable amount of bits for the sub-second precision, in our case\nthat's 12 bits for the milliseconds within the second.\n\ninfo_outline\n\nIf you click \"Regenerate\" a few times, you should see the first 9 characters\nof the timestamp only change once a second, these are the bits representing\nthe Unix Epoch time in seconds. The last three bits are the milliseconds\nwithin that second.\n\nThe version and variant follow the same setup as UUIDv4, however the version\nis set to 7.\n\nThe main value for the timestamp at the front of the UUID is that UUIDv7s (and\nthe other new UUIDs in the draft) are monotonically increasing (within the\nsame sub-second), meaning that a UUIDv7 generated now is always going to be\nlarger than a UUIDv7 generated a millisecond ago.\n\nYou'll also notice a new kind of section in UUIDv7, the \"monotonic sequence\"\nsection. This section of 12 bits is designed to ensure that the UUIDs\ngenerated within the same sub-second are also monotonically increasing. In our\ncase, for each subsequent UUIDv7 generated within the same millisecond, the\nmonotonic sequence counter will increase by one. Note that this is only\nrelevant for UUIDs generated on the same machine within the same millisecond,\nit will not ensure any ordering of UUIDs if they're generated independently of\neach other in the same millisecond.\n\nHere are some example UUIDs generated in the same millisecond:\n\n  * 061ff8d8-e24b-7000-8092-ca1e5440d491\n  * 061ff8d8-e24b-7001-b653-1c41e471cd78\n  * 061ff8d8-e24b-7002-9bc2-82b5da559f1d\n\nWhen using UUIDv7 as a primary key, you get the same sortability as a\nsequential ID with the flexibility of distributed generation. If you're\nlooking to do a performant sort on creation time using UUIDv4, you'd need a\nseparate indexed creation time column, but if you're using UUIDv7 then you can\nuse the primary key as the sort column (since it's already indexed).\n\n##\n\nlink\n\nULID\n\nIn late 2017, almost 4 years before the UUIDv7 specification was drafted, the\nUniversally Unique Lexicographically Sortable Identifier (or ULID) was\nproposed, not as an RFC Draft, but as a grassroots proposal over GitHub. You\ncan take a read of the (quite concise) specification for ULID on GitHub.\n\nA ULID is a 128-bit label, just like a UUID. It's sortable, has millisecond\nprecision, and is monotonically increasing, just like UUIDv7.\n\nULIDs are typically represented as a Crockford's Base 32 encoded string,\ninstead of a hexadecimal string like UUIDs. As an example, instead of\n017eb31e-1440-b69e-d82f-5f0937f823c8, the same value can be represented as\n0GWWXY2G84DFMRVWQNJ1SRYCMC.\n\nFor the purpose of comparison with UUIDs, I'm going to represent all ULIDs as\nhexadecimal strings, in the same 8, 4, 4, 4, 12 segments which we have been\nusing.\n\nWithin a ULID, there are 48 bits of time and 80 bits of randomness.\n\n    \n    \n    018ed3ca-811d-cc0d-94eb-62663e59925c\n\nWhile there are 48 bits of time information in both UUIDv7 (with millisecond\nprecision) and ULID, the ULID standard encodes the time as Unix Epoch in\nmilliseconds for the whole 48 bits whereas UUIDv7 splits the time into 36\nseconds bits and 12 millisecond bits.\n\nULIDs also remove the bits pertaining to the version and variant, giving us 6\nextra bits to play with but removing all indication that ULIDs are in fact\nULIDs. Because UUIDs encode version and variant information inside the label,\nthey can be reliably decoded into their composite parts (e.g. timestamp and\nrandomness). If you wanted to extract the timestamp from a ULID, the client\nwould need to know that the string being processed is a ULID, and not an\ninvalid (or potentially valid looking) UUID.\n\nULIDs are monotonically increasing, but there is no defined monotonic counter\nlike in UUIDv7. Instead, ULIDs generated in the same millisecond on the same\nmachine will have sequential randomness sections.\n\nHere are some example ULIDs generated in the same millisecond:\n\n  * 017ece40-2a1e-63ac-a58d-e336f30c1d76\n  * 017ece40-2a1e-63ac-a58d-e336f30c1d77\n  * 017ece40-2a1e-63ac-a58d-e336f30c1d78\n\nULIDs are a great alternative to ULIDv7s. They contain more randomness and a\nstraightforward structure at the cost of not explicitly exposing the version,\nvariant, or monotonic counter. UUIDs are also the perfect choice if you're\nwriting some apocalypse-scenario software (assuming you have a working\ncomputer) as they can continue to be generated until 10,889AD compared to\nUUIDv7s measly 4,147AD death date.\n\n##\n\nlink\n\nThe main differences between UUIDv7 and ULID are:\n\n  * UUIDv7\n  * UUIDv7 will work until 4,147AD whereas ULID will work until 10,889AD\n\n##\n\nlink\n\nComparison\n\nFormat| Sortable| Monotonic| Randomness  \n---|---|---|---  \nUUIDv4| No| No| 122 bits  \nUUIDv7| Yes| Yes| 62 bits  \nULID| Yes| Yes| 80 bits*  \n  \n* - Random bits are incremented sequentially within the same millisecond.\n\n##\n\nlink\n\nImplementing UUIDs/ULIDs in PostgreSQL\n\ninfo_outline\n\nThis section is tailored to PostgreSQL, if you're using a different database\nengine then you'll need to look elsewhere to understand how to implement these\nkinds of primary keys.\n\nWhile all of these formats can be generated by the client before inserting\nthem into the database, for the purpose of simplicity and consistency, having\nthem be generated within the database engine is preferred.\n\nThankfully, PostgreSQL includes a uuid data type which accepts a case\ninsentive 128-bit hexadecimal string, parses it into binary data and stores it\nas 16 bytes of data. This is drastically better than storing the value as a\nstring in the database, which would take up 37 bytes of space including the\ndashes, or 33 bytes of space with the dashes stripped out.\n\nHere are some implementation details for populating those uuid columns and\nsetting up tables with UUID/ULID primary keys:\n\n###\n\nlink\n\nUUIDv4\n\nPostgreSQL has built in support for UUIDv4 through the pgcrypto or the uuid-\nossp extensions.\n\n    \n    \n    CREATE EXTENSION IF NOT EXISTS pgcrypto; SELECT gen_random_uuid(); --> f449a5bc-a221-4e9d-8819-e7f22b83d8ae\n\nThis makes it extremely easy to setup a table with a UUIDv4 primary key:\n\n    \n    \n    CREATE TABLE my_uuidv4_things( id UUID NOT NULL DEFAULT gen_random_uuid(), name TEXT NOT NULL, PRIMARY KEY (id) ); INSERT INTO my_uuidv4_things(name) VALUES ('foo'); SELECT * FROM my_uuidv4_things; -- id | name ----------------------------------------+------ -- 8501364b-b669-4c17-bd98-00bad8cd8f7d | foo\n\n###\n\nlink\n\nUUIDv7\n\nThere don't seem to be any existing built-in or extension functions that\nsupport generating UUIDv7s in PostgreSQL. To generate a UUIDv7, the function\nbelow could be tweaked in order to support the correct formatting.\n\n###\n\nlink\n\nULID\n\nThere are a few different implementations of ULIDs in Go, or in plsql.\nHowever, both of these implementations return the Crockford Base 32 text\nrepresentation of ULID (taking up 26 bytes), instead of as a UUID datatype\n(taking up 16 bytes). Due to the natural multiplexing nature of PostgreSQL\n(and relational databases in general), having a consistent, shared monotonic\ncounter is difficult, if not impossible. The Go library used by the Go\nPostgreSQL implementation includes an implementation of the monotonic counter,\nhowever, it's not used by the Go PostgreSQL extension. The plsql\nimplementation doesn't have a monotonic counter at all.\n\nI wanted a simple ULID PostgreSQL implementation without the complexity of the\nmonotonic counter that generated a UUID data typed value. So I wrote one:\n\n    \n    \n    CREATE EXTENSION IF NOT EXISTS pgcrypto; CREATE OR REPLACE FUNCTION generate_ulid() RETURNS uuid AS $$ SELECT (lpad(to_hex(floor(extract(epoch FROM clock_timestamp()) * 1000)::bigint), 12, '0') || encode(gen_random_bytes(10), 'hex'))::uuid; $$ LANGUAGE SQL; SELECT generate_ulid(); --> 017eb31e-1440-b69e-d82f-5f0937f823c8\n\nBreaking down the function:\n\n  * The first half lpad(to_hex(floor(extract(epoch FROM clock_timestamp()) * 1000)::bigint), 12, '0') gets the milliseconds since the Unix Epoch, and converts it to a hexadecimal string of length 12 (it'll have a leading 0 for the next 500 years or so).\n  * The second half encode(gen_random_bytes(10), 'hex') generates 10 random bytes and converts them to hexadecimal.\n\nTogether these make the 16-byte (or 128-bit) ULID label, which is finally cast\nto a UUID data type with ::uuid.\n\nOur new function can now be used as a default value for a primary key:\n\n    \n    \n    CREATE TABLE my_ulid_things( id UUID NOT NULL DEFAULT generate_ulid(), name TEXT NOT NULL, PRIMARY KEY (id) ); INSERT INTO my_ulid_things(name) VALUES ('foo'); SELECT * FROM my_ulid_things; -- id | name ----------------------------------------+------ -- 017eb31e-1440-b69e-d82f-5f0937f823c8 | foo\n\n##\n\nlink\n\nBenchmarks\n\nWhen compared to the native implementation of gen_random_uuid(),\ngenerate_ulid() performs 73% slower when generating 10 million values, but\nonly 31% slower when generating and inserting 1 million values.\n\nMeaning that while ULIDs are slower to generate (at least with this\nimplementation), they are much faster to insert. My guess is that due to the\nsequential and highly clustered significant bytes of the ULIDs, they are much\nfaster to create the index entries for. Meanwhile, the UUIDv4s are extremely\nsparse, so they are much slower to create the index entries for.\n\nHere's how I got these numbers:\n\n    \n    \n    createdb ulid-test\n    \n    \n    generate-benchmark.sql\n    \n    \n    EXPLAIN ANALYSE SELECT gen_random_uuid() FROM generate_series(1, 10000000); -- 6766.681ms EXPLAIN ANALYSE SELECT generate_ulid() FROM generate_series(1, 10000000); -- 11750.966ms\n    \n    \n    generate-insert-benchmark.sql\n    \n    \n    CREATE TABLE uuid_keys(id UUID); CREATE TABLE ulid_keys(id UUID); EXPLAIN ANALYSE INSERT INTO uuid_keys(id) SELECT gen_random_uuid() FROM generate_series(1, 1000000); -- 1372.470ms EXPLAIN ANALYSE INSERT INTO ulid_keys(id) SELECT generate_ulid() FROM generate_series(1, 1000000); -- 1803.472ms\n\n##\n\nlink\n\nConclusion\n\nULIDs are slower than their counterparts. For me, the benefits of a sortable\nglobally unique identifier make the tradeoff worth it.\n\nBack to Home\n\n", "frontpage": true}
