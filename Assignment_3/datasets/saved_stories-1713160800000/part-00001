{"aid": "40035636", "title": "Dumping Parallel NAND with Glasgow", "url": "https://colinoflynn.com/2024/04/dumping-parallel-nand-with-glasgow/", "domain": "colinoflynn.com", "votes": 3, "user": "vitplister", "posted_at": "2024-04-14 23:57:57", "comments": 0, "source_title": "Dumping Parallel NAND with Glasgow", "source_text": "Dumping Parallel NAND with Glasgow \u2013 Colin O'Flynn\n\nSkip to content\n\nColin O'Flynn\n\nEmbedded Security, Electronics & More!\n\n## Posts Index\n\nCircuit Cellar Articles\n\nExperimenting with Metastability and Multiple Clocks on FPGAs\n\nFPGA Board Design Tips\n\nProgrammable Logic in Practice\n\nCircuit Cellar 25th Anniversary Edition\n\nDesign a FIR Filter in an FPGA in 30 mins using High Level Synthesis\n\nElectronics & Production\n\nIntel LGA1700 (12th/13th gen, i9 3900k) Top Resistors/Capacitors\n\nAnalog Discover Pro Teardown\n\nMeatBag PnP - Simple Pick-n-Place\n\nA Low-Cost X-Y Scanner using 3D Printer\n\nLow-Cost SMD Soldering Setup\n\nESC SV 2015 - USSSSSB: Talking USB From Python\n\nExperiments with Seek Thermal Camera\n\nUSB Inrush Testing\n\nDriver Signing Notes\n\nSMD Solder Paste Stencil Creation with Silhouette Cameo\n\nHackaday Project and Latest Circuit Cellar Columns\n\nEELive! (ESC) Conference Slides + Programs\n\nSelecting an Oscilloscope\n\nMaking a USB-HID Keyboard Encoder Board for PicoScope\n\nMaking a Simple Scope Probe Holder\n\nSplit Ground Plane: Example of failing high-speed signals\n\nBed of Nails Test Bed\n\nJCOP\n\nQTabWidget in PySide Automatically Resize\n\nAtMega Card (Funcard) SmartCard Programming & Fuse Setup\n\nGetting started with GIT Revision Control\n\nHigh-Speed ADC with Variable Gain Amp Input\n\nAvnet Spartan-6 LX9 Board: Or How ChipScope is your Saviour\n\nTurbo Coding Tutorial\n\nLPCXpresso LPC1114 J4 JTAG Pinout\n\nInterfacing to 34401A\n\nCompass Circles\n\nMaking AT90USBKEY Run on 5V (Easy Way)\n\nFIP is IPv6 Ready\n\nFIP - The Flexible IP(v6) Stack\n\nAddition of IMU / MLX90609 Code\n\nMoving electronics projects from old site\n\nUpdated 15dot4-tools\n\nHardware Hacking\n\nDumping Parallel NAND with Glasgow\n\nRECON 2023: Adventures of My Oven (Pinocchio) with ChipWhisperer\n\nNew England Hardware Security Day 2022 Talk\n\nApple AirTag Teardown & Test Point Mapping\n\nBAM BAM!! On Reliability of EMFI for in-situ Automotive ECU Attacks\n\nSquare Terminal Teardown\n\nAmazon Echo Dot Gen 3 - Microphone Disable Circuitry\n\nA Call for Time Travel Resistant Cryptography (TTRC)\n\nUSB Triggering & Hacking\n\nFICHSA ChipWhisperer Tutorial Requirements\n\nGlitching Trezor using EMFI Through The Enclosure\n\nEmbedded World 2019 Conference Talk\n\nMore Research, More Fun - I'm now an Assistant Professor\n\nBreaking Electronic Door Locks Like You're on CSI: Cyber - Black Hat 2017 Talk\n\nPhD Thesis Finally Done\n\nPhilips Hue, AES-CCM, and more!\n\nPhilips Hue - R.E. Whitepaper from Black Hat 2016\n\nBlack Hat Slides - PIN-Protected HD Enclosure / MB86C311A Research\n\nGetting Root on Philips Hue Bridge 2.0\n\nSECT-2015 Talk Slides\n\nDEFCON Talk Slides\n\nSide-Channel Power Analysis of AES Core in Project Vault\n\nAtlSecCon Presentation Slides\n\nBreaking IEEE 802.15.4 Networks: Paper/Presentation\n\nProduct Reviews\n\nRigol DP832 Review\n\nPicoScope 2204A Review\n\nPicoScope 5000 (5444) Review\n\nPicoScope 6000 (6403D) Review & Comparison\n\nQuit wasting time debugging USB: Using TotalPhase Triggers\n\nMetcal MX-500P Soldering Station Review & Repair\n\nSpringer / SpringerLink MyCopy Review\n\nSteam Engine\n\nDanni Build - Feb 11/23\n\nUncategorized\n\nNova Scotia Embarrassment -\n\nNew Site Layout Live\n\nSplitting of NewAE & ColinOflynn.com\n\nMeet me Live, Site Updates, and Book Updates\n\nTikiWiki Upgrade\n\nArticles Posted\n\nYouTube Posts\n\nSquare Terminal Teardown\n\nAmazon Echo Dot Gen 3 - Microphone Disable Circuitry\n\n## PAGES INDEX\n\n## Tags\n\n## From the Blog\n\n# Dumping Parallel NAND with Glasgow\n\nI recently got my Glasgow device, which is a rather impressive piece of tech.\nI followed the Windows installation instructions and it \u201cJust Worked\u201d,\nincluding installing the toolchain! On one computer I needed to use Zadig to\nforce the driver to be libusbK, but on another Windows computer it wasn\u2019t\nneeded. In this blog post, I\u2019m going to explore a parallel NAND device that I\nwanted to dump, and find out how well Glasgow works.\n\n## About Parallel NAND & Mounting\n\nThe first step was mounting the FLASH chip. The chip in question\n(MT29F4G08ABBDA3W) is a dual-package DDR and NAND flash device. I did this\ndead-bug style, using a pinout map I printed out and mirrored to make it\neasier for me to tack wires onto each one:\n\nFor each row I used kaptop tape to hold down the previous row, so I didn\u2019t\nhave to worry about knocking previously soldered wires off. I also only\nconnected one GND & VCC pin \u2013 the NAND portion only had a couple VCC pins\nanyway, but it was even easier if I could only connect a single one. Here\u2019s a\nphoto of this part-way. Notice I only expose a single row of pads to make tit\neasier to solder to only the right pads. Once a row is done I cover it with\nkapton tape, which protects it from the next layer of soldering, in addition\nto giving it more mechanical strength. The wire is an enamel coated wire with\na low temperature insulation that will melt off soldering iron heat.\n\nIn Glasgow you\u2019ll see reference to Open NAND Flash Interface (ONFI). If you do\na search of the datasheet ONFI might not show up, but if you check the\ndatasheet you\u2019ll see that it supports ONFI as this is part of the\nidentification:\n\n## Glasgow parallel NAND support\n\nAs described above, these devices are described as ONFI. I used the glasgow\nmemory-onfi command. Here is the help output showing everything you\u2019ll need to\nuse it:\n\n    \n    \n    usage: glasgow run memory-onfi [-h] [--port SPEC] [--pins-io SET] [--pin-cle NUM] [--pin-ale NUM] [--pin-re NUM] [--pin-we NUM] [--pin-r-b NUM] [--pins-ce SET] (-V [VOLTS] | -M | --keep-voltage) [-c CHIP] [-P SIZE] [-S SIZE] [-B SIZE] OPERATION ... This applet is PREVIEW QUALITY and may CORRUPT DATA or have missing features. Use at your own risk. Identify, read and write memories compatible with ONFI NAND Flash memory. The applet roughly follows the ONFI 1.0 specification, but tolerates the very common non-ONFI- compliant memories by gracefully degrading autodetection of memory functionality. Only the asynchronous NAND interface is supported. All R/B# pins should be tied together, and externally pulled up. All CE# pins must be either connected or pulled high to avoid bus contention; for unidentified devices, this means all 4 CE# pins available on the package. The NAND Flash command set is not standardized in practice. This applet uses the following commands when identifying the memory: * Cmd 0xFF: Reset (all devices) * Cmd 0x90 Addr 0x00: Read ID, JEDEC Manufacturer and Device (all devices) * Cmd 0x90 Addr 0x20: Read ID, ONFI Signature (ONFI and some non-ONFI devices) * Cmd 0xEC: Read Parameter Page (ONFI only) If the memory doesn't respond or gives invalid response to ONFI commands, it can still be used, but the array parameters need to be specified explicitly. The applet use the following commands while reading and writing data: * Cmd 0x70: Read Status (all devices) * Cmd 0x00 Addr Col1..2,Row1..3 Cmd 0x30: Read (all devices) * Cmd 0x60 Addr Row1..3 Cmd 0xD0: Erase (all devices) * Cmd 0x80 Addr Col1..2,Row1..3 [Cmd 0x85 Col1..2]+ Cmd 0x10: Page Program (all devices) positional arguments: OPERATION identify identify device using ONFI parameter page read read data and spare contents for a page range program program data and spare contents for a page range erase erase any blocks containing a page range options: -h, --help show this help message and exit -P SIZE, --page-size SIZE Flash page (without spare) size, in bytes (default: autodetect) -S SIZE, --spare-size SIZE Flash spare size, in bytes (default: autodetect) -B SIZE, --block-size SIZE Flash block size, in pages (default: autodetect) build arguments: --port SPEC bind the applet to port SPEC (default: AB) --pins-io SET bind the applet I/O lines 'io' to pins SET (default: 0,1,2,3,4,5,6,7) --pin-cle NUM bind the applet I/O line 'cle' to pin NUM (default: 8) --pin-ale NUM bind the applet I/O line 'ale' to pin NUM (default: 9) --pin-re NUM bind the applet I/O line 're' to pin NUM (default: 10) --pin-we NUM bind the applet I/O line 'we' to pin NUM (default: 11) --pin-r-b NUM bind the applet I/O line 'r_b' to pin NUM (default: 12) --pins-ce SET bind the applet I/O lines 'ce' to pins SET (default: 13,14) run arguments: -V [VOLTS], --voltage [VOLTS] set I/O port voltage explicitly -M, --mirror-voltage sense and mirror I/O port voltage --keep-voltage do not change I/O port voltage -c CHIP, --chip CHIP select chip connected to CE# signal CHIP (one of: 1..4, default: 1)\n\nThe important part is the pin numbering. You can change where pins connect to,\nbut since I was just wiring my board up using fly wires, I followed their\nsuggested example pins. Note that pin 8 = B0, 9 = B1, etc in this example. I\nalso had wired out the LOCK pin, which the datasheet says you can just ignore.\n\nWatch the RB pin \u2013 you need a pull-up on this pin, as it\u2019s open-drain by\ndefault. I used a 2.2K resistor and pulled it up using the VCC connection from\nthe B port. At this point my setup looks something like this:\n\nNice! Now with great hope in our heart we run the identify command. I\u2019ll save\nyou some space and tell you to also include the verbose output, like this:\nglasgow -v run memory-onfi -V 1.8 identify\n\n    \n    \n    $ glasgow -v run memory-onfi -V 1.8 identify D: glasgow.device.hardware: found revC3 device with serial C3-20240303T140525Z D: glasgow.applet.memory.onfi: claimed pipe P and port(s) A, B D: glasgow.applet.memory.onfi: adding reset register at address 0x00 D: glasgow.applet.memory.onfi: assigning pin 'cle' to device pin B0 D: glasgow.applet.memory.onfi: assigning pin 'ale' to device pin B1 D: glasgow.applet.memory.onfi: assigning pin 're' to device pin B2 D: glasgow.applet.memory.onfi: assigning pin 'we' to device pin B3 D: glasgow.applet.memory.onfi: assigning pin 'r_b' to device pin B4 D: glasgow.applet.memory.onfi: assigning pin set 'io' to device pins A0, A1, A2, A3, A4, A5, A6, A7 D: glasgow.applet.memory.onfi: assigning pin set 'ce' to device pins B5, B6 D: glasgow.target.toolchain: using toolchain 'builtin' (yosys 0.39.0.0.post694, nextpnr-ice40 0.7.0.0.post519, icepack 0.7.0.0.post519) I: glasgow.device.hardware: generating bitstream ID 18adf47dd70eb39c986fdd271f431495 D: glasgow.target.hardware: bitstream ID 18adf47dd70eb39c986fdd271f431495 is cached I: glasgow.cli: running handler for applet 'memory-onfi' W: glasgow.cli: applet 'memory-onfi' is PREVIEW QUALITY and may CORRUPT DATA I: glasgow.applet.memory.onfi: port(s) A, B voltage set to 1.8 V D: glasgow.applet.memory.onfi: port(s) A, B pull resistors disabled D: glasgow.applet.memory.onfi: ONFI: select chip=0 D: glasgow.applet.memory.onfi: ONFI: reset D: glasgow.applet.memory.onfi: ONFI: command=0xff D: glasgow.applet.memory.onfi: ONFI: r/b wait D: glasgow.applet.memory.onfi: ONFI: select chip=1 D: glasgow.applet.memory.onfi: ONFI: reset D: glasgow.applet.memory.onfi: ONFI: command=0xff D: glasgow.applet.memory.onfi: ONFI: r/b wait D: glasgow.applet.memory.onfi: ONFI: select chip=0 D: glasgow.applet.memory.onfi: ONFI: read ID addr=0x00 D: glasgow.applet.memory.onfi: ONFI: command=0x90 address=<00> D: glasgow.applet.memory.onfi: ONFI: read data=<2cac> I: glasgow.applet.memory.onfi: JEDEC manufacturer 0x2c (Micron Technology) device 0xac D: glasgow.applet.memory.onfi: ONFI: read ID addr=0x00 D: glasgow.applet.memory.onfi: ONFI: command=0x90 address=<00> D: glasgow.applet.memory.onfi: ONFI: read data=<2cac9015> I: glasgow.applet.memory.onfi: ID signature: 2c ac 90 15 D: glasgow.applet.memory.onfi: ONFI: read ID addr=0x20 D: glasgow.applet.memory.onfi: ONFI: command=0x90 address=<20> D: glasgow.applet.memory.onfi: ONFI: read data=<4f4e4649> D: glasgow.applet.memory.onfi: ONFI: read parameter page copies=3 D: glasgow.applet.memory.onfi: ONFI: command=0xec address=<00> D: glasgow.applet.memory.onfi: ONFI: r/b wait D: glasgow.applet.memory.onfi: ONFI: read data=<4f4e4649020018003f000000000000000000000000000000000000000000004d4943524f4e2020202020204d543239463447303841424244413357202020202c... (768 bytes total)> W: glasgow.applet.memory.onfi: invalid ONFI parameter page: integrity checks failed on all redundant pages E: glasgow.applet.memory.onfi: cannot identify non-ONFI device\n\nHmm, what happened? That data looks \u201cpretty valid\u201d, but not quite there? Lets\ndig into Glasgow to see how we can get more information about what happened.\n\n## Modifying Glasgow Applets\n\nAfter following the Glasgow instructions, I had my copy of glasgow cloned from\ngit into a directory. But I was running Glasgow at the command line just like\nany other tool. Luckily because Glasgow was installed in \u201ceditable\u201d mode, it\nwill use my cloned files to run my commands. So any changes we make to the\nsource Python are reflected immediately in our tool.\n\nI\u2019ll make a few changes to two files to help with my debugging. If you want to\nfollow along, the files for reference are (GitHub links):\nhttps://github.com/GlasgowEmbedded/glasgow/blob/main/software/glasgow/applet/memory/onfi/__init__.py\nhttps://github.com/GlasgowEmbedded/glasgow/blob/main/software/glasgow/protocol/onfi.py\n\nIt\u2019s the latter one that includes the CRC check that is failing. At line 101\nat the linked checkout (may have changed on current main), there is a CRC\ncheck. I forced it to print the *entire* failing CRC by adding lines 103-105:\n\n    \n    \n    101: if crc_expected == crc_actual: 102: break 103: else: 104: print(\"%x != %x\"%(crc_actual, crc_expected)) 105: print(\" \".join([\"%02x\"%d for d in data[:254]]))\n\nThis gave me the following debug output:\n\n    \n    \n    4e2020202020204d543239463447303841424244413357202020202c... (768 bytes total)> ef01 != 4f0c 4f 4e 46 49 02 00 18 00 3f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 4d 49 43 52 4f 4e 20 20 20 20 20 20 4d 54 32 39 46 34 47 30 38 41 42 42 44 41 33 57 20 20 20 20 2c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 00 00 40 00 00 02 00 00 10 00 40 00 00 00 00 10 00 00 01 23 01 50 00 01 05 01 00 00 04 00 04 01 0e 00 00 00 00 00 00 00 00 00 00 00 00 00 0a 1f 00 1f 00 58 02 b8 0b 19 00 64 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 01 00 00 02 04 80 01 81 04 01 02 01 0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 72 99ec != 4e4f 4e 46 49 02 00 18 00 3f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 4d 49 43 52 4f 4e 20 20 20 20 20 20 4d 54 32 39 46 34 47 30 38 41 42 42 44 41 33 57 20 20 20 20 2c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 00 00 40 00 00 02 00 00 10 00 40 00 00 00 00 10 00 00 01 23 01 50 00 01 05 01 00 00 04 00 04 01 0e 00 00 00 00 00 00 00 00 00 00 00 00 00 0a 1f 00 1f 00 58 02 b8 0b 19 00 64 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 01 00 00 02 04 80 01 81 04 01 02 01 0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 72 0c 7546 != 464e 46 49 02 00 18 00 3f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 4d 49 43 52 4f 4e 20 20 20 20 20 20 4d 54 32 39 46 34 47 30 38 41 42 42 44 41 33 57 20 20 20 20 2c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 00 00 40 00 00 02 00 00 10 00 40 00 00 00 00 10 00 00 01 23 01 50 00 01 05 01 00 00 04 00 04 01 0e 00 00 00 00 00 00 00 00 00 00 00 00 00 0a 1f 00 1f 00 58 02 b8 0b 19 00 64 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 01 00 00 02 04 80 01 81 04 01 02 01 0a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 72 0c 4f\n\nWhat\u2019s going on here? While the issue is that we\u2019ve actually *dropped* a byte.\nIn the first sequence of 00\u2019s it is one 00 byte short! If you hack the source\nto insert an extra zero byte at that location, it will \u201cjust work\u201d. How do we\nactually fix it though?\n\nOne thing you could try is to modify the Glasgow applet to increase the wait\ncycles, you can see right here. If you change that constant and rerun glasgow,\nyou\u2019ll see a FPGA build happen. It\u2019s amazing how quickly changes in \u201cRTL\u201d\nbecome real, and shows that there is a lot of power hidden in this system. But\nultimately that won\u2019t do much, because the root cause isn\u2019t something you can\neasily fix in RTL, but related to my physical board.\n\n### Adding Termination Resistors\n\nThe fact we were missing bytes was a bit of a red flag. The most likely\nscenario here is that the NAND chip actually output two bytes at some point,\nwhich suggested to me it was seeing two transitions on the read or write\nflags. Remember the NAND stuff is all asynchronous so if there is toggling on\nthe lines it will do the reads! And because my breakout board was so hacky it\nwould be hardy surprising!\n\nScoping the WE pin in combination with a random data pin (to also check timing\non the flag transition) suggested this was the case. Check out how much\nringing we are seeing:\n\nNot good! Wait cycles won\u2019t help us here, because it\u2019s the high slew rate in\ncombination with our long leads & very poorly constructed breakout board that\nis probably contributing to this. We need to slow down the slew rate, and the\neasiest way is some series resistors.\n\nNow I\u2019m too lazy to add resistors to all the pins, so I just added them to the\nones I thought would matter: the read & write flag pins, WE and RE. It\u2019s those\npins that if they have extra transitions will cause extra bytes to be clocked\nin (or out) of the device, which would mean bad things are going to happen to\nour device! Here\u2019s how the series resistors look now, there is just two\nresistors connected instead of directly to the glasgow on two pins:\n\nRunning identify is now much more satisfying:\n\n    \n    \n    I: glasgow.device.hardware: device already has bitstream ID 18adf47dd70eb39c986fdd271f431495 I: glasgow.cli: running handler for applet 'memory-onfi' W: glasgow.cli: applet 'memory-onfi' is PREVIEW QUALITY and may CORRUPT DATA I: glasgow.applet.memory.onfi: port(s) A, B voltage set to 1.9 V I: glasgow.applet.memory.onfi: JEDEC manufacturer 0x2c (Micron Technology) device 0xac I: glasgow.applet.memory.onfi: ID signature: 2c ac 90 15 I: glasgow.applet.memory.onfi: ONFI revision 1.0 I: glasgow.applet.memory.onfi: ONFI manufacturer information: I: glasgow.applet.memory.onfi: JEDEC ID: 0x2c (Micron Technology) I: glasgow.applet.memory.onfi: manufacturer: MICRON I: glasgow.applet.memory.onfi: model: MT29F4G08ABBDA3W I: glasgow.applet.memory.onfi: date code: (not specified) I: glasgow.applet.memory.onfi: Features: I: glasgow.applet.memory.onfi: data bus width: 8-bit I: glasgow.applet.memory.onfi: multi-LUN operations: no I: glasgow.applet.memory.onfi: block programming order: sequential I: glasgow.applet.memory.onfi: interleaved operations: yes I: glasgow.applet.memory.onfi: odd-to-even copyback: yes I: glasgow.applet.memory.onfi: Optional commands: I: glasgow.applet.memory.onfi: Page Cache Program: yes I: glasgow.applet.memory.onfi: Read Cache (Enhanced/End): yes I: glasgow.applet.memory.onfi: Get/Set Features: yes I: glasgow.applet.memory.onfi: Read Status Enhanced: yes I: glasgow.applet.memory.onfi: Copyback Program/Read: yes I: glasgow.applet.memory.onfi: Read Unique ID: yes I: glasgow.applet.memory.onfi: Memory organization: I: glasgow.applet.memory.onfi: page size: 2048 + 64 bytes I: glasgow.applet.memory.onfi: partial page size: 512 + 16 bytes I: glasgow.applet.memory.onfi: block size: 64 pages I: glasgow.applet.memory.onfi: LUN size: 4096 blocks; 262144 pages I: glasgow.applet.memory.onfi: target size: 1 LUNs; 4096 blocks; 262144 pages I: glasgow.applet.memory.onfi: address cycles: 3 row, 2 column I: glasgow.applet.memory.onfi: bits per cell: 1 I: glasgow.applet.memory.onfi: bad blocks per LUN: 80 (maximum) I: glasgow.applet.memory.onfi: block endurance: 100000 cycles (maximum) I: glasgow.applet.memory.onfi: guaranteed blocks: 1 (at target beginning) I: glasgow.applet.memory.onfi: guaranteed block endurance: 0 cycles I: glasgow.applet.memory.onfi: programs per page: 4 (maximum) I: glasgow.applet.memory.onfi: ECC correctability: 4 bits (maximum, per 512 bytes) I: glasgow.applet.memory.onfi: Electrical parameters: I: glasgow.applet.memory.onfi: I/O pin capacitance: 10 pF I: glasgow.applet.memory.onfi: timing modes: 0, 1, 2, 3, 4 I: glasgow.applet.memory.onfi: program cache timing modes: 0, 1, 2, 3, 4 I: glasgow.applet.memory.onfi: page program time: 600 us (maximum) I: glasgow.applet.memory.onfi: block erase time: 3000 us (maximum) I: glasgow.applet.memory.onfi: page read time: 25 us (maximum) I: glasgow.applet.memory.onfi: change column setup time: 100 us (minimum)\n\nCheck that \u201cLUN Size\u201d, and note there is a total of 262144 pages. We\u2019ll need\nthat number when we go to dump out the entire flash. But first, let\u2019s check if\nit\u2019s actually working well (or well enough at least).\n\n### Dumping Reliably\n\nNow we\u2019ll run a dump of 1000 pages four times in a row, like this:\n\n    \n    \n    glasgow run memory-onfi -V 1.8 read 0 1000 test001.bin glasgow run memory-onfi -V 1.8 read 0 1000 test002.bin glasgow run memory-onfi -V 1.8 read 0 1000 test003.bin glasgow run memory-onfi -V 1.8 read 0 1000 test004.bin\n\nThen run a diff between the files to check if they are the same (or not). In\nmy case I still had some issues, and it still looked like occasionally\ndropping bytes (I used the 010 Editor compare mode to see this, as it does a\ngood job of showing inserted/skipped bytes). Rather than fix the SI issues\n(the right answer) I hacked up some software. To do this, I modified the\napplet around line 709 to look like this:\n\n    \n    \n    while count > 0: self.logger.info(\"reading page (row) %d\", row) chunk = await onfi_iface.read(column=0, row=row, length=page_size + spare_size) chunk1 = await onfi_iface.read(column=0, row=row, length=page_size + spare_size) chunk2 = await onfi_iface.read(column=0, row=row, length=page_size + spare_size) chunk3 = await onfi_iface.read(column=0, row=row, length=page_size + spare_size) if chunk == chunk1 == chunk2 == chunk3: pass else: self.logger.info(\"oops, multi-read failed, retrying...\") continue\n\nI should point out this can easily fail, since the error cases aren\u2019t random\nbut seem to be based on e.g., the data pattern resulting in more ringing. In\nmy case I didn\u2019t need a clean dump but wanted to check if root password were\nconstant or not between units, so I was happy enough to accept some corrupted\ndata as a risk. You may want to experiment more with the series resistors,\ndecoupling caps, or connecting more of the VCC/GNDs to improve your\nexperience!\n\n    \n    \n    glasgow run memory-onfi -V 1.8 read 0 262144 flash_dump.bin\n\nAnd finally you can work through it with binwalk. In my case though I didn\u2019t\nneed such fancy stuff, just a simple:\n\nstrings flash_dump.bin | grep '\\$1\\$'\n\nDumped out the hash of the root password. I did try a few different dumps to\nreduce the chance my one section was corrupted! But I\u2019m going to combine this\nwith some JTAG work to access the FLASH a second way, a topic for another blog\npost.\n\nPosted on April 14, 2024April 14, 2024Author Colin O'FlynnCategories Hardware\nHackingTags glasgow, hardware hacking, nand flash, tutorial\n\n### Leave a Reply Cancel reply\n\nProudly powered by WordPress\n\n", "frontpage": true}
