{"aid": "40022772", "title": "U-root/CPU: CPU command in Go, inspired by the Plan 9 CPU command", "url": "https://github.com/u-root/cpu", "domain": "github.com/u-root", "votes": 4, "user": "rcarmo", "posted_at": "2024-04-13 12:39:26", "comments": 0, "source_title": "GitHub - u-root/cpu: cpu command in Go, inspired by the Plan 9 cpu command", "source_text": "GitHub - u-root/cpu: cpu command in Go, inspired by the Plan 9 cpu command\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nu-root / cpu Public\n\n  * Notifications\n  * Fork 28\n  * Star 225\n\ncpu command in Go, inspired by the Plan 9 cpu command\n\n### License\n\nBSD-3-Clause license\n\n225 stars 28 forks Branches Tags Activity\n\nStar\n\nNotifications\n\n# u-root/cpu\n\nThis commit does not belong to any branch on this repository, and may belong\nto a fork outside of the repository.\n\n10 Branches\n\n0 Tags\n\n## Folders and files\n\nName| Name| Last commit message| Last commit date  \n---|---|---|---  \n  \n## Latest commit\n\nLencerfAdd flag -useKey for ssh without keysa1625e1 \u00b7\n\n## History\n\n326 Commits  \n  \n### .circleci\n\n|\n\n### .circleci\n\n| Replace multierror.Append with errors.Join  \n  \n### .github/workflows\n\n|\n\n### .github/workflows\n\n| Set up the github workflow to build across 4 architectures (#260)  \n  \n### client\n\n|\n\n### client\n\n| Add flag -useKey for ssh without keys  \n  \n### cmds\n\n|\n\n### cmds\n\n| Add flag -useKey for ssh without keys  \n  \n### configs\n\n|\n\n### configs\n\n| add a config for 5.4.0  \n  \n### doc/img\n\n|\n\n### doc/img\n\n| README: add photo of IP camera robots  \n  \n### ds\n\n|\n\n### ds\n\n| ds: fix staticcheck warnings (#262)  \n  \n### mount\n\n|\n\n### mount\n\n| rename and fix a broken test  \n  \n### p9cpu\n\n|\n\n### p9cpu\n\n| build(deps): bump mio from 0.8.6 to 0.8.11 in /p9cpu (#265)  \n  \n### server\n\n|\n\n### server\n\n| Add flag -useKey for ssh without keys  \n  \n### session\n\n|\n\n### session\n\n| \"revert\" 4781f0e (allow setting tmpMnt)  \n  \n### .gitignore\n\n|\n\n### .gitignore\n\n| Add go, gox, and docker build targets  \n  \n### Dockerfile\n\n|\n\n### Dockerfile\n\n| Merge decentralized cpud to cpud (#237)  \n  \n### LICENSE\n\n|\n\n### LICENSE\n\n| Add a LICENSE file  \n  \n### Makefile\n\n|\n\n### Makefile\n\n| Merge decentralized cpud to cpud (#237)  \n  \n### README.md\n\n|\n\n### README.md\n\n| README: add notes on and demo of cpu over USB (#245)  \n  \n### TESTCPU\n\n|\n\n### TESTCPU\n\n| TESTCPU: while we're at it, clean up serial usage  \n  \n### TESTDOCKERCPU\n\n|\n\n### TESTDOCKERCPU\n\n| Add dnssd support to cpu (#6)  \n  \n### go.mod\n\n|\n\n### go.mod\n\n| build(deps): bump golang.org/x/crypto from 0.14.0 to 0.17.0 (#259)  \n  \n### go.sum\n\n|\n\n### go.sum\n\n| build(deps): bump golang.org/x/crypto from 0.14.0 to 0.17.0 (#259)  \n  \n## Repository files navigation\n\n# cpu\n\nThis repo is an implementation the Plan 9 cpu command, both client and server,\nfor Linux. More detail is available in the CPU chapter of the LinuxBoot book.\nUnlike the Plan 9 command, this version uses the ssh protocol for the\nunderlying transport. It includes features familiar to ssh users, such as\nsupport for the ssh config file.\n\n## Overview\n\nThe cpu command lets you log in from a local system to a remote system and see\nsome or all of the files (how much is up to you) from the local system.\n\nThis is wonderfully convenient for embedded systems programmers. Because some\nor all the files can come from your local machine, including binaries, the\nonly thing you need installed on the remote machine is the cpu daemon itself.\n\n### Motivation\n\nConsider the case of running a complex Python program on an embedded system.\nWe will need to either do a full install of some distro on that system,\nmeaning we need USB ports and local storage; or we will need to run the\nprogram over the network.\n\nInstalling distros can turn into a mess. Some programs only work under\nspecific distros. In some cases, when two programs are needed in a pipeline,\nit can happen that they only work under different distros! Users are left\njuggling USB sticks and NVME cards, and this fails the first time there are\ntwo programs which need two different distros.\n\nRunning over a network is usually done with ssh, but ssh can not supply the\nprograms and files. We would need to either set up a network file system,\nmeaning finding a sysadmin willing to set it up, and keep it working; or,\ntrying to figure out which files the program needs, and using rsync or scp to\nget them there. In some cases, the target system might not have enough memory\nto hold those files!\n\nCpu looks like ssh, but with an important difference: it also provides a file\ntransport so that the files your program needs are available via a 9p mount.\nFor example, if I have an embedded system named camera, and I need to read the\nflash with the flashrom command, I simply type:\n\n    \n    \n    cpu camera flashrom -r rom.img\n\nBreaking this down: cpu is the cpu command; camera is the host name; flashrom\nis the command to run; the options are to do a read (-r) into a file called\nrom.img.\n\nWhere does that file end up? In whatever of my home directories I ran the cpu\ncommand from. I need not worry about scp'ing it back, or any such thing; it's\njust there.\n\n### Building your own docker container\n\nYou can easily build your own docker container to try things out.\n\n    \n    \n    docker build -t \"${USER}/cpu:latest\" .\n\nor if you have installed a version of docker buildx, you can build a multi-\narch manifest container and push it to docker hub:\n\n    \n    \n    % docker login % docker buildx build --platform \"linux/amd64,linux/arm64,linux/arm/v7\" --progress plain --pull -t \"${USER}/cpu:latest\" .\n\n### Pre-built Docker container for trying out cpu (on arm64 & amd64 for now)\n\nWe have created a docker container so you can try cpu client and server:\n\n    \n    \n    ghcr.io/u-root/cpu:main\n\nIt includes both the cpud (server) and cpu (client) commands. In the\ncontainer, you only have access to date and cat commands, but that is enough\nto get the idea.\n\nYou will need keys. You can either use your own SSH keys that you use for\nother things, for example:\n\n    \n    \n    export KEY=~/.ssh/id_rsa export KEY=~/.ssh/a_special_key_for_this_docker\n\nor generate one and use it.\n\n    \n    \n    ssh-keygen -f key -t rsa -P \"\" export KEY=`pwd`/key\n\nNOTE! The name KEY is not required. Instead of KEY, you can use any name you\nwant, as long as you use it in the docker command below.\n\nTo start the cpud, you need docker installed. Once that is done, you need to\ncreate a docker network and start the daemon, with public and private keys.\nThe --mount option allows docker to provide the keys, using a bind mount for\nboth the private and public key. That is how we avoid storing keys in the\ncontainer itself.\n\n    \n    \n    docker network create cpud # If you ran docker before and it failed in some way, you may need to remove the # old identity (e.g. docker rm cpud_test) docker run --rm -v $KEY.pub:/key.pub -v $KEY:/key -v /tmp --name cpud_test --privileged=true -t -i -p 17010:17010 ghcr.io/u-root/cpu:main\n\nThen you can try running a command or two by using the embedded cpu client in\nthe docker container. NOTE: when you run cpu in this way, it does not\nimmediately have access to your host's file system, which means you won't be\nable to really leverage the back-mount and you'll have to artificially set\nenvironment variables (like PWD) so that the remote task can execute.\n\n    \n    \n    docker exec -it -e PWD=/root cpud_test /bin/cpu -key /key localhost /bin/date\n\nRemember, this cpu command is running in the container. You need to use the\nname /key in the container, not $KEY and you'll only be able to run binaries\nthat have been pre-loaded into the container (which in the public container is\n/bin/cat and /bin/date)\n\nTo see the mounts:\n\n    \n    \n    docker exec -it -e PWD=/root cpud_test /bin/cpu -key /key localhost /bin/cat /proc/mounts\n\nYou might want to just get a cpu command to let you talk to the docker cpud\ndirectly:\n\n    \n    \n    go install github.com/u-root/cpu/cmds/cpu@latest\n\nAnd now you can run\n\n    \n    \n    cpu -key $KEY localhost date\n\nNOTE: if you are running on OSX, remember that your cpud docker is linux, so\nif you try the above command you'll see:\n\n    \n    \n    $ cpu -key $KEY localhost date 2022/10/13 18:52:17 CPUD(as remote):fork/exec /bin/date: exec format error\n\nTo deal with that we'll have to play games with the namespace, which we'll\ncover next.\n\n### cpu on heterogeneous systems.\n\nThe cpu command sets up the various 9p mounts with a default namespace. Users\ncan override this default with the -namespace switch. The argument to the\nswitch looks like PATH variables, with comma-separated values, but with one\nextra option: users can, optionally, specify the local path and the remote\npath. This is useful when running ARM binaries hosted from an x86 system.\n\nIn the example below, we show starting up a bash on an ARM system (solidrun\nhoneycomb) using a cpu command running on an x86 system.\n\n    \n    \n    cpu -namespace /home:/bin=`pwd`/bin:/lib=`pwd`/lib:/usr=`pwd`/usr honeycomb /bin/bash\n\nBreaking this down, we set up the namespace so that:\n\n  * the remote /home is from our /home\n  * the remote /bin is from pwd/bin -- which, in this case, was an unpacked arm64 file system image\n  * the remote /lib is from pwd/lib\n  * the remote /usr is from pwd/usr\n\nWe can use the path /bin/bash, because /bin/bash on the remote points to\npwd/bin/bash on the local machine.\n\nWe can use the same trick to cpu to Linux from OSX, but instead of having an\nArm tree under pwd we'll need a Linux binary tree to pick binaries from.\n\n### cpu over USB\n\nThere are many IoT like devices that do not have an ethernet port. Fear not\nthough: The Linux USB gadget drivers offer ethernet via USB!\n\nThere are tutorials out there, and here is the gist:\n\n  * enable the Linux kernel options\n\n    * CONFIG_USB_GADGET\n    * CONFIG_USB_ETH\n    * CONFIG_USB_ETH_RNDIS (for Windows support)\n    * CONFIG_INET\n  * add the MAC addresses for your gadget device and the machine you connect to in the kernel CMDLINE, e.g., g_ether.dev_addr=12:34:56:78:9a:bc g_ether.host_addr=12:34:56:78:9a:bd\n\n## cpu will be familiar to ssh users\n\nAs mentioned, cpu looks and feels a lot like ssh, to the point of honoring ssh\nconfig files. For the honeycomb, for example, the ssh config entry looks like\nthis (we shorten the name to 'h' for convenience):\n\n    \n    \n    Host h HostName honeycomb Port 17010 User root IdentityFile ~/.ssh/apu2_rsa\n\nNote that the cpu command is itself a 9p server; i.e., your instance of cpu\nruns your server. The remote cpu server may run as root, but all file accesses\nhappen locally as you. Hence, the cpu command does not grant greater access to\nthe local machine than you already possess. I.e., there is no privilege\nescalation.\n\n## cpu and Docker\n\nMaintaining file system images is inconvenient. We can use Docker containers\non remote hosts instead. We can take a standard Docker container and, with\nsuitable options, use docker to start the container with cpu as the first\nprogram it runs.\n\nThat means we can use any Docker image, on any architecture, at any time; and\nwe can even run more than one at a time, since the namespaces are private.\n\nIn this example, we are starting a standard Ubuntu image:\n\n    \n    \n    docker run -v /home/rminnich:/home/rminnich -v /home/rminnich/.ssh:/root/.ssh -v /etc/hosts:/etc/hosts --entrypoint /home/rminnich/go/bin/cpu -it ubuntu@sha256:073e060cec31fed4a86fcd45ad6f80b1f135109ac2c0b57272f01909c9626486 h Unable to find image 'ubuntu@sha256:073e060cec31fed4a86fcd45ad6f80b1f135109ac2c0b57272f01909c9626486' locally docker.io/library/ubuntu@sha256:073e060cec31fed4a86fcd45ad6f80b1f135109ac2c0b57272f01909c9626486: Pulling from library/ubuntu a9ca93140713: Pull complete Digest: sha256:073e060cec31fed4a86fcd45ad6f80b1f135109ac2c0b57272f01909c9626486 Status: Downloaded newer image for ubuntu@sha256:073e060cec31fed4a86fcd45ad6f80b1f135109ac2c0b57272f01909c9626486 WARNING: The requested image's platform (linux/arm64/v8) does not match the detected host platform (linux/amd64) and no specific platform was requested 1970/01/01 21:37:32 CPUD:Warning: mounting /tmp/cpu/lib64 on /lib64 failed: no such file or directory # ls bbin buildbin env go init lib proc tcz ubin var bin dev etc home key.pub lib64 sys tmp usr #\n\nNote that the image was updated and then started. The /lib64 mount fails,\nbecause there is no /lib64 directory in the image, but that is harmless.\n\nOn the local host, on which we ran docker, this image will show up in docker\nps:\n\n    \n    \n    CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b92a3576229b ubuntu \"/home/rminnich/go/b...\" 9 seconds ago Up 9 seconds inspiring_mcnulty\n\nEven though the binaries themselves are running on the remote ARM system.\n\n## Testing with vsock\n\nVsock is a useful transport layer available in Linux, and support by at least\nQEMU.\n\nWe use the mdlayher/vsock package.\n\nIn the cpu and cpud, the switch\n\n    \n    \n    -net vsock\n\nwill enable vsock.\n\nIn the host kernel, you need vhost_vsock module:\n\n    \n    \n    sudo modprobe vhost_vsock\n\n.\n\nWhen starting qemu, add\n\n    \n    \n    -device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=3\n\nto the command line. The '3' is arbitrary; it just needs to be agreed upon on\nboth sides.\n\nWhen running a cpu command, the host name is the vsock guest-cid you specified\nin qemu:\n\n    \n    \n    cpu -net vsock 3 date\n\nIf you want a different port, you can use the same -sp switch you use for\nother network types.\n\n## De-centralized cpu with DNS-SD\n\nA variation of the cpu and cpud commands now exist which use dns-sd to\nautodiscover and register cpu resources. DNS-SD is a multi-cast DNS protocol\nthat will multi-cast out requests for resources and get responses from\nparticipating cpud nodes. Meta-data provides information such as architecture,\nOS, number of cores, free memory, load average, and number of existing cpu\nclients. When you start a decpud you can specify additional meta-data which\nmight be harder to auto-disocver such as near=storage, near=gateway, near=gpu,\nor secure=true (if running in a confidential computing domain).\n\nIn order to use this functionality, you can use decpu and decpud just as you\nwould cpu and cpud. decpud will enable dns-sd registration by default, and\nmulticast its information in response to requests. In order to use this from\ndecpu, you can just specify decpu without a hostname and, by default, it will\nfind the lowest loaded decpud with the same architecture and OS as the host\nyou run the decpu command from.\n\nYou can specify additional constraints by using a dns-sd URI formulation:\n\n    \n    \n    decpu dnssd://?requirement=value\\&otherrequirement=\\<othervalue\\&sort=tenet\n\nEssentially you can provide a set of key/value requirements that must be met\nin order for a decpud node to be considered. You can override the defaults\n(arch/os), or you can specify a minimum core count or minimum amount of free\nmemory. Numeric values can use comparison operators (< or >) Finally, you can\nspecify any number of numeric keys to sort based on. If you want to ignore one\nof the default requirements (e.g. arch, os) then you can set to a *:\n\n    \n    \n    decpu dnssd://?arch=\\*\\&os=\\*\n\nThis can be useful if what you are running is a script or an interpretive\nlanguage like python. If you are running on the shell, make sure you escape\nany characters the shell may have an interest in (<, >, !, &, *)\n\n### Runnign the DNS-SD tools inside Docker\n\nIn order to use dns-sd you have to be able to send/receive multicast. The\neasiest way to do this on Linux is to use host networking when you start your\ndocker containers (--network host). This unfortunately does not work on Mac\nOSX, so you will need to run a relay on your system that tunnels multicast\nto/from the docker network. The relay client can be run in every container or\nyou can start all dns-sd containers in the same docker network and start a\nrelay container client on that network to communicate for the group.\n\nThere is a container in the decent-e fork of the dnssd package:\nhttps://github.com/decent-e/dnssd under cmd/relay. Running relay will start\nthe server on the host, and running relay mode=client will start the client\ninside the docker container. You can also use a pre-build docker image (\ndocker pull ghcr.io/decent-e/dnssd:main ) to start the client in a docker.\n\nExample: (on mac)\n\n    \n    \n    # presumes you have already setup your $KEY appropriately % docker create network cpud % go install github.com/decent-e/dnssd/cmd/relay@latest % export PATH=$GOBIN:$PATH % relay & % docker run -d --network cpud ghcr.io/decent-e/dnssd:main % docker run -d --network cpud -v $KEY:/key -v $KEY.pub:/key.pub -v /tmp:/tmp --privileged --rm --name decpud ghcr.io/decent-e/cpu:decent-e /bin/decpud % docker exec -i -t -e PWD=/ decpud /bindecpu -key /key . /bin/date # you should also be able to see the service from your mac % dns-sd -B _ncpu._tcp Browsing for _ncpu._tcp DATE: ---Sun 09 Oct 2022--- 18:35:56.925 ...STARTING... Timestamp A/R Flags if Domain Service Type Instance Name 18:35:56.925 Add 3 17 local. _ncpu._tcp. d3c196958c24-cpud 18:35:56.925 Add 2 14 local. _ncpu._tcp. d3c196958c24-cpud\n\n## Summary\n\nThe cpu command makes using small embedded systems dramatically easier. There\nis no need to install a distro, or juggle distros; there is no need to scp\nfiles back and forth; just run commands as needed.\n\n## Development\n\nFor debugging, tcpdump is very handy. Read a short tutorial to get familiar\nwith it.\n\n## Further reading\n\n### Talks\n\n  * Short Talk \"building small stateless network-controlled appliances with coreboot/linuxboot and u-root\u2019s cpu command\"\n\n    * at Open Source Firmware Conference 2019 slides / recording\n    * at BARC2021 slides (PDF)\n  * Network Managed Processors at IoT World 2021\n  * \"Plan 9 CPU command, in Go, for Linux - the network is the computer -- for real this time\" at FOSDEM 2022\n  * \"Drivers From Outer Space at CLT 2022 - Fast, Simple Driver Development\"\n  * Short demo of Attaching CPUs via USB\n\n### History\n\nThe first version of cpu was developed for Plan 9, and is described here.\n\n## About\n\ncpu command in Go, inspired by the Plan 9 cpu command\n\n### Topics\n\ngolang cpu plan9\n\n### Resources\n\nReadme\n\n### License\n\nBSD-3-Clause license\n\nActivity\n\nCustom properties\n\n### Stars\n\n225 stars\n\n### Watchers\n\n49 watching\n\n### Forks\n\n28 forks\n\nReport repository\n\n## Releases\n\nNo releases published\n\n## Packages 1\n\n  * cpu\n\n## Contributors 15\n\n## Languages\n\n  * Go 58.9%\n  * Rust 39.4%\n  * Shell 1.1%\n  * Other 0.6%\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
