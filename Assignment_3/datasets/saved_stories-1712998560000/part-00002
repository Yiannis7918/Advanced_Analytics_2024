{"aid": "40019698", "title": "Rust proposal for ABI for higher-level languages", "url": "https://github.com/rust-lang/compiler-team/issues/631", "domain": "github.com/rust-lang", "votes": 1, "user": "oaimtiaz1", "posted_at": "2024-04-13 01:50:14", "comments": 0, "source_title": "Experimental feature gate for `extern \"crabi\"` ABI \u00b7 Issue #631 \u00b7 rust-lang/compiler-team", "source_text": "Experimental feature gate for `extern \"crabi\"` ABI \u00b7 Issue #631 \u00b7 rust-\nlang/compiler-team \u00b7 GitHub\n\nSkip to content\n\nSign in\n\n# Search code, repositories, users, issues, pull requests...\n\nSearch syntax tips\n\nSign in\n\nSign up\n\nYou signed in with another tab or window. Reload to refresh your session. You\nsigned out in another tab or window. Reload to refresh your session. You\nswitched accounts on another tab or window. Reload to refresh your session.\nDismiss alert\n\nrust-lang / compiler-team Public\n\n  * Notifications\n  * Fork 66\n  * Star 374\n\nJump to bottom\n\n# Experimental feature gate for extern \"crabi\" ABI #631\n\nClosed\n\n1 of 3 tasks\n\njoshtriplett opened this issue May 9, 2023 \u00b7 3 comments\n\nClosed\n\n1 of 3 tasks\n\n# Experimental feature gate for extern \"crabi\" ABI #631\n\njoshtriplett opened this issue May 9, 2023 \u00b7 3 comments\n\nLabels\n\nmajor-change A proposal to make a major change to rustc major-change-accepted\nA major change proposal that was accepted T-compiler Add this label so rfcbot\nknows to poll the compiler team\n\n## Comments\n\nMember\n\n###\n\njoshtriplett commented May 9, 2023 \u2022\n\nNote: This is a fairly long proposal, halfway to an eRFC, largely to lay out\nthe requirements and alternatives. It's been reviewed and approved by T-lang\nfrom a language experiment point of view, but not yet reviewed or approved by\nT-compiler. This MCP seeks approval for an experimental feature gate\nsupporting experimentation on an extern \"crabi\" and repr(crabi) ABI.There will\nneed to be a full RFC before this can be stabilized (or marked as a non-\nexperimental feature gate), and that full RFC will include the ABI spec. This\nproposal allows for experimentation to design and test that ABI spec.\n\n# Summary\n\nThis experimental feature gate proposal proposes developing a new ABI, extern\n\"crabi\", and a new in-memory representation, repr(crabi), for interoperability\nacross high-level programming languages that have safe data types.This will\nuse the feature gate crabi, which will be marked as experimental until a\nsubsequent RFC provides a precise definition of crABI.This work was previously\ndiscussed under the names \"safe ABI\" and \"interop ABI\", but was renamed to\n\"crabi\" to avoid misleadingly broad implications of \"safe\" or \"interop\".\n\n# Motivation\n\nToday, developers building projects incorporating multiple languages, or\ncalling a library written in one language from another, often have to use the\nC ABI as a lowest-common-denominator for cross-language function calls. As a\nresult, such cross-language calls use unsafe C representations, even for types\nthat both languages understand. For instance, passing a string from Rust to\nanother high-level language will typically use an unsafe C char *, even if\nboth languages have a safe type for counted UTF-8 strings.For popular pairs of\nlanguages, developers sometimes create higher-level binding layers for\ncombining those languages. However, the creation of such binding layers\nrequires one-off effort between every pair of programming languages. Such\nbinding layers also add work and overhead to the project for each pair of\nlanguages, and may not play well together when using more than one in the same\nproject.Furthermore, higher-level data types such as Option and Result\ncurrently require translation into C-ABI-compatible types, which discourages\nthe use of such types in cross-language interfaces, and encourages the use of\nmore complex and less safe encodings (e.g. manually encoding Option via an\ninvalid value of a parameter).Finally, system libraries and other shared\nlibraries typically use the C ABI as well. Software making a Linux .so,\nWindows DLL, or macOS dylib, will typically expose a C-compatible ABI, and\ncannot easily provide a higher-level safe ABI without shipping language-\nspecific high-level bindings.crABI will define a standard way to make calls\nacross high-level languages, passing high-level data types, without dropping\nto the lowest common denominator of C. crABI will work with any language\nproviding a C-compatible FFI (including C itself), and languages can also add\nspecific higher-level native support for crABI.crABI aims to be a reasonable\ndefault for compiled libraries in both static and dynamic form, including\nsystem libraries.\n\n# Requirements\n\nThe crABI experiment will include a new ABI, extern \"crabi\", and a new in-\nmemory representation, repr(crabi).The crABI support for Rust will be a strict\nsuperset of the C ABI support for Rust. This ensures that, for functionality\nnot yet supported by crABI, users still have the option of using their own\ntranslations to the raw C ABI, while still using crABI for what it does\nsupport.crABI will be defined via \"lowering\" to the C ABI: crABI will define\nhow to pass or return types not supported by C, by defining how to translate\nthem to types and structures supported by C. This allows any language with C\nFFI support to also call functions using crABI, without requiring special\nlanguage support. However, languages may still wish to add higher-level\nsupport for crABI, to avoid having to write a translation layer for their own\nnative types.To the extent crABI supports passing ownership (e.g. strings), it\nmust also specify how to reclaim the associated memory. (However, future\nsupport for objects or traits may require invoking a destructor instead.)crABI\ncould define a symbol naming scheme, to allow identifying symbols that use\ncrABI. However, crABI must be compatible with languages that only support C\nFFI and do not have native crABI support, and which must thus reference the\nsymbol via its name; therefore, crABI should not have a complex or non-obvious\nmangling scheme.crABI should include a versioning scheme, to allow for future\ncompatible extensibility. crABI version 1 will handle many simple cases of\nwidespread interest. More complex cases, such as trait objects, or arbitrary\nobjects with methods, will get deferred to future versions. The versioning\nscheme will allow for both compatible and incompatible changes; changes to\ncrABI will strive to remain compatible with previous versions when not using\nfunctionality unsupported by those previous versions.Rust will support\ndefining functions using crABI, and calling crABI functions defined elsewhere.\nRust will support compiling both static and dynamic libraries that export\ncrABI symbols.Rust should also support passing around function pointers to\nfunctions that use crABI.\n\n## Non-requirements\n\ncrABI does not aim to support the full richness of Rust's type system, or that\nof other languages. It aims to support common cases more safely and simply.In\nparticular, while crABI will over time support an increasing subset of Rust\nfeatures, and specific types from the standard library will become available\nas the necessary features to support them do, crABI does not aim to support\nthe entire Rust standard library.crABI will not aim to support complex\nlifetime handling, or to fully solve problems related to describing pointer\nlifetimes across different languages. crABI may provide limited support for\nsome subsets of this, such as \"this pointer is only valid for the duration of\nthis call and must not be retained\", or \"this pointer transfers ownership to\nthe callee, and the caller must not retain it\".crABI (at least in the first\nversion) will not provide an interface description language (IDL), in either\nsource or compiled form; function symbols using crABI will not provide\nfunction signature information in compiled objects. A future version of crABI\nmay generate and provide machine-readable interface descriptions.crABI does\nnot aim to provide \"translations\" between the most native representations of\ndifferent languages. For instance, though different languages may store\nstrings in different fashions, crABI string types will have a specific\nrepresentation in memory and a specific lowering to C function\nparameters/results. Languages whose native string representation does not\nmatch crABI string representation may need to translate, or may need to treat\nthe crABI string object as a distinct data type and provide distinct\nmechanisms for working with it. (By contrast, WebAssembly Interface Types\n(WIT) aims to provide such translations in an efficient fashion, by generating\ntranslation code as needed between formats.)crABI cannot support arbitrary\ncompile-time generic functions; generics will require the use of opaque\nobjects, trait objects, or similar. A future version could support exporting\nspecific instantiations of generics. (However, crABI will support enough of\ngenerics to allow types like Option<u64> or Result<u64, ConcreteError> or [u8;\n16] or [u8] to work, such as by supporting their use with concrete types as\nlong as no generic parameters remain unbound in the final function\nsignature.)crABI cannot prevent callers from passing parameters that violate\nthe specification, and does not claim to. More generally, crABI does not\nprovide sandboxing or similar functionality that would be required to\ninteroperate with untrusted code.The initial version of crABI will likely not\nattempt to standardize destructors or memory reclamation, though future\nversions may. Users of crABI will still need to provide and use xyz_free\nfunctions to delegate object destruction and reclamation back to the code that\nprovided the object.\n\n# Potential functionality\n\nThis section includes some potential examples of types crABI could support.\nSome of these will appear in the first version of crABI; many will get\ndeferred to a future version.\n\n  * Tuples, of arbitrary size.\n  * The \"unit\" type ().\n  * enums, including enum variants containing fields.\n    * More specifically, Option and Result.\n  * Counted UTF-8 strings, (with no guarantee of a NUL terminator).\n  * A Unicode scalar value (Rust char).\n  * Filesystem paths, or other operating-system strings.\n  * Arrays, with a compile-time-known size.\n  * Counted slices.\n  * Ranges\n  * Owned pointers to any supported type (e.g. Box), as well as owned pointers to types that can't be passed by value.\n  * References, with a limited degree of lifetime support.\n    * &str\n  * Closures, with a limited degree of lifetime support.\n  * Futures, with a limited degree of lifetime support. This would in particular support extern \"crabi\" async fn.\n  * \"noreturn\" functions, as expressed in Rust via -> !.\n  * Opaque objects with crABI methods, without exposing representation. (This would allow passing objects like Vec or HashMap or HashSet, without constraining the internals. This would also allow interoperating across versions of Rust.)\n    * An opaque error container, for use with Result.\n  * Trait objects with crABI methods. (This may use the same mechanism as objects.)\n\n# Open questions\n\n  * Niches: should we support cases like Option<bool> without a separate discriminant, or should we (for simplicity) always pass a separate discriminant? Likely the latter. However, what about things like Option<&T> and Option<NonZeroU32>, for which Rust guarantees the representation of None? Those work with the C ABI, and they have to work with crABI, but can we make them work with crABI using the same encoding of None?\n  * What subset of lifetimes can, and should, we support? We can't enforce them cross-language, but they may be useful as an advisory/documentation mechanism. Or we could leave them out entirely.\n  * To what extent should crABI make any attempt to specify things that can't be enforced, rather than ignoring semantics entirely and only specifying how types get passed?\n  * How can we make it easy to support data structures without having to do translation from repr(Rust) to repr(crabi) and have parallel structures? Can we make that less painful to express, and ideally mostly free at runtime?\n    * Related: how can we handle tuples? Do we need a way to express repr(crabi) tuples? How can we do that conveniently?\n  * Should we provide support for extensible enums, such that we don't assume the discriminant matches one of the known variants? Would doing so make using enums less ergonomic? Could we address that with language changes?\n  * For handling objects, could we avoid having to pass in-memory function pointers via a vtable, and instead reference specific symbols? This wouldn't work for generics, though. Can we do any better than a vtable?\n  * For ranges, should we provide a concrete range type or types, or should we defer that and handle ranges as opaque objects or traits?\n  * Do we get any value out of supporting (), other than completeness? Passing () by value should just be ignored as if it weren't specified. Do we want people using pointers to (), and do those have any advantage over pointers to void?\n  * Should we do anything special about i128 and u128, or should we just push for getting those supported correctly in extern \"C\"?\n  * For generics, such as Option<u64> or Result<u32, ConcreteError> or [u8; 16], does the rule \"all generic parameters must be bound to concrete types in the function signature\" suffice, or do we need a more complex rule than that?\n  * Unwinding: The default extern \"crabi\" should not support unwind, and most languages don't tend to have support for unwinding through C-ABI functions, but should we have a crabi-unwind variant? Would doing so provide value?\n\n# Prior art\n\nSome potential sources of inspiration:\n\n  * WebAssembly Interface Types\n  * The abi_stable crate (which aims for Rust-to-Rust stability, not cross-language interoperation, but it still serves as a useful reference)\n  * stabby\n  * UniFFI\n  * Diplomat\n  * Swift's stable ABI\n  * C++'s various ABIs (and the history of its ABI changes). crABI should not strive to be a superset of any C++ ABI, though.\n  * Many, many interface description languages (IDLs).\n  * The x86-64 psABI. While we're not specifying the lowering all the way to specific architectures, we can still learn from how it handles various types.\n\n# Rationale and alternatives\n\nRather than being defined via lowering to the C ABI, crABI could directly\ndefine how to pass parameters on underlying architectures, such as which\nregisters to use for which parameters and how to pass or return specific\ntypes. This would have the advantage of allowing improvements over the C ABI.\nHowever, this would have multiple substantial disadvantages, such as requiring\ndedicated support in every programming language (rather than leveraging C FFI\nsupport), and requiring definition for every target architecture. Instead,\nthis proposal suggests making such improvements at the C ABI level, such as by\ndefining extensions for passing or returning specific types in a more\nefficient fashion.crABI could exclude portions of the C ABI considered unsafe,\nsuch as raw pointers. This would make crABI not a strict superset of the C\nABI. This would make it difficult to handle functionality that crABI does not\nyet support, while simultaneously using crABI for functionality it does\nsupport. For instance, a program may wish to pass both an enum parameter and a\nraw pointer parameter. Leaving out this functionality might encourage people\nto avoid crABI or to define some functions via crABI and some via C\nABI.\"crABI\" serves as a neutral name identifying this ABI and its\nfunctionality. (Thanks to @m-ou-se for the name \"crABI\".) This work previously\nwent under the name \"safe ABI\", but given that the ABI does not exclude\nportions of the C ABI considered unsafe, a name like \"safe\" would be a\nmisnomer. This work also previously went under the names \"interop\" and\n\"interoperable ABI\"; however, the names interop and \"interoperable ABI\" are\nnot particularly identifying, unambiguous, easy to talk about, or other\nproperties of a good name. In addition, \"interop\"/\"interoperable\" can imply a\ngreater breadth than the initial version of crABI aspires to, such as\nincluding an IDL.crABI does not officially stand for anything. Insert your\nfavorite backronym.\n\n# Future work\n\n  * Debug/trace tools, such as debugger support or ltrace support, to decode crABI structures and types.\n  * Adding native crABI support to various languages.\n  * Shipping C header files defining structures for crABI.\n\n# Mentors or Reviewers\n\n@m-ou-se and @joshtriplett are planning to work on this, and potentially\ncoordinate other contributions.\n\n# Process\n\nThe main points of the Major Change Process are as follows:\n\n  * File an issue describing the proposal.\n  * A compiler team member or contributor who is knowledgeable in the area can second by writing @rustbot second.\n    * Finding a \"second\" suffices for internal changes. If however, you are proposing a new public-facing feature, such as a -C flag, then full team check-off is required.\n    * Compiler team members can initiate a check-off via @rfcbot fcp merge on either the MCP or the PR.\n  * Once an MCP is seconded, the Final Comment Period begins. If no objections are raised after 10 days, the MCP is considered approved.\n\nYou can read more about Major Change Proposals on forge.\n\n# Comments\n\nThis issue is not meant to be used for technical discussion. There is a Zulip\nstream for that. Use this issue to leave procedural comments, such as\nvolunteering to review, indicating that you second the proposal (or third,\netc), or raising a concern that you would like to be addressed.  \n---  \nThe text was updated successfully, but these errors were encountered:  \n  \njoshtriplett added major-change A proposal to make a major change to rustc\nT-compiler Add this label so rfcbot knows to poll the compiler team labels May\n9, 2023\n\nCollaborator\n\n###\n\nrustbot commented May 9, 2023\n\nThis issue is not meant to be used for technical discussion. There is a Zulip\nstream for that. Use this issue to leave procedural comments, such as\nvolunteering to review, indicating that you second the proposal (or third,\netc), or raising a concern that you would like to be addressed.cc @rust-\nlang/compiler @rust-lang/compiler-contributors  \n---  \n  \nrustbot added the to-announce Announce this issue on triage meeting label May\n9, 2023\n\nContributor\n\n###\n\noli-obk commented May 10, 2023\n\n@rustbot second  \n---  \n  \nrustbot added the final-comment-period The FCP has started, most (if not all)\nteam members are in agreement label May 10, 2023\n\njoshtriplett mentioned this issue May 10, 2023\n\nTracking Issue for the experimental crabi ABI rust-lang/rust#111423\n\nOpen\n\n4 tasks\n\nContributor\n\n###\n\napiraino commented May 25, 2023\n\n@rustbot label -final-comment-period +major-change-accepted  \n---  \n  \napiraino closed this as completed May 25, 2023\n\nrustbot added major-change-accepted A major change proposal that was accepted\nand removed final-comment-period The FCP has started, most (if not all) team\nmembers are in agreement labels May 25, 2023\n\napiraino removed the to-announce Announce this issue on triage meeting label\nMay 25, 2023\n\nSign up for free to join this conversation on GitHub. Already have an account?\nSign in to comment\n\nLabels\n\nmajor-change A proposal to make a major change to rustc major-change-accepted\nA major change proposal that was accepted T-compiler Add this label so rfcbot\nknows to poll the compiler team\n\n4 participants\n\n## Footer\n\n\u00a9 2024 GitHub, Inc.\n\nYou can\u2019t perform that action at this time.\n\n", "frontpage": false}
