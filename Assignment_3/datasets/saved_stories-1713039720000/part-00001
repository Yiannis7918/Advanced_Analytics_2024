{"aid": "40023319", "title": "Tree-shaking, the horticulturally misguided algorithm", "url": "https://wingolog.org/archives/2023/11/24/tree-shaking-the-horticulturally-misguided-algorithm", "domain": "wingolog.org", "votes": 35, "user": "andsoitis", "posted_at": "2024-04-13 14:20:20", "comments": 6, "source_title": "wingolog", "source_text": "tree-shaking, the horticulturally misguided algorithm \u2014 wingolog\n\n# wingolog\n\n## tree-shaking, the horticulturally misguided algorithm\n\n24 November 2023 11:41 AM\n\n  * scheme\n  * guile\n  * hoot\n  * wasm\n  * webassembly\n  * dce\n  * tree-shaking\n  * gc\n  * garbage collection\n  * python\n  * go\n  * clojure\n  * clojurescript\n  * compilers\n  * igalia\n\nLet\u2019s talk about tree-shaking!\n\n### looking up from the trough\n\nBut first, I need to talk about WebAssembly\u2019s dirty secret: despite the hype,\nWebAssembly has had limited success on the web.\n\nThere is Photoshop, which does appear to be a real success. 5 years ago there\nwas Figma, though they don\u2019t talk much about Wasm these days. There are quite\na number of little NPM libraries that use Wasm under the hood, usually\ncompiled from C++ or Rust. I think Blazor probably gets used for a few in-\nhouse corporate apps, though I could be fooled by their marketing.\n\nYou might recall the hyped demos of 3D first-person-shooter games with Unreal\nengine again from 5 years ago, but that was the previous major release of\nUnreal and was always experimental; the current Unreal 5 does not support\ntargetting WebAssembly.\n\nDon\u2019t get me wrong, I think WebAssembly is great. It is having fine success in\noff-the-web environments, and I think it is going to be a key and growing part\nof the Web platform. I suspect, though, that we are only just now getting past\nthe trough of disillusionment.\n\nIt\u2019s worth reflecting a bit on the nature of web Wasm\u2019s successes and\nfailures. Taking Photoshop as an example, I think we can say that Wasm does\nvery well at bringing large C++ programs to the web. I know that it took quite\nsome work, but I understand the end result to be essentially the same source\ncode, just compiled for a different target.\n\nSimilarly for the JavaScript module case, Wasm finds success in getting legacy\nC++ code to the web, and as a way to write new web-targetting Rust code. These\nare often tasks that JavaScript doesn\u2019t do very well at, or which need a\nshared implementation between client and server deployments.\n\nOn the other hand, WebAssembly has not been a Web success for DOM-heavy apps.\nNobody is talking about rewriting the front-end of wordpress.com in Wasm, for\nexample. Why is that? It may sound like a silly question to you: Wasm just\nisn\u2019t good at that stuff. But why? If you dig down a bit, I think it\u2019s that\nthe programming models are just too different: the Web\u2019s primary programming\nmodel is JavaScript, a language with dynamic typing and managed memory,\nwhereas WebAssembly 1.0 was about static typing and linear memory. Getting to\nthe DOM from Wasm was a hassle that was overcome only by the most ardent of\nthe true Wasm faithful.\n\nRelatedly, Wasm has also not really been a success for languages that aren\u2019t,\nlike, C or Rust. I am guessing that wordpress.com isn\u2019t written mostly in C++.\nOne of the sticking points for this class of language. is that C#, for\nexample, will want to ship with a garbage collector, and that it is annoying\nto have to do this. Check my article from March this year for more details.\n\nHappily, this restriction is going away, as all browsers are going to ship\nsupport for reference types and garbage collection within the next months;\nChrome and Firefox already ship Wasm GC, and Safari shouldn\u2019t be far behind\nthanks to the efforts from my colleague Asumu Takikawa. This is an\nextraordinarily exciting development that I think will kick off a whole\n\u2018nother Gartner hype cycle, as more languages start to update their toolchains\nto support WebAssembly.\n\n### if you don\u2019t like my peaches\n\nWhich brings us to the meat of today\u2019s note: web Wasm will win where compilers\ncreate compact code. If your language\u2019s compiler toolchain can manage to\nproduce useful Wasm in a file that is less than a handful of over-the-wire\nkilobytes, you can win. If your compiler can\u2019t do that yet, you will have to\ninstead rely on hype and captured audiences for adoption, which at best\nresults in an unstable equilibrium until you figure out what\u2019s next.\n\nIn the JavaScript world, managing bloat and deliverable size is a huge\nindustry. Bundlers like esbuild are a ubiquitous part of the toolchain,\ncompiling down a set of JS modules to a single file that should include only\nthose functions and data types that are used in a program, and additionally\napplying domain-specific size-squishing strategies such as minification\n(making monikers more minuscule).\n\nLet\u2019s focus on tree-shaking. The visual metaphor is that you write a bunch of\ncode, and you only need some of it for any given page. So you imagine a tree\nwhose, um, branches are the modules that you use, and whose leaves are the\nindividual definitions in the modules, and you then violently shake the tree,\nprobably killing it and also annoying any nesting birds. The only thing that\u2019s\nleft still attached is what is actually needed.\n\nThis isn\u2019t how trees work: holding the trunk doesn\u2019t give you information as\nto which branches are somehow necessary for the tree\u2019s mission. It also primes\nyour mind to look for the wrong fixed point, removing unneeded code instead of\nkeeping only the necessary code.\n\nBut, tree-shaking is an evocative name, and so despite its horticultural and\nalgorithmic inaccuracies, we will stick to it.\n\nThe thing is that maximal tree-shaking for languages with a thicker run-time\nhas not been a huge priority. Consider Go: according to the golang wiki, the\nmost trivial program compiled to WebAssembly from Go is 2 megabytes, and\nadding imports can make this go to 10 megabytes or more. Or look at Pyodide,\nthe Python WebAssembly port: the REPL example downloads about 20 megabytes of\ndata. These are fine sizes for technology demos or, in the limit, very rich\napplications, but they aren\u2019t winners for web development.\n\n### shake a different tree\n\nTo be fair, both the built-in Wasm support for Go and the Pyodide port of\nPython both derive from the upstream toolchains, where producing small\nbinaries is nice but not necessary: on a server, who cares how big the app is?\nAnd indeed when targetting smaller devices, we tend to see alternate\nimplementations of the toolchain, for example MicroPython or TinyGo. TinyGo\nhas a Wasm back-end that can apparently go down to less than a kilobyte, even!\n\nThese alternate toolchains often come with some restrictions or peculiarities,\nand although we can consider this to be an evil of sorts, it is to be expected\nthat the target platform exhibits some co-design feedback on the language. In\nparticular, running in the sea of the DOM is sufficiently weird that a Wasm-\ntargetting Python program will necessarily be different than a \u201cnative\u201d Python\nprogram. Still, I think as toolchain authors we aim to provide the same\nlanguage, albeit possibly with a different implementation of the standard\nlibrary. I am sure that the ClojureScript developers would prefer to remove\ntheir page documenting the differences with Clojure if they could, and perhaps\nif Wasm becomes a viable target for Clojurescript, they will.\n\n### on the algorithm\n\nTo recap: now that it supports GC, Wasm could be a winner for web development\nin Python and other languages. You would need a different toolchain and an\neffective tree-shaking algorithm, so that user experience does not degrade. So\nlet\u2019s talk about tree shaking!\n\nI work on the Hoot Scheme compiler, which targets Wasm with GC. We manage to\nget down to 70 kB or so right now, in the minimal \u201cmain\u201d compilation unit, and\nare aiming for lower; auxiliary compilation units that import run-time\nfacilities (the current exception handler and so on) from the main module can\nbe sub-kilobyte. Getting here has been tricky though, and I think it would be\neven trickier for Python.\n\nSome background: like Whiffle, the Hoot compiler prepends a prelude onto user\ncode. Tree-shakind happens in a number of places:\n\n  * partial evaluation will evaluate unused bindings for effect, possibly eliding them\n\n  * fixing letrec will do the same\n\n  * CPS frequently traverses the program, following only referenced function, value, and control edges, e.g. via renumbering\n\n  * There is an explicit dead-code elimination pass which tries to elide unused effect-free allocations, a situation that can arise due to other optimizations\n\n  * Finally there is a standard library written in raw-ish WebAssembly, whose definitions (globals, tables, imports, functions, etc) are included in the residual binary only as neeeded.\n\nGenerally speaking, procedure definitions (functions / closures) are the easy\npart: you just include only those functions that are referenced by the code.\nIn a language like Scheme, this gets you a long way.\n\nHowever there are three immediate challenges. One is that the evaluation model\nfor the definitions in the prelude is letrec*: the scope is recursive but\nordered. Binding values can call or refer to previously defined values, or\ncapture values defined later. If evaluating the value of a binding requires\nreferring to a value only defined later, then that\u2019s an error. Again, for\nprocedures this is trivially OK, but as soon as you have non-procedure\ndefinitions, sometimes the compiler won\u2019t be able to prove this nice \u201conly\nrefers to earlier bindings\u201d property. In that case the fixing letrec\n(reloaded) algorithm will end up residualizing bindings that are set!, which\nof all the tree-shaking passes above require the delicate DCE pass to remove\nthem.\n\nWorse, some of those non-procedure definitions are record types, which have\nvtables that define how to print a record, how to check if a value is an\ninstance of this record, and so on. These vtable callbacks can end up keeping\na lot more code alive even if they are never used. We\u2019ll get back to this\nlater.\n\nSimilarly, say you print a string via display. Well now not only are you\nbringing in the whole buffered I/O facility, but you are also calling a highly\npolymorphic function: display can print anything. There\u2019s a case for\nbitvectors, so you pull in code for bitvectors. There\u2019s a case for pairs, so\nyou pull in that code too. And so on.\n\nOne solution is to instead call write-string, which only writes strings and\nnot general data. You\u2019ll still get the generic buffered I/O facility (ports),\nthough, even if your program only uses one kind of port.\n\nThis brings me to my next point, which is that optimal tree-shaking is a flow\nanalysis problem. Consider display: if we know that a program will never have\nbitvectors, then any code in display that works on bitvectors is dead and we\ncan fold the branches that guard it. But to know this, we have to know what\nkind of arguments display is called with, and for that we need higher-level\nflow analysis.\n\nThe problem is exacerbated for Python in a few ways. One, because object-\noriented dispatch is higher-order programming. How do you know what foo.bar\nactually means? Depends on foo, which means you have to thread around\nrepresentations of what foo might be everywhere and to everywhere\u2019s caller and\neverywhere\u2019s caller\u2019s caller and so on.\n\nSecondly, lookup in Python is generally more dynamic than in Scheme: you have\n__getattr__ methods (is that it?; been a while since I\u2019ve done Python)\neverywhere and users might indeed use them. Maybe this is not so bad in\npractice and flow analysis can exclude this kind of dynamic lookup.\n\nFinally, and perhaps relatedly, the object of tree-shaking in Python is a mess\nof modules, rather than a big term with lexical bindings. This is like\nJavaScript, but without the established ecosystem of tree-shaking bundlers;\nPython has its work cut out for some years to go.\n\n### in short\n\nWith GC, Wasm makes it thinkable to do DOM programming in languages other than\nJavaScript. It will only be feasible for mass use, though, if the resulting\nWasm modules are small, and that means significant investment on each\nlanguage\u2019s toolchain. Often this will take the form of alternate toolchains\nthat incorporate experimental tree-shaking algorithms, and whose alternate\nstandard libraries facilitate the tree-shaker.\n\nWelp, I\u2019m off to lunch. Happy wassembling, comrades!\n\n## related articles\n\n  * requiem for a stringref\n  * missing the point of webassembly\n  * a world to win: webassembly for the rest of us\n  * just-in-time code generation within webassembly\n  * the half strap: self-hosting and guile\n  * a register vm for guile\n\n### 2 responses\n\n  1. Hubert says:\n\n27 November 2023 2:25 AM\n\nTr\u00e8s belle discussion! I followed the link to the Pyodide REPL example, noting\nthe 20MB download, but this is an repl and so I expect it brings a lot of\ncapability with it (compared to \u201cjust an app\u201d). Typing 3 + 5 semicolon and\nenter in it, it replied with 8, which is nice.\n\nWhat I wonder then is if a scheme repl coded using guile-Hoot (for example)\ncould be expected to form a much smaller download? Also, I noticed that the\nPyodide REPL kept one of my machine\u2019s cores 100 percent busy at all times\n(even when not interacting with it; in Firefox) and would hope that other\nrepls (eg. for Scheme) would be less \u201ccomputationally\u201d demanding.\n\n  2. Ole Laursen says:\n\n27 November 2023 3:03 PM\n\nOn a horticultural note, it\u2019s common to have to shake weeds violently to get\nthe dirt off their roots. Trees grow as weed too, but are extremely difficult\nto pull out unless they are very small.\n\nSo weed shaking might be a better name.\n\nPerhaps also in other respects more appropriate.\n\nComments are closed.\n\npowered by tekuti\n\n", "frontpage": true}
