{"aid": "40014983", "title": "\"Expand\" Your API's Horizons", "url": "https://pocketflows.com/blog/expand-your-apis-horizons", "domain": "pocketflows.com", "votes": 1, "user": "theodoretliu", "posted_at": "2024-04-12 16:49:26", "comments": 0, "source_title": "Expand Your API's Horizons \u2014 Pocketflows Blog", "source_text": "Expand Your API's Horizons \u2014 Pocketflows Blog\n\nPocketflows\n\nBlog\n\nApril 12, 2024\n\n# expand Your API's Horizons: Ergonomic REST APIs with Dynamic Object\nExpansion\n\nTeddy LiuCo-Founder @ Pocketflows\n\nThe classic \"galaxy brain\" or \"expanding brain\" meme\n\nPremier API companies, like Stripe, implement an additional expand parameter\non all their endpoints. Generally, nested objects in the Stripe API are not\nexpanded by default and instead are represented by their id . This parameter\ngives you ability to inflate the nested objects returned from the API and get\ntheir attributes and also recursively inflate the nested objects within them.\n\nAt Pocketflows, we're building embedded APIs to help VSaaS and enterprise\ncompanies build high-quality customer engagement tools faster and better. It's\nour goal to offer the best API experience, so we have implemented the expand\nparameter and wanted to share our thoughts.\n\n## Motivation\n\nWhy have an expand parameter at all? We can see its utility by examining\nalternative approaches. Note that GraphQL actually solves many of the\nfollowing concerns, but that's a topic for a future blog post.\n\n### Approach 1: Expand Everything\n\nOne option (that Pocketflows implemented in its MVP) is to expand every nested\nobject fully and recursively. For example, in Pocketflows, there is a Member\nwhich associates both a User and a Rewards Program and gives . If we take the\n\"expand everything\" approach, a GET to /members/mem_1 would return\n\n    \n    \n    { \"id\": \"mem_1\", \"point_total\": 1000, \"point_balance\": 2000, \"user\": { \"id\": \"u_1\", \"phone_number\": \"+1234567890\" }, \"rewards_program\": { \"id\": \"rp_1\", \"points_earned_per_dollar_spent\": 2, \"point_redemption_value\": \"0.01\", \"points_for_member_class_attendance\": 100 } }\n\n#### Pros\n\n  * Simplifies serialization on the server \u2014 just return all fields and do so recursively\n  * The API caller will never have to specify additional parameters and will always get the data they're looking for.\n\n#### Cons\n\n  * Likely sends way more data than the API caller needs and this problem only worsens as the number of resources and amount of nesting in your API grows\n  * With scaled API usage, this approach will consume a lot of bandwidth unnecessarily. You will be sending bytes for nested objects that are never used. This is particularly exacerbated when requesting a list of objects. For example, getting all Members would return an array of the above object and for many of the Members, rewards_programs would be exactly the same object!\n\nOne final subtlety is that with this approach, you need to be careful about\nimplicit cycles within your object model. If there was a one-to-one\nrelationship between two objects and we expand everything naively, we end up\nwith a situation similar to infinite recursion!\n\n### Approach 2: Expand Nothing\n\nOn the opposite extreme, we can choose to expand none of the nested objects.\nKeeping the example from above, with Members, making a GET request to\n/members/mem_1 would return:\n\n    \n    \n    { \"id\": \"mem_1\", \"point_total\": 1000, \"point_balance\": 2000, \"user\": \"u_1\", \"rewards_program\": \"rp_1\" }\n\nThis approach addresses some of the concerns from the \"expand everything\"\napproach.\n\n#### Pros\n\n  * There are no risks of infinite recursion in serialization.\n  * Depending on the underlying DB data model, it may not be necessary to even query multiple tables.\n  * The amount of data sent is minimal, preserving bandwidth.\n  * In the case of arrays, the amount of duplication is minimal \u2014 limited to just the IDs.\n\n#### Cons\n\n  * If the API caller does want additional information about the User or Rewards Program , they need to make a separate API calls to /users/u_1 and /rewards_program/rp_1 .\n\n### Approach 3: expand parameter\n\nThe \"expand nothing\" approach has many benefits with one major limiting\ndownside: when the API caller would prefer to have more information about a\nnested object, they need to make separate calls to the API. We address this by\nproviding an opt-in parameter: expand. The default behavior of all endpoints\nis to \"expand nothing\" as above, but when API callers want to view nested\nobjects in the response, they can provide the expand parameter and get the\ndata in the same response.\n\nContinuing with the example, suppose an API caller would like to view a\nMember's point total and would also like their phone number to send them a\nnotification. They can now include the expand parameter in the GET request:\n/members/:id?expand[]=user . This returns\n\n    \n    \n    { \"id\": \"mem_1\", \"point_total\": 1000, \"point_balance\": 2000, \"user\": { \"id\": \"u_1\", \"phone_number\": \"+1234567890\" }, \"rewards_program\": \"rp_1\" }\n\nThe result selectively expands the User nested object but leaves the Rewards\nProgram unexpanded. This gives the API caller the requested information about\nthe User (their phone number) while not giving redundant information about the\nRewards Program . There are few tradeoffs here! We're minimizing the amount of\nbandwidth and redundant information while still giving all the relevant\ninformation in one API call. The API caller only needs to provide an extra\nquery parameter.\n\n## Semantics\n\nNow that we have motivated the utility of the expand parameter, we should also\nclarify the way it works! expand is an array of strings passed to the query\nparameters of GET requests and the request body of POST and DELETE requests.\n\nFor GET requests, arrays are encoded with the expand[] scheme. For example, if\nthe intent is to expand both user and rewards_program , the query parameters\nshould be expand[]=user&expand[]=rewards_program. This will be interpreted as\n\n    \n    \n    expand = [\"user\", \"rewards_program\"]\n\nby the API.\n\nEach of the strings should correspond to keys in the response object that have\nexpandable values. In a Member object:\n\n    \n    \n    { \"id\": \"mem_1\", \"point_total\": 1000, \"point_balance\": 2000, \"user\": \"u_1\", \"rewards_program\": \"rp_1\" }\n\n\"user\" and \"rewards_program\" are valid values.\n\nIn addition, recursively nested objects can also be expanded with a dot\nnotation. For example, an Event in Pocketflows has an associated Member. If we\nwould like to see the associated Member's phone number, we would expand the\n\"member\" key and then the \"user\" key in a Member. The API call might be POST\nwith\n\n    \n    \n    { ...rest, \"expand\": [\"member.user\"] }\n\nreturning the result\n\n    \n    \n    { \"id\": \"ev_1\", \"member\": { \"id\": \"mem_1\", \"user\": { \"id\": \"u_1\", \"phone_number\": \"+1234567890\" }, \"rewards_program\": \"rp_1\" }, \"event_name\": \"user.book\" }\n\nNote that \"member.user\" automatically implies the expansion of \"member\" . It\nis not necessary to pass both \"member\" and \"member.user\" .\n\nFor endpoints that return multiple objects or expanding nested objects in\narrays, the expand parameter needs to pass the next relevant key, skipping any\npotential array indexing. Again, the rule for matching keys must be followed.\nIf you make a GET to /members, you receive the result\n\n    \n    \n    { \"members\": [ { \"id\": \"mem_1\", \"user\": \"u_1\", ... }, { \"id\": \"mem_2\", \"user\": \"u_2\", ... } ] }\n\nTo expand the \"user\" key for all of these, pass ?expand[]=members.user to the\nquery to receive:\n\n    \n    \n    { \"members\": [ { \"id\": \"mem_1\", \"user\": { \"id\": \"u_1\", \"phone_number\": \"+1234567890\" }, ... }, { \"id\": \"mem_2\", \"user\": { \"id\": \"u_2\", \"phone_number\": \"+0987654321\" }, ... } ] }\n\n### Restrictions and Errors\n\nTo prevent excess querying that stems from requesting too many layers of\nnested objects, we can restrict the amount of chaining allowed by the expand\nparameter. Stripe chooses a value of 3; providing deeper nesting should result\nin an error. At the moment, Pocketflows makes no such restrictions! Arbitrary\ndepth can be provided to our API with no errors.\n\nIf the API caller passes a key that's not valid on the object, either because\nthe key is misspelled or the key does not correspond to an expandable object,\nthis should generate an error from the API.\n\n## Implementation\n\nAt Pocketflows, we're building our API with Ruby on Rails. Stay tuned for a\nfuture blog post to learn tips and tricks from our example implementation!\n\n## Conclusion\n\nThe expand provides flexibility to API callers while providing sensible and\nminimal defaults for all endpoints \u2014 unless otherwise specified, the amount of\ndata sent is minimal, conserving bandwidth and database utilization.\nImplementing the expand parameter is relatively straightforward, and we hope\nyou also include it in your API!\n\nAre you looking to build customer engagement for your VSaaS or consumer-facing\nbusiness? At Pocketflows, we're creating embedded APIs to build high-quality\ncustomer engagement products. We're incorporating the best API practices (as\nseen in this article) making for the best developer experience. If you're\ninterested in learning more, click the button below!\n\nLearn more\n\n", "frontpage": false}
