{"aid": "40008718", "title": "How to create C binding for a Rust library", "url": "https://developers.redhat.com/articles/2022/09/05/how-create-c-binding-rust-library", "domain": "redhat.com", "votes": 1, "user": "Arteiii", "posted_at": "2024-04-12 01:54:47", "comments": 0, "source_title": "How to create C binding for a Rust library | Red Hat Developer", "source_text": "How to create C binding for a Rust library | Red Hat Developer\n\nSkip to main content\n\n## Quick links: redhat.com, Customer Portal, Red Hat's developer site, Red\nHat's partner site.\n\n  * You are here\n\n### Red Hat\n\nLearn about our open source products, services, and company.\n\n  * You are here\n\n### Red Hat Customer Portal\n\nGet product support and knowledge from the open source experts.\n\n  * You are here\n\n### Red Hat Developer\n\nRead developer tutorials and download Red Hat software for cloud application\ndevelopment.\n\n  * You are here\n\n### Red Hat Partner Connect\n\nGet training, subscriptions, certifications, and more for partners to build,\nsell, and support customer solutions.\n\n## Products & tools\n\n  * ### Ansible.com\n\nLearn about and try our IT automation product.\n\n  * ### Red Hat Ecosystem Catalog\n\nFind hardware, software, and cloud providers\u2015and download container\nimages\u2015certified to perform with Red Hat technologies.\n\n## Try, buy, & sell\n\n  * ### Red Hat Hybrid Cloud Console\n\nAccess technical how-tos, tutorials, and learning paths focused on Red Hat\u2019s\nhybrid cloud managed services.\n\n  * ### Red Hat Store\n\nBuy select Red Hat products and services online.\n\n  * ### Red Hat Marketplace\n\nTry, buy, sell, and manage certified enterprise software for container-based\nenvironments.\n\n## Events\n\n  * ### Red Hat Summit and AnsibleFest\n\nRegister for and learn about our annual open source IT industry event.\n\nArticle\n\n# How to create C binding for a Rust library\n\nSeptember 5, 2022\n\nProgramming languages & frameworksRustCLinux\n\nGris Ge\n\nPrincipal Software Engineer\n\n  * Elements of a C binding\n  * Output pointer for a string\n  * Output pointer for an opaque struct\n  * Logging in the C binding\n  * Fixing the SONAME\n  * Memory leak test for the C binding\n  * Packaging for the C binding\n\nThis article is the second installment of a series about how to take advantage\nof the recent Rust support added to Linux. The first article in the series, 3\nessentials for writing a Linux system library in Rust, describes special\nconsiderations that system libraries require when you are writing in Rust.\nThis article demonstrates how to create a C binding so that programmers in C\nor C++ can call your Rust library. Rust has not conquered the Linux world yet,\nso our system library needs to provide bindings to other languages.\n\nCheck out the other three articles in this series:\n\n  * Part 1: 3 essentials for writing a Linux system library in Rust\n\n  * Part 3: How to create Python binding for a Rust library\n\n  * Part 4: Build trust in continuous integration for your Rust library\n\nThe Rust team has created a great document, Rust API Guidelines, about how to\ncreate a robust Rust library and crate. This article focuses on Linux-specific\ntopics.\n\nYou can download the demo code from its GitHub repository. The package\ncontains:\n\n  * An echo server listening on the Unix socket /tmp/librabc\n  * A Rust crate that connects to the socket and sends a ping packet every 2 seconds\n  * A C/Python binding\n  * A command-line interface (CLI) for the client\n\nElements of a C binding\n\n## Elements of a C binding\n\nRust can generate C dynamic libraries (.so files) as well as static libraries\n(.a files), which can be easily wrapped in Go bindings and Python bindings and\nused in code written in those languages.\n\nYou can refer to the full code of the C library written in Rust in the clib\nfolder of the GitHub repository.\n\nThe following line in the repository's Cargo.toml file generates a C binding\nto your Rust library as a .so file:\n\n    \n    \n    crate-type = [\"cdylib\"]\n\nCopy snippet\n\nUse staticlib in place of cdylib to generate a static library.\n\nTwo elements of the library code lib.rs should be noted here:\n\n  * The #[no_mangle] macro before each function instructs the Rust compiler not to add special characters to symbol names as it does for Rust native code. The symbols are left plain so that C code can link to this file and refer to the symbols.\n  * The extern \"C\" keywords on functions instruct Rust to use the system ABI (glibc in the case of Linux) instead of the Rust ABI to accommodate the C linker.\n\nAn example of a function follows:\n\n    \n    \n    #[no_mangle] pub extern \"C\" fn rabc_client_new( client: *mut *mut RabcClient, log: *mut *mut c_char, err_kind: *mut *mut c_char, err_msg: *mut *mut c_char, ) -> u32 { RABC_PASS }\n\nCopy snippet\n\nYou might wonder about the use of *mut *mut. These are raw pointers pointing\nto a raw pointer in Rust, like using void ** in C as an output pointer.\n\nThe function has two types of output pointer:\n\n  * *mut *mut c_char is an output pointer to type String(char *)\n  * *mut *mut RabcClient is an output pointer to an opaque struct RabcClient\n\nWe will look at each of these types.\n\nOutput pointer for a string\n\n## Output pointer for a string\n\nIn the C world, char ** in a function argument returns a string (char *) to\nthe library consumer like this:\n\n    \n    \n    if (result != NULL) { *result = malloc(strlen(\"ping\") + 1); if (*result != NULL) { snprintf(*result, strlen(\"ping\") + 1, \"%s\", \"ping\"); } }\n\nCopy snippet\n\nThe following Rust code does the same using std::ffi::CString:\n\n    \n    \n    if !result.is_null() { unsafe { *result = std::ptr::null_mut(); } if let Ok(s) = std::ffi::CString::new(\"ping\") { unsafe { *result = s.into_raw(); } } }\n\nCopy snippet\n\nThe Rust documentation states: \"Failure to call CString::from_raw will lead to\na memory leak. To prevent memory leaking, the memory of CString::into_raw()\nshould be freed (the C free should not be used) via\nstd::ffi::CString::from_raw\":\n\n    \n    \n    #[no_mangle] pub extern \"C\" fn free_foo( result: *mut libc::c_char, ) { if !result.is_null() { unsafe { std::ffi::CString::from_raw(result) } } }\n\nCopy snippet\n\nOutput pointer for an opaque struct\n\n## Output pointer for an opaque struct\n\nIn the C world, it is common to expose an opaque struct in a library to let\nthe developer maintain a compatible ABI when adding properties to the struct.\n\nIn our example, we need to expose the Rust struct RabcClient. The C compiler\ndoes not know the size of the opaque struct, so we can expose it only as a\npointer whose size is known to the compiler.\n\nLet's see how this workaround is done in Rust:\n\n    \n    \n    #[no_mangle] pub extern \"C\" fn rabc_client_new( client: *mut *mut RabcClient, log: *mut *mut c_char, err_kind: *mut *mut c_char, err_msg: *mut *mut c_char, ) -> u32 { // Many lines omitted if client.is_null() { return RABC_FAIL_NULL_POINTER; } unsafe { *client = std::ptr::null_mut(); } unsafe { *client = Box::into_raw(Box::new(c)); RABC_PASS } }\n\nCopy snippet\n\nThe client: *mut *mut RabcClient clause is an output pointer to RabcClient.\n\nBecause we should never dereference a null pointer, we put in the check\nclient.is_null().\n\nThe line *client = std::ptr::null_mut(); makes sure we always set the output\npointer to NULL when an error happens.\n\nThe Box::into_raw() function gets the pointer to RabcClient and removes its\nmemory chunk from the Rust memory management system, trusting the library's\nuser to manage the memory.\n\nAfter finishing all work with RabcClient, the user has to call\nrabc_client_free(), which frees the memory leaked by Box::into_raw(). The Rust\nlibrary claims ownership of this memory chunk and drops it, thus freeing the\nmemory:\n\n    \n    \n    #[no_mangle] pub extern \"C\" fn rabc_client_free(client: *mut RabcClient) { if !client.is_null() { unsafe { drop(Box::from_raw(client)); } } }\n\nCopy snippet\n\nLogging in the C binding\n\n## Logging in the C binding\n\nC lacks a standard logging system. So the Rust library in this example stores\nits JSON-formatted logs in char * strings as an output pointer of a function.\nA Python or Go binding reads this string and converts it to their logging\nsystem.\n\nThe full logging code is in the repository's logger.rs file. The code is based\non the work of Gabriel Bastos\u2014many thanks to Gabriel.\n\nGiven the Rust log crate infrastructure, you just need to implement the\nlog::Log trait by storing logs in a Vec<LogEntry> in memory, then dumping them\nto MemoryLogger.drain(). The most difficult parts are:\n\n  * The struct MemoryLogger instance should have a static lifetime so that it could be invoked by log::debug() and etc functions in any thread context.\n  * Draining the logs must be done in a thread-safe manner.\n\nWe will look at each of these issues.\n\n### Static lifetime for the MemoryLogger instance\n\nTo give struct MemoryLogger a static lifetime, use OnceCell.set():\n\n    \n    \n    static INSTANCE: OnceCell<MemoryLogger> = OnceCell::new(); // Many lines omitted fn init_logger() -> Result<&'static MemoryLogger, RabcError> { match INSTANCE.get() { Some(l) => { Ok(l) } None => { if INSTANCE.set(MemoryLogger::new()).is_err() { return Err(foo); } if let Some(l) = INSTANCE.get() { if let Err(e) = log::set_logger(l) { Err(foo) } else { Ok(l) } } else { Err(foo) } } } }\n\nCopy snippet\n\n### Thread-safe draining of logs\n\nThe C library should be thread-safe, so all the data in MemoryLogger should be\nan atomic type or be protected by a lock. In this example, we protect the data\nthrough a std::sync::Mutex):\n\n    \n    \n    pub(crate) struct MemoryLogger { consumer_count: AtomicU16, logs: Mutex<Vec<LogEntry>>, }\n\nCopy snippet\n\nThe consumer_count variable tracks the thread count of log consumers. When the\nlast C function using logs invokes MemoryLogger::drain(), the library drops\nthe logs from Vec<LogEntry>. Otherwise, the .drain call returns a copy of the\nlogs that were logged since the specified time.\n\n    \n    \n    pub(crate) fn drain(&self, since: SystemTime) -> String { let mut logs = self.logs.lock().expect(\"inner lock poisoned\"); let ret = serde_json::to_string( &logs .as_slice() .iter() .filter(|l| l.time >= since) .collect::<Vec<&LogEntry>>(), ) .unwrap_or_default(); if self.consumer_count.fetch_sub(1, Ordering::SeqCst) == 1 { logs.clear(); } ret }\n\nCopy snippet\n\nIf you try this C library in a multithreaded program, you will find that the\nlogs retrieved are mixed with output from other threads. I don't have a good\nsolution for a thread-local logger yet, but I found suggestions for one at\nrust-lang/log. A pull request to this demo GitHub project will be much\nappreciated.\n\nFixing the SONAME\n\n## Fixing the SONAME\n\nRust does not support the SONAME naming convention yet as I draft this\narticle. As a workaround, you can define the following in .cargo/config.toml:\n\n    \n    \n    [build] rustflags = \"-Clink-arg=-Wl,-soname=libfoo.so.0\"\n\nCopy snippet\n\nYou can also use patchelf to modify the SONAME after the cargo build:\n\n    \n    \n    patchelf --set-soname libfoo.so.0\n\nCopy snippet\n\nMemory leak test for the C binding\n\n## Memory leak test for the C binding\n\nThe C binding uses a lot of unsafe keywords to work with Rust raw pointers. So\nI recommend running a memory leak test for the C binding. The example project\noffers a make clib_check command that uses Valgrind against a C program linked\nto our C binding .so file. The code is in a file named rabc_test.c and the\nproject's Makefile.\n\nPackaging for the C binding\n\n## Packaging for the C binding\n\nTo ship a C binding, you need:\n\n  * The following .so files:\n\n    * librabc.so.0.1\n    * librabc.so.0, linked to librabc.so.0.1\n    * librabc.so, linked to librabc.so.0\n  * The C header file: rabc.h.\n  * A Pkgconfig file: rabc.pc.in\n\nYou can write a Makefile containing a make install command to install all\nthose files.\n\nFor Fedora RPM packaging, the .cargo/config.toml fix shown earlier for SONAME\nwill not work, because Fedora uses .cargo/config to change the dependency\nsource searching folder. Therefore, we will use the patchelf method for\nFedora:\n\n    \n    \n    %prep %setup -q rm .cargo/config.toml %cargo_prep %install env SKIP_PYTHON_INSTALL=1 \\ PREFIX=%{_prefix} \\ LIBDIR=%{_libdir} \\ %make_install patchelf --set-soname librabc.so.2 \\ %{buildroot}/%{_libdir}/librabc.so.%{version}\n\nCopy snippet\n\nRed Hat Enterprse Linux has no patchelf in the build root, so you need to\nmerge the flags defined in .cargo/config. The following snippet shows how I\nset the flags:\n\n    \n    \n    %prep # Source1 is vendored dependencies %cargo_prep -V 1 _FLAGS=`sed -ne 's/rustflags = \"\\(.\\+\\)\"/\\1/p' .cargo/config.toml` sed -i -e \"s/rustflags = \\[\\(.\\+\\), \\]$/rustflags = [\\1, \\\"$_FLAGS\\\"]/\" \\ .cargo/config\n\nCopy snippet\n\n##What's next?\n\nRequirements might change from time to time, so please refer to the latest\nFedora and Red Hat Enterprise Linux packaging guides.\n\nThe C binding can also be used in other languages such as Python and Go. The\nnext article in this series demonstrates how to create a Python binding on top\nof the C binding from this article.\n\nLast updated: August 14, 2023\n\n## Recent Articles\n\n  * ### Detect network issues in Open vSwitch using Red Hat Insights\n\n  * ### Enable GPU acceleration with the Kernel Module Management Operator\n\n  * ### Getting started with MongoDB and Quarkus: Beyond the basics\n\n  * ### Improvements to static analysis in the GCC 14 compiler\n\n  * ### How to add debug support for Go stripped binaries\n\n## Related Content\n\n### C/C++ library upgrades and opaque data types in process shared memory\n\n### How C array sizes become part of the binary interface of a library\n\n### New Red Hat compilers toolsets in beta: Clang and LLVM, GCC, Go, Rust\n\n### Getting started with rust-toolset\n\n## What\u2019s up next?\n\nGet a hands-on introduction to daily life as a developer crafting code on\nOpenShift, the open source container application platform from Red Hat, with\nOpenShift for Developers.\n\nGet the e-book\n\nLinkedIn YouTube Twitter Facebook\n\n### Products\n\n  * Red Hat Enterprise Linux\n  * Red Hat OpenShift\n  * Red Hat Ansible Automation Platform\n  * See all products\n  * See all technologies\n\n### Build\n\n  * Developer Sandbox\n  * Developer Tools\n  * Interactive Tutorials\n  * API Catalog\n  * Operators Marketplace\n\n### Quicklinks\n\n  * Learning Resources\n  * E-books\n  * Cheat Sheets\n  * Blog\n  * Events\n\n### Communicate\n\n  * About us\n  * Contact sales\n  * Find a partner\n  * Report a website issue\n  * Site Status Dashboard\n  * Report a security problem\n\n### RED HAT DEVELOPER\n\nBuild here. Go anywhere.\n\nWe serve the builders. The problem solvers who create careers with code.\n\nJoin us if you\u2019re a developer, software engineer, web designer, front-end\ndesigner, UX designer, computer scientist, architect, tester, product manager,\nproject manager or team lead.\n\nSign me up\n\n### Red Hat legal and privacy links\n\n  * About Red Hat\n  * Jobs\n  * Events\n  * Locations\n  * Contact Red Hat\n  * Red Hat Blog\n  * Diversity, equity, and inclusion\n  * Cool Stuff Store\n  * Red Hat Summit\n\n### Red Hat legal and privacy links\n\n  * Privacy statement\n  * Terms of use\n  * All policies and guidelines\n  * Digital accessibility\n  * Cookie preferences\n\n\u2713\n\nThanks for sharing!\n\nAddToAny\n\nMore...\n\n## Report a website issue\n\n", "frontpage": false}
