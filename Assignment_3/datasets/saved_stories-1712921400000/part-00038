{"aid": "40008841", "title": "Building a Linux Container Using Namespaces: Part \u2013 1", "url": "https://www.polarsparc.com/xhtml/Containers-1.html", "domain": "polarsparc.com", "votes": 11, "user": "Arteiii", "posted_at": "2024-04-12 02:22:25", "comments": 0, "source_title": "Building a Linux Container using Namespaces :: Part - 1", "source_text": "Building a Linux Container using Namespaces :: Part - 1\n\nPolarSPARC  \n---  \n  \nBuilding a Linux Container using Namespaces :: Part - 1\n\nBhaskar S| 03/13/2020  \n---|---  \n  \nOverview\n\nEver wondered how Linux Containers worked ???\n\nCurrently, Docker is one of the most popular and prevalent container\nimplementations.\n\nContainers run on top of the same Operating System kernel, but isolate the\napplication processes running inside them from one another. One of the secret\nsauces behind containers is Namespaces.\n\nA Namespace abstracts global system resources, such as, host names, user IDs,\ngroup IDs, process IDs, network ports, etc., in a way that it appears to the\nprocesses (within the namespace) as though they have their own isolated\ninstance of the global system resources. One of the primary goals of\nnamespaces is to support the implementation of containers (lightweight\nvirtualization).\n\nCurrently, in Linux there are 6 types of namespaces - IPC, Network, Mount,\nPID, User, and UTS.\n\nThe following are brief descriptions for each of the namespaces:\n\n  * IPC :: This namespace isolates certain interprocess communication (IPC) resources, namely, Message Queues, Semaphores, and Shared Memory\n\n  * Network :: This namespace provides isolation of the system resources associated with networking, such as, Network devices, IP addresses, IP routing tables, /proc/net directory, port numbers, and so on\n\n  * Mount :: This namespace isolates the set of filesystem mount points seen by a group of processes. Processes in different mount namespaces can have different views of the filesystem hierarchy\n\n  * PID :: This namespace isolates the process ID number space. This allows processes in different PID namespaces to have the same PID\n\n  * User :: This namespace isolates the user and group ID number spaces, such that, a process's user and group IDs can be different inside and outside the user namespace\n\n  * UTS :: This namespace isolates two system identifiers \u00e2\u20ac\u201d the hostname and the domainname. For containers, the UTS namespaces allows each container to have its own hostname and NIS domain name\n\nFor the demonstration in this article, we will be using the unshare Linux\ncommand as well as implement, build, and execute a simple container using\ngolang.\n\nInstallation and Setup\n\nThe installation is on a Ubuntu 18.04 LTS based Linux desktop.\n\nWe will need two commands newuidmap and newgidmap to demonstrate User\nnamespace. For this, we need to install the package uidmap.\n\nTo install the package uidmap, execute the following command:\n\n$ sudo apt install -y uidmap\n\nNext, we will need the brctl command to create a bridge network interface. For\nthis, we need to install the package bridge-utils.\n\nTo install the package bridge-utils, execute the following command:\n\n$ sudo apt install -y bridge-utils\n\nTo develop, build, and execute the simple container in go programming\nlanguage, we need to install the golang package.\n\nTo check the version of golang available to install, execute the following\ncommand:\n\n$ sudo apt-cache policy golang\n\nThe following would be a typical output:\n\n#### Output.1\n\n    \n    \n    golang: Installed: (none) Candidate: 2:1.13~1ubuntu1ppa1~bionic Version table: *** 2:1.13~1ubuntu1ppa1~bionic 500 500 http://ppa.launchpad.net/hnakamur/golang-1.13/ubuntu bionic/main amd64 Packages 500 http://ppa.launchpad.net/hnakamur/golang-1.13/ubuntu bionic/main i386 Packages 100 /var/lib/dpkg/status 2:1.10~4ubuntu1 500 500 http://archive.ubuntu.com/ubuntu bionic/main amd64 Packages\n\nTo install golang, execute the following command:\n\n$ sudo apt install -y golang\n\nThe above installation procedure installs golang from the official Ubuntu\nrepository.\n\nCreate a directory for developing, building, and running go programs by\nexecuting the following commands:\n\n$ mkdir $HOME/projects/go\n\n$ export GOPATH=$HOME/projects/go\n\nWe will need one of the popular go packages on netlink for networking.\n\nTo download the go package, execute the following command:\n\n$ go get github.com/vishvananda/netlink\n\nOpen two Terminal windows - we will refer to them as TA and TB respectively.\nTB is where we will demonstrate the simple container.\n\nWe need to download a minimal root filesystem (rootfs) that will be used as\nthe base image for the simple container. For our demonstration, we will choose\nthe latest Ubuntu Base 18.04.4 LTS at the time of this article.\n\nWe will assume the latest Ubuntu Base is downloaded to the directory\n$HOME/Downloads.\n\nHands-on with Namespaces\n\nUTS Namespace\n\nThe unshare command executes the specified program with the indicated\nnamespace(s) isolated from the parent process.\n\nTo display the options for the unshare command, execute the following command\nin TA:\n\n$ unshare -h\n\nThe following would be a typical output:\n\n#### Output.2\n\n    \n    \n    Usage: unshare [options] [<program> [<argument>...]] Run a program with some namespaces unshared from the parent. Options: -m, --mount[=<file>] unshare mounts namespace -u, --uts[=<file>] unshare UTS namespace (hostname etc) -i, --ipc[=<file>] unshare System V IPC namespace -n, --net[=<file>] unshare network namespace -p, --pid[=<file>] unshare pid namespace -U, --user[=<file>] unshare user namespace -C, --cgroup[=<file>] unshare cgroup namespace -f, --fork fork before launching <program> --mount-proc[=<dir>] mount proc filesystem first (implies --mount) -r, --map-root-user map current user to root (implies --user) --propagation slave|shared|private|unchanged modify mount propagation in mount namespace -s, --setgroups allow|deny control the setgroups syscall in user namespaces -h, --help display this help -V, --version display version\n\nEach process (with [PID]) has associated with it a sub-directory\n/proc/[PID]/ns that contains one entry for each of the namespaces.\n\nTo list all the namespaces associated with a process, execute the following\ncommand in TA :\n\n$ ls -l /proc/$$/ns\n\nThe following would be a typical output:\n\n#### Output.3\n\n    \n    \n    total 0 lrwxrwxrwx 1 alice alice 0 Mar 7 12:17 cgroup -> 'cgroup:[4026531835]' lrwxrwxrwx 1 alice alice 0 Mar 7 12:17 ipc -> 'ipc:[4026531839]' lrwxrwxrwx 1 alice alice 0 Mar 7 12:17 mnt -> 'mnt:[4026531840]' lrwxrwxrwx 1 alice alice 0 Mar 7 12:17 net -> 'net:[4026531993]' lrwxrwxrwx 1 alice alice 0 Mar 7 12:17 pid -> 'pid:[4026531836]' lrwxrwxrwx 1 alice alice 0 Mar 7 20:41 pid_for_children -> 'pid:[4026531836]' lrwxrwxrwx 1 alice alice 0 Mar 7 12:17 user -> 'user:[4026531837]' lrwxrwxrwx 1 alice alice 0 Mar 7 12:17 uts -> 'uts:[4026531838]'\n\nTo launch a simple container whose host name is isolated from the parent host\nname, execute the following command in TB:\n\n$ sudo unshare -u /bin/sh\n\nThe -u option enables the UTS namespace.\n\nThe command prompt will change to a #.\n\nTo check the PID of the simple container, execute the following command in TB:\n\n# echo $$\n\nThe following would be a typical output:\n\n#### Output.4\n\n    \n    \n    18872\n\nTo list all the namespaces associated with the simple container, execute the\nfollowing command in TB:\n\n# ls -l /proc/$$/ns\n\nThe following would be a typical output:\n\n#### Output.5\n\n    \n    \n    total 0 lrwxrwxrwx 1 root root 0 Mar 7 12:36 cgroup -> 'cgroup:[4026531835]' lrwxrwxrwx 1 root root 0 Mar 7 12:36 ipc -> 'ipc:[4026531839]' lrwxrwxrwx 1 root root 0 Mar 7 12:36 mnt -> 'mnt:[4026531840]' lrwxrwxrwx 1 root root 0 Mar 7 12:36 net -> 'net:[4026531993]' lrwxrwxrwx 1 root root 0 Mar 7 12:36 pid -> 'pid:[4026531836]' lrwxrwxrwx 1 root root 0 Mar 7 12:36 pid_for_children -> 'pid:[4026531836]' lrwxrwxrwx 1 root root 0 Mar 7 12:36 user -> 'user:[4026531837]' lrwxrwxrwx 1 root root 0 Mar 7 12:36 uts -> 'uts:[4026533064]'\n\nComparing Output.5 to Output.3, we see a change in the uts namespace, which is\nexpected and correct.\n\nTo change the host name of the simple container, execute the following command\nin TB:\n\n# hostname leopard\n\nTo display the host name of the parent host, execute the following command in\nTA:\n\n$ hostname\n\nThe following would be a typical output:\n\n#### Output.6\n\n    \n    \n    polarsparc\n\nTo display the host name of the simple container, execute the following\ncommand in TB:\n\n# hostname\n\nThe following would be a typical output:\n\n#### Output.7\n\n    \n    \n    leopard\n\nThis demonstrates to us that we have isolated the host name of the simple\ncontainer from the parent host name.\n\nTo exit the simple container, execute the following command in TB:\n\n# exit\n\nNext, we will mimic the above UTS namespace isolation using the following go\nprogram:\n\nThe Command function from the exec package allows one to run the specified\ncommand (1st parameter) with the supplied arguments (2nd parameter). It\nreturns an instance of the Cmd struct.\n\nOne can set the standard input (os.Stdin), the standard output os.Stdout, the\nstandard error os.Stderr, and some operating system specific attributes on the\nreturned Cmd instance. In this case, we specify the syscall.CLONE_NEWUTS OS\nattribute to indicate the command be run in a new UTS namespace.\n\nIMPORTANT : When the main process starts, it internally spawns another main\nprocess (with the CLONE argument) in a new namespace. It is this spawned main\nprocess (running in the new namespace) that is overlayed (syscall.Exec) with\nthe shell command by invoking the function execContainerShell.\n\nCreate and change to the directory $GOPATH/uts by executing the following\ncommands in TB:\n\n$ mkdir -p $GOPATH/uts\n\n$ cd $GOPATH/uts\n\nCopy the above code into the program file main.go in the current directory.\n\nTo compile the program file main.go, execute the following command in TB:\n\n$ go build main.go\n\nTo run program main, execute the following command in TB:\n\n$ sudo ./main\n\nThe following would be a typical output:\n\n#### Output.8\n\n    \n    \n    2020/03/07 12:49:11 Starting process ./main with args: [./main] 2020/03/07 12:49:11 Ready to run command ... 2020/03/07 12:49:11 Starting process ./main with args: [./main CLONE] 2020/03/07 12:49:11 Ready to exec container shell ... ->\n\nThe command prompt will change to a ->.\n\nTo display the host name of the simple container, execute the following\ncommand in TB:\n\n-> hostname\n\nThe following would be a typical output:\n\n#### Output.9\n\n    \n    \n    leopard\n\nTo exit the simple container, execute the following command in TB:\n\n-> exit\n\nSUCCESS !!! We have demonstrated the UTS namespace using both the unshare\ncommand and a simple go program.\n\nUser Namespace\n\nLet us layer the User namespace on top of the UTS namespace.\n\nTo launch a simple container whose user/group IDs as well as the host name are\nisolated from the parent namespace, execute the following command in TB:\n\n$ sudo unshare -uU /bin/sh\n\nThe -U option enables the User namespace.\n\nTo display the user ID and group ID in the new namespace, execute the\nfollowing command in TB:\n\n$ id\n\nThe following would be a typical output:\n\n#### Output.10\n\n    \n    \n    uid=65534(nobody) gid=65534(nogroup) groups=65534(nogroup)\n\nWhen a User namespace is created, it starts without a mapping for the\nuser/group IDs in the new namespace to the parent user/group IDs. The unmapped\nuser/group ID is assigned the default value of the overflow user/group ID. The\ndefault value for the overflow user ID is read from\n/proc/sys/kernel/overflowuid (which is 65534). Similarly, the default value\nfor the overflow group ID is read from /proc/sys/kernel/overflowgid (which is\n65534).\n\nTo fix the mapping for the user/group ID to the parent user/group ID, exit the\nsimple container by executing the following command in TB:\n\n$ exit\n\nTo re-launch the simple container with the current effective user/group ID\nmapped to the superuser user/group ID in the new namespace, execute the\nfollowing command in TB:\n\n$ sudo unshare -uUr /bin/sh\n\nThe -r option enables the mapping of the user/group IDs in the new namespace\nto the parent namespace user/group IDs.\n\nThe command prompt will change to a #.\n\nTo display the user ID and group ID in the new namespace, execute the\nfollowing command in TB:\n\n# id\n\nThe following would be a typical output:\n\n#### Output.11\n\n    \n    \n    uid=0(root) gid=0(root) groups=0(root)\n\nTo list all the namespaces associated with the simple container, execute the\nfollowing command in TB:\n\n# ls -l /proc/$$/ns\n\nThe following would be a typical output:\n\n#### Output.12\n\n    \n    \n    total 0 lrwxrwxrwx 1 root root 0 Mar 7 13:09 cgroup -> 'cgroup:[4026531835]' lrwxrwxrwx 1 root root 0 Mar 7 13:09 ipc -> 'ipc:[4026531839]' lrwxrwxrwx 1 root root 0 Mar 7 13:09 mnt -> 'mnt:[4026531840]' lrwxrwxrwx 1 root root 0 Mar 7 13:09 net -> 'net:[4026531993]' lrwxrwxrwx 1 root root 0 Mar 7 13:09 pid -> 'pid:[4026531836]' lrwxrwxrwx 1 root root 0 Mar 7 13:09 pid_for_children -> 'pid:[4026531836]' lrwxrwxrwx 1 root root 0 Mar 7 13:09 user -> 'user:[4026532892]' lrwxrwxrwx 1 root root 0 Mar 7 13:09 uts -> 'uts:[4026533401]'\n\nComparing Output.12 to Output.3, we see a change in both the uts namespace as\nwell as the user namespace, which is what is expected and correct.\n\nTo exit the simple container, execute the following command in TB:\n\n# exit\n\nNext, we will mimic the above UTS and User namespace isolation using the\nfollowing go program:\n\nAs indicated previously, the Command function returns an instance of the Cmd\nstruct.\n\nIn this example, we specify the additional syscall.CLONE_NEWUSER OS attribute\nto indicate the command be run in a new User namespace.\n\nIn addition, we set the user ID map UidMappings as an array of\nsyscall.SysProcIDMap struct entries, each consisting of the user ID mapping in\nthe container (ContainerID) to the user ID in the host namespace (HostID). In\nthis case, we map the root user ID 0 in the container to the root user ID 0 of\nthe host namespace. Similarly, we set the group ID map GidMappings\n\nCreate and change to the directory $GOPATH/user by executing the following\ncommands in TB:\n\n$ mkdir -p $GOPATH/user\n\n$ cd $GOPATH/user\n\nCopy the above code into the program file main.go in the current directory.\n\nTo compile the program file main.go, execute the following command in TB:\n\n$ go build main.go\n\nTo run program main, execute the following command in TB:\n\n$ sudo ./main\n\nThe following would be a typical output:\n\n#### Output.13\n\n    \n    \n    2020/03/07 13:17:02 Starting process ./main with args: [./main] 2020/03/07 13:17:02 Ready to run command ... 2020/03/07 13:17:02 Starting process ./main with args: [./main CLONE] 2020/03/07 13:17:02 Ready to exec container shell ... ->\n\nThe command prompt will change to a ->.\n\nTo display the user ID and group ID in the new namespace, execute the\nfollowing command in TB:\n\n-> id\n\nThe following would be a typical output:\n\n#### Output.14\n\n    \n    \n    uid=0(root) gid=0(root) groups=0(root)\n\nTo list all the namespaces associated with the simple container, execute the\nfollowing command in TB:\n\n-> ls -l /proc/$$/ns\n\nThe following would be a typical output:\n\n#### Output.15\n\n    \n    \n    total 0 lrwxrwxrwx 1 root root 0 Mar 13 21:17 cgroup -> 'cgroup:[4026531835]' lrwxrwxrwx 1 root root 0 Mar 13 21:17 ipc -> 'ipc:[4026531839]' lrwxrwxrwx 1 root root 0 Mar 13 21:17 mnt -> 'mnt:[4026531840]' lrwxrwxrwx 1 root root 0 Mar 13 21:17 net -> 'net:[4026531993]' lrwxrwxrwx 1 root root 0 Mar 13 21:17 pid -> 'pid:[4026531836]' lrwxrwxrwx 1 root root 0 Mar 13 21:17 pid_for_children -> 'pid:[4026531836]' lrwxrwxrwx 1 root root 0 Mar 13 21:17 user -> 'user:[4026532666]' lrwxrwxrwx 1 root root 0 Mar 13 21:17 uts -> 'uts:[4026532723]'\n\nTo display the host name of the simple container, execute the following\ncommand in TB:\n\n-> hostname\n\nThe following would be a typical output:\n\n#### Output.16\n\n    \n    \n    leopard\n\nTo exit the simple container, execute the following command in TB:\n\n-> exit\n\nSUCCESS !!! We have demonstrated the combined UTS and User namespaces using\nboth the unshare command and a simple go program.\n\nPID Namespace\n\nLet us now layer the PID namespace on top of the User namespace and the UTS\nnamespace.\n\nTo launch a simple container whose process IDs as well as the user/group IDs\nand the host name are isolated from the parent namespace, execute the\nfollowing command in TB:\n\n$ sudo unshare -uUrpf --mount-proc /bin/sh\n\nThe -p option enables the PID namespace.\n\nThe -f option enables spawning (or forking) of new processes in the new\nnamespace.\n\nThe --mount-proc option mounts the proc filesystem as a private mount at /proc\nin the new namespace. This means the /proc pseudo directory only shows\ninformation only about processes within that PID namespace.\n\n#### ATTENTION\n\n    \n    \n    Ensure the option -f is *SPECIFIED*. Else will encounter the following error:\n    \n    /bin/sh: 4: Cannot fork\n\nThe command prompt will change to a #.\n\nTo display all the processes in the new namespace, execute the following\ncommand in TB:\n\n# ps -fu\n\nThe following would be a typical output:\n\n#### Output.17\n\n    \n    \n    USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.0 4628 880 pts/1 S 09:08 0:00 /bin/sh root 6 0.0 0.0 37368 3340 pts/1 R+ 09:12 0:00 ps -fu\n\nTo display all the processes in the parent namespace, execute the following\ncommand in TA:\n\n$ ps -fu\n\nThe following would be a typical output:\n\n#### Output.18\n\n    \n    \n    USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND polarsparc 8695 0.0 0.0 22840 5424 pts/1 Ss 08:43 0:00 bash polarsparc 8681 0.0 0.0 22708 5096 pts/0 Ss 08:43 0:00 bash polarsparc 9635 0.0 0.0 37368 3364 pts/0 R+ 09:12 0:00 \\_ ps -fu\n\nComparing Output.17 to Output.18, we see the isolation between the new\nnamespace and the parent namespace, which is what is expected and correct.\n\nTo exit the simple container, execute the following command in TB:\n\n# exit\n\nNext, we will mimic the above UTS, User, and PID namespace isolation using the\nfollowing go program:\n\nAs indicated previously, the Command function returns an instance of the Cmd\nstruct.\n\nIn this example, we specify the additional syscall.CLONE_NEWNS and\nsyscall.CLONE_NEWPID OS attributes to indicate the command be run in a new PID\nnamespace.\n\nCreate and change to the directory $GOPATH/pid by executing the following\ncommands in TB:\n\n$ mkdir -p $GOPATH/pid\n\n$ cd $GOPATH/pid\n\nCopy the above code into the program file main.go in the current directory.\n\nTo compile the program file main.go, execute the following command in TB:\n\n$ go build main.go\n\nTo run program main, execute the following command in TB:\n\n$ sudo ./main\n\nThe following would be a typical output:\n\n#### Output.19\n\n    \n    \n    2020/03/07 13:38:02 Starting process ./main with args: [./main] 2020/03/07 13:38:02 Ready to run command ... 2020/03/07 13:38:02 Starting process ./main with args: [./main CLONE] 2020/03/07 13:38:02 Ready to exec container shell ... ->\n\nThe command prompt will change to a ->.\n\nTo display the host name of the simple container, execute the following\ncommand in TB:\n\n-> hostname\n\nThe following would be a typical output:\n\n#### Output.20\n\n    \n    \n    leopard\n\nTo display the user ID and group ID in the new namespace, execute the\nfollowing command in TB:\n\n-> id\n\nThe following would be a typical output:\n\n#### Output.21\n\n    \n    \n    uid=0(root) gid=0(root) groups=0(root)\n\nTo display all the processes in the simple container, execute the following\ncommand in TB:\n\n-> ps -fu\n\nThe following would be a typical output:\n\n#### Output.22\n\n    \n    \n    USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.0 4628 776 pts/1 S 09:41 0:00 root 6 0.0 0.0 37368 3400 pts/1 R+ 09:41 0:00 ps -fu\n\nTo list all the namespaces associated with the simple container, execute the\nfollowing command in TB:\n\n-> ls -l /proc/$$/ns\n\nThe following would be a typical output:\n\n#### Output.23\n\n    \n    \n    total 0 lrwxrwxrwx 1 root root 0 Mar 14 09:44 cgroup -> 'cgroup:[4026531835]' lrwxrwxrwx 1 root root 0 Mar 14 09:44 ipc -> 'ipc:[4026531839]' lrwxrwxrwx 1 root root 0 Mar 14 09:44 mnt -> 'mnt:[4026532366]' lrwxrwxrwx 1 root root 0 Mar 14 09:44 net -> 'net:[4026531993]' lrwxrwxrwx 1 root root 0 Mar 14 09:44 pid -> 'pid:[4026532368]' lrwxrwxrwx 1 root root 0 Mar 14 09:44 pid_for_children -> 'pid:[4026532368]' lrwxrwxrwx 1 root root 0 Mar 14 09:44 user -> 'user:[4026532365]' lrwxrwxrwx 1 root root 0 Mar 14 09:44 uts -> 'uts:[4026532367]'\n\nTo exit the simple container, execute the following command in TB:\n\n-> exit\n\nSUCCESS !!! We have demonstrated the combined UTS, User, and PID namespaces\nusing both the unshare command and a simple go program.\n\nMount Namespace\n\nWe will now setup the minimal Ubuntu Base image for use in the new namespace\nin the /tmp directory.\n\nTo create and copy the base image to a directory in /tmp, execute the\nfollowing commands in TA:\n\n$ mkdir -p /tmp/rootfs/.old_root\n\n$ tar -xvf $HOME/Downloads/ubuntu-base-18.04.4-base-amd64.tar.gz --directory\n/tmp/rootfs\n\ncd /tmp\n\nNow let us now layer the Mount namespace on top of the User, the UTS, and the\nPID namespaces.\n\nTo launch a simple container whose mount points as well as the process IDs,\nthe user/group IDs, and the host name are isolated from the parent namespace,\nexecute the following command in TB:\n\n$ sudo unshare -uUrpfm --mount-proc /bin/sh\n\nThe -m option enables the Mount namespace.\n\nThe command prompt will change to a #.\n\nTo list all the mount points in the parent namespace, execute the following\ncommand in TA:\n\n$ cat /proc/mounts | sort\n\nThe following would be a typical output:\n\n#### Output.24\n\n    \n    \n    cgroup /sys/fs/cgroup/blkio cgroup rw,nosuid,nodev,noexec,relatime,blkio 0 0 cgroup /sys/fs/cgroup/cpu,cpuacct cgroup rw,nosuid,nodev,noexec,relatime,cpu,cpuacct 0 0 cgroup /sys/fs/cgroup/cpuset cgroup rw,nosuid,nodev,noexec,relatime,cpuset 0 0 cgroup /sys/fs/cgroup/devices cgroup rw,nosuid,nodev,noexec,relatime,devices 0 0 cgroup /sys/fs/cgroup/freezer cgroup rw,nosuid,nodev,noexec,relatime,freezer 0 0 cgroup /sys/fs/cgroup/hugetlb cgroup rw,nosuid,nodev,noexec,relatime,hugetlb 0 0 cgroup /sys/fs/cgroup/memory cgroup rw,nosuid,nodev,noexec,relatime,memory 0 0 cgroup /sys/fs/cgroup/net_cls,net_prio cgroup rw,nosuid,nodev,noexec,relatime,net_cls,net_prio 0 0 cgroup /sys/fs/cgroup/perf_event cgroup rw,nosuid,nodev,noexec,relatime,perf_event 0 0 cgroup /sys/fs/cgroup/pids cgroup rw,nosuid,nodev,noexec,relatime,pids 0 0 cgroup /sys/fs/cgroup/rdma cgroup rw,nosuid,nodev,noexec,relatime,rdma 0 0 cgroup /sys/fs/cgroup/systemd cgroup rw,nosuid,nodev,noexec,relatime,xattr,name=systemd 0 0 cgroup /sys/fs/cgroup/unified cgroup2 rw,nosuid,nodev,noexec,relatime,nsdelegate 0 0 configfs /sys/kernel/config configfs rw,relatime 0 0 debugfs /sys/kernel/debug debugfs rw,relatime 0 0 devpts /dev/pts devpts rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000 0 0 /dev/sda1 / ext4 rw,relatime,errors=remount-ro,data=ordered 0 0 /dev/sdb1 /home ext4 rw,relatime,data=ordered 0 0 /dev/sdc1 /home/data ext4 rw,relatime,data=ordered 0 0 fusectl /sys/fs/fuse/connections fusectl rw,relatime 0 0 gvfsd-fuse /run/user/1000/gvfs fuse.gvfsd-fuse rw,nosuid,nodev,relatime,user_id=1000,group_id=1000 0 0 hugetlbfs /dev/hugepages hugetlbfs rw,relatime,pagesize=2M 0 0 mqueue /dev/mqueue mqueue rw,relatime 0 0 proc /proc proc rw,nosuid,nodev,noexec,relatime 0 0 pstore /sys/fs/pstore pstore rw,nosuid,nodev,noexec,relatime 0 0 securityfs /sys/kernel/security securityfs rw,nosuid,nodev,noexec,relatime 0 0 sysfs /sys sysfs rw,nosuid,nodev,noexec,relatime 0 0 systemd-1 /proc/sys/fs/binfmt_misc autofs rw,relatime,fd=25,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=28210 0 0 tmpfs /dev/shm tmpfs rw,nosuid,nodev 0 0 tmpfs /run/lock tmpfs rw,nosuid,nodev,noexec,relatime,size=5120k 0 0 tmpfs /run tmpfs rw,nosuid,noexec,relatime,size=3293620k,mode=755 0 0 tmpfs /run/user/1000 tmpfs rw,nosuid,nodev,relatime,size=3293616k,mode=700,uid=1000,gid=1000 0 0 tmpfs /sys/fs/cgroup tmpfs ro,nosuid,nodev,noexec,mode=755 0 0 udev /dev devtmpfs rw,nosuid,relatime,size=16402556k,nr_inodes=4100639,mode=755 0 0\n\nNow, let us list all the mount points in the new namespace by executing the\nfollowing command in TB:\n\n# cat /proc/mounts | sort\n\nThe following would be a typical output:\n\n#### Output.25\n\n    \n    \n    cgroup /sys/fs/cgroup/blkio cgroup rw,nosuid,nodev,noexec,relatime,blkio 0 0 cgroup /sys/fs/cgroup/cpu,cpuacct cgroup rw,nosuid,nodev,noexec,relatime,cpu,cpuacct 0 0 cgroup /sys/fs/cgroup/cpuset cgroup rw,nosuid,nodev,noexec,relatime,cpuset 0 0 cgroup /sys/fs/cgroup/devices cgroup rw,nosuid,nodev,noexec,relatime,devices 0 0 cgroup /sys/fs/cgroup/freezer cgroup rw,nosuid,nodev,noexec,relatime,freezer 0 0 cgroup /sys/fs/cgroup/hugetlb cgroup rw,nosuid,nodev,noexec,relatime,hugetlb 0 0 cgroup /sys/fs/cgroup/memory cgroup rw,nosuid,nodev,noexec,relatime,memory 0 0 cgroup /sys/fs/cgroup/net_cls,net_prio cgroup rw,nosuid,nodev,noexec,relatime,net_cls,net_prio 0 0 cgroup /sys/fs/cgroup/perf_event cgroup rw,nosuid,nodev,noexec,relatime,perf_event 0 0 cgroup /sys/fs/cgroup/pids cgroup rw,nosuid,nodev,noexec,relatime,pids 0 0 cgroup /sys/fs/cgroup/rdma cgroup rw,nosuid,nodev,noexec,relatime,rdma 0 0 cgroup /sys/fs/cgroup/systemd cgroup rw,nosuid,nodev,noexec,relatime,xattr,name=systemd 0 0 cgroup /sys/fs/cgroup/unified cgroup2 rw,nosuid,nodev,noexec,relatime,nsdelegate 0 0 configfs /sys/kernel/config configfs rw,relatime 0 0 debugfs /sys/kernel/debug debugfs rw,relatime 0 0 devpts /dev/pts devpts rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000 0 0 /dev/sda1 / ext4 rw,relatime,errors=remount-ro,data=ordered 0 0 /dev/sdb1 /home ext4 rw,relatime,data=ordered 0 0 /dev/sdc1 /home/data ext4 rw,relatime,data=ordered 0 0 fusectl /sys/fs/fuse/connections fusectl rw,relatime 0 0 gvfsd-fuse /run/user/1000/gvfs fuse.gvfsd-fuse rw,nosuid,nodev,relatime,user_id=1000,group_id=1000 0 0 hugetlbfs /dev/hugepages hugetlbfs rw,relatime,pagesize=2M 0 0 mqueue /dev/mqueue mqueue rw,relatime 0 0 proc /proc proc rw,nosuid,nodev,noexec,relatime 0 0 proc /proc proc rw,nosuid,nodev,noexec,relatime 0 0 pstore /sys/fs/pstore pstore rw,nosuid,nodev,noexec,relatime 0 0 securityfs /sys/kernel/security securityfs rw,nosuid,nodev,noexec,relatime 0 0 sysfs /sys sysfs rw,nosuid,nodev,noexec,relatime 0 0 systemd-1 /proc/sys/fs/binfmt_misc autofs rw,relatime,fd=25,pgrp=0,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=28210 0 0 tmpfs /dev/shm tmpfs rw,nosuid,nodev 0 0 tmpfs /run/lock tmpfs rw,nosuid,nodev,noexec,relatime,size=5120k 0 0 tmpfs /run tmpfs rw,nosuid,noexec,relatime,size=3293620k,mode=755 0 0 tmpfs /run/user/1000 tmpfs rw,nosuid,nodev,relatime,size=3293616k,mode=700,uid=1000,gid=1000 0 0 tmpfs /sys/fs/cgroup tmpfs ro,nosuid,nodev,noexec,mode=755 0 0 udev /dev devtmpfs rw,nosuid,relatime,size=16402556k,nr_inodes=4100639,mode=755 0 0\n\nComparing Output.25 and Output.24, we see the one difference for proc. When a\nnew Mount namespace is created, the mount points of the new namespace is a\ncopy of the mount points in the parent's namespace.\n\nWe will now demonstrate any changes to the new namespace will not affect the\nparent namespace.\n\nTo make the mount point / (and its children recursively) to be private to the\nnew namespace, execute the following command in TB:\n\n# mount --make-rprivate /\n\nTo recursive bind the mount point rootfs/ to rootfs/ in the new namespace,\nexecute the following command in TB:\n\n# mount --rbind rootfs/ rootfs/\n\nWe need the proc filesystem in the new namespace for making changes to mounts.\nTo mount /proc as the proc filesystem proc in the new namespace, execute the\nfollowing command in TB:\n\n# mount -t proc proc rootfs/proc\n\nNext, we need to make rootfs/ the root filesystem in the new namespace and\nmove the parent root filesystem to rootfs/.old_root using the pivot_root\ncommand. To do that, execute the following commands in TB:\n\n# pivot_root rootfs/ rootfs/.old_root\n\n# cd /\n\nTo list all the file(s) under / in the parent namespace, execute the following\ncommand in TA:\n\n$ ls -l /\n\nThe following would be a typical output:\n\n#### Output.26\n\n    \n    \n    total 96 drwxr-xr-x 2 root root 4096 Mar 1 10:58 bin drwxr-xr-x 3 root root 4096 Mar 16 21:15 boot drwxr-xr-x 2 root root 4096 Sep 13 2019 cdrom drwxr-xr-x 22 root root 4560 Mar 21 06:59 dev drwxr-xr-x 163 root root 12288 Mar 20 10:01 etc drwxr-xr-x 5 root root 4096 Sep 13 2019 home lrwxrwxrwx 1 root root 33 Mar 16 21:15 initrd.img -> boot/initrd.img-4.15.0-91-generic lrwxrwxrwx 1 root root 33 Feb 17 14:08 initrd.img.old -> boot/initrd.img-4.15.0-88-generic drwxr-xr-x 25 root root 4096 Mar 16 13:37 lib drwxr-xr-x 2 root root 4096 Jul 29 2019 lib64 drwx------ 2 root root 16384 Sep 13 2019 lost+found drwxr-xr-x 3 root root 4096 Nov 10 13:00 media drwxr-xr-x 2 root root 4096 Jul 29 2019 mnt drwxr-xr-x 7 root root 4096 Mar 13 08:04 opt dr-xr-xr-x 328 root root 0 Mar 21 06:59 proc drwx------ 9 root root 4096 Feb 23 13:25 root drwxr-xr-x 36 root root 1140 Mar 21 07:04 run drwxr-xr-x 2 root root 12288 Mar 16 13:37 sbin drwxr-xr-x 2 root root 4096 Jul 29 2019 srv dr-xr-xr-x 13 root root 0 Mar 21 06:59 sys drwxrwxrwt 20 root root 4096 Mar 21 11:10 tmp drwxr-xr-x 11 root root 4096 Jul 29 2019 usr drwxr-xr-x 11 root root 4096 Jul 29 2019 var lrwxrwxrwx 1 root root 30 Mar 16 21:15 vmlinuz -> boot/vmlinuz-4.15.0-91-generic lrwxrwxrwx 1 root root 30 Feb 17 14:08 vmlinuz.old -> boot/vmlinuz-4.15.0-88-generic\n\nTo list all the file(s) under / in the new namespace, execute the following\ncommand in TB:\n\n# ls -l /\n\nThe following would be a typical output:\n\n#### Output.27\n\n    \n    \n    total 72 drwxr-xr-x 2 nobody nogroup 4096 Feb 3 20:24 bin drwxr-xr-x 2 nobody nogroup 4096 Apr 24 2018 boot drwxr-xr-x 2 nobody nogroup 4096 Feb 3 20:24 dev drwxr-xr-x 29 nobody nogroup 4096 Feb 3 20:24 etc drwxr-xr-x 2 nobody nogroup 4096 Apr 24 2018 home drwxr-xr-x 8 nobody nogroup 4096 May 23 2017 lib drwxr-xr-x 2 nobody nogroup 4096 Feb 3 20:23 lib64 drwxr-xr-x 2 nobody nogroup 4096 Feb 3 20:23 media drwxr-xr-x 2 nobody nogroup 4096 Feb 3 20:23 mnt drwxr-xr-x 2 nobody nogroup 4096 Feb 3 20:23 opt dr-xr-xr-x 328 root root 0 Mar 21 14:10 proc drwx------ 2 nobody nogroup 4096 Feb 3 20:24 root drwxr-xr-x 4 nobody nogroup 4096 Feb 3 20:23 run drwxr-xr-x 2 nobody nogroup 4096 Feb 3 20:24 sbin drwxr-xr-x 2 nobody nogroup 4096 Feb 3 20:23 srv drwxr-xr-x 2 nobody nogroup 4096 Apr 24 2018 sys drwxrwxr-x 2 nobody nogroup 4096 Feb 3 20:24 tmp drwxr-xr-x 10 nobody nogroup 4096 Feb 3 20:23 usr drwxr-xr-x 11 nobody nogroup 4096 Feb 3 20:24 var\n\nComparing Output.26 and Output.27, we see the root filesystems are totally\ndifferent.\n\nTo mount /tmp as the temporary filesystem tmpfs in the new namespace, execute\nthe following command in TB:\n\n# mount -t tmpfs tmpfs /tmp\n\nTo create a text file /tmp/leopard.txt in the directory /tmp of the new\nnamespace, execute the following command in TB:\n\n# echo 'leopard' > /tmp/leopard.txt\n\nTo list the properties of the file /tmp/leopard.txt in the new namespace,\nexecute the following command in TB:\n\n# ls -l /tmp/leopard.txt\n\nThe following would be a typical output:\n\n#### Output.28\n\n    \n    \n    -rw-r--r-- 1 root root 7 Mar 14 22:05 /tmp/leopard.txt\n\nTo list the properties of the file /tmp/leopard.txt in the parent namespace,\nexecute the following command in TA:\n\n$ ls -l /tmp/leopard.txt\n\nThe following would be a typical output:\n\n#### Output.29\n\n    \n    \n    ls: cannot access '/tmp/leopard.txt': No such file or directory\n\nFinally, to completely remove the parent root filesystem rootfs/.old_root from\nthe new namespace, execute the following commands in TB:\n\n# mount --make-rprivate /.old_root\n\n# umount -l /.old_root\n\nTo list all the mount points in the new namespace by executing the following\ncommand in TB :\n\n# cat /proc/mounts | sort\n\nThe following would be a typical output:\n\n#### Output.30\n\n    \n    \n    /dev/sda1 / ext4 rw,relatime,errors=remount-ro,data=ordered 0 0 proc /proc proc rw,relatime 0 0 tmpfs /tmp tmpfs rw,relatime 0 0\n\nTo exit the new namespace, execute the following command in TB:\n\n# exit\n\nSUCCESS !!! We have demonstrated the combined UTS, User, PID, and Mount\nnamespaces using the unshare command.\n\nReferences\n\nOverview of Linux Namespaces\n\nOverview of Linux User Namespace\n\nOverview of Linux PID Namespace\n\nOverview of Linux Mount Namespace\n\nNamespaces in Operation\n\nunshare Linux Command\n\n\u00a9 PolarSPARC\n\n", "frontpage": true}
