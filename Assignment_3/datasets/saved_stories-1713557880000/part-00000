{"aid": "40087117", "title": "How to be a great software engineer without using your brain", "url": "https://suchdevblog.com/lessons/HowToNotUseYourBrain.html", "domain": "suchdevblog.com", "votes": 4, "user": "SamuelFaure", "posted_at": "2024-04-19 14:16:54", "comments": 0, "source_title": "\ud83e\udde0 How to be a great software engineer without using your brain | Such Dev Blog", "source_text": "\ud83e\udde0 How to be a great software engineer without using your brain | Such Dev Blog\n\nSuch Dev Blog\n\n  * Who am I ?\n  * Portfolio\n  * Resources\n\n    * Resources for the Beginner WebDev\n    * Resources for the Intermediate WebDev\n    * Resources for the Senior WebDev\n    * Design resources for WebDevs\n  * Lessons\n\n    * \ud83d\udcc8 Productivity and Well-being, A summary of what works.\n    * Dramatically increase your productivity with Atomic Git Commits\n    * How to Learn Git Slowly\n    * How to Start Learning CSS without hating yourself\n    * \ud83e\udde0 How to be a great software engineer without using your brain\n\n      * I - Using Your Brain Considered Harmful\n      * II - Problem: Software engineering is complicated.\n      * III - When to think hard, and how to do it.\n      * IV - Work methodologies for the dumb and the lazy.\n      * Conclusion\n    * Explaining Ruby's Singleton Class (Eigenclass) to confused beginners\n  * Opinions\n\n    * The Technical Debt explained with a kitchen analogy\n    * Why our work culture sucks\n    * The Marie Kondo guide for the Clean Developer\n  * Tutorials\n\n    * Build your own system with ArchLinux\n    * Upload Files from Vue.js to Rails with ActiveStorage\n    * Filter Anything in a Rails request in 10 lines of code\n    * Test all your GET routes in rails with 20 lines of code\n    * Testing Ansible scripts with Vagrant\n    * How to use Solr / Sunspot with Rails\n    * Debugging Solr Sunspot like a pro\n\n# \ud83e\udde0 How to be a great software engineer without using your brain\n\nThis article was first featured on Dev.toopen in new window. Thanks to the\neditorial team for choosing it as a top 7 weekly!\n\nI choose a lazy person to do a hard job. Because a lazy person will find an\neasy way to do it. - Bill Gates\n\nThis article is intended to teach you how to do your daily job as a software\nengineer -and do it very well- with the minimal amount of efforts.\n\nWhile I do believe this will have some interesting information for most\nreaders, it will be an especially great read for people who struggle with\nADHD. If you know a programmer or aspiring programmer in this situation, you\nmight help them (and myself) by sharing this article.\n\nLet's start.\n\n## I - Using Your Brain Considered Harmful\n\n### I dislike using my brain.\n\nThe reason is, using your brain is hard. Most people will avoid doing hard\nthings too often. If you can do a great job without efforts, then why should\nyou? You don't get extra points for difficulty.\n\nJob satisfaction increases when you're not suffering. Your energy levels stays\nhigh, your productivity as well.\n\nThere is a secret to achieving high efficiency with minimal efforts, it's\ncalled \"being smart about it\". Martial artists achieve high efficiency by\napplying high pressure onto an opponent's sensitive points. That's knowledge\nwell used.\n\nLet's be smart about it then.\n\n## II - Problem: Software engineering is complicated.\n\nWell, then we just have to make it simple, this way we won't have to think too\nmuch.\n\nTurns out, this task is also the best description of the work of a software\nengineer: reducing complexity.\n\nComplexity is bad. Very, very badopen in new window. It is your job to make\neverything as simple as possible. As we will discuss later, this is the part\nwhere you actually need to be smart and use your brain.\n\nWe achieve simplicity via both programming practices, and work methodologies.\nSome examples:\n\nProgramming practices Elegant, high-quality code. Following best practices.\nUsing the right OOP patterns at the right time, functional programming when it\nmakes sense. Refactoring. Avoiding technical debtopen in new window and\nspaghetti code. You get the idea, but this is not what this article is about,\nwe're here for the next section:\n\nWork methodologies Let's explore some work methods that will help you save on\nall that precious brainpower.\n\n## III - When to think hard, and how to do it.\n\nAs you will notice, the methodologies I will detail are not really about not\nthinking. They are about thinking hard, at the right time.\n\nI do believe there are merits in the saying: \"Sleep only when you're very\nsleepy, eat only when you're very hungry\". I would add: \"Think hard only when\nyou really need to think hard\".\n\nKnowing when to think hard and then actually thinking hard is key to building\ngreat software.\n\nHere are two great work methods to achieve great thinking:\n\nDeep work: as explained by Cal Newport in his (amazing) book, it's all about\nmaximizing work efficiency by achieving high focus.\n\nPomodoros: By cutting your work into small time fractions and combining this\nwith deep work, you can actually achieve your best work.\n\nFeel free to research those topics, because I will not detail them here. We're\ngoing to focus less on how to use your brain and more on when to use your\nbrain.\n\n## IV - Work methodologies for the dumb and the lazy.\n\n### Atomic Git commitsopen in new window\n\nThe way you use Git can force you to use your brain more efficiently. I\nstrongly advise you to read the linked article, it explains why quite well.\n\nThe gist is: using Atomic Git commits forces you to map in your head the exact\nsuite of commits necessary to achieve your goals, in small steps.\n\nBreaking up a big task into smaller, simpler, easier steps? That's the\ntextbook recipe for reducing complexity!\n\nThe difficulty with this method is that you have to pay in mental currency at\nthe very beginning. As they say, \"A week of coding can save on 30 minutes of\nplanning\". Still, because thinking is hard, we tend not to do it. That is a\nmistake, because you will have to pay the interests later.\n\nOnce you've cut your task into smaller steps, you can turn off your brain. You\nwon't need that bag of meat anymore.\n\n### BDD, Not TDD.\n\nSo I'm definitely not making friends here (hello ThePrimeagen, hope you like\nthis one as well), since this is a very controversial topic. This will digress\nsomewhat, but I think in an interesting way. Disclaimer, this is only my\nopinion, yadda-yadda.\n\nI strongly believe that Behavior-Driven Development is an amazing tool to use\nyour brain as little as possible while achieving high-quality code.\n\nI use the term \"Behavior-Driven Development\" to address a common criticism of\nTest-Driven Development, which is \"You don't know what you want at first, so\nwhen doing TDD you have to rewrite your tests once you know what you want\".\n\nI believe there is a misunderstanding here between opponents and proponents of\nTDD, and the misunderstanding might stem from confusion between TDD and BDD.\n\nWhat supporters of TDD/BDD are hearing is: \"I don't know the specifications\nI'm supposed to fulfill\". This sounds ridiculous: If you don't know what\nyou're supposed to achieve, you should definitely go have a brain-using\nsession until you clarified your specifications.\n\nWhat the opponents of TDD are actually saying is: \"I don't know the steps that\nwill lead me to fulfill my specifications\".\n\nThe difference between those is basically unit testing. Of course you very\nrarely know what the details of your code will look like before you write it,\nso if you're unit testing small portions of code -such as your methods- you\nwill end up rewriting a lot of (mostly useless) tests and have a miserable\ntime.\n\nThe right smallest unit to test in an OOP context is in my opinion generally\nthe Class. And if you thought long enough about the architecture of your code\n(for example when you were breaking down your task in smaller steps, see\nAtomic Git Commits), you will know which classes you want at every step of the\nway.\n\nHence, you will never have to rewrite anything.\n\nAs I said before, I do believe that you should think long and hard before\ndoing any coding, at least until you know exactly what your specifications\nare, including some hard thinking about possible edge cases.\n\nThis is what BDD is all about: thinking hard about your exact specifications\nand coding them first. You know what you want, and once it's in the code, you\njust need to make the specs go brrrr green.\n\nFrankly, once your specs are written down, you can turn off your brain. The\nrest of the work can barely be called \"work\".\n\n## Conclusion\n\nI hope you found something interesting in this article. Don't hesitate to\nshare if you think this can help someone struggle less with the daily demands\nof software engineering.\n\nLast Updated: 4/19/2024, 2:16:15 PM\n\nContributors: Samuelfaure\n\n", "frontpage": false}
