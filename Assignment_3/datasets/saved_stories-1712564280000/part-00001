{"aid": "39965657", "title": "Implicit Data Markup (2023)", "url": "https://rsaarelm.github.io/implicit-data-markup", "domain": "rsaarelm.github.io", "votes": 1, "user": "LAC-Tech", "posted_at": "2024-04-08 02:17:03", "comments": 0, "source_title": "Implicit data markup", "source_text": "Implicit data markup\n\nposts | tags | links\n\n# Implicit data markup\n\nTags: cs/rust, cs/idm, org/notes | 2023-04-22\n\ntl;dr: Minimalist, non-self-describing markup and serialization language\noptimized for human-writability, with an implementation for Rust's Serde,\navailable at github and crates.io.\n\nMy initial note-taking system had a good system for nested, wiki-like note-\ntaking, but it was a bit lacking in any sort of principled metadata system.\nYou can do a lot with an uniform structured data syntax, but many of the\nexisting ones are ugly and verbose or just otherwise awkward to type by hand.\n\nI wanted a notation that's simple to write by hand, does not involve awkward\nblobs of machine-generated cruft, and generally stays out of your way. One\nexample of a syntax getting in your way is how JSON requires you to add\nquotation marks around every string value.\n\nS-expressions used in Lisp are a very simple universal data format, but they\nare formed with parentheses, not with indentation. The nested outlines format\nsuggests using a structure based on newlines and semantically significant\nindentation instead.\n\n## Outlines as expressions\n\nIt turns out that there are propositions for S-expressions that use\nindentation instead of parentheses, like SRFI 49. A rough idea is to replace\natoms with lines and lists with nested blocks. There is a problem though, how\ndo you distinguish ((a b) (c d)) from (((a b)) ((c d)))? The syntax needs some\nsingle extra group separator construct to express the double opening\nparenthesis. SRFI 49 uses the keyword group for this, so (as far as I\nunderstand it) you'd have\n\n    \n    \n    a b c d\n\nand then\n\n    \n    \n    group a b group c d\n\nAfter poking around a bit, I didn't find the direct mapping to S-expressions\nas quite the right fit. Instead, I was looking for something that has the\noutline types as its initial building block.\n\nAt this point, the idea was starting to become a bit clearer. Everything\nstarts with an outline that's a list of items. Items are either single lines\nor sections that consist of a headline and a body. Strings in general can be\ncalled words if they are nonempty but contain no whitespace, lines if they\ncontain no newlines and paragraphs otherwise. (Empty strings aren't called\nanything, you can't really express them in this system.)\n\nThere are now three ways to present a sequence. A sequence consisting of only\nof words can be displayed as a single line. A sequence consisting of words or\nlines can be displayed as a block of uniformly indented lines. A sequence\nconsisting of paragraphs can be displayed as a list of sections. Paragraphs\nprobably aren't section-shaped, so now we're going to need a similar group\nseparator as SRFI 49 had. Let's introduce double hyphen (--) as a dummy\nheadline and make the actual paragraph be its body. This is now our group\nseparator symbol. We'll call sections that have a -- headline blocks. The\ndouble hyphen is also the comment prefix just so I can say I have\nsyntactically significant comments.\n\n    \n    \n    -- Sequence of words on a single line one two three -- Sequence of lines -- twenty one twenty two twenty three -- Sequence of sections \u2019Twas brillig, and the slithy toves Did gyre and gimble in the wabe: All mimsy were the borogoves, And the mome raths outgrabe. -- Sequence of non-section paragraphs with group separators -- CARD AREA REAR DART -- SATOR AREPO TENET OPERA ROTAS\n\n## Implicit data with Serde\n\nSo now I have something a little like S-expressions, where can I go from here?\nI'm writing programs with Rust, where you usually have a Serde serializer\nlibrary that can convert between program data and a data format. An important\nthing with Serde is that you are always deserializing into a known type. I\nfigured I could cut some corners on syntax by exploiting knowledge of the\nexpected type when parsing the input. At any point, the parser knows two\nthings: What kind of type it expects to read next and what shape of an outline\nfragment it is looking at. If it's expecting a structured type like a vector\nor a struct, it will try treating the outline fragment as a sequence\nexpression. If it's expecting an atomic type like a number or a string, it\nwill read in the outline fragment as a single string and try to convert it\ninto the type.\n\nSince the deserializer knows what type it expects, the format doesn't need\nsyntax to help it along. You can write both the list [\"a\", \"b\", \"c\"] and the\nstring \"a b c\" as just a b c, and it will get parsed correctly according to\nthe expected type. As long as you don't need to handle strings that are empty\nor made of only whitespace, there's no need to have any sort of string\nquotation syntax. Any nonempty, not-only-whitespace string is either a word, a\nline or a paragraph, and all of those can be delimited with just the\nwhitespace and the group separator.\n\n## The outline type\n\nThe initial idea was to read the outline notes into an outline type, and then\nsomehow pick fragments of that and use the Serde type deserializer on them. At\nsome point I got thinking. The outline itself seems to have a pretty\nstraightforward recursive type, something like this:\n\n    \n    \n    struct Outline(Vec<(String, Outline)>);\n\n(\"An outline is a sequence of sections, each of which consists of a headline\nstring and an indented body outline.\")\n\nSo could I skip having extra machinery for reading in the entire outline and\nuse my Serde library for that as well, given a well-picked type for a whole\noutline?\n\nLooking at the proposed outline type, the headline string is the only concrete\nvalue there, everything else is structural recursion. A regular string type\ndoesn't quite cut it here though, the headlines are special. First of all,\nthey have to be lines. The headline string must never contain newlines. It\nalso mustn't be followed by the body on the same line, even if the headline is\njust a single word, and the body is another single word. Second, I want the\noutline type to be able to consume and print entire outline files verbatim.\nThis means reading in comments and blank lines as well as content.\n\nSerde is quite rigid about doing anything weird like introducing a second\n\"must be a line, also grabs comments\" string type, you get the Rust type\nmodel, and that's it, so this was the point where I decided to start doing\nstupid things to make the cool idea work. I hacked up a \"raw mode\" that's\narbitrarily marked with the otherwise mostly useless singleton tuple type\n(A,). Pairs also get special treatment in parsing. Sequences like vectors must\nbe serialized uniformly, either as horizontal lines or vertical blocks, but\npairs can be serialized as sections where the first value is the headline and\nthe second value is the body. If the pair's first element is in raw mode, the\npair must be a section.\n\nPair (\"a\", \"b\") can be serialized as a b, but pair ((\"a\",), \"b\") must become\n\n    \n    \n    a b\n\nNow we've got the new version of the outline declaration:\n\n    \n    \n    struct Outline(Vec<((String,), Outline)>);\n\nThe singleton tuple on the headline string declares raw mode, I do some very\nhairy work on the Serde code to support the two parsing paths for raw vs non-\nraw input, and everything is go. The serialization type system can now eat\nentire outline note files and preserve all their structure and content.\n\n## Metadata in the outlines\n\nOkay, this is neat and all, but how do you get from the full outline parsing\ntype into a convention for metadata? First question is, what should the\nmetadata look like in notes anyway. A whole sub-outline seems like the obvious\nunit to attach it to, so maybe it should be some sort of header region?\n\n    \n    \n    Note headline -- note: This part is the metadata date: 2020-01-02 tags: notetaking syntax This is the Note body\n\nThat's a bit awkward with the leading --, but looks okay, syntax is pretty\nminimal. I could maybe make it even more minimal, do I really need the colons\nafter the attribute names? Attribute sets look like I could parse them with my\nexisting machinery and a type like Vec<(String, String)> (no raw mode this\ntime), but that would not support the colon in the middle.\n\nIn another fit of weirdness, I started thinking of Clojure's :keyword syntax\nwith a colon before the name, much easier to parse since the colon precedes\nthe entire pair rather than showing up in the middle of it, and the awkward\ninitial indentation of the metadata block. The end result was the second bit\nof dedicated IDM syntax that makes it look like struct attributes have\nClojure-like keyword syntax while actually having nothing to do with\nattributes. The actual colon-syntax rule in IDM is that a group of consecutive\nsection headlines starting with colons at the start of an outline is treated\nas an indented sub-outline with an empty headline.\n\nSo we start with the initial idea minus the colons:\n\n    \n    \n    Note headline -- note This part is the metadata date 2020-01-02 tags notetaking syntax This is the Note body\n\nAnd apply the colon block syntactic sugar to get:\n\n    \n    \n    Note headline :note This part is the metadata :date 2020-01-02 :tags notetaking syntax This is the Note body\n\nThis is what metadata looks like then. You can now write code to walk your\noutline type, look for outlines where the first item is a headline-less block,\nand, well, what do you do with them anyway? Since the expected type dictates\nwhat we get when we parse the input, parsing the same input into different\ntypes can get us different interpretations of it. The metadata can be parsed\nby printing out the outline block containing it and reading it back in into a\ndifferent type. Reading into Vec<(String, String)> is pretty much a catch-all\nfor single-word attributes and the values after them. Reading into\nHashMap<String, String> is mostly the same, except duplicate attributes are no\nlonger allowed (they probably shouldn't be). If you have a very good idea what\nyou're expecting, you can read into a struct with the expected attribute names\nas fields and more specific types as values.\n\nThe map-of-strings is a good middle of the road option, and Serde knows about\nmap types specifically, so IDM has another use of the raw type for this. If\nyou have a map type inside the raw mode singleton tuple as the first element\nof a tuple, the whole tuple will be parsed as an outline with optional\nmetadata. Now we can write the final form of the outline type:\n\n    \n    \n    struct AnnotatedOutline( (IndexMap<String, String>,), Vec<((String,), AnnotatedOutline)>);\n\nThe initial part reads in the metadata header as a map, and ends up with an\nempty map if the outline has no metadata. The second part is the familiar\nplain outline inner type again, except now it recurses into another annotated\noutline instead.\n\nAnd that's it, now you can write neat structured data, embed it in your\noutline notes and read it back, at least if you write your note-parsing tool\nin Rust. Check out the Implicit Data Markup project over at GitHub for more\ndetails.\n\n", "frontpage": false}
