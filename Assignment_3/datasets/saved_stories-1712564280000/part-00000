{"aid": "39965649", "title": "Lambda Screen: Fractals in Pure Lambda Calculus", "url": "https://text.marvinborner.de/2024-03-25-02.html", "domain": "marvinborner.de", "votes": 2, "user": "marvinborner", "posted_at": "2024-04-08 02:15:53", "comments": 0, "source_title": "Lambda Screen", "source_text": "Lambda Screen: Fractals in Pure Lambda Calculus\n\n# Lambda Screen\n\nFractals in Pure Lambda Calculus\n\nMarvin Borner\n\n2024-04-08\n\nPure lambda calculus has encodings for many different data structures like\nlists, numbers, strings, and trees. Wrapped in monadic IO, lambda calculus\nprovides a great interface for computation \u2013 as can be seen in user-friendly\nsyntactic variants like my programming language bruijn. Such simple languages,\nhowever, typically don\u2019t support graphical output (aside from ASCII art).\n\nI present the \u201cLambda Screen\u201d, a way to use terms of pure lambda calculus for\ngenerating images. I also show how recursive terms (induced by fixed-point\ncombinators) can lead to infinitely detailed fractals.\n\nIf you want to skip the details or want to figure out its inner workings\nyourself, go to my reference implementation (source-code) and flip through the\nexamples.\n\n# Encoding\n\nA screen is a term \u03bbx.(x tl tr bl br), where the terms tl, tr, bl, and br\nrepresent the top-left, top-right, bottom-left, and bottom-right quadrants of\nthe image. Each of these terms can either be another screen, or a pixel.\n\nA pixel is either on (white) or off (black). In its on state, a pixel is\ndefined as the k combinator w=\u03bbw b.w In its off state, it\u2019s the ki combinator\nb=\u03bbw b.b This decision was made for simplicity and could be any other state\nencoding, including ones of arbitrary size and color.\n\n## Example\n\nClick the \u201cRender\u201d button to see the results.\n\n  * \u03bb_ x.(x b b b b)\n\n  * \u03bb_ x.(x \u03bby.(y b w w b) w w b)\n\n# Rendering\n\nFor this project, I decided that the entire behavior of the screen is defined\nby a single closed lambda term. Upon execution of the renderer, this function\ngets applied to the default empty screen (four white squares). This enables\nthe use of point-free/Tacit programming (e.g. using combinators), such that\nyou don\u2019t necessarily have to construct screens/colors at all.\n\nThrough slightly modified beta-reduction, the screen gets updated in-place\nwhile the term converges to its normal form. High rendering depths or\ndiverging behavior may stop the renderer before convergence is reached.\n\nNote that the renderer would also work with normal beta-reduction until\nconvergence. The additional steps were only made to add support for in-place\nrendering of diverging terms.\n\n# Reduction\n\nThe in-place reduction-rendering works as follows (written as pseudo-Haskell\nusing de Bruijn indices; actually implemented in JavaScript).\n\nFigure out if a term looks like a screen:\n\n    \n    \n    isScreen (Abs (App (App (App (App (Idx 0) _) _) _) _)) = True isScreen _ = False\n\nColor the quadrants depending on pixel state (or grey if term is not yet\nfigured out):\n\n    \n    \n    quadrantColor (Abs (Abs (Idx 1))) = White quadrantColor (Abs (Abs (Idx 0))) = Black quadrantColor _ = Grey\n\nReduce to normal form (or loop endlessly):\n\n    \n    \n    nf (Abs t) = Abs $ nf t nf (App l r) = case nf l of Abs t -> nf $ subst t r t -> App t (nf r) nf t = t\n\nReduce to weak-head normal form:\n\n    \n    \n    whnf (App l r) = case whnf l of Abs t -> whnf $ subst t r t -> App t r whnf t = t\n\nReduce to screen normal form (either \u03bbx.((((x tl) tr) bl) br), \u03bbw b.w, or \u03bbw\nb.b):\n\n    \n    \n    snf t = case whnf t of Abs b -> case Abs $ whnf b of t@(Abs (Abs _)) -> nf t -- not a screen! t -> let go t | isScreen t = t go (App l r) = case whnf l of (Abs t) -> go $ subst t r t -> go $ App t (whnf r) go (Abs t) = go $ Abs $ whnf t in go t _ -> error \"not a screen/pixel\"\n\nMain reduction and rendering loop (assuming drawing functions that use and\nreturn some ctx):\n\n    \n    \n    reduce ((t, ctx) : ts) | quadrantColor t != Grey = reduce ts reduce ((t, ctx) : ts) = if isScreen $ snf t then let (App (App (App (App _ tl) tr) bl) br) = t in reduce [ (tl, drawTopLeft ctx (quadrantColor tl)) , (tr, drawTopRight ctx (quadrantColor tr)) , (bl, drawBottomLeft ctx (quadrantColor bl)) , (br, drawBottomRight ctx (quadrantColor br)) ] ++ ts else do -- this is pseudo-Haskell after all drawAt ctx (quadrantColor t) reduce ts\n\nSee my reference implementation for more details.\n\n# Fractals\n\n## Sierpi\u0144ski Triangle\n\nWe can\u2019t trivially draw the classic \u201cstanding-up\u201d Sierpi\u0144ski triangle, since\ndrawing the diagonals over square borders would get quite complex.\n\nInstead, we can draw a rotated variant using a simple rewrite rule:\n\nEvery black square stays black forever; each (sub-)quadrant gets recursively\napplied to this rewrite rule.\n\nTranslated to lambda calculus, we get the following:\n\ntriangle\u27f9triangle\u2032=\u03bbx.(x triangle b triangle triangle)=\u03bb_.(y \u03bbt x.(x t b t t))\n\nHere, the rendering is stopped automatically after the smallest resolution of\nthe canvas is reached. Note how the triangle structure appears even though we\nonly ever explicitly draw black pixels. This is because the unresolved\nrecursive triangle calls get (temporarily) drawn as grey until they also get\nreduced. If the reduction wouldn\u2019t be stopped, the canvas would slowly become\nblack entirely.\n\n## T-Square\n\nIn each iteration, the T-Square adds new overlapping squares to the quadrants\nof every square already drawn. For lambda screen we can interpret this as a\nrecursive split into smaller squares, where in each iteration one of the\nquadrants (depending on its position) gets drawn as black.\n\nThe first three iterations look something like this (only black and non-wavy)\n\nWe can model this iteration as a mutual recurrence relation:\n\ntltrblbrtsquare=\u03bbx.(x tl tr bl b)=\u03bbx.(x tl tr b br)=\u03bbx.(x tl b bl br)=\u03bbx.(x b\ntr bl br)=\u03bbx.(x tl tr bl br)\n\nThis relation can be solved using a variadic fixed-point combinator:\n\ntl\u2032tr\u2032bl\u2032br\u2032=\u03bbtl tr bl br.\u03bbx.(x tl tr bl b)=\u03bbtl tr bl br.\u03bbx.(x tl tr b br)=\u03bbtl\ntr bl br.\u03bbx.(x tl b bl br)=\u03bbtl tr bl br.\u03bbx.(x b tr bl br)mutual=(y* \u03bba.(a tl\u2032\n\u03bbb.(b tr\u2032 \u03bbc.(c bl\u2032 \u03bbd.(d br\u2032 nil)))))\n\nThus giving us the final term tsquare\u2019, where the indices indicate the nth\nhead selection of Church lists:\n\ntsquare\u2019=\u03bb_ x.(x mutual0 mutual1 mutual2 mutual3)\n\n## \u201cSierpi\u0144ski Carpet\u201d\n\nThe exact drawing of the Sierpi\u0144ski Carpet is left as an exercise to the\nreader.\n\nSince it\u2019s a bit more straightforward, I decided to generate a slight\nvariant^1 where each quadrant isn\u2019t split into 9 but 4 quadrants per\niteration.\n\nBeautifully drawn visualization of the first three iterations. The red marks\nwill be stable (non-recursive) black squares, while the grey squares will be\nstable white squares. Green and yellow lines added to indicate the splitting\nof squares at each level.\n\nEach new stable quadrant will be one of the following:\n\nsub-tlsub-trsub-blsub-br=\u03bbx.(x b w w \u03bby.(y w w w b))=\u03bbx.(x w b \u03bby.(y w w b w)\nw)=\u03bbx.(x w \u03bby.(y w b w w) b w)=\u03bbx.(x \u03bby.(y b w w w) w w b)\n\nWe again model the generation as a mutual recurrence relation:\n\ntltrblbrcarpet=\u03bbx.(x tl tr bl sub-br)=\u03bbx.(x tl tr sub-bl br)=\u03bbx.(x tl sub-tr\nbl br)=\u03bbx.(x sub-tl tr bl br)=\u03bbx.(x tl tr bl br)\n\nGiving us, as before, the final term:\n\nmutualcarpet\u2032=(y* \u03bba.(a tl\u2032 \u03bbb.(b tr\u2032 \u03bbc.(c bl\u2032 \u03bbd.(d br\u2032 nil)))))=\u03bb_ x.(x\nmutual0 mutual1 mutual2 mutual3)\n\nThere\u2019s obviously huge potential for golfing the term size \u2013 so if you\u2019re into\nthat, have fun!\n\n## Cantor Dust\n\nThe Cantor dust is another great example of how infinitely detailed structures\nappear as unreduced (grey) quadrants when reduction inevitably gets halted.\n\nIn this case, a square gets recursively split into four new squares. Since we\ndo the same split four times, we can construct the new quadrant using a\nquadruple function:\n\nquadruplecantortltrblbr=\u03bbq x.(x q q q q)=\u03bbx.(tl tr bl br)=(quadruple (\u03bbx.x\ncantor b b b)=(quadruple (\u03bbx.x b cantor b b)=(quadruple (\u03bbx.x b b cantor\nb)=(quadruple (\u03bbx.x b b b cantor)\n\nAfter removing the recursive calls using y, we get\n\n\u2217 \u2217 \u2217\n\nAll of the examples above (and more) can also be found, rendered, and modified\nhere.\n\n# Utilities\n\nLastly, here are some useful terms for experimentation (also available in the\n\u201ctemplate\u201d preset).\n\nChecking whether a pixel p is black or white: w?b?=\u03bbp.p=\u03bbp.(p b w)\n\nInverting the state of pixel p: invert=c=\u03bbp x y.(p y x)\n\nGetting the term at a position p of screen s:\n\ntl=\u03bbtl tr bl br.tltr=\u03bbtl tr bl br.trbl=\u03bbtl tr bl br.blbr=\u03bbtl tr bl br.brget=\u03bbp\ns.(s p)\n\nReplacing a quadrant of screen s with q:\n\ntl!tr!bl!br!=\u03bbs q.(s \u03bbtl tr bl br x.(x q tr bl br))=\u03bbs q.(s \u03bbtl tr bl br x.(x\ntl q bl br))=\u03bbs q.(s \u03bbtl tr bl br x.(x tl tr q br))=\u03bbs q.(s \u03bbtl tr bl br x.(x\ntl tr bl q))\n\nApplying each quadrant of a screen s to a function f:\n\nmap=\u03bbf s.(s \u03bbtl tr bl br.\u03bbx.(x (f tl) (f tr) (f bl) (f br)))\n\nOf course you could also use the definition of any function in bruijn\u2019s\nstandard library.\n\n\u2766\n\nThanks for reading. Contact me via email. Support on Ko-fi. Subscribe on RSS.\n\nI\u2019ve also applied for a talk about this topic at GPN22 in Karlsruhe, so you\nmay see me there as well.\n\n  1. It may also be a variant of the T-Square, not sure about the exact definitions. Looks pretty though.\u21a9\ufe0e\n\n  * Share on Twitter\n  * Share on Mastodon\n\n", "frontpage": false}
