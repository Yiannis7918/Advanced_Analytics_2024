{"aid": "40032025", "title": "Strengthening Java Obfuscation with Native Code Integration", "url": "https://widening.re/research/strengthening-java-obfuscation/", "domain": "widening.re", "votes": 2, "user": "xiaomayi", "posted_at": "2024-04-14 15:54:23", "comments": 0, "source_title": "Strengthening Java Obfuscation with Native Code Integration", "source_text": "Strengthening Java Obfuscation with Native Code Integration\n\n## \u2207 Widening\n\nGet quote\n\n# Strengthening Java Obfuscation with Native Code Integration\n\nPublished at 2024-04-14\n\nEnd-user security threats like reverse engineering and code tampering pose\nsignificant challenges for software developers. These threats can lead to\nintellectual property theft and compromised program functionality. Traditional\ncode obfuscation techniques can help, but they often struggle with the\ndetailed information present in bytecode languages like Java.\n\n\u2207 Widening offers a comprehensive suite of software protection services,\nincluding advanced obfuscation specifically designed for bytecode. Our\nsolutions go beyond basic obfuscation to make reverse engineering\nsignificantly more difficult, while maintaining program functionality and\nperformance.\n\nHowever, widely used bytecode languages present difficulties for obfuscation\ndue to their inherent structural and type information. This is particularly\ntrue for Java bytecode, which is designed to enable runtime verification and\noptimization, leading to detailed high-level information being retained. In\ncontrast, optimized machine code from compiled C code contains less\ninformation as it doesn\u2019t require runtime functionalities. This suggests that\nexploring alternative approaches, potentially involving native libraries,\ncould be a promising direction for enhancing obfuscation effectiveness for\nbytecode languages.\n\nWhile some suggest hiding critical Java program sections by implementing them\nin lower-level languages like C, this approach comes with limitations:\n\n  * Increased Development Complexity: Developers need proficiency in both Java and C, potentially introducing compatibility issues and increasing project complexity.\n  * Reduced Security Guarantees: Separating code into C libraries bypasses Java\u2019s built-in verification mechanisms, potentially introducing security vulnerabilities that Java\u2019s checks would normally prevent.\n  * Portability Concerns: C code often lacks portability across different architectures. Implementing portable C code requires additional effort, raising development costs.\n\nThis article proposes a method for automatically converting specific sections\nof Java bytecode into C code. Developers can identify these confidential\nsections based on their software\u2019s security needs. Our tool analyzes the\ncompiled Java code, extracts the annotated parts from the bytecode, and\ntranslates them into C. The translated C code is then compiled into a shared\nlibrary, which the remaining Java program can access using the JNI (Java\nNative Interface).\n\n## Java Internals\n\nThis section provides a brief overview of Java\u2019s unique approach to program\nexecution. Unlike languages like C and C++, Java code isn\u2019t directly compiled\nto machine code for specific processors. Instead, it\u2019s compiled into an\nintermediate format called bytecode. This bytecode acts as a portable set of\ninstructions that can be interpreted and run by the Java Virtual Machine\n(JVM). The JVM itself is available on various platforms, allowing Java\nprograms to function consistently across different operating systems and\nhardware architectures.\n\nThe Java Virtual Machine (JVM) relies on a stack data structure to manage\noperands during program execution. This means all calculations and operations\nhappen by:\n\n  1. Pushing the values involved (operands) onto the stack.\n  2. Processing them based on the operation (e.g., addition).\n  3. Pushing the resulting value back onto the stack.\n\nFor example, adding two integers involves:\n\n  1. Pushing both integers onto the stack.\n  2. Executing the addition instruction.\n  3. The result of the addition is then pushed back onto the stack, replacing the original values.\n\nMethod calls also utilize the stack. Arguments are pushed onto the stack\nbefore calling the method. After the method finishes execution: if it returns\na value (non-void), the result is placed on the stack. This allows subsequent\noperations to access the returned value easily.\n\n### Key Operations\n\nField Access: Instructions in this category interact with fields of a class.\nThey allow reading or writing values from these fields. Each instruction\nexplicitly references the class name, the field name, and the data type of the\nfield.\n\nMethod Calls: Dedicated bytecode instructions handle method calls. They\nspecify the called method along with its class and the types of its\nparameters. Before a method call, arguments are pushed onto the stack. After\nthe call is made, the return value (if any) becomes available on top of the\nstack. It\u2019s important to note that non-static methods require an additional\nparameter that references the current object. A special case of method calls\nexists for features from dynamic languages, such as Java\u2019s lambda expressions.\n\nObject and Array Creation: These instructions handle allocating memory for new\nobjects and arrays. Once the allocation is complete, a reference to the newly\ncreated object or array is pushed onto the stack.\n\nControl Flow: Instructions in this category manage the flow of the program\u2019s\nexecution. This includes defining labels for jumps and enabling conditional\nbranching. A specific opcode handles the switch-case statement, specifying the\njump table based on the value of the switch expression. Control flow\ninstructions also include those for returning from methods.\n\nConstants: Dedicated instructions exist to push constant values (strings or\nnumbers) onto the stack. Different instructions are used for different data\ntypes like strings, integers, and floats.\n\nLocal Variables: Bytecode instructions interact with local variables by\ncopying their values to/from the stack or by loading constant values into\nthem.\n\nExpressions: This category covers instructions for various operations. These\ninclude arithmetic operations (like multiplication), logical operations (like\nNOT, XOR, AND), and type conversions (like converting an integer to a long). A\nspecial opcode exists for INSTANCEOF checks, which verify the type of an\nobject.\n\nException Handling: These instructions manage exceptions within the program.\nThey define try/catch blocks and specify the types of exceptions that can be\nhandled within those blocks. Additionally, an instruction allows throwing a\nnew exception for potential handling by the caller of the code.\n\n### The Java Native Interface\n\nThe Java Native Interface (JNI) acts as a bridge between Java code and native\ncode, typically written in C. This allows Java programs to leverage platform-\nspecific functionality, such as direct hardware interaction or low-level I/O\noperations.\n\nHere\u2019s how it works:\n\n  * JNI Methods: Developers can mark specific Java methods with the native modifier. These methods have no Java implementation but rely on native code for their functionality.\n  * Shared Libraries: The platform-specific implementation for these native methods resides in separate shared libraries (Figure 1).\n  * Execution Trigger: Whenever a native method is called in Java code, the corresponding native code from the shared library is executed.\n\n## How the transformations works\n\nThis section describes a method to modify a Java program by replacing specific\nparts with a native C library.\n\n  1. Identifying and Annotating Methods: Developers mark methods containing sensitive code for translation. The original Java code within these methods is removed, and the native modifier is added to trigger JNI usage at runtime.\n\n  2. Static Initialization: A call to System.loadLibrary is inserted within the class\u2019s static initialization section. This links the class with the generated C library.\n\n  3. Bytecode-to-C Translation: The removed Java code is translated opcode by opcode into a C function (Figure 3d). This translation process iterates through each opcode and generates equivalent C statements.\n\n  4. Stack and Variable Management: The C code emulates the Java Virtual Machine\u2019s stack behavior using a C stack for operand manipulation (push/pop operations).Local variables are stored in a C array, similar to the Java bytecode\u2019s approach with LOAD and STORE opcodes. Both the operand stack and variable array are pre-defined with static allocation at compile time based on known sizes.\n\n  5. Data Size Handling: Java bytecode uses a 32-bit operand stack and variable array, with 64-bit values (double and long) taking two elements. The C code uses a 64-bit array for both operands and variables due to JNI\u2019s representation of all Java types as a 64-bit C union. This ensures all data fits within a single element.\n\n#### Translating arithmetic and logical operation\n\nIn Java, each arithmetic operation (addition, subtraction, etc.) gets compiled\ninto a bytecode instruction with a specific data type (integer, float, etc.).\nThe beauty lies in the one-to-one correspondence between these bytecode\ninstructions and C arithmetic operators. This is because both Java bytecode\nand C offer the same set of fundamental arithmetic operations.\n\nThe only exceptions are logical and arithmetic shifts. Java bytecode supports\nboth types of shifts, whereas C uses either one depending on whether the\noperand is signed or unsigned. To maintain consistency with Java\u2019s behavior,\nour tool employs type casting when translating these operations in C.\n\n#### Translating Control Flow\n\nControl flow manipulation involves instructions for conditional branching and\nlooping. While Java uses keywords like \u201cwhile\u201d and \u201cfor\u201d to create structured\ncontrol flow, these are compiled into bytecode using labels, gotos, and if-\nbranches. Since C also supports goto statements and labels, these bytecode\ninstructions can be directly translated to their corresponding C keywords.\n\nJava bytecode offers two switch opcodes, TABLESWITCH and LOOKUPSWITCH. These\nare translated into standard C switch statements. It\u2019s important to note that\nalthough Java allows switch statements with String values, C doesn\u2019t. However,\nJava compiles these String switches into bytecode switches that operate on\ninteger values. Therefore, the same translation pattern applies for both types\nof Java switch statements.\n\nOne final point: our translation process skips unnecessary labels that might\nappear in unreachable sections of Java code (e.g., after a return statement).\nThese labels are not allowed in C and would create errors during compilation.\n\n#### Translating calling methods\n\nA unique challenge arises when translated code interacts with other Java\nmethods or accesses fields within Java classes. While these elements are\nreadily accessible within Java code, they\u2019re invisible to C code.\n\nOur solution leverages reflection features available through JNI utility\nfunctions. Reflection allows us to call methods and access fields by name at\nruntime. Some method calls, known as virtual calls, depend on a class\u2019s\ninheritance hierarchy. This applies to opcodes like INVOKEVIRTUAL,\nINVOKESTATIC, and INVOKEINTERFACE. In such cases, the translator needs to\nidentify the most specific implementation of the called method by examining\nthe inheritance tree.\n\nThe JNI layer provides utility functions named Call[type]MethodA (where [type]\nis replaced with the return type of the Java method) to handle this process.\nThese functions can handle primitive data types, objects, or void return\nvalues.\n\n### Does it cope with recent innovations in obfuscations?\n\nObfuscation is a common method to deter attackers from reverse engineering\nsoftware. However, for languages like Java that compile to structured\nbytecode, obfuscation alone might not be enough to fully protect sensitive\ncode.\n\nThis article proposes a program transformation approach that translates\nspecific Java sections into C code. Developers can identify these security-\ncritical portions for automatic conversion. The translated C code is then\ncompiled into machine-specific binary code, which executes when the original\ncode is called.\n\nWe envision further development on this approach through two key initiatives:\n\n  * Combined Obfuscation: We aim to integrate our transformation tool with existing C obfuscation tools. This will create a comprehensive toolchain capable of achieving a very high level of protection for Java programs.\n\n  * Rigorous Evaluation: We plan to design controlled experiments and user studies. These will assess the effectiveness of our approach by measuring how much harder it is to reverse engineer and attack the transformed code compared to the original Java version.\n\nThis placement positions \u2207 Widening\u2019s services as a solution to the\nlimitations identified in the context of Intellectual Property Protection. It\nprovides a simple, but yet well-designed solution and highlights the relevance\nof \u2207 Widening\u2019s offerings within the context of the discussed challenges.\n\n## About \u2207 Widening\n\n\u2207 Widening is a boutique Italian cybersecurity firm with deep expertise in\nsoftware analysis. We work in the context of MATE attack and defence. We have\nplenty of experience in terms of building, and disrupting software protections\nto achieve client needs.\n\nWe use reverse engineering, software attacks, and static analysis to uncover\nthe inner workings of any software, from desktop applications to malicious\nsoftware.\n\nContact us for a quote\n\nMade in Italy. 2024\n\n", "frontpage": false}
