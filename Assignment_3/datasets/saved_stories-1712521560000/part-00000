{"aid": "39960982", "title": "What's the Latest with WirePlumber?", "url": "https://www.collabora.com/news-and-blog/blog/2024/02/19/whats-the-latest-with-wireplumber/", "domain": "collabora.com", "votes": 2, "user": "bpierre", "posted_at": "2024-04-07 14:23:59", "comments": 0, "source_title": "What's the latest with WirePlumber?", "source_text": "What's the latest with WirePlumber?\n\n  * About\n\n    * Who we are\n\n    * Our expertise\n\n    * Our work\n\n    * Open Source\n\n    * Our ecosystem\n\n  * Services\n\n    * Guide\n\n    * Train\n\n    * Build\n\n    * Integrate\n\n    * Optimize\n\n    * Maintain\n\n  * Industries\n\n    * Automotive\n\n    * Digital TV\n\n    * Silicon\n\n    * OEM\n\n    * VR/AR\n\n  * News & Blog\n  * Careers\n  * Contact\n\n  * About\n  * Services\n  * Industries\n  * News & Blog\n  * Careers\n  * Contact\n\n  * +44 (0)1223 362967\n  * +1 514 667 2499\n  * contact@collabora.com\n\n  * Home\n  * News & Blog\n  * Blog\n\n## What's the latest with WirePlumber?\n\nGeorge Kiagiadakis February 19, 2024\n\nShare this post:\n\nReading time: 7 minutes\n\nI\u2019ve been quiet about WirePlumber for a significant amount of time. It was\nback in 2022 when after a series of issues were found in its design, I made\nthe call to rework some of its fundamentals in order to allow it to grow. I\nmentioned this in this post at that moment. And long story short, the year now\nis 2024 (time flies, who knew?!).\n\n### What were the issues?\n\nThe main limiting factor in the design was the most powerful feature of\nWirePlumber: the scripting system. When we designed the scripting system, the\nhypothesis was that if we provided an API that would allow scripts to get\nreferences to PipeWire objects and subscribe to their events independently,\nthen any functionality could easily be built on top. This couldn\u2019t have been\nmore wrong because, as it turned out, components built on top of scripts\nactually depend on one another and it is critical at times to be able to\nensure the order in which the event handlers (callbacks) will be executed.\nFurthermore, what we also realized was that it was hard to write relatively\nsmall scripts. Big chunks of logic quickly started accumulating within single\nscript files, making them quite hard to work with. This also made it\nimpossible for users to slightly modify certain behavior without having to\ncopy the entire script first.\n\nThe solution was to redo the scripting system in a different way. Instead of\nletting the scripts do whatever they want, we introduced a central component\nthat manages references to all the PipeWire objects, the \u201cstandard event\nsource\u201d. And in addition, we added a mechanism for scripts to subscribe to\nevents from those objects using other objects that we call \u201chooks\u201d. The hooks\ncan have dependencies between one another, allowing them to be ordered, and\nthey can pass data between them, allowing them to cooperate on making\ndecisions instead of racing against one another.\n\nThis was a game changer. After working with this system for a while and\ntransforming the old scripts to use hooks, it all became much cleaner and\neasier to work with.\n\nAlong this process, we also realized that we could introduce virtual events\nthat do not originate from PipeWire objects in order to run chains of hooks to\nmake decisions. For instance, the process of selecting which \u201csink\u201d node is\ngoing to be the default audio output of the system has been implemented with a\nvirtual event called \u201cselect-default-node\u201d. This event is generated within a\nhook that reacts to several events which can be interpreted as potential\nchanges in the sinks. When the event is generated, a list of available sink\nnodes with their properties is collected and passed onto the \u201cselect-default-\nnode\u201d hooks as event data. Afterward, each hook runs through this list and\nattempts to make a decision based on some heuristics. If the hook makes a\ndecision, it stores the selected node together with a priority number in the\nevent data. Then the next hook in the chain starts from there and makes its\nown decision, but it only changes the result if the priority ends up being\nhigher than the previous one.\n\nAs you can tell, this system makes it easy for users to override the default\nlogic with minimal effort. In the above example of hooks that select the\ndefault \u201csink\u201d, for instance, a user could add a custom script with a hook\nthat also reacts to the \u201cselect-default-node\u201d event and is linked in a\nspecific position in the existing hooks chain, using hook dependencies. That\nhook can then introduce custom logic for selecting the default sink and store\nit with a much higher priority, to override the decisions made by the other\nhooks. The interesting part here is that it does not need to always store a\nresult; it is perfectly fine to return without taking any action and let the\nexisting upstream hooks make a decision themselves, allowing the custom hook\nto be as minimal as possible in its logic.\n\n### Where are we now?\n\nFor about 2 years now, this entire refactoring work used to live in a branch\ncalled \u201cnext\u201d. At the beginning of January this year, I merged this into\n\u201cmaster\u201d and made a first pre-release of what will become WirePlumber 0.5.0.\nThen last week, I made a second pre-release (version 0.4.82).\n\nApart from the scripting system changes, there are also several other features\nthat have accumulated during this time. We have made changes in the\nconfiguration system, utilizing SPA-JSON files, a dependency-based system for\nloading components, and dynamic settings accessible via wpctl. We have also\nintroduced \u201csmart filters\u201d, a system to automatically plug filter nodes in\nfront of device nodes, and based on that we have also refactored the Bluetooth\nauto-switch mechanism to always provide a virtual Bluetooth source that auto-\nswitches the underlying headset device to the HSP/HFP profile when this source\nis linked to an application. And all that is further enhanced by refinements\nin the linking policy, which now supports further fine-tuning through new node\nproperties, and a built-in deduplication mechanism for camera devices,\nallowing the libcamera and V4L2 monitors to run in parallel but with only one\nof them providing a node for each camera, depending on the camera type.\n\nThis week I am working on some more configuration system improvements and the\nplan is to get a release candidate out by next week. This should pave the path\nfor a final release soon afterward, provided that no serious issues are found.\nOf course, your feedback is going to be invaluable to make this go smoothly,\nso stay tuned!\n\n### What\u2019s next?\n\nWith the right infrastructure in place, I believe that WirePlumber is very\nwell positioned now more than ever to grow. To start with, after all this\ntime, there are still features missing that would make a lot of sense to have.\n\nOne such feature, for instance, is the ability to follow JACK-like rules for\nlinking arbitrary ports together. So far, WirePlumber\u2019s linking policy\noperates on nodes and takes action on linking together nodes, instead of\nports. Then there is a component that automatically discovers the ports of\nthose nodes and links them together one by one. Because the existing policy\noperates on nodes, such a feature would easily conflict, but with the new\nhooks system I am confident they can be made to work together.\n\nAnother big missing feature is proper access control. Our access control\nscripts have not even been ported to the hooks system, so that is a first\naction to take. But more importantly, WirePlumber, in my opinion, needs to\nhave a mechanism to maintain groups of objects and groups of clients and make\nsure that the permission bits for those objects are kept up-to-date for each\nclient every time there is a change in the registry. Grouping would allow us\nto build access control rules, similar to how user groups work on the file\nsystem.\n\nBeyond missing features, I would love to see proper \u201cmixer controls\u201d and\n\u201cdefault nodes\u201d APIs becoming part of the WirePlumber library. Currently, we\nhave this functionality built as modules that provide some objects that can be\ninteracted with using GObject signals and properties. This was done to avoid\ncommitting to public APIs and it\u2019s fine for Lua scripts, but it has\nlimitations and awkwardness. Most importantly, though, these APIs fail to work\nwell with the \u201cstandard event source\u201d and the hooks system, because they\nmaintain their own references to PipeWire objects and fall into the same trap\nthat the scripts used to. This needs a little bit of redesign to make sure\nthat external references can be used without compromising the ability to use\nthese APIs in client applications outside the WirePlumber daemon.\n\nApart from all these, I would be very interested to see third-party\napplications taking advantage of the features that we have built-in. It would\nmake sense, for example, for a filtering application to use the \u201csmart\nfilters\u201d functionality or provide 3rd-party hooks to extend the linking\npolicy. I am sure that as these features are getting utilized and improved,\nthe user experience can be improved significantly.\n\n### Related Posts\n\n##### WirePlumber: Exploring Lua scripts with Event Dispatcher\n\n##### WirePlumber's Event Dispatcher: a new, simplified way of handling\nPipeWire events\n\n##### From Lua to JSON: refactoring WirePlumber's configuration system\n\n### Related Posts\n\n##### WirePlumber: Exploring Lua scripts with Event Dispatcher\n\n##### WirePlumber's Event Dispatcher: a new, simplified way of handling\nPipeWire events\n\n##### From Lua to JSON: refactoring WirePlumber's configuration system\n\n### Comments (0)\n\n### Add a Comment\n\n## Search the newsroom\n\n## Latest Blog Posts\n\n### Automatic regression handling and reporting for the Linux Kernel\n\n14/03/2024\n\nIn continuation with our series about Kernel Integration we'll go into more\ndetail about how regression detection, processing, and tracking...\n\n### Almost a fully open-source boot chain for Rockchip's RK3588!\n\n21/02/2024\n\nNow included in our Debian images & available via our GitLab, you can build a\ncomplete, working BL31 (Boot Loader stage 3.1), and replace...\n\n### What's the latest with WirePlumber?\n\n19/02/2024\n\nBack in 2022, after a series of issues were found in its design, I made the\ncall to rework some of WirePlumber's fundamentals in order to...\n\n### DRM-CI: A GitLab-CI pipeline for Linux kernel testing\n\n08/02/2024\n\nContinuing our Kernel Integration series, we're excited to introduce DRM-CI, a\ngroundbreaking solution that enables developers to test their...\n\n### Persian Rug, Part 4 - The limitations of proxies\n\n23/01/2024\n\nThis is the fourth and final part in a series on persian-rug, a Rust crate for\ninterconnected objects. We've touched on the two big limitations:...\n\n### How to share code between Vulkan and Gallium\n\n16/01/2024\n\nOne of the key high-level challenges of building Mesa drivers these days is\nfiguring out how to best share code between a Vulkan driver...\n\n#### About Collabora\n\nWhether writing a line of code or shaping a longer-term strategic software\ndevelopment plan, we'll help you navigate the ever-evolving world of Open\nSource.\n\n\ud55c\uad6d\uc5b4 \ubc84\uc804\uc758 Collabora.com \ubcf4\uae30\n\nAcesse Collabora.com em Portugu\u00eas\n\n#### Learn more\n\n  * Who we are\n  * Services\n  * Our expertise\n  * Industries\n  * Our work\n  * Careers\n  * Open Source\n\nCollabora on Twitter Collabora on YouTube Collabora on Mastodon Collabora on\nLinkedIn Collabora on Facebook Collabora RSS Feed\n\n+44 1223 362967\n\n+1 514 667 2499\n\ncontact@collabora.com\n\nWe use cookies on this website to ensure that you get the best experience. By\ncontinuing to use this website you are consenting to the use of these cookies.\nTo find out more please follow this link.\n\nCollabora Ltd \u00a9 2005-2024. All rights reserved. Privacy Notice. Sitemap.\n\n", "frontpage": false}
