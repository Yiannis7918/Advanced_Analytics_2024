{"aid": "39961856", "title": "Solving Advent of Code '23 \"Aplenty\" by Compiling", "url": "https://abhinavsarkar.net/posts/compiling-aoc23-aplenty/", "domain": "abhinavsarkar.net", "votes": 1, "user": "todsacerdoti", "posted_at": "2024-04-07 16:36:03", "comments": 0, "source_title": "Solving Advent of Code \u201923 \u201cAplenty\u201d by Compiling", "source_text": "Solving Advent of Code \u201923 \u201cAplenty\u201d by Compiling | abhinavsarkar.net\n\n# Solving Advent of Code \u201923 \u201cAplenty\u201d by Compiling\n\n  * April 7, 2024\n  * 0 comments\n  * 1 \ud83d\udd01\n  * Tags: programmingparsinginterpreterscompilershaskell\n\nEvery year I try to solve some problems from the Advent of Code (AoC)\ncompetition in a not straightforward way. Let\u2019s solve the part one of the day\n19 problem Aplenty by compiling the problem input to an executable file.\n\nEvery year I try to solve some problems from the Advent of Code (AoC)\ncompetition in a not straightforward way. Let\u2019s solve the part one of the day\n19 problem Aplenty by compiling the problem input to an executable file.\n\n## The Problem\n\nWhat the problem presents as input is essentially a program. Here is the\nexample input:\n\n    \n    \n    px{a<2006:qkq,m>2090:A,rfg} pv{a>1716:R,A} lnx{m>1548:A,A} rfg{s<537:gd,x>2440:R,A} qs{s>3448:A,lnx} qkq{x<1416:A,crn} crn{x>2662:A,R} in{s<1351:px,qqz} qqz{s>2770:qs,m<1801:hdj,R} gd{a>3333:R,R} hdj{m>838:A,pv} {x=787,m=2655,a=1222,s=2876} {x=1679,m=44,a=2067,s=496} {x=2036,m=264,a=79,s=2244} {x=2461,m=1339,a=466,s=291} {x=2127,m=1623,a=2188,s=1013}\n\nexinput.txt\n\nEach line in the first section of the input is a code block. The bodies of the\nblocks have statements of these types:\n\n  * Accept (A) or Reject (R) that terminate the program.\n  * Jumps to other blocks by their names, for example: rfg as the last statement of the px block in the first line.\n  * Conditional statements that have a condition and what to do if the condition is true, which can be only Accept/Reject or a jump to another block.\n\nThe problem calls the statements \u201crules\u201d, the blocks \u201cworkflows\u201d, and the\nprogram \u201csystem\u201d.\n\nAll blocks of the program operates on a set of four values: x, m, a, and s.\nThe problem calls them \u201cratings\u201d, and each set of ratings is for/forms a\n\u201cpart\u201d. The second section of the input specifies a bunch of these parts to\nrun the system against.\n\nThis seems to map very well to a C program, with Accept and Reject returning\ntrue and false respectively, and jumps accomplished using gotos. So that\u2019s\nwhat we\u2019ll do: we\u2019ll compile the problem input to a C program, then compile\nthat to an executable, and run it to get the solution to the problem.\n\nAnd of course, we\u2019ll do all this in Haskell. First some imports:\n\n    \n    \n    {-# LANGUAGE LambdaCase #-} {-# LANGUAGE StrictData #-} module Main where import qualified Data.Array as Array import Data.Char (digitToInt, isAlpha, isDigit) import Data.Foldable (foldl', foldr') import Data.Function (fix) import Data.Functor (($>)) import qualified Data.Graph as Graph import Data.List (intercalate, (\\\\)) import qualified Data.Map.Strict as Map import System.Environment (getArgs) import qualified Text.ParserCombinators.ReadP as P import Prelude hiding (GT, LT)\n\n## The Parser\n\nFirst, we parse the input program to Haskell data types. We use the ReadP\nparser library built into the Haskell standard library.\n\n    \n    \n    data Part = Part { partX :: Int, partM :: Int, partA :: Int, partS :: Int } deriving (Show) data Rating = X | M | A | S deriving (Show, Eq) emptyPart :: Part emptyPart = Part 0 0 0 0 addRating :: Part -> (Rating, Int) -> Part addRating p (r, v) = case r of X -> p {partX = v} M -> p {partM = v} A -> p {partA = v} S -> p {partS = v} partParser :: P.ReadP Part partParser = foldl' addRating emptyPart <$> P.between (P.char '{') (P.char '}') (partRatingParser `P.sepBy1` P.char ',') partRatingParser :: P.ReadP (Rating, Int) partRatingParser = (,) <$> ratingParser <*> (P.char '=' *> intParser) ratingParser :: P.ReadP Rating ratingParser = P.get >>= \\case 'x' -> pure X 'm' -> pure M 'a' -> pure A 's' -> pure S _ -> P.pfail intParser :: P.ReadP Int intParser = foldl' (\\n d -> n * 10 + d) 0 <$> P.many1 digitParser digitParser :: P.ReadP Int digitParser = digitToInt <$> P.satisfy isDigit parse :: (Show a) => P.ReadP a -> String -> Either String a parse parser text = case P.readP_to_S (parser <* P.eof) text of [(res, \"\")] -> Right res [(_, s)] -> Left $ \"Leftover input: \" <> s out -> Left $ \"Unexpected output: \" <> show out\n\nPart is a Haskell data type representing parts, and Rating is an enum for,\nwell, ratings^1. Following that are parsers for parts and ratings, written in\nApplicative and Monadic styles using the basic parsers and combinators\nprovided by the ReadP library.\n\nFinally, we have the parse function to run a parser on an input. We can try\nparsing parts in GHCi:\n\n    \n    \n    > parse partParser \"{x=2127,m=1623,a=2188,s=1013}\" Right (Part {partX = 2127, partM = 1623, partA = 2188, partS = 1013})\n\nNext, we represent and parse the program, I mean, the system:\n\n    \n    \n    newtype System = System (Map.Map WorkflowName Workflow) deriving (Show, Eq) data Workflow = Workflow { wName :: WorkflowName, wRules :: [Rule] } deriving (Show, Eq) type WorkflowName = String data Rule = AtomicRule AtomicRule | If Condition AtomicRule deriving (Show, Eq) data AtomicRule = Jump WorkflowName | Accept | Reject deriving (Show, Eq, Ord) data Condition = Comparison Rating CmpOp Int deriving (Show, Eq) data CmpOp = LT | GT deriving (Show, Eq)\n\nA System is a map of workflows by their names. A Workflow has a name and a\nlist of rules. A Rule is either an AtomicRule, or an If rule. An AtomicRule is\neither a Jump to another workflow by name, or an Accept or Reject rule. The\nCondition of an If rule is a less that (LT) or a greater than (GT) Comparison\nof some Rating of an input part with an integer value.\n\nNow, it\u2019s time to parse the system:\n\n    \n    \n    systemParser :: P.ReadP System systemParser = System . foldl' (\\m wf -> Map.insert (wName wf) wf m) Map.empty <$> workflowParser `P.endBy1` P.char '\\n' workflowParser :: P.ReadP Workflow workflowParser = Workflow <$> P.many1 (P.satisfy isAlpha) <*> P.between (P.char '{') (P.char '}') (ruleParser `P.sepBy1` P.char ',') ruleParser :: P.ReadP Rule ruleParser = (AtomicRule <$> atomicRuleParser) P.<++ ifRuleParser ifRuleParser :: P.ReadP Rule ifRuleParser = If <$> (Comparison <$> ratingParser <*> cmpOpParser <*> intParser) <*> (P.char ':' *> atomicRuleParser) atomicRuleParser :: P.ReadP AtomicRule atomicRuleParser = do c : _ <- P.look case c of 'A' -> P.char 'A' $> Accept 'R' -> P.char 'R' $> Reject _ -> (Jump .) . (:) <$> P.char c <*> P.many1 (P.satisfy isAlpha) cmpOpParser :: P.ReadP CmpOp cmpOpParser = P.choice [P.char '<' $> LT, P.char '>' $> GT]\n\nParsing is straightforward as there are no recursive data types or complicated\nprecedence or associativity rules here. We can exercise it in GHCi (output\nformatted for clarity):\n\n    \n    \n    > parse workflowParser \"px{a<2006:qkq,m>2090:A,rfg}\" Right ( Workflow { wName = \"px\", wRules = [ If (Comparison A LT 2006) (Jump \"qkq\"), If (Comparison M GT 2090) Accept, AtomicRule (Jump \"rfg\") ] } )\n\nExcellent! We can now combine the part parser and the system parser to parse\nthe problem input:\n\n    \n    \n    data Input = Input System [Part] deriving (Show) inputParser :: P.ReadP Input inputParser = Input <$> systemParser <*> (P.char '\\n' *> partParser `P.endBy1` P.char '\\n')\n\nBefore moving on to translating the system to C, let\u2019s write an interpreter so\nthat we can compare the output of our final C program against it for\nvalidation.\n\n## The Interpreter\n\nEach system has a workflow named \u201cin\u201d, where the execution of the system\nstarts. Running the system results in True if the run ends with an Accept\nrule, or in False if the run ends with a Reject rule. With this in mind, let\u2019s\ncook up the interpreter:\n\n    \n    \n    runSystem :: System -> Part -> Bool runSystem (System system) part = runRule $ Jump \"in\" where runRule = \\case Accept -> True Reject -> False Jump wfName -> jump wfName jump wfName = case Map.lookup wfName system of Just workflow -> runRules $ wRules workflow Nothing -> error $ \"Workflow not found in system: \" <> wfName runRules = \\case (rule : rest) -> case rule of AtomicRule aRule -> runRule aRule If cond aRule -> if evalCond cond then runRule aRule else runRules rest _ -> error \"Workflow ended without accept/reject\" evalCond = \\case Comparison r LT value -> rating r < value Comparison r GT value-> rating r > value rating = \\case X -> partX part M -> partM part A -> partA part S -> partS part\n\nThe interpreter starts by running the rule to jump to the \u201cin\u201d workflow.\nRunning a rule returns True or False for Accept or Reject rules respectively,\nor jumps to a workflow for Jump rules. Jumping to a workflow looks it up in\nthe system\u2019s map of workflows, and sequentially runs each of its rules.\n\nAn AtomicRule is run as previously mentioned. An If rule evaluates its\ncondition, and either runs the consequent rule if the condition is true, or\nmoves on to running the rest of the rules in the workflow.\n\nThat\u2019s it for the interpreter. We can run it on the example input:\n\n    \n    \n    > inputText <- readFile \"input.txt\" > Right (Input system parts) = parse inputParser inputText > runSystem system (parts !! 0) True > runSystem system (parts !! 1) False\n\nThe AoC problem requires us to return the sum total of the ratings of the\nparts that are accepted by the system:\n\n    \n    \n    solve :: Input -> Int solve (Input system parts) = sum . map (\\(Part x m a s) -> x + m + a + s) . filter (runSystem system) $ parts\n\nLet\u2019s run it for the example input:\n\n    \n    \n    > Right input <- parse inputParser <$> readFile \"exinput.txt\" > solve input 19114\n\nIt returns the correct answer! Next up, we generate some C code.\n\n## The Control-flow Graph\n\nBut first, a quick digression to graphs. A Control-flow graph or CFG, is a\ngraph of all possible paths that can be taken through a program during its\nexecution. It has many uses in compilers, but for now, we use it to generate\nmore readable C code.\n\nUsing the Data.Graph module from the containers package, we write the function\nto create a control-flow graph for our system/program, and use it to\ntopologically sort the workflows:\n\n    \n    \n    type Graph' a = (Graph.Graph, Graph.Vertex -> (a, [a]), a -> Maybe Graph.Vertex) cfGraph :: Map.Map WorkflowName Workflow -> Graph' WorkflowName cfGraph system = graphFromMap . Map.toList . flip Map.map system $ \\(Workflow _ rules) -> flip concatMap rules $ \\case AtomicRule (Jump wfName) -> [wfName] If _ (Jump wfName) -> [wfName] _ -> [] where graphFromMap :: (Ord a) => [(a, [a])] -> Graph' a graphFromMap m = let (graph, nLookup, vLookup) = Graph.graphFromEdges $ map (\\(f, ts) -> (f, f, ts)) m in (graph, \\v -> let (x, _, xs) = nLookup v in (x, xs), vLookup) toposortWorkflows :: Map.Map WorkflowName Workflow -> [WorkflowName] toposortWorkflows system = let (cfg, nLookup, _) = cfGraph system in map (fst . nLookup) $ Graph.topSort cfg\n\nGraph' is a simpler type for a graph of nodes of type a. The cfGraph function\ntakes a the map from workflow names to workflows \u2014 that is, a system \u2014 and\nreturns a control-flow graph of workflow names. It does this by finding jumps\nfrom workflows to other workflows, and connecting them.\n\nThen, the toposortWorkflows function uses the created CFG to topologically\nsort the workflows. We\u2019ll see this in action in a bit. Moving on to ...\n\n## The Compiler\n\nThe compiler, for now, simply generates the C code for a given system. We\nwrite a ToC typeclass for convenience:\n\n    \n    \n    class ToC a where toC :: a -> String instance ToC Part where toC (Part x m a s) = \"{\" <> intercalate \", \" (map show [x, m, a, s]) <> \"}\" instance ToC CmpOp where toC = \\case LT -> \"<\" GT -> \">\" instance ToC Rating where toC = \\case X -> \"x\" M -> \"m\" A -> \"a\" S -> \"s\" instance ToC AtomicRule where toC = \\case Accept -> \"return true;\" Reject -> \"return false;\" Jump wfName -> \"goto \" <> wfName <> \";\" instance ToC Condition where toC = \\case Comparison rating op val -> toC rating <> \" \" <> toC op <> \" \" <> show val instance ToC Rule where toC = \\case AtomicRule aRule -> toC aRule If cond aRule -> \"if (\" <> toC cond <> \") { \" <> toC aRule <> \" }\" instance ToC Workflow where toC (Workflow wfName rules) = wfName <> \":\\n\" <> intercalate \"\\n\" (map ((\" \" <>) . toC) rules) instance ToC System where toC (System system) = intercalate \"\\n\" [ \"bool runSystem(short x, short m, short a, short s) {\", \" goto in;\", intercalate \"\\n\" (map (toC . (system Map.!)) $ toposortWorkflows system), \"}\" ] instance ToC Input where toC (Input system parts) = intercalate \"\\n\" [ \"#include <stdbool.h>\", \"#include <stdio.h>\\n\", toC system, \"int main() {\", \" int parts[][4] = {\", intercalate \",\\n\" (map ((\" \" <>) . toC) parts), \" };\", \" int totalRating = 0;\", \" for(int i = 0; i < \" <> show (length parts) <> \"; i++) {\", \" int x = parts[i][0];\", \" int m = parts[i][1];\", \" int a = parts[i][2];\", \" int s = parts[i][3];\", \" if (runSystem(x, m, a, s)) {\", \" totalRating += x + m + a + s;\", \" }\", \" }\", \" printf(\\\"%d\\\", totalRating);\", \" return 0;\", \"}\" ]\n\nAs mentioned before, Accept and Reject rules are converted to return true and\nfalse respectively, and Jump rules are converted to gotos. If rules become if\nstatements, and Workflows become block labels followed by block statements.\n\nA System is translated to a function runSystem that takes four parameters, x,\nm, a and s, and runs the workflows translated to blocks by executing goto in.\n\nFinally, an Input is converted to a C file with the required includes, and a\nmain function that solves the problem by calling the runSystem function for\nall parts.\n\nLet\u2019s throw in a main function to put everything together.\n\n    \n    \n    main :: IO () main = do file <- head <$> getArgs code <- readFile file case parse inputParser code of Right input -> putStrLn $ toC input Left err -> error err\n\nThe main function reads the input from the file provided as the command line\nargument, parses it and outputs the generated C code. Let\u2019s run it now.\n\n## The Compiler Output\n\nWe compile our compiler and run it to generate the C code for the example\nproblem:\n\n    \n    \n    $ ghc --make aplenty.hs $ ./aplenty exinput.txt > aplenty.c\n\nThis is the C code it generates:\n\n    \n    \n    #include <stdbool.h> #include <stdio.h> bool runSystem(short x, short m, short a, short s) { goto in; in: if (s < 1351) { goto px; } goto qqz; qqz: if (s > 2770) { goto qs; } if (m < 1801) { goto hdj; } return false; qs: if (s > 3448) { return true; } goto lnx; lnx: if (m > 1548) { return true; } return true; px: if (a < 2006) { goto qkq; } if (m > 2090) { return true; } goto rfg; rfg: if (s < 537) { goto gd; } if (x > 2440) { return false; } return true; qkq: if (x < 1416) { return true; } goto crn; hdj: if (m > 838) { return true; } goto pv; pv: if (a > 1716) { return false; } return true; gd: if (a > 3333) { return false; } return false; crn: if (x > 2662) { return true; } return false; } int main() { int parts[][4] = { {787, 2655, 1222, 2876}, {1679, 44, 2067, 496}, {2036, 264, 79, 2244}, {2461, 1339, 466, 291}, {2127, 1623, 2188, 1013} }; int totalRating = 0; for(int i = 0; i < 5; i++) { int x = parts[i][0]; int m = parts[i][1]; int a = parts[i][2]; int s = parts[i][3]; if (runSystem(x, m, a, s)) { totalRating += x + m + a + s; } } printf(\"%d\", totalRating); return 0; }\n\nWe see the toposortWorkflows function in action, sorting the blocks in the\ntopological order of jumps between them, as opposed to the original input.\nDoes this work? Only one way to know:\n\n    \n    \n    $ gcc aplenty.c -o solution $ ./solution 19114\n\nPerfect! The solution matches the interpreter output.\n\n## The Bonus: Optimizations\n\nBy studying the output C code, we spot some possibilities for optimizing the\ncompiler output. Notice how the lnx block returns same value (true) regardless\nof which branch it takes:\n\n    \n    \n    lnx: if (m > 1548) { return true; } return true;\n\nSo, we should be able to replace it with:\n\n    \n    \n    lnx: return true;\n\nIf we do this, the lnx block become degenerate, and hence the jumps to the\nblock can be inlined, turning the qs block from:\n\n    \n    \n    qs: if (s > 3448) { return true; } goto lnx;\n\nto:\n\n    \n    \n    qs: if (s > 3448) { return true; } return true;\n\nwhich makes the if statement in the qs block redundant as well. Hence, we can\nrepeat the previous optimization and further reduce the generated code.\n\nAnother possible optimization is to inline the blocks to which there are only\nsingle jumps from the rest of the blocks, for example the qqz block.\n\nLet\u2019s write these optimizations.\n\n### Simplify Workflows\n\n    \n    \n    simplifyWorkflows :: System -> System simplifyWorkflows (System system) = System $ Map.map simplifyWorkflow system where simplifyWorkflow (Workflow name rules) = Workflow name $ foldr' ( \\r rs -> case rs of [r'] | ruleOutcome r == ruleOutcome r' -> rs _ -> r : rs ) [last rules] $ init rules ruleOutcome = \\case If _ aRule -> aRule AtomicRule aRule -> aRule\n\nsimplifyWorkflows goes over all workflows and repeatedly removes the\nstatements from the end of the blocks that has same outcome as the statement\nprevious to them.\n\n### Inline Redundant Jumps\n\n    \n    \n    inlineRedundantJumps :: System -> System inlineRedundantJumps (System system) = System $ foldl' (flip Map.delete) (Map.map inlineJumps system) $ Map.keys redundantJumps where redundantJumps = Map.map (\\wf -> let ~(AtomicRule rule) = head $ wRules wf in rule) . Map.filter (\\wf -> length (wRules wf) == 1) $ system inlineJumps (Workflow name rules) = Workflow name $ map inlineJump rules inlineJump = \\case AtomicRule (Jump wfName) | Map.member wfName redundantJumps -> AtomicRule $ redundantJumps Map.! wfName If cond (Jump wfName) | Map.member wfName redundantJumps -> If cond $ redundantJumps Map.! wfName rule -> rule\n\ninlineRedundantJumps find the jumps to degenerate workflows and inlines them.\nIt does this by first going over all workflows and creating a map of\ndegenerate workflow names to the only rule in them, and then replacing the\njumps to such workflows with the only rules.\n\n### Remove Jumps\n\n    \n    \n    removeJumps :: System -> System removeJumps (System system) = let system' = foldl' (flip $ Map.adjust removeJumpsWithSingleJumper) system $ toposortWorkflows system in System . foldl' (flip Map.delete) system' . (\\\\ [\"in\"]) $ workflowsWithNJumpers 0 system' where removeJumpsWithSingleJumper (Workflow name rules) = Workflow name $ init rules <> case last rules of AtomicRule (Jump wfName) | wfName `elem` workflowsWithSingleJumper -> let (Workflow _ rules') = system Map.! wfName in rules' rule -> [rule] workflowsWithSingleJumper = workflowsWithNJumpers 1 system workflowsWithNJumpers n sys = let (cfg, nLookup, _) = cfGraph sys in map (fst . nLookup . fst) . filter (\\(_, d) -> d == n) . Array.assocs . Graph.indegree $ cfg\n\nremoveJumps does two things: first, it finds blocks with only one jumper, and\ninlines their statements to the jump location. Then it finds blocks to which\nthere are no jumps, and removes them entirely from the program. It uses the\nworkflowsWithNJumpers helper function that uses the control-flow graph of the\nsystem to find all workflows to which there are n number of jumps, where n is\nprovided as an input to the function. Note the usage of the toposortWorkflows\nfunction here, which makes sure that we remove the blocks in topological\norder, accumulating as many statements as possible in the final program.\n\nWith these functions in place, we write the optimize function:\n\n    \n    \n    optimize :: System -> System optimize = applyTillUnchanged (removeJumps . inlineRedundantJumps . simplifyWorkflows) where applyTillUnchanged :: (Eq a) => (a -> a) -> a -> a applyTillUnchanged f = fix (\\recurse x -> if f x == x then x else recurse (f x))\n\nWe execute the three optimization functions repeatedly till a fixed point is\nreached for the resultant System, that is, till there are no further\npossibilities of optimization.\n\nFinally, we change our main function to apply the optimizations:\n\n    \n    \n    main :: IO () main = do file <- head <$> getArgs code <- readFile file case parse inputParser code of Right (Input system parts) -> putStrLn . toC $ Input (optimize system) parts Left err -> error err\n\nCompiling the optimized compiler and running it as earlier, generates this C\ncode for the runSystem function now:\n\n    \n    \n    bool runSystem(short x, short m, short a, short s) { goto in; in: if (s < 1351) { goto px; } if (s > 2770) { return true; } if (m < 1801) { goto hdj; } return false; px: if (a < 2006) { goto qkq; } if (m > 2090) { return true; } if (s < 537) { return false; } if (x > 2440) { return false; } return true; qkq: if (x < 1416) { return true; } if (x > 2662) { return true; } return false; hdj: if (m > 838) { return true; } if (a > 1716) { return false; } return true; }\n\nIt works well^2. We now have 1.7x fewer lines of code as compared to before^3.\n\n## The Conclusion\n\nThis was another attempt to solve Advent of Code problems in somewhat unusual\nways. This year we learned some basics of compilation. Swing by next year for\nmore weird ways to solve simple problems.\n\nThe full code for this post is available here.\n\n  1. I love how I have to write XMAS horizontally and vertically a couple of time.\u21a9\ufe0e\n\n  2. I\u2019m sure many more optimizations are possible yet. After all, this program is essentially a decision tree.\u21a9\ufe0e\n\n  3. For the actual problem input with 522 blocks, the optimizations reduce the LoC by 1.5x.\u21a9\ufe0e\n\n### Like, repost, or comment\n\n  * Fediverse\n  * Lobsters\n  * Reddit\n  * Discourse\n  * Comments below\n\nPosted by Abhinav Sarkar\n\nhttps://abhinavsarkar.net/posts/compiling-aoc23-aplenty/\n\n### Like this post? Subscribe to get future posts by email.\n\n### Got suggestions, corrections, or thoughts? Post a comment!\n\n### 0 comments\n\n### 1 Mentions\n\n  * Previous Implementing Co, a Small Language With Coroutines #4: Adding Channels\n\n\u00a9 2017\u20132023, Abhinav Sarkar\n\n", "frontpage": false}
