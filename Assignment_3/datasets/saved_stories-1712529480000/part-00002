{"aid": "39961859", "title": "Getting rid of set-car and set-cdr (2007)", "url": "https://blog.racket-lang.org/2007/11/getting-rid-of-set-car-and-set-cdr.html", "domain": "racket-lang.org", "votes": 2, "user": "swatson741", "posted_at": "2024-04-07 16:36:08", "comments": 0, "source_title": "Getting rid of", "source_text": "Getting rid of `set-car!` and `set-cdr!`\n\nRacket\n\nblog\n\n12 Nov 2007\n\n# Getting rid of set-car! and set-cdr!\n\nposted by Matthew Flatt\n\n## Functional is Beautiful\n\nScheme is a \u201cmostly functional\u201d language. Although Schemers don\u2019t hesitate to\nuse set! when mutation solves a problem best, Scheme programmers prefer to\nthink functionally. Purely functional programs are easier to test, they make\nbetter and more reliable APIs, and our environments, compilers, and run-time\nsystems take advantage of functional style.\n\nA Schemer\u2019s functional bias is especially strong when writing programs that\nprocess and produce lists. The map function, which does both, is a thing of\nbeauty:\n\n    \n    \n    (define (map f l) (cond [(null? l) '()] [else (cons (f (car l)) (map f (cdr l)))]))\n\nThe map function is most beautiful when the given f is functional. If f has\nside-effects, the the above implementation over-specifies map, which is\ntraditionally allowed to process the list in any order that it wants (though\nPLT Scheme guarantees left-to-right order, as above). Arguably, when some\nother Schemer provides a non-functional f, then it\u2019s their problem; they have\nto deal with the consequences (which may well be minor compared to some\nbenefits of using mutation).\n\nThe map function might also receive a non-list, but the map implementor can\nguard against such misuse of map by wrapping it with a check,\n\n    \n    \n    (define (checked-map f l) (if (list? l) (map f l) (error 'map \"not a list\")))\n\nand then exporting checked-map instead of the raw map. This kind of checking\ngives nicer error messages, and it helps hide implementation details of map.\nWe could further also imagine that the raw map is compiled without run-time\nchecks on car and cdr.\n\n## The Problem with Mutable Pairs\n\nWhat if someone calls checked-map like this?:\n\n    \n    \n    (define l (list 1 2 3 4 5)) (checked-map (lambda (x) (set-cdr! (cddr l) 5)) l)\n\nThe f provided to map in this case is not purely functional. Moreover, it uses\nmutation in a particularly unfortunate way: the list? test in checked-map\nsucceeds, because the argument is initially a list, and the mutation is\nultimately discovered by a call to cdr \u2014 but only if checks haven\u2019t been\ndisabled.\n\nIf you\u2019re a Schemer, then unless you\u2019ve seen this before, or unless you\nthought a bit about the title of this section, then you probably didn\u2019t think\nof the above test case for map. A Schemer\u2019s view of lists is so deeply\nfunctional that it\u2019s hard to make this particular leap.\n\nFurthermore, this example is not contrived. If you have either Chez Scheme\nversion 6.1 or a pre\u2013200 MzScheme sitting around, calling map as above leads\nto a seg fault or an invalid memory access:\n\n    \n    \n    Chez Scheme Version 6.1 Copyright (c) 1998 Cadence Research Systems > (define l (list 1 2 3 4 5)) > (map (lambda (x) (set-cdr! (cddr l) 5)) l) Error: invalid memory reference. Some debugging context may have been lost.\n\nThe map example illustrates how mutable pairs can break a Schemer\u2019s natural\nand ingrained model of programming. Of course, if optimizing and providing\nfriendly error messages for map were the only issues with mutable pairs, then\nit wouldn\u2019t matter; Scheme implementors are smart enough to (eventually) get\nthis right. Unfortunately, the underlying problem is more pervasive.\n\nIn the API for a typical Scheme library, lists can be used for many kinds of\ninput and output. Flags for options might be provided in a list. A function\nmight provide information about the current configuration (e.g., the current\nitems in a GUI list box) in a list. Procedures or methods that deal gracefully\nwith list mutation are few and far between. In most cases, the result of\nunexpected mutation is merely a bad error message; sometimes, however,\nunexpected mutation of a list can break the library\u2019s internal invariants. In\nthe worst case, the library whose internal invariants are broken plays some\nrole in a system\u2019s overall security.\n\nMutable lists also interfere with the language\u2019s extensibility. The PLT Scheme\ncontract system, for example, offers a way to wrap an exported function with a\ncontract that constrains its input and outputs, which are optionally (in\nprinciple) enforced by run-time checks. Higher-order contracts, such as \u201ca\nlist of functions that consume and produce numbers\u201d, require wrappers on sub-\npieces, and these wrappers can be installed only by copying the enclosing\nlist. Copying a mutable list changes the semantics of a program, however,\nwhereas contracts are supposed to enforce invariants without otherwise\nchanging the program. Copying an immutable list creates no such problem.\n\nFinally, mutable lists make the language\u2019s specification messy. The R6RS\neditors spent considerable energy trying to pin down the exception-raising\nguarantees of map; the possibility of mutable pairs made it difficult to\nprovide much of a guarantee. The standard says that implementations should\ncheck that the lists provided tomap are the same length, but it\u2019s not worth\nmuch to require that check, since an argument\u2019s length as a list can change\nvia mutation to the list\u2019s pairs.\n\n## Switching to Immutable Pairs\n\nThe designers of PLT Scheme long ago recognized the problems of mutable pairs,\nand we introduced functions like cons-immutable andlist-immutable to support\nprogramming with immutable lists. These additions solved some problems \u2014 but\nonly in the cases where we were careful to use immutable lists. The R6RS\neditors also recognized the problems of mutable pairs, so that set-car! and\nset-cdr! were banished to their own library \u2014 but programmers are still free\nto use that library.\n\nWhile these are worthwhile steps for many reasons, they do not solve the\nunderlying problem. Library implementors who deal in lists must still either\nset up elaborate guards against mutation, pretend that the problem doesn\u2019t\nmatter, or require the use of a special immutable-list datatype that is\nincompatible with libraries whose authors set up elaborate guards or ignore\nthe problem.\n\nWhy all this hassle? If most Scheme code really does use and expect pairs in a\nfunctional way, can\u2019t we just switch to immutable pair? Most Scheme code will\nstill work, untold security holes will have been closed, specifications will\nbecome instantly tighter, and language extensions like contracts will work\nbetter.\n\nSchemers have been reluctant to make this leap, because it has never been\nclear just how much code relies on mutable pairs. We don\u2019t know how much the\nswitch will cost in porting time and long-term incompatibility, and we don\u2019t\nreally know how much we will gain. We won\u2019t know until we try it.\n\nFor PLT Scheme v4.0, we\u2019re going to try it. In our main dialects of Scheme\n(such as the mzscheme language), cons will create immutable pairs, and pair?\nand list? will recognize only immutable pairs and lists. The set-car! and set-\ncdr procedures will not exist. A new set of procedure mcons, mcar, mcdr, set-\nmcar!, and set-mcdr! will support mutable pairs. (A related v4.0 change is\nthat define-struct by default creates immutable structure types.)\n\nOf course, PLT Scheme v4.0 will support an R5RS language where cons is mcons,\nand so on, so many old programs can still run easily in the new version. The\ndifference is that interoperability between R5RS libraries and PLT Scheme\nlibraries will be less direct than before.\n\n## Experience So Far\n\nPLT Scheme v3.99.0.2 exists already in a branch of our SVN repository, and it\nwill soon move to the SVN trunk. That is, we have already ported at least a\nhalf million lines of Scheme code to a dialect without set-car! and set-cdr!.\n\nThe conversion took about eight hours. Obviously, relatively little code had\nto change. The following are the typical porting scenarios:\n\n  * The reverse! and append! functions were frequently used for \u201clinear updates\u201d by performance-conscious implementors. As our underlying Scheme implementation has improved, however, the performance benefits of these functions has become less. All uses could be replaced with reverse and append.\n\n  * The set-cdr! operation was often used to implement an internal queue. Such internal queues were easily changed to use mcons,mcar, mcdr, and set-mcdr!.\n\n  * An association-list mapping was sometimes updated with set-cdr! when a mapping was present, otherwise the list was extended. Since the extension case was supported, it was easy to just update the list functionally. (The relevant lists were short; if the lists were long, the right change would be to use a hash table instead of a list.)\n\n  * A pair was sometime used for an updatable mapping where a distinct structure type is better. The quick solution was to throw in a mutable box in place of the value.\n\nThe PLT Scheme code might be better positioned for the switch than arbitrary\nScheme code. Most of it was written by a handful of people who understood the\nproblems of mutable pairs, and who might therefore shy away from them.\nHowever, the PLT Scheme code base includes a lot of code that was not written\nspecifically for PLT Scheme, including Slatex, Tex2page, and many SRFI\nreference implementations. With the exception of SRFI\u20139, which generalizes\nset! to work with pairs, the SRFI implementations were remarkably trouble\nfree. (Thanks to Olin Shivers for making mutation optional in the \u201clinear\nupdate\u201d functions like reverse! from SRFIs 1 and 32.)\n\nIn addition, we looked at a number of standard Scheme benchmarks, which can be\nfound here:\n\nhttp://svn.plt-scheme.org/plt/trunk/collects/tests/mzscheme/benchmarks/common/\n\nOf the 28 benchmarks, eight of them mutate pairs. Four of those are trivially\nconverted to functional programs, along the lines of the scenarios above. One,\ndestruct, is designed specifically to test mutation performance, so it makes\nno sense to port. Another, sort1, is a sorting algorithm that inherently\nrelies on mutation; a functional sort is obviously possible, but that would be\na different benchmark. The conform benchmark uses mutable pairs for tables in\na relatively non-local way; as a modern Scheme program, it would probably be\nwritten with structures, but it\u2019s not trivial to port. The peval benchmark\nuses pairs to represent Scheme programs, and it partially evaluates the\nprogram by mutating it, so it is not trivial to port. To summarize, out of 28\nold, traditional benchmark programs, only two represent interesting programs\nthat are not easily adapted to immutable pairs. (They run in PLT Scheme\u2019s R5RS\nlanguage, of course.)\n\nFinally, we selected a useful third-party library that is not included with\nPLT Scheme. We checked the generic SSAX implementation (not the PLT Scheme\nversion), and we found a couple of uses of set-car! and set-cdr!. Again, they\nfall into the above queue and association-list categories that are easily and\nlocally converted.\n\nMeanwhile, as we start to use v3.99 to run scripts in our day-to-day work,\nimmutable pairs have so far created no difficulty at all. So far, then, our\noptimism in trying immutable pairs seems to be justified; it just might work.\n\n## But It\u2019s Lisp Tradition!\n\nA typical response to news of the demise of mutable pairs is that it will\ncreate lot of trouble, because mutable pairs are Scheme tradition, and surely\nlots of useful old code exploits them in lots of places.\n\nWe\u2019re eager to hear whether anyone has such code. Our initial hypothesis is\nthat practically all old code falls into one of two categories:\n\n  * The code is easily ported to immutable pairs, along the same lines as above (i.e., local queues and small association lists).\n\n  * The code so old and generic that it can be run as an R5RS program. It won\u2019t call into the large PLT Scheme set of libraries that will expect immutable pairs, and it can easily be used as a library with wrappers that convert mutable pairs back and forth with immutable pairs.\n\nFrankly, we\u2019re not so eager to hear opinions based on guesswork about existing\ncode and how it might get used. Download v3.99 from SVN or as a nightly build\nwhen it becomes available; let us know your guesses about how running your old\ncode would go, but then let us know what actually happens.\n\nThe immutable-pairs plan for v4.0 is not set in stone, but we won\u2019t make the\ndecision based on guesswork. More libraries (other than R5RS) to aid\ncompatibility may be useful, but so far we don\u2019t have a tangible need for\nthem. In any case, we\u2019ll revert to mutable pairs only if significant\nexperience with the pre-release version demonstrates that it really won\u2019t\nwork.\n\nA brave and commendable experiment!\n\nI think there are two distinct issues here: set-cdr! can mutate list structure\n(and creates problems for functions that assume that list structure is\ninvariant) whereas set-car! mutates list contents but not structure (and\nprevents copying). I think the former is much more troublesome than the\nlatter. Did you consider semi-mutable pairs, that is, pairs whose car is\nmutable but cdr is immutable? In the code you have converted, is set-cdr! more\ncommon than set-car!?\n\n\u2014 Alan Watson, 12 November 2007\n\nset-car! doesn\u2019t merely prevent copying (which is a big enough problem for the\ncontract system); it can also break invariants, as in the example of\nreflecting a list-box\u2019s content.\n\nSo, keeping set-car! leaves us with problems. Would keeping it solve any\nproblems in practice? I did indeed see set-cdr! more than set-car!, and I\ncan\u2019t think of an example that would have run if only we had kept set-car!.\nThus, aside from tradition, I don\u2019t yet see any rationale for keeping set-car!\n\u2014 but I\u2019m eager to hear about other experience.\n\n\u2014 Matthew Flatt, 12 November 2007\n\nThe only situations where I find myself mutating pairs are, on first glance,\ngenerating lists front to back, which you discussed, using pairs to implement\nsimple \u2018pairs of values\u2019, where structs/objects/vectors could be used instead,\nand for sorted insertion into lists, which is more fundamental, but I guess\nwould be a good place to use mutable pairs.\n\n\u2014 Marijn, 13 November 2007\n\nPerhaps all I am saying is that the arguments against set-car! are the\nstandard arguments against mutation, whereas the arguments against set-cdr!\nare those plus the problems it creates for procedures like map. Thus, the\njustification for eliminating set-car! is similar to the justification for\nmaking records immutable (as you have done), whereas the justification for\neliminating set-cdr! is this and more.\n\n\u2014 Alan Watson, 13 November 2007\n\nAlan: I think that the arguments against set-cdr! are in fact the same\narguments against any old mutation (ie, just like the anti-set-car!\narguments). Even tho the core libraries of Scheme (things like map) suffer\nmore due to set-cdr!, ordinary programs suffer equally in our experience (as\nMatthew has explained).\n\nAnyways, let me encourage you to put your theory to the test and find some\nnon-trivial programs or libraries that back up your point!\n\n\u2014 Robby, 13 November 2007\n\nMy point is not that there are libraries or programs in which set-car! is a\ngood idea. My point is an opinion, perhaps badly expressed, on why each\ncreates problems and which is worse. Sorry for the noise.\n\n\u2014 Alan Watson, 13 November 2007\n\nI tend to agree. I do use set-car! and set-cdr! time to time, but mostly from\nmy laziness to use more appropriate data structures instead. Recently I also\nstarted to avoid the use of set-cdr! to create list from front to back, for it\ndoesn\u2019t work well with call/cc.\n\nHowever, there\u2019s one more area that I see the mutable pairs are indispensable;\ncircular lists. Though it has its own problems, it is sometimes very handy to\nexpress some kind of code concisely where I\u2019d use infinite lazy list in\nHaskell. It only needs mutation at construction time, and we can make it\n\u201cfreeze\u201d so that it won\u2019t have the problem of \u201cthe list changing during\ntraversal\u201d.\n\nDo you have some plan to support circular structures specially (e.g. srfi\u201338\nnotation or srfi\u20131\u2019s circular-list procedure hides mutation \u201cunder the hood\u201d\nso that the users only see immutable, already constructed structures)?\n\n\u2014 Shiro Kawai, 13 November 2007\n\nYes. Version 3.99.0.2 has make-reader-graph for creating cycles built from\nimmutable pairs. We need a better name, but the current name reflects that\nread still supports the #n= and #n# graph notation. (We\u2019ve dropped support for\ncyclic syntax objects, though, so read-syntax no longer supports the graph\nnotation).\n\n\u2014 Matthew Flatt, 13 November 2007\n\nWell, I\u2019ve been online now for over 30 minutes, and AFAIK, I haven\u2019t been\nhacked. This is a banner day. Hi Matt; great article! Out of necessity, from a\nsecurity standpoint, I have converted all my boxes to some flavor of *nix. As\nsoon as I can download 3.99, I\u2019ll try to reproduce the flavor of the data from\nmy flatten benchmark article. This time it will be different, simply because\nthey\u2019ll be on a new OS. However, I have a bunch of varients of the flatten\nalgorithm, using both muttable and immutable methods. As I recall from my\nearlier results, the biggest difference advantage to using mutation came about\nwhen a poor algorithm had been choosen to begin with, that required the\nreversal of the result list. These quite substantially improved their\nperformance with the use of reverse! However, the more elegant functional\nsolutions, under favorable conditions, actually out performed even the fastest\nmutable algorithms. Not typically, but definitely always in the race. The\nsuccess of building functional solutions, which are also efficient is\ncertainly achieved with other functional languages. I\u2019ll have to redesign my\nqueue routine, as you mentioned, but it will be worth the effort. I\u2019m looking\nforward to getting a copy on my box as soon as possible.\n\nTake care.\n\n\u2014kylr\n\n\u2014 Kyle Smith, 18 November 2007\n\nDid not observe any problem beyond the typical usages noted in the article\nwhen I moved SSAX and SXML to R6RS libraries.\n\nTypical use is in implementing \u201cefficient\u201d queues. I expect an applicative\nqueue such as found in Okasaki would work fine on modern hardware and scheme\nimplementations.\n\nI doubt there is a systemic problem out there.\n\n\u2014 GreyLensman, 18 November 2007\n\nHow difficult would it be to replace set! with explicit boxes?\n\n\u2014 Ethan Aubin, 21 November 2007\n\nAre you considering changing the behaviour of eq? or eqv? on (now immutable)\npairs? Currently, two immutable pairs whose cars and cdrs are eq? can only be\ndistinguished by eq? or eqv?. As such, should they really be considered to be\ndistinct or is their apparent distinctiveness simply an artifact of the\nimplementation that should be hidden from the programmer?\n\n\u2014 Alan Watson, 26 November 2007\n\nWow, did I make a mistake.\n\nBackground. In PLT Redex, the stepper uses mutable lists to represent the\ncurrently visible portion of the reduction graph. When someone clicks the\n\u201cnext\u201d button, it does a set-cdr! to add something to the end of that graph.\n\nThe Mistake. When I converted the code to v4, I figured that I should preserve\nthe mutation, so I went in and changed a few set-car!s to set-mcar!s and then\nchanged about 15 or 20 uses of filter, for-each, ormap, list-ref, and friends\nto versions of those that worked on mutable pairs instead of immutable ones.\nThis took about 2 hours.\n\nNot too bad, you might think. Two hours? Sometimes fixing one little bug can\ntake longer than that, days even. Got away cheaply, you might think ...\n\nWhat I Should Have Done. Today I decided that I wanted the code to work in\nboth v4 and in earlier versions of PLT Scheme, since the code\u2019ll be on PLaneT,\nafter all and not everyone is using v4 yet. Sigh. So now I need to go undo\nthat work and copy the list instead of mutating its tail. So I did that.\n\n5 minutes. Done. Working code.\n\n10 more minutes: removing all of the now useless helper functions that dealt\nwith the mutable-pair versions of filter, for-each, ormap, list-ref.\n\nOh well. Lesson learned, I suppose.\n\n\u2014 Robby, 27 November 2007\n\nOn replacing set! with set-box!: in a sense, this is so easy that the compiler\ndoes it automatically. That is, mutable variables are already implemented via\nboxes. You always know statically whether a variable needs to be boxed and\nunboxed due to lexical scope plus rules on mutating module-defined\nidentifiers. For essentially the same reason, set! doesn\u2019t really cause much\ntrouble; programmers usually see set!s and know to treat the relevant variable\nwith care \u2014 in contrast with set-car!s, which could be in a library that you\ndon\u2019t see.\n\n\u2014 Matthew Flatt, 27 November 2007\n\nWe have so far not changed the interaction of cons with eq? or eqv?.\nSpecifically, cons, list, etc. are guaranteed to create fresh cons cells, in\nthe sense that eq? distinguishes them, even though the cons cells are\nimmutable. I think we may want to remove this guarantee eventually, because it\nwould make some constant-folding optimizations easier and enable hash-consing,\nbut we\u2019ll take one step at a time.\n\n\u2014 Matthew Flatt, 27 November 2007\n\nA little late, but ...\n\nOnce one acknowledges value of circular/recursive list data, it follows that\nthere is likely value in the native runtime creation of such data as may be\nused for example to express arbitrarily recursively defined hierarchical\ninformation; which beyond the trivial, seems seems like a significant loss to\nthe language to push such capability outside the baseline scope of the\nlanguage by default.\n\nYes, such capability may be defined and utilized as required although not as\nelegantly as if it were native; however it seems a shame to seriously consider\nalienating the previously native capability to dynamically formulate native\nlist data from datum not known at program specification/compile time (i.e. the\nability to formulate and manipulate such list datum from information extracted\nduring run-time, as data bases typically are, can not be performed natively\nwithout set-car! set-cdr!, nor specified purely functionally); as the loss of\nsuch a potentially powerful and useful capability seems like a poor trade in\nexchange for the questionable value of default immutable lists, especially as\nthe mutability of function argument can most typically be easily determined\nwithin a function, and optimizations applied accordingly, and in the few cases\nwhere it can\u2019t, so what, presume it may be mutated. (If the concern is limited\nto map, then simply specify that map\u2019s arguments are presumed to not be\nmutated until terminated, or generally forbidden).\n\n\u2014 pschlie, 15 December 2007\n\nThe entire purpose of this experiment was to avoid caveats like \u201cseems\u201d,\n\u201clikely\u201d and \u201cpotentially\u201d. If you have real examples to show, that would be\ninteresting. So far we have far better abstract arguments against mutation\nthan for it, and no concrete experience suggesting it should be brought back.\n\nAlso, I should remind you that mcons (and friends) exist, as do mutable\nstructs. These are as \u201cnative\u201d as it gets.\n\n\u2014 Robby, 15 December 2007\n\nSomewhat more concrete:\n\n  * presume the run-time creation, storage and/or retrieval of arbitrarily recursive list structured data is useful (or please prove otherwise).\n\n(Personally see no value in presenting any particular program utilizing such\ncapabilities, as the potential usefulness of such data structures representing\nstate transition graphs, or more generally arbitrarily self recursive data\nrepresentations are self evident; just as I see no value in any example given\nof how list mutation may yield indeterminate behavior in the absents of the\nspecification of evaluation order; as overall the less flexible and\ndeterministic a language is, the less useful it tends to be. Thereby I view\ndropping native mutable lists in an effort to improve determinism, in effect\nan attempt to improve a deficiency by removing utility; as opposed to\nimproving its utility, by removing a deficiency.)\n\nImplying:\n\n  * a facility to create/manipulate such data at run-time is required.\n\n  * mcons (and friends) are only rudimentarily facilitates, which exclusively operate on a now severely crippled data type because mutable lists have been alienated from the language (incompatible with car and friends) and thereby incompatible with the majority of all native list functions and thereby now require an entirely redundant and largely absent collection of functions to specified to operate on and utilize them (inclusive of their inability to be evaluated as code):\n\n  * a facility to store and retrieve such data at run-time is required.\n\n  * as there is no current reader support to denote mutable lists:\n\n    * (mcons \u2018a \u2019{b}) -> {a . (b)} ; not {a b} as likely (cons \u2018a \u2019(b)) -> (a b) ; expected by analogy\n\n    * (define x (mcons \u2019+ (mcons 1 (mcons 2 null)))) ; i.e. {+ 1 2} (with-output-to-file \u201cf\u201d (lambda () (print x)) \u2019text \u2019replace) (with-input-from-file \u201cf\u201d (lambda () (read))) => (+ 1 2) ; wrong\n\n    * (define x (mcons 1 null)) (set-mcdr! x x) ; i.e. #0={1 . #0} (with-output-to-file \u201cf\u201d (lambda () (print x)) \u2019text \u2019replace) (with-input-from-file \u201cf\u201d (lambda () (read))) => #0=(1 . #0#) ; wrong\n\n[not to mention (define x \u2019#0=(1 . #0#)) isn\u2019t accepted anymore]\n\nSo overall, scheme absent mutable lists removes an entire class of\ncapabilities which which was never proven to be useless, in fact arguably\nknown to be otherwise, nor given analogous facilities of comparable utility.\n\nYes, such facilities may be structured from non-native structured data types\nand a corresponding new set of support functions; just as in most languages;\nhowever scheme was previously unique in that such a capability was inherent.\n(while were at it, maybe list data types and functions should be removed\nentirely, as after all, they\u2019re not strictly necessary as evidenced by most\nall other languages).\n\nIn hind sight, justifying mutable list removal because large classes of\nprograms do not require them, or that the language\u2019s specification may be\neasier in their absents, or because the contract facility implementation isn\u2019t\ncapable determining if list data is in fact potentially mutated; hardly seems\nreasonable. IMHO\n\n\u2014 pschlie, 16 December 2007\n\nPaul, this is not what I meant by concrete. No one said (or attempted to\nprove) that mutable cons cells were useless. Indeed, we still support them,\nbut we just do not use them by default anymore.\n\nThe comment \u201cjustifying mutable list removal because large classes of programs\ndo not require them\u201d misses half of the problem with mutable lists. The first\nhalf of the problem, in fact. Matthew\u2019s post clearly explains why mutable\nlists cause problems in concrete ways and, if you permit me to say so, makes a\nfar more convincing abstract case against mutable pairs than your abstract\narguments for them.\n\nBut, in any case, these abstract arguments (either way) ultimately need to be\nbacked up with real programs. Let me encourage you once again to provide some\nto back up your arguments. We have found none in a large body of code. Have\nyou investigated a body of code and found some?\n\n\u2014 Robby, 16 December 2007\n\nThe problems you describe with mutability remind me of type-theory where each\nkind of thing is separated into its own type. Then you can always use the\ntypes in conjunction with each other if you need the functionality of both.\n\nFor example, if you had the types list and mutable you could distinguish\nbetween an immutable list of immutable elements, an immutable list of mutable\nelements, a mutable list of immutable elements, and so on, and put this in\nyour \u201ccontract system\u201d (whatever that is).\n\nThis not only documents the usage of things like mutability, but also allows\nthe compiler (in theory) to check such constraints on inputs and outputs.\n\nWhen a function like map expects an immutable list, it will simply use the\nlist type without restricting the mutation of elements. But in places where\nthat could be harmful, a different type can be used. The conventional Scheme\nway of allowing everything to be mutable prevents this separation of distinct\nproperties of values.\n\nI\u2019m not too familiar with how Scheme implements things, but the general way\nthis is done is to box things that are mutable.\n\n\u2014 Jon T, 28 December 2007\n\nIn another five years or so you\u2019ll be where ML was twenty years ago! Better\nlate than never, I suppose, but, really, what is the point?\n\n\u2014 Existential Type, 25 January 2008\n\n\u201cExistential Type\u201d: your comment begs the exact same reply with macros, except\nthat five years is probably optimistic, and twenty years is an underestimate.\nOr type reflection that maybe some day will get ML some of the advantages of\nScheme.\n\n(But this is, of course, a pointless flame, just like your comment. FWIW, the\nmain issue is legacy code, and switching to Scheme with immutable lists is\nslightly easier than switching to ML. At least for us Scheme freaks.)\n\n\u2014 Eli Barzilay, 25 January 2008\n\nThe conversion of my code took less than a day (about 10000 lines, a guess,\nfor I never counted the nr of lines) There are two types of instances in which\nI used set-cdr!: for assoclists and imperative queues. Assoclists now have\nbecome immutable lists of mutable pairs with a hybrid-assq procedure added.\nThe imperative queues remain mutable lists, the cdr of the last pair being the\nonly one being updated. My code did not contain anything like append! or\nreverse!. I found no trouble in swithing to v3.99.0.9. I say yes to the better\nconditions for optimization. Jos Koot\n\n\u2014 jos koot, 26 January 2008\n\nEli, you seem forget that all Scheme fits into tiny corner of ML, namely a\nsingle recursive datatype.\n\n\u2014 Existential Type, 26 January 2008\n\nEli, I agree with you about the pointlessness of an ML-vs-Scheme flame war.\nCan you be more explicit about what you mean by \u201ctype reflection\u201d? That sounds\ninteresting, but I have no idea what you\u2019re talking about.\n\n\u2014 Michael, 26 January 2008\n\nExistential Type: From this side of the fence I can say that Scheme covers all\nof ML, with all types that were and will be written. But this is a second\npointless flame, and still irrelevant to the context. I could just as well\npoint at the many limitations of ML types (eg, what\u2019s the real type of map?\nsqrt? printf? collatz? GetFunction(\u201cfoo\u201d,\"bar.dll\")?). But that\u2019s not going to\ndo any good, so I\u2019ll stop replying. Feel free to continue on the PLT list, or\nemail me.\n\nMichael: I\u2019m talking about several efforts that attempt to get the benefits of\na dynamic language into a static language like ML. There was some work done on\nreflecting types (or reifying types) which makes it possible to sort of\npackage a value together with a type object (in the run-time sense; it becomes\na value). IIRC, there was also something related to universal types that goes\nin the same direction.\n\nPersonally, I found that MLers who blindly bash Scheme for it\u2019s lack of types\nare just as bad as Schemers who blindly bash all static typing. IMO (and in\nthe opinion of many other good people I\u2019ve talked to) there are very good\nadvantages on both sides \u2014 and the real challenge is to get dynamic languages\nlike Scheme to benefit from the advantages of statically typed languages like\nML, and vice versa. Some people choose to work on just that (from either\nside), some people don\u2019t but appreciate those who do, and some people will\ninevitably continue to spit out useless comments even in a completely\nunrelated context, like the above anonymous poster.\n\n\u2014 Eli Barzilay, 26 January 2008\n\nDon\u2019t you just love it when language maintainers drop a feature because\nsomeone, somewhere, might misuse it?\n\nWhat\u2019s next? Dropping the number zero, because it can cause a divide-by-zero\nerror?\n\nI\u2019m de-installing PLT today and switching to an implementation which doesn\u2019t\nthink I\u2019m an idiot.\n\n\u2014 T., 24 June 2008\n\nT: In fact, most modern languages dropped the number zero as a pointer. Most\nlanguages also restrict you from using a ton of other features, so which\nimplementation are you going to install: C? assembler? maybe you\u2019ll get a\nsoldering iron?\n\n\u2014 Eli Barzilay, 24 June 2008\n\nT: You do realize, don\u2019t you, that set-car! and set-cdr! are still available\nin PLT Scheme 4.0, only as a library instead of as a built-in feature? Given\nthat, I don\u2019t see what you are so upset about. You\u2019re free to use set-car! and\nset-cdr! as much as you want.\n\n\u2014 Michael Vanier, 24 June 2008\n\nI know this is an old, and probably dead thread, but I did want to respond to\none post.\n\n\u2014-Quote\u2014- Robby said... ... But, in any case, these abstract arguments (either\nway) ultimately need to be backed up with real programs. Let me encourage you\nonce again to provide some to back up your arguments. We have found none in a\nlarge body of code. Have you investigated a body of code and found some?\nDecember 16, 2007 6:56 PM \u2014-End Quote\u2014-\n\nOver 25 years ago, I used set-cdr! in a PC Scheme implementation of N-Queens\nfor an AI class. Besides using set-cdr!, calls to move a queen were properly\ntail recursive. I noticed the PLT Scheme benchmark didn\u2019t use tail recursion\nfor moves, so I modified my code to match the benchmark. The following times\ncompare the improvements for just using set-cdr! and for using set-cdr!\ncombined with tail recursion:\n\nPLT Scheme Benchmark: > (begin (collect-garbage) (time (nqueens 15))) cpu\ntime: 158899 real time: 158982 gc time: 16920 2279184 (execution time = cpu\ntime - gc time = 142.0s)\n\nset-cdr! version: > (begin (collect-garbage) (time (N-Queens 15))) cpu time:\n138616 real time: 138787 gc time: 3286 2279184 (execution time = cpu time - gc\ntime = 135.3s)\n\nset-cdr! plus properly tail recursive moves: > (begin (collect-garbage) (time\n(N-Queens 15))) cpu time: 119845 real time: 120061 gc time: 3284 2279184\n(execution time = cpu time - gc time = 116.5s)\n\nAs you can see, using set-cdr! improved overall cpu time by about the same\namount as using properly tail recursive moves. The major performance\nimprovement for set-cdr! came from reduced garbage collection. N-Queens is\njust one example of back-tracking used to traverse a search space. Any time\nthe search space can be pruned before the back-tracking call is made, and\nrestored on return from the call, set-cdr! should yield improved performance.\nIt\u2019s also very localized, as shown by the following code snippet:\n\n(else ..(set-mcdr! prior-column (mcdr column)) ..(begin0 ....(place&move safe-\ncolumns ...........(mcdr safe-columns) safe-columns ...........(cons (mcar\ncolumn) solution) count) ....(set-mcdr! prior-column column))))))\n\nIn the above example, prior-column and column traverse the list, while safe-\ncolumns always points to it\u2019s beginning. The list is never copied, just\nmanipulated with set-mcdr! as the search space is traversed. Also, the list\ngoes from 0 to N to simplify handling prior-column.\n\nGene Snider\n\n\u2014 Gene Snider, 27 January 2010\n\nWay to go PLT Scheme 4.x. You\u2019ve just made it impossible for me to use your\nScheme to work through the exercises in The Scheme Programming Language (4th\nedition) \u2014 see for example Exercise 2.9.3 on page 55.\n\nAs if learning a language like Scheme isn\u2019t hard enough for us poor suckers\ntrying to break out of the imperative/object world. Do you really have to add\nyet more beautiful impediments?\n\n\u2014 Mike Taylor, 14 April 2010\n\nMike, mcons, mcar, mcdr, set-mcar!, and set-mcdr! are provided by scheme\nalready. Just add (require scheme/mpair) to your definitions to get more\nmutable pair functionality. You will need to use slightly different function\nnames, e.g. mlist, mlength, etc. The /scheme/mpair module is well documented.\n\nWhen I first wrote N-Queens, returning the solutions was a requirement. So\nnaturally I built the solutions with cons for later return. After my earlier\npost, I realized that two additional lines of code would eliminate all cons\noperations. Now, it doesn\u2019t garbage collect until N = 17:\n\n> (begin (collect-garbage) (time (N-Queens 17))) cpu time: 6670485 real time:\n> 6702624 gc time: 618 95815104 618ms time in gc while taking 1 hour and 51\n> minutes to determine 95,815,104 solutions isn\u2019t bad.\n\nThe key is: (else ..(set-mcdr! prior-column (mcdr column)) ..(set-mcdr! column\nsolution) ..(begin0 ....(next-queen safe-columns column new-count) ....(set-\nmcdr! column (mcdr prior-column)) ....(set-mcdr! prior-column column)))\n\nGene\n\n\u2014 Gene Snider, 13 May 2010\n\n## next Your security hole is my fun hack, or: computing factorial in DrScheme\nwith a click-powered loop.\n\n## prev Don\u2019t say \u201cabstract\u201d (instead say \u201cgeneral\u201d)\n\nMade with Frog, a static-blog generator written in Racket. Source code for\nthis blog.\n\n", "frontpage": false}
