{"aid": "40030338", "title": "Elliptic Curve Cryptography", "url": "https://cryptobook.nakov.com/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc", "domain": "nakov.com", "votes": 1, "user": "fisheuler", "posted_at": "2024-04-14 11:19:59", "comments": 0, "source_title": "Elliptic Curve Cryptography (ECC)", "source_text": "Elliptic Curve Cryptography (ECC) | Practical Cryptography for Developers\n\n# Practical Cryptography for Developers\n\nSoftUni Nakov.com\n\n  * Welcome\n\n  * Preface\n\n  * Cryptography - Overview\n\n  * Hash Functions\n\n    * Crypto Hashes and Collisions\n\n    * Hash Functions: Applications\n\n    * Secure Hash Algorithms\n\n    * Hash Functions - Examples\n\n    * Exercises: Calculate Hashes\n\n    * Proof-of-Work Hash Functions\n\n  * MAC and Key Derivation\n\n    * HMAC and Key Derivation\n\n    * HMAC Calculation - Examples\n\n    * Exercises: Calculate HMAC\n\n    * KDF: Deriving Key from Password\n\n    * PBKDF2\n\n    * Modern Key Derivation Functions\n\n    * Scrypt\n\n    * Bcrypt\n\n    * Linux crypt()\n\n    * Argon2\n\n    * Secure Password Storage\n\n    * Exercises: Password Encryption\n\n  * Secure Random Generators\n\n    * Pseudo-Random Numbers - Examples\n\n    * Secure Random Generators (CSPRNG)\n\n    * Exercises: Pseudo-Random Generator\n\n  * Key Exchange and DHKE\n\n    * Diffie\u2013Hellman Key Exchange\n\n    * DHKE - Examples\n\n    * Exercises: DHKE Key Exchange\n\n  * Encryption: Symmetric and Asymmetric\n\n  * Symmetric Key Ciphers\n\n    * Cipher Block Modes\n\n    * Popular Symmetric Algorithms\n\n    * The AES Cipher - Concepts\n\n    * AES Encrypt / Decrypt - Examples\n\n    * Ethereum Wallet Encryption\n\n    * Exercises: AES Encrypt / Decrypt\n\n    * ChaCha20-Poly1305\n\n    * Exercises: ChaCha20-Poly1305\n\n  * Asymmetric Key Ciphers\n\n    * The RSA Cryptosystem - Concepts\n\n    * RSA Encrypt / Decrypt - Examples\n\n    * Exercises: RSA Encrypt / Decrypt\n\n    * Elliptic Curve Cryptography (ECC)\n\n    * ECDH Key Exchange\n\n    * ECDH Key Exchange - Examples\n\n    * Exercises: ECDH Key Exchange\n\n    * ECC Encryption / Decryption\n\n    * ECIES Hybrid Encryption Scheme\n\n    * ECIES Encryption - Example\n\n    * Exercises: ECIES Encrypt / Decrypt\n\n  * Digital Signatures\n\n    * RSA Signatures\n\n    * RSA: Sign / Verify - Examples\n\n    * Exercises: RSA Sign and Verify\n\n    * ECDSA: Elliptic Curve Signatures\n\n    * ECDSA: Sign / Verify - Examples\n\n    * Exercises: ECDSA Sign and Verify\n\n    * EdDSA and Ed25519\n\n    * EdDSA: Sign / Verify - Examples\n\n    * Exercises: EdDSA Sign and Verify\n\n  * Quantum-Safe Cryptography\n\n    * Quantum-Safe Signatures - Example\n\n    * Quantum-Safe Key Exchange - Example\n\n    * Quantum-Safe Asymmetric Encryption - Example\n\n  * More Cryptographic Concepts\n\n    * Digital Certificates - Example\n\n    * TLS - Example\n\n    * One-Time Passwords (OTP) - Example\n\n  * Crypto Libraries for Developers\n\n    * JavaScript Crypto Libraries\n\n    * Python Crypto Libraries\n\n    * C# Crypto Libraries\n\n    * Java Crypto Libraries\n\n  * Conclusion\n\nPowered by GitBook\n\n# Elliptic Curve Cryptography (ECC)\n\nThe Elliptic Curve Cryptography (ECC) is modern family of public-key\ncryptosystems, which is based on the algebraic structures of the elliptic\ncurves over finite fields and on the difficulty of the Elliptic Curve Discrete\nLogarithm Problem (ECDLP).\n\nECC implements all major capabilities of the asymmetric cryptosystems:\nencryption, signatures and key exchange.\n\nThe ECC cryptography is considered a natural modern successor of the RSA\ncryptosystem, because ECC uses smaller keys and signatures than RSA for the\nsame level of security and provides very fast key generation, fast key\nagreement and fast signatures.\n\n##\n\nECC Keys\n\nThe private keys in the ECC are integers (in the range of the curve's field\nsize, typically 256-bit integers). Example of 256-bit ECC private key (hex\nencoded, 32 bytes, 64 hex digits) is:\n0x51897b64e85c3f714bba707e867914295a1377a7463a9dae8ea6a8b914246319.\n\nThe key generation in the ECC cryptography is as simple as securely generating\na random integer in certain range, so it is extremely fast. Any number within\nthe range is valid ECC private key.\n\nThe public keys in the ECC are EC points - pairs of integer coordinates {x,\ny}, laying on the curve. Due to their special properties, EC points can be\ncompressed to just one coordinate + 1 bit (odd or even). Thus the compressed\npublic key, corresponding to a 256-bit ECC private key, is a 257-bit integer.\nExample of ECC public key (corresponding to the above private key, encoded in\nthe Ethereum format, as hex with prefix 02 or 03) is:\n0x02f54ba86dc1ccb5bed0224d23f01ed87e4a443c47fc690d7797a13d41d2340e1a. In this\nformat the public key actually takes 33 bytes (66 hex digits), which can be\noptimized to exactly 257 bits.\n\n##\n\nCurves and Key Length\n\nECC crypto algorithms can use different underlying elliptic curves. Different\ncurves provide different level of security (cryptographic strength), different\nperformance (speed) and different key length, and also may involve different\nalgorithms.\n\nECC curves, adopted in the popular cryptographic libraries and security\nstandards, have name (named curves, e.g. secp256k1 or Curve25519), field size\n(which defines the key length, e.g. 256-bit), security strength (usually the\nfield size / 2 or less), performance (operations/sec) and many other\nparameters.\n\nECC keys have length, which directly depends on the underlying curve. In most\napplications (like OpenSSL, OpenSSH and Bitcoin) the default key length for\nthe ECC private keys is 256 bits, but depending on the curve many different\nECC key sizes are possible: 192-bit (curve secp192r1), 233-bit (curve\nsect233k1), 224-bit (curve secp224k1), 256-bit (curves secp256k1 and\nCurve25519), 283-bit (curve sect283k1), 384-bit (curves p384 and secp384r1),\n409-bit (curve sect409r1), 414-bit (curve Curve41417), 448-bit (curve\nCurve448-Goldilocks), 511-bit (curve M-511), 521-bit (curve P-521), 571-bit\n(curve sect571k1) and many others.\n\n##\n\nECC Algorithms\n\nElliptic-curve cryptography (ECC) provides several groups of algorithms, based\non the math of the elliptic curves over finite fields:\n\n  * ECC digital signature algorithms like ECDSA (for classical curves) and EdDSA (for twisted Edwards curves).\n\n  * ECC encryption algorithms and hybrid encryption schemes like the ECIES integrated encryption scheme and EEECC (EC-based ElGamal).\n\n  * ECC key agreement algorithms like ECDH, X25519 and FHMQV.\n\nAll these algorithms use a curve behind (like secp256k1, curve25519 or p521)\nfor the calculations and rely of the difficulty of the ECDLP (elliptic curve\ndiscrete logarithm problem). All these algorithms use public / private key\npairs, where the private key is an integer and the public key is a point on\nthe elliptic curve (EC point). Let's get into details about the elliptic\ncurves over finite fields.\n\n##\n\nElliptic Curves\n\nIn mathematics elliptic curves are plane algebraic curves, consisting of all\npoints {x, y}, described by the equation:\n\nCryptography uses elliptic curves in a simplified form (Weierstras form),\nwhich is defined as:\n\n  * y2 = x3 + _a_x + b\n\nFor example, the NIST curve secp256k1 (used in Bitcoin) is based on an\nelliptic curve in the form:\n\n  * y2 = x3 + 7 (the above elliptic curve equation, where a = 0 and b = 7)\n\nThis is a visualization of the above elliptic curve:\n\nTo learn more about the equations of the elliptic curves and how they look\nlike, play a bit with this online elliptic curve visualization tool:\nhttps://www.desmos.com/calculator/ialhd71we3.\n\n###\n\nElliptic Curves over Finite Fields\n\nThe elliptic curve cryptography (ECC) uses elliptic curves over the finite\nfield Fp (where p is prime and p > 3) or F2m (where the fields size p = 2_m_).\nThis means that the field is a square matrix of size p x p and the points on\nthe curve are limited to integer coordinates within the field only. All\nalgebraic operations within the field (like point addition and multiplication)\nresult in another point within the field. The elliptic curve equation over the\nfinite field Fp takes the following modular form:\n\n  * y2 \u2261 x3 + _a_x + b (mod p)\n\nRespectively, the \"Bitcoin curve\" secp256k1 takes the form:\n\n  * y2 \u2261 x3 + 7 (mod p)\n\nUnlike RSA, which uses for its key space the integers in the range [0...p-1]\n(the field Zp), the ECC uses the points {x, y} within the Galois field Fp\n(where x and y are integers in the range [0...p-1]).\n\nAn elliptic curve over the finite field Fp consists of:\n\n  * a set of integer coordinates {x, y}, such that 0 \u2264 x, y < p\n\n  * staying on the elliptic curve: _y_2 \u2261 x3 + _a_x + b (mod p)\n\nExample of elliptic curve over the finite field F17:\n\n  * y2 \u2261 x3 + 7 (mod 17)\n\nThis elliptic curve over F17 looks like this:\n\nNote that the elliptic curve over finite field y2 \u2261 x3 + 7 (mod 17) consists\nof the blue points at the above figure, i.e. in practice the \"elliptic curves\"\nused in cryptography are \"sets of points in square matrix\", not classical\n\"curves\".\n\nThe above curve is \"educational\". It provides very small key length (4-5\nbits). In the real world developers typically use curves of 256-bits or more.\n\n###\n\nElliptic Curves over Finite Fields: Calculations\n\nIt is pretty easy to calculate whether certain point belongs to certain\nelliptic curve over a finite field. For example, a point {x, y} belongs to the\ncurve y2 \u2261 x3 + 7 (mod 17) when and only when:\n\n  * x3 + 7 - y2 \u2261 0 (mod 17)\n\nThe point P {5, 8} belongs to the curve, because (5**3 + 7 - 8**2) % 17 == 0.\nThe point {9, 15} does not belong to the curve, because (9**3 + 7 - 15**2) %\n17 != 0. These calculations are in Python style. The above mentioned elliptic\ncurve and the points {5, 8} and {9, 15} are visualized below:\n\n###\n\nMultiplying ECC Point by Integer\n\nTwo points over an elliptic curve (EC points) can be added and the result is\nanother point. This operation is known as EC point addition. If we add a point\nG to itself, the result is G + G = 2 * G. If we add G again to the result, we\nwill obtain 3 * G and so on. This is how EC point multiplication is defined.\n\nA point G over an elliptic curve over finite field (EC point) can be\nmultiplied by an integer k and the result is another EC point P on the same\ncurve and this operation is fast:\n\n  * P = k * G\n\nThe above operation involves some formulas and transformations, but for\nsimplicity, we shall skip them. The important thing to know is that\nmultiplying EC point by integer returns another EC point on the same curve and\nthis operation is fast. Multiplying an EC point by 0 returns a special EC\npoint called \"infinity\".\n\nEveryone is free to read more about EC point multiplication in Wikipedia.\n\n###\n\nExample: Multiply EC Point by Integer\n\nThe formulas for EC multiplication differ for the different forms of\nrepresentation of the curve. In this example, we shall use an elliptic curve\nin the classical Weierstrass form.\n\nFor example let's take the EC point G = {15, 13} on the elliptic curve over\nfinite field y2 \u2261 x3 + 7 (mod 17) and multiply it by k = 6. We shall obtain an\nEC point P = {5, 8}:\n\n  * P = k * G = 6 * {15, 13} = {5, 8}\n\nThe below figure visualizes this example of EC point multiplication:\n\n###\n\nOrder and Cofactor of Elliptic Curve\n\n\u0410n elliptic curve over a finite field can form a finite cyclic algebraic\ngroup, which consists of all the points on the curve. In a cyclic group, if\ntwo EC points are added or an EC point is multiplied to an integer, the result\nis another EC point from the same cyclic group (and on the same curve). The\norder of the curve is the total number of all EC points on the curve. This\ntotal number of points includes also the special point called \"point at\ninfinity\", which is obtained when a point is multiplied by 0.\n\nSome curves form a single cyclic group (holding all their EC points), while\nothers form several non-overlapping cyclic subgroups (each holding a subset of\nthe curve's EC points). In the second scenario the points on the curve are\nsplit into h cyclic subgroups (partitions), each of order r (each subgroup\nholds equal number of points). The order of entire group is n = h * r (the\nnumber of subgroups, multiplied by the number of points in each subgroup). The\nnumber of subgroups h holding the EC points is called cofactor.\n\nThe cofactor is typically expressed by the following formula:\n\n  * h = n / r\n\nwhere\n\n  * n is the order of the curve (the number of all its points)\n\n  * h is the curve cofactor (the number of non-overlapping subgroups of points, which together hold all curve points)\n\n  * r is the order of the subgroups (the number of points in each subgroup, including the infinity point for each subgroup)\n\nIn other words, the points over an elliptic curve stay in one or several non-\noverlapping subsets, called cyclic subgroups. The number of subgroups is\ncalled \"cofactor\". The total number of points in all subgroups is called\n\"order\" of the curve and is usually denoted by n. If the curve consists of\nonly one cyclic subgroup, its cofactor h = 1. If the curve consists of several\nsubgroups, its cofactor > 1.\n\n  * Example of elliptic curve having cofactor = 1 is secp256k1.\n\n  * Example of elliptic curve having cofactor = 8 is Curve25519.\n\n  * Example of elliptic curve having cofactor = 4 is Curve448.\n\n###\n\nThe \"Generator\" Point in ECC\n\nFor the elliptic curves over finite fields, the ECC cryptosystems define a\nspecial pre-defined (constant) EC point called generator point G (base point),\nwhich can generate any other point in its subgroup over the elliptic curve by\nmultiplying G by some integer in the range [0...r]. The number r is called\n\"order\" of the cyclic subgroup (the total number of all points in the\nsubgroup).\n\nFor curves with cofactor = 1 there is only one subgroup and the order n of the\ncurve (the total number of different points over the curve, including the\ninfinity) is equal to the number r.\n\nWhen G and n are carefully selected, and the cofactor = 1, all possible EC\npoints on the curve (including the special point infinity) can be generated\nfrom the generator G by multiplying it by integer in the range [1...n]. This\ninteger n is known as \"order of the curve\".\n\nIt is important to know that the order r of the subgroup, obtained from\ncertain EC generator point G (which may be different from the order of the\ncurve) defines the total number of all possible private keys for this curve: r\n= n / h (curve order, divided by the curve cofactor). Cryptographers select\ncarefully the elliptic curve domain parameters (curve equation, generator\npoint, cofactor, etc.) to ensure that the key space is large enough for\ncertain cryptographic strength.\n\nTo summarize, in the ECC cryptography the EC points, together with the\ngenerator point G form cyclic groups (or cyclic subgroups), which means that a\nnumber r exists (r > 1), such that r * G = 0 * G = infinity and all points in\nthe subgroup can be obtained by multiplying G by integer in the range [1...r].\nThe number r is called order of the group (or subgroup).\n\nElliptic curve subgroups usually have many generator points, but\ncryptographers carefully select one of them, which generates the entire group\n(or subgroup) and is suitable for performance optimizations in the\ncomputations. This is the generator known as \"G\".\n\nIt is known that for some curves different generator points generate subgroups\nof different order. More precisely, if the group order is n, for each prime d\ndividing n, there is a point Q such that d * Q = infinity. This means that\nsome points used as generators for the same curve will generate smaller\nsubgroups than others. if the group is small, the security is weak. This is\nknown as \"small-subgroup\" attacks. This is the reason why cryptographers\nusually choose the subgroup order r to be a prime number.\n\nFor elliptic curves with cofactor h > 1, different base points can generate\ndifferent subgroups of EC points on the curve. By choosing a certain generator\npoint, we choose to operate over a certain subgroup of points on the curve and\nmost EC point operations and ECC crypto algorithms will work well. Still in\nsome cases, special attention should be given, so it is recommended to use\nonly proven ECC implementations, algorithms and software packages.\n\n###\n\nGenerator Point - Example\n\nAt the above example (the EC over finite field y2 \u2261 x3 + 7 mod 17), if we take\nthe point G = {15, 13} as generator, any other point from the curve can be\nobtained by multiplying G by some integer in the range [1...18]. Thus the\norder of this EC is n = 18 and its cofactor h = 1.\n\nNote that the curve has 17 normal EC points (shown at the above figures) + one\nspecial \"point at infinity\", all staying in a single subgroup, and the curve\norder is 18 (not 17).\n\nNote also, that if we take the point {5, 9} as generator, it will generate\njust 3 EC points: {5, 8}, {5, 9} and infinity. Because the curve order is not\nprime number, different generators may generate subgroups of different order.\nThis is a good example why we should not \"invent\" our own elliptic curves for\ncryptographic purposes and we should use proven curves.\n\n###\n\nPrivate Key, Public Key and the Generator Point in ECC\n\nIn the ECC, when we multiply a fixed EC point G (the generator point) by\ncertain integer k (k can be considered as private key), we obtain an EC point\nP (its corresponding public key).\n\nConsequently, in ECC we have:\n\n  * \u0415lliptic curve (EC) over finite field Fp\n\n  * G == generator point (fixed constant, a base point on the EC)\n\n  * k == private key (integer)\n\n  * P == public key (point)\n\nIt is very fast to calculate P = k * G, using the well-known ECC\nmultiplication algorithms in time log_2(k_), e.g. the \"double-and-add\nalgorithm\". For 256-bit curves, it will take just a few hundreds simple EC\noperations.\n\nIt is extremely slow (considered infeasible for large k) to calculate k = P /\nG.\n\nThis asymmetry (fast multiplication and infeasible slow opposite operation) is\nthe basis of the security strength behind the ECC cryptography, also known as\nthe ECDLP problem.\n\n###\n\nElliptic-Curve Discrete Logarithm Problem (ECDLP)\n\nThe Elliptic Curve Discrete Logarithm Problem (ECDLP) in computer science is\ndefined as follows:\n\n  * By given elliptic curve over finite field Fp and generator point G on the curve and point P on the curve, find the integer k (if it exists), such that P = k * G\n\nFor carefully chosen (by cryptographers) finite fields and elliptic curves,\nthe ECDLP problem has no efficient solution.\n\nThe multiplication of elliptic curve points in the group Fp is similar to\nexponentiation of integers in the group Zp (this is known as multiplicative\nnotation) and this is how the ECDLP problem is similar to the DLP problem\n(discrete logarithm problem).\n\nIn the ECC cryptography, many algorithms rely on the computational difficulty\nof the ECDLP problem over carefully chosen field Fp and elliptic curve, for\nwhich no efficient algorithm exists.\n\n###\n\nECC and Curve Security Strength\n\nBecause the fastest known algorithm to solve the ECDLP for key of size k needs\nk steps, this means that to achieve a k-bit security strength, at least\n2*k-bit curve is needed. Thus 256-bit elliptic curves (where the field size p\nis 256-bit number) typically provide nearly 128-bit security strength.\n\nIn fact, the strength is slightly less, because the order of the curve (n) is\ntypically less than the fields size (p) and because the curve may have\ncofactor h > 1 (and subgroup order r = n / h, smaller than n) and because the\nnumber of steps is not exactly k, but is 0.886\u2217k. A precise security strength\nestimation for the most popular standard elliptic curves is given here:\nhttp://safecurves.cr.yp.to/rho.html.\n\nFor example, the secp256k1 (p = 256) curve provides ~ 128-bit security (127.8\nbits to be precise) and the Curve448 (p = 448) provides ~ 224-bit security\n(222.8 bits to be precise).\n\n###\n\nMultiplication of EC Points - Example in Python\n\nNow, after all the concepts, let's write some code. We shall use the Python\nlibrary tinyec, which provides ECC primitives, such as cyclic groups (the\nSubGroup class), elliptic curves over finite fields (the Curve class) and EC\npoints (the Point class). First, install the package tinyec:\n\n    \n    \n    pip install tinyec\n\nWe shall play with the educational curve from our previous examples y2 \u2261 x3 +\n7 (mod 17), with the generator point G = {15, 13}, which has order of n = 18.\nWe shall name it p1707.\n\n    \n    \n    from tinyec.ec import SubGroup, Curve field = SubGroup(p=17, g=(15, 13), n=18, h=1) curve = Curve(a=0, b=7, field=field, name='p1707') print('curve:', curve) for k in range(0, 25): p = k * curve.g print(f\"{k} * G = ({p.x}, {p.y})\")\n\nRun the above code example: https://repl.it/@nakov/EC-points-in-Python. The\nabove code demonstrates the EC multiplication. It multiplies the generator\npoint G by 0, 1, 2, ..., 24. The output from the above program is as follows:\n\n    \n    \n    curve: \"p1707\" => y^2 = x^3 + 0x + 7 (mod 17) 0 * G = (None, None) 1 * G = (15, 13) 2 * G = (2, 10) 3 * G = (8, 3) 4 * G = (12, 1) 5 * G = (6, 6) 6 * G = (5, 8) 7 * G = (10, 15) 8 * G = (1, 12) 9 * G = (3, 0) 10 * G = (1, 5) 11 * G = (10, 2) 12 * G = (5, 9) 13 * G = (6, 11) 14 * G = (12, 16) 15 * G = (8, 14) 16 * G = (2, 7) 17 * G = (15, 4) 18 * G = (None, None) 19 * G = (15, 13) 20 * G = (2, 10) 21 * G = (8, 3) 22 * G = (12, 1) 23 * G = (6, 6) 24 * G = (5, 8)\n\nIt is visible that 0 * G = infinity. It is also clearly visible, that the EC\ngroup is cyclic and the order of the EC group is n = 18, because starting from\nk = 18, the next points repeat the first ones:\n\n  * 18 * G = 0 * G = infinity\n\n  * 19 * G = 1 * G = {15, 13}\n\n  * 20 * G = 2 * G = {2, 10}\n\n  * 21 * G = 3 * G = {8, 3}\n\n  * etc.\n\nThe EC points, generated by multiplying the generator point G by 2, 3, 4, ...,\n17 are shown on the figure below:\n\nLet's modify a bit the above example and change the generator point to be G' =\n{5, 9}. This will change significantly the output:\n\n    \n    \n    from tinyec.ec import SubGroup, Curve field = SubGroup(p=17, g=(5, 9), n=18, h=1) curve = Curve(a=0, b=7, field=field, name='p1707') print('curve:', curve) for k in range(0, 25): p = k * curve.g print(f\"{k} * G' = ({p.x}, {p.y})\")\n\nRun the above code example: https://repl.it/@nakov/EC-points-by-generator-\npoint-in-Python. The output shows that the subgroup order of the new generator\npoint is not 18, but is 3. This is possible, because 18 is not prime. It is\nclear from the output, that 3 * G' = infinity and the obtained subgroup order\nis 3:\n\n    \n    \n    curve: \"p1707\" => y^2 = x^3 + 0x + 7 (mod 17) 0 * G' = (None, None) 1 * G' = (5, 9) 2 * G' = (5, 8) 3 * G' = (None, None) 4 * G' = (5, 9) 5 * G' = (5, 8) 6 * G' = (None, None) ...\n\nThe above example again confirms that designing an elliptic curve for\ncryptography should be done by cryptographers, not by developers. Developers\nshould rely on well established crypto-standards and proven crypto-libraries.\n\n###\n\nMultiplication of EC Points - Real-World Example in Python\n\nNow, let's write a real-world example. Instead of using our educational curve\np1707 (4-5-bit curve, p = 17), we shall use the 192-bit cryptographic curve\nsecp192r1 (192-bit, p =\n6277101735386680763835789423207666416083908700390324961279). The below example\nis similar to the previous:\n\n    \n    \n    from tinyec import registry curve = registry.get_curve('secp192r1') print('curve:', curve) for k in range(0, 10): p = k * curve.g print(f\"{k} * G = ({p.x}, {p.y})\") print(\"Cofactor =\", curve.field.h) print('Cyclic group order =', curve.field.n) nG = curve.field.n * curve.g print(f\"n * G = ({nG.x}, {nG.y})\")\n\nRun the above code example: https://repl.it/@nakov/EC-points-in-real-world-in-\nPython. The output is also similar to the previous example:\n\n    \n    \n    curve: \"secp192r1\" => y^2 = x^3 + 6277101735386680763835789423207666416083908700390324961276x + 2455155546008943817740293915197451784769108058161191238065 (mod 6277101735386680763835789423207666416083908700390324961279) 0 * G = (None, None) 1 * G = (602046282375688656758213480587526111916698976636884684818, 174050332293622031404857552280219410364023488927386650641) 2 * G = (5369744403678710563432458361254544170966096384586764429448, 5429234379789071039750654906915254128254326554272718558123) 3 * G = (2915109630280678890720206779706963455590627465886103135194, 2946626711558792003980654088990112021985937607003425539581) 4 * G = (1305994880430903997305943738697779408316929565234787837114, 3981863977451150342116987835776121688410789618551673306674) 5 * G = (410283251116784874018993562136566870110676706936762660240, 1206654674899825246688205669651974202006189255452737318561) 6 * G = (4008504146453526025173196900303594155799995627910231899946, 3263759301305176906990806636587838100022690095020155627760) 7 * G = (3473339081378406123852871299395262476289672479707038350589, 2152713176906603604200842901176476029776544337891569565621) 8 * G = (1167950611014894512313033362696697441497340081390841490910, 4002177906111215127148483369584652296488769677804145538752) 9 * G = (3176317450453705650283775811228493626776489433309636475023, 44601893774669384766793803854980115179612118075017062201) Cofactor = 1 Cyclic group order = 6277101735386680763835789423176059013767194773182842284081 n * G = (None, None)\n\nThe curve secp192r1 uses a cyclic group of very large order n =\n6277101735386680763835789423176059013767194773182842284081 (prime number) with\ncofactor h = 1, and as we can expect, n * G = infinity, just like at the\nprevious example with our educational curve.\n\nNow, let's generate a random private key privKey (integer in the range\n[0...n-1]) and its corresponding public key pubKey = privKey * G:\n\n    \n    \n    from tinyec import registry import secrets curve = registry.get_curve('secp192r1') privKey = secrets.randbelow(curve.field.n) pubKey = privKey * curve.g print(\"private key:\", privKey) print(\"public key:\", pubKey)\n\nRun the above code example: https://repl.it/@nakov/EC-points-private-public-\nkeys-in-Python. The above code will produce output like this:\n\n    \n    \n    private key: 4225655318977962031264230130242180748818603147467615868902 public key: (5396030834456770190396776530938374882273836179487834152291, 3422160588166914010077732710830109086004758012634997793937) on \"secp192r1\" => y^2 = x^3 + 6277101735386680763835789423207666416083908700390324961276x + 2455155546008943817740293915197451784769108058161191238065 (mod 6277101735386680763835789423207666416083908700390324961279)\n\nLater we shall use such pairs of ECC keys {private key, public key} to encrypt\ndata, sign messages and verify signatures.\n\nNote that in real projects, 192-bit curves are considered weak, so 256-bit\ncurves are recommended (or more bits), where the keys are also 256-bits (or\nrespectively more). We use 192-bit curve in the above example just to make the\nsample output smaller.\n\n###\n\nPublic Key Compression in the Elliptic Key Cryptosystems\n\nElliptic curves over finite fields Fp (in the Weierstrass form) have at most 2\npoints per y coordinate (odd x and even x). This property comes from the\nnature of the elliptic curve equation and is illustrated at the below graph:\n\nDue to this property, an elliptic curve point (and respectively an ECC public\nkey) P {x, y} can be compressed as C {x, odd/even). This means to erase the y\ncoordinate from the point and represent it as 1 bit (odd y or even y).\n\nCompressed EC point is an EC point {x, y} represented in its shorter form {x,\nodd / even}. ECC public keys are EC points, so they can also be compressed in\nthe same way.\n\nTo decompress a point, we can calculate its two possible y coordinates by the\nformulas:\n\n  * y1 = mod_sqrt(x3 + ax + b, p)\n\n  * y2 = p - mod_sqrt(x3 + ax + b, p)\n\nThen we take the odd or even from the above coordinates (according to the\nadditional parity bit in the compressed representation).\n\nThe modular square root (mod_sqrt) can be calculated using the Tonelli\u2013Shanks\nalgorithm.\n\nLet's take an example: at the elliptic curve y2 \u2261 x3 + 7 (mod 17) the point P\n{10, 15} can be compressed as C {10, odd}. For decompression, we first\ncalculate the two possible y coordinates for x = 10 using the above formulas:\ny1 = 2 and y2 = 15. Then we choose the odd one: y = 15. The decompressed point\nis {10, 15}.\n\n###\n\nCompressing a EC Point / Public Key - Example in Python\n\nThe code below implements public key compression and decompression in Python.\nIt uses a library called nummaster for the \"modular square root\" function,\nwhich is unavailable in Python. First install the nummaster package:\n\n    \n    \n    pip install nummaster\n\nNow implement the EC point compression and decompression functions in Python:\n\n    \n    \n    from nummaster.basic import sqrtmod def compress_point(point): return (point[0], point[1] % 2) def uncompress_point(compressed_point, p, a, b): x, is_odd = compressed_point y = sqrtmod(pow(x, 3, p) + a * x + b, p) if bool(is_odd) == bool(y & 1): return (x, y) return (x, p - y)\n\nFinally, compress and decompress the point {10, 15} on the curve y2 \u2261 x3 + 7\n(mod 17), just as an example:\n\n    \n    \n    p, a, b = 17, 0, 7 point = (10, 15) print(f\"original point = {point}\") compressed_p = compress_point(point) print(f\"compressed = {compressed_p}\") restored_p = uncompress_point(compressed_p, p, a, b) print(f\"uncompressed = {restored_p}\")\n\nRun the above code example: https://repl.it/@nakov/EC-point-compression-\ndecompression-in-Python. The output of the above code is:\n\n    \n    \n    original point = (10, 15) compressed = (10, 1) uncompressed = (10, 15)\n\n###\n\nElliptic Curve Domain Parameters for ECC\n\nECC elliptic curves are described by a set of elliptic curve domain\nparameters, such as the curve equation parameters, the field parameters and\nthe generator point coordinates. These parameters are specified in\ncryptography standards, such as:\n\n  * SEC 2: Recommended Elliptic Curve Domain Parameters\n\n  * NIST FIPS PUB 186-4 Digital Signature Standard (DSS)\n\n  * Brainpool ECC Standard (RFC-5639)\n\nThese standards define the parameters for a set of named curves, such as\nsecp256k1, P-521 and brainpoolP512t1. The elliptic curves over finite fields,\ndescribed in these crypto standards are well researched and analysed by\ncryptographers and are considered to have certain security strength, also\ndescribed in these standards.\n\nSome cryptographers (like Daniel Bernstein) believe that most of the curves,\ndescribed in the official crypto-standards are \"unsafe\" and define their own\ncrypto-standards, which consider the ECC security in much broader level.\n\nThe Bernstein's SafeCurves standard lists the curves, which are safe according\nto a set of ECC security requirements. The standard is available at\nhttps://safecurves.cr.yp.to.\n\n###\n\nChoosing an Elliptic Curve for ECC\n\nTo use ECC all communicating parties should agree on the EC domain parameters\n(all the elements defining the elliptic curve). It is highly recommended to\nuse a named curve from the above standards with at least 256-bit modulus.\nStandard curves are well studied by cryptographers to guarantee their security\nstrength.\n\nDon't use own elliptic curve (with non-standard domain parameters), unless you\nare experienced cryptographer and you know very well what are you doing! Many\ncurves have weaknesses, which make the ECDLP problem not so difficult and\ncompromise the security. If you are afraid of backdoored curves, use a\nstandard safe curve from the SafeCurves list.\n\n###\n\nNamed Curves - Example\n\nIn ECC cryptography, elliptic curves over the finite fields are used, where\nthe modulus p and the order n are very large integers (n is usually prime\nnumber), e.g. 256-bit number. The finite field of the curve is of square form\nof size p x p, which is incredibly large, and all possible EC points on the\ncurve (the order of the curve n) is also a very big integer, e.g. 256-bit. For\nexample, the domain parameters for the curve secp256k1 (the Bitcoin curve) are\ndefined as follows:\n\n  * p (modulus) = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\n\n  * n (order; size; the count of all possible EC points) = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n\n  * a (the constant \"a\" in y^2 \u2261 x^3 + a*x + b (mod p)) = 0x0000000000000000000000000000000000000000000000000000000000000000\n\n  * b (the constant \"b\" in y^2 \u2261 x^3 + a*x + b (mod p)) = 0x0000000000000000000000000000000000000000000000000000000000000007\n\n  * g (the curve generator point G {x, y}) = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8)\n\n  * h (cofactor, typically 1) = 01\n\nWe already know that a 256-bit curve (which means that p and n are 256-bit\nnumbers) provides 128-bit security strength, which means that to find the\nprivate key from the public key or signature, the best known non-quantum\nalgorithm will take approximately 2128 operations. The above-defined ECC curve\nsecp256k1 has 128-bit strength.\n\n###\n\nPython Examples with the \"secp256k1\" Curve\n\nNow let's put in action the above domain parameters for the secp256k1 curve.\nLet's define the EC and calculate the public key for certain private key:\n\n    \n    \n    from tinyec.ec import SubGroup, Curve # Domain parameters for the `secp256k1` curve # (as defined in http://www.secg.org/sec2-v2.pdf) name = 'secp256k1' p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 a = 0x0000000000000000000000000000000000000000000000000000000000000000 b = 0x0000000000000000000000000000000000000000000000000000000000000007 g = (0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798, 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8) h = 1 curve = Curve(a, b, SubGroup(p, g, n, h), name) print('curve:', curve) privKey = int('0x51897b64e85c3f714bba707e867914295a1377a7463a9dae8ea6a8b914246319', 16) print('privKey:', hex(privKey)[2:]) pubKey = curve.g * privKey pubKeyCompressed = '0' + str(2 + pubKey.y % 2) + str(hex(pubKey.x)[2:]) print('pubKey:', pubKeyCompressed)\n\nRun the above code example: https://repl.it/@nakov/secp256k1-curve-in-Python.\nThe above code defines the secp256k1 curve through its domain parameters and\ncalculates a public key by given private key. This is done by multiplying the\ncurve generator G by the private key. The result is correct, like it is\nvisible from the program output:\n\n    \n    \n    curve: \"secp256k1\" => y^2 = x^3 + 0x + 7 (mod 115792089237316195423570985008687907853269984665640564039457584007908834671663) privKey: 51897b64e85c3f714bba707e867914295a1377a7463a9dae8ea6a8b914246319 pubKey: 02f54ba86dc1ccb5bed0224d23f01ed87e4a443c47fc690d7797a13d41d2340e1a\n\nThe public key is compressed and encoded in the standard format (encode the y\ncoordinate as prefix 02 or 03).\n\n##\n\nEdwards Curves\n\nElliptic curves in the elliptic curve cryptography (ECC) may be presented in\nseveral forms (representations), which are proven to be birationally\nequivalent (isomorphic):\n\n  * Weierstrass form of elliptic curve:\n\n    * y2 = x3 + _a_x + b\n\n    * Example Weierstrass curve used in ECC is secp256k1, which has the form y2 = x3 + 7\n\n  * Montgomery form of elliptic curve:\n\n    * _B_y2 = x3 + _A_x2 + x\n\n    * Example Montgomery curve used in ECC is Curve25519, which has the form y2 = x3 + _486662_x2 + x\n\n  * Edwards form of elliptic curve:\n\n    * x2 + y2 = 1 + _d_x2y2\n\n    * Example Edwards curve used in ECC is Curve448, which has the form x2 + y2 = 1 - _39081_x2y2\n\nFor performance reasons elliptic curve cryptography (ECC) sometimes uses\nEdwards curves, which are elliptic curves in the following form:\n\n  * x2 + y2 = 1 + _d_x2y2\n\nFor example, if d = 300, the Edwards curve x2 + y2 = 1 + _300_x2y2 looks like\nthis:\n\nEvery Edwards curve is birationally equivalent to an elliptic curve in\nWeierstrass form (y2 = x3 + _a_x + b) and thus has the same properties like\nthe classical elliptic curves.\n\nEdwards curves over a finite prime field Fp (where p is large prime number)\nprovide fast integer to EC point multiplication, which has similar\ncryptographic properties like the classical elliptic curves, and the ECDLP\nproblem has the same computational difficulty, suitable for cryptographic\npurposes.\n\nExamples of well-known cryptographic elliptic Edwards curves over finite prime\nfields are: Curve1174 (251-bit), Curve25519 (255-bit), Curve383187 (383-bit),\nCurve41417 (414-bit), Curve448 (448-bit), E-521 (521-bit) and others.\n\n###\n\nCurve25519, X25519 and Ed25519\n\nWith carefully selected curve parameters, the Edwards curves over finite\nfields can implement ECC cryptosystems capable to provide ECDH key agreement\nschemes, digital signatures and hybrid encryption schemes, with very high\nperformance.\n\nFor example, the Curve25519 is the Edwards curve, defined by the following\nelliptic curve equation in Montgomery form:\n\n  * y2 = x3 + _486662_x2 + x\n\nover the finite prime field Fp, where p = 2255 - 19 (the curve is 255-bit).\n\nIn fact, the above equation does not match directly the Edwards curve\nequation, but it is proven to be birationally equivalent to the following\ntwisted Edwards curve (known as edwards25519):\n\n  * -x2 + y2 = 1 + _37095705934669439343138083508754565189542113879843219016388785533085940283555_x2y2\n\nThe elliptic curve Curve25519 consists of all points {x, y} with integer\ncoordinates, defined by the modular equation:\n\n  * y2 \u2261 x3 + _486662_x2 + x (mod 2255 - 19)\n\nThe above equation has its equivalent in the classical Weierstrass form for\nthe elliptic curves (y2 = x3 + _a_x + b), but the above form is designed\nespecially for speed optimizations.\n\nThe Curve25519 is carefully engineered, by a team of cryptographers, led by\nDaniel Bernstein, at several levels of design and implementation to achieve\nvery high speeds without compromising security.\n\nThe Curve25519 has order (in its underlying cyclic group) n = 2252 +\n0x14def9dea2f79cd65812631a5cf5d3ed and cofactor h = 8 and provides 125.8-bit\nsecurity strength (it is sometimes referred as ~ 128-bit security). The\nprivate keys for the Curve25519 are 251 bits and are usually encoded as\n256-bit integers (32 bytes, 64 hex digits). The public keys are typically\nencoded also as 256-bit integers (255-bit y-coordinate + 1-bit x-coordinate)\nand this is very convenient for developers.\n\nBased on the Curve25519 an ECDH function is derived, called X25519 (used for\nelliptic-key Diffie\u2013Hellman key agreement schemes) and fast digital signature\nscheme is derived, called Ed25519, based on the the EdDSA algorithm. These\nschemes are very fast, because they involve multiplications and other simple\noperations with small integers (mostly 32-bit arithmetic), which can be\nefficiently implemented in the modern microprocessors (CPUs). Note that X25519\nand Ed25519 use different encodings for the EC points, so they are not\ndirectly compatible and require conversion if you want to use the same public-\nprivate key pairs.\n\n###\n\nCurve448, X448 and Ed448\n\nThe Curve448 (Curve448-Goldilocks) is an untwisted Edwards curve, defined by\nthe equation:\n\n  * x2 + y2 = 1 - _39081_x2y2\n\nover the finite prime field Fp, where p = 2448 - 2224 - 1. It has order of n =\n2446 - 0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d and cofactor\nh = 4. Like any other Edwards curve, the Curve448 has equivalent in the\nWeierstrass form (y2 = x3 + _a_x + b), but the above Edwards form provides\nsignificant optimizations in the EC point calculations and improved\nperformance.\n\nThe Curve448 provides ~ 224-bit security level (more precisely 222.8-bits).\nThe private keys for the Curve448 are 446 bits and are typically encoded as\n448-bit integers (56 bytes, 112 hex digits). The public keys are also encoded\nas 448-bit integers.\n\nThe Curve448 is suitable for ECDH key agreement (ECDH function, known as X448)\nand for fast digital signatures (EdDSA algorithm, known as Ed448 or\nedwards448). Note that X448 and Ed448 use different encodings for the EC\npoints, so they are not directly compatible and require conversion if you want\nto use the same public-private key pairs.\n\n###\n\nCurve25519 or Curve448?\n\nPrefer Curve448 to Curve25519 when your application needs a higher level of\nsecurity, but have in mind that Curve448 is about 3 times slower than\nCurve25519 and uses longer key length and signature length.\n\nPrefer Curve25519 to Curve448 when you need better performance and smaller\nkeys and signatures.\n\nLearn more about the Curve25519 and Curve448 from the technical perspective\nfrom:\n\n  * RFC 7748 - Elliptic Curves for Security - the Internet technical standard for implementing the X25519 and X448 key exchange protocols.\n\n  * RFC 8032 - Edwards-Curve Digital Signature Algorithm (EdDSA) - the Internet technical standard for implementing the the Ed25519 and EdDSA-Ed448 signature schemes.\n\nIn the general case, have in mind that Curve25519 is faster than secp256k1 and\nthe other 256-bit standard NIST curves and is considered more secure, so it is\nthe recommended choice for ~ 128-bit security. Similarly, the Curve448 has\nbetter performance than the classical curves with similar key length, so it is\nthe recommended curve for ~ 224-bit security.\n\n###\n\nCurve25519 - Example in Python\n\nTo demonstrate the elliptic curve Curve25519 in practice, we shall first\ninstall the pynacl crypto library for Python:\n\n    \n    \n    pip install pynacl\n\nThe Python binding to the Networking and Cryptography (NaCl) library (PyNaCl)\nimplements many modern cryptographic algorithms, including the EC point\narithmetic over the Curve25519 and Ed25519 signatures.\n\nNext, generate a random 252-bit private key and its corresponding public key\n(EC point) on the Curve25519 (both keys will be encoded internally as 256-bit\nintegers):\n\n    \n    \n    from nacl.public import PrivateKey import binascii privKey = PrivateKey.generate() pubKey = privKey.public_key print(\"privKey:\", binascii.hexlify(bytes(privKey))) print(\"pubKey: \", binascii.hexlify(bytes(pubKey)))\n\nRun the above code example: https://repl.it/@nakov/Curve25519-in-Python. The\nsample output from the above code shows that both the public and the private\n(secret) keys on the Curve25519 are encoded as 256-bit integers (64 hex\ndigits, 32 bytes) and this simplifies the developers:\n\n    \n    \n    privKey: b'8175f7cd524a59b6efbd447985ce5d97c546b319521ff236203970e50052c641' pubKey: b'cf97a96568fee4ddb232f617fd5b9df2d2e5b90e68ba7f6d5129ea92d7d8f95e'\n\nIn fact, different crypto libraries may use different key encodings and\ntypically X25519 ECDH keys are encoded differently than Ed25519 keys\n(Montgomery curve coordinates vs. twisted Edwards curve coordinates).\n\nPreviousExercises: RSA Encrypt / DecryptNextECDH Key Exchange\n\nLast updated 4 years ago\n\nOn this page\n\n  * ECC Keys\n  * Curves and Key Length\n  * ECC Algorithms\n  * Elliptic Curves\n  * Elliptic Curves over Finite Fields\n  * Elliptic Curves over Finite Fields: Calculations\n  * Multiplying ECC Point by Integer\n  * Example: Multiply EC Point by Integer\n  * Order and Cofactor of Elliptic Curve\n  * The \"Generator\" Point in ECC\n  * Generator Point - Example\n  * Private Key, Public Key and the Generator Point in ECC\n  * Elliptic-Curve Discrete Logarithm Problem (ECDLP)\n  * ECC and Curve Security Strength\n  * Multiplication of EC Points - Example in Python\n  * Multiplication of EC Points - Real-World Example in Python\n  * Public Key Compression in the Elliptic Key Cryptosystems\n  * Compressing a EC Point / Public Key - Example in Python\n  * Elliptic Curve Domain Parameters for ECC\n  * Choosing an Elliptic Curve for ECC\n  * Named Curves - Example\n  * Python Examples with the \"secp256k1\" Curve\n  * Edwards Curves\n  * Curve25519, X25519 and Ed25519\n  * Curve448, X448 and Ed448\n  * Curve25519 or Curve448?\n  * Curve25519 - Example in Python\n\nWas this helpful?\n\n", "frontpage": false}
