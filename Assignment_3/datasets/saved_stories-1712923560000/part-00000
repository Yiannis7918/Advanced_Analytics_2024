{"aid": "40009790", "title": "Building an Interactive Shell in Golang", "url": "https://www.dolthub.com/blog/2023-03-29-interactive-shell-golang/", "domain": "dolthub.com", "votes": 1, "user": "ingve", "posted_at": "2024-04-12 06:03:13", "comments": 0, "source_title": "Building an interactive shell in Golang", "source_text": "Building an interactive shell in Golang | DoltHub Blog\n\nBlog\n\n# Building an interactive shell in Golang\n\nZach Musgrave\n\nMarch 29, 2024\n\nGOLANG\n\n8 min read\n\nGo is great for building command-line applications. We built one: Dolt, the\nworld's first version-controlled SQL database. We wrote our own command line\nparser for handling all of Dolt's subcommands and arguments, but maybe we\nshouldn't have. There are lots of great ones out there that if we might have\nused instead if we were starting the project today:\n\n  * spf13/cobra has great support for code generation from a simple text command format, and will generate you zsh and other shell completions for free.\n  * charmbracelet/gum is a golang tool for generating very stylish command line prompts you can compose into shell scripts.\n  * alecthomas/kingpin is a great all-around library for building command-line apps, and is probably the closest to what we built ourselves.\n\nSo there's lots of great tooling for addressing this common use case which Go\nis great at.\n\nBut what if you want to build an interactive shell in Go? What do you use?\nThere aren't nearly as many options out there.\n\nThis blog will teach you how to use the best option we know of,\nabiosoft/ishell, and discuss how to get the most out of it. You'll learn how\nto configure the interactive shell with the commands you want to handle, how\nto quit the shell, and how to use the built-in quality-of-life features of the\npackage. We'll also show how we used it to build Dolt's built-in SQL shell\ncapabilities.\n\n# Demo\n\nWhen you fire up Dolt's SQL shell, this is what you see:\n\n    \n    \n    % dolt sql # Welcome to the DoltSQL shell. # Statements must be terminated with ';'. # \"exit\" or \"quit\" (or Ctrl-D) to exit. last_insert/main*> show tables; +-----------------------+ | Tables_in_last_insert | +-----------------------+ | test | +-----------------------+ 1 row in set (0.00 sec) last_insert/main*> select * from test; +------+----+ | name | id | +------+----+ | one | 1 | +------+----+ 1 row in set (0.00 sec) last_insert/main*> call dolt_checkout('-b', 'newBranch'); +--------+--------------------------------+ | status | message | +--------+--------------------------------+ | 0 | Switched to branch 'newBranch' | +--------+--------------------------------+ 1 row in set (0.01 sec) last_insert/newBranch> call dolt_checkout('main'); +--------+---------------------------+ | status | message | +--------+---------------------------+ | 0 | Switched to branch 'main' | +--------+---------------------------+ 1 row in set (0.00 sec) last_insert/main*> exit Bye\n\nThere's a couple things to pay attention to here:\n\n  * The shell begins with a greeting message that tells users how to use it.\n  * Each line where the user can enter input has a prompt, which can be altered depending on the state of the shell. In our SQL shell, it shows you which database and branch you're connected to.\n  * You exit the shell with a particular input, either quit or exit in our case.\n\nWe also use color in the shell, both for the prompts and the output. Here's\nhow it appears in my terminal:\n\nSo that's what a shell does, and how it differs from normal command-line\napplications: you have a loop where you accept user input over and over,\ngiving answers or doing other work, until the user decides to exit with a\npredefined command.\n\n# Pre-defined commands or free-form?\n\nThe original abiosoft/ishell package is built to process predefined commands,\nwhere each command dispatches to a different handler. In action, this looks\nlike:\n\n    \n    \n    shell.AddCmd(&ishell.Cmd{ Name: \"login\", Help: \"simulate a login\", Func: func(c *ishell.Context) { // disable the '>>>' for cleaner same line input. c.ShowPrompt(false) defer c.ShowPrompt(true) // yes, revert after login. // get username c.Print(\"Username: \") username := c.ReadLine() // get password. c.Print(\"Password: \") password := c.ReadPassword() ... // do something with username and password c.Println(\"Authentication Successful.\") }, })\n\nThen at runtime, you would see:\n\n    \n    \n    >>> login Username: someusername Password: Authentication Successful.\n\nThis is great and has a ton of uses, but we wanted something slightly\ndifferent. Rather than have pre-defined commands with their own handlers, we\nwanted something more like a REPL, where we just read input until we find a\ndelimiter, then process it the same way every time. For Dolt's SQL shell, this\nmeans reading a query until we see a ; character, then sending that query to\nthe database and printing results, over and over. This wasn't easy to do with\nthe original package, so we forked our own copy to add this capability. That's\nhow we're handling the free-form SQL query capability above. If that's what\nyou're trying to do, feel free to use our fork instead of the original\npackage. We'll demonstrate how to configure the shell in free-form mode in the\nfollowing sections.\n\n# Launching the shell for pre-defined commands\n\nTo launch your shell, first choose some configuration options and create a new\nshell:\n\n    \n    \n    rlConf := readline.Config{ Prompt: initialPrompt, Stdout: cli.CliOut, Stderr: cli.CliOut, HistoryFile: historyFile, HistoryLimit: 500, HistorySearchFold: true, DisableAutoSaveHistory: true, } shell := ishell.NewWithConfig(&rlConf)\n\nThen add your commands. Each command is a *ishell.Cmd.\n\n    \n    \n    shell.AddCmd(&ishell.Cmd{ Name: \"login\", Help: \"simulate a login\", Func: func(c *ishell.Context) { ... }, }) shell.AddCmd(...) shell.AddCmd(...)\n\nFinally, run it:\n\n    \n    \n    // blocks until shell.Stop() is called by some command shell.Run()\n\n# Launching an uninterpreted (free-form) shell\n\nIf you want your shell to be free-form, your setup is different. What you do\ndepends on your configuration, but you'll need to create your shell with\nadditional configuration to control line terminators and how to quit the\nshell:\n\n    \n    \n    shellConf := ishell.UninterpretedConfig{ ReadlineConfig: &rlConf, QuitKeywords: []string{ \"quit\", \"exit\", \"quit()\", \"exit()\", }, LineTerminator: \";\", } shell := ishell.NewUninterpreted(&shellConf)\n\nThen start the shell in uninterpreted (free-form) mode, with a single function\nto handle parsing all input. Here's what ours does:\n\n    \n    \n    shell.Uninterpreted(func(c *ishell.Context) { // The entire input line is provided as the single element in c.Args query := c.Args[0] if len(strings.TrimSpace(query)) == 0 { return } singleLine := strings.ReplaceAll(query, \"\\n\", \" \") // Add this query to our command history if err := shell.AddHistory(singleLine); err != nil { shell.Println(color.RedString(err.Error())) } query = strings.TrimSuffix(query, shell.LineTerminator()) var nextPrompt string var multiPrompt string var sqlSch sql.Schema var rowIter sql.RowIter // Execute the query on the database, then either print the query results or an error if there was one func() { // We start a new context here so the user can interrupt a long-running query subCtx, stop := signal.NotifyContext(initialCtx, os.Interrupt, syscall.SIGTERM) defer stop() sqlCtx := sql.NewContext(subCtx, sql.WithSession(sqlCtx.Session)) // Execute the query and print the results or the error if sqlSch, rowIter, err = processQuery(sqlCtx, query, qryist); err != nil { verr := formatQueryError(\"\", err) shell.Println(verr.Verbose()) } else if rowIter != nil { switch closureFormat { case engine.FormatTabular, engine.FormatVertical: err = engine.PrettyPrintResultsExtended(sqlCtx, closureFormat, sqlSch, rowIter) default: err = engine.PrettyPrintResults(sqlCtx, closureFormat, sqlSch, rowIter) } if err != nil { shell.Println(color.RedString(err.Error())) } } nextPrompt, multiPrompt = formattedPrompts(db, branch, dirty) }() // Update the prompts with the current database and branch name shell.SetPrompt(nextPrompt) shell.SetMultiPrompt(multiPrompt) }) // Run the shell. This blocks until the user exits. shell.Run()\n\nThis is long but what it's doing is actually pretty simple: get a query,\nprocess it, and either print the results or an error message. Then change the\nprompts to the shell as necessary. We add color where necessary with the\nfatih/color package.\n\n# Interrupting execution\n\nTo stop execution of the shell, there are a few different options.\n\n## EOF handler\n\nFirst, you can install an end-of-file handler to decide what to do if input\nruns out:\n\n    \n    \n    shell.EOF(func(c *ishell.Context) { c.Stop() })\n\nThis handler gets called if the user pipes a file into the program and it\nends, or when the user sends the special EOF character (Ctrl-D on Unix\nsystems) from their keyboard. You can do whatever you want here, but the\nsimplest option is to stop the shell like we do above.\n\n## Interrupt handler\n\nNext, you can install an interrupt handler. This controls what happens when\nthe process gets a SIGINT signal, like when the user presses Ctrl-C.\n\n    \n    \n    shell.Interrupt(func(c *ishell.Context, count int, input string) { if count > 1 { c.Stop() } else { c.Println(\"Received SIGINT. Interrupt again to exit, or use ^D, quit, or exit\") } })\n\nAgain, you can do anything you want here. The shell keeps track of how many\ntimes in a row the handler was invoked. We chose to only quit on the second\ninterrupt signal.\n\n## Quit keywords\n\nFinally, for free-form shells, the QuitKeywords field of the shell\nconfiguration will automatically cause the shell to exit if a quit keyword is\nencountered verbatim.\n\n    \n    \n    shellConf := ishell.UninterpretedConfig{ ReadlineConfig: &rlConf, QuitKeywords: []string{ \"quit\", \"exit\", \"quit()\", \"exit()\", }, LineTerminator: \";\", }\n\n# Getting fancy: adding shell history and tab completion\n\nOne of the reasons we were initially so impressed with the ishell package is\nits support of two great quality-of-life features: shell history and auto-\ncomplete.\n\nHistory is built into pretty much every shell you use for Unix or Mac systems.\nIt's what causes your previous commands to cycle through when you press the up\narrow. Some shells also allow you to search through your history with a\nhotkey, usually Ctrl-R. This is a must-have feature for a SQL shell, where you\noften want to run the same query over and over with slight variations. ishell\nhas great history support, including search.\n\nTo enable history, just provide a filepath to the history file at config time,\nthen make sure to update the history on every command:\n\n    \n    \n    shell.AddHistory(inputLine)\n\nTo enable auto-complete is a bit more work. In standard mode (pre-defined\ncommands), names of commands will auto-complete. But if you want to do\nsomething fancier, you'll need to implement a custom completer. Ours is\ncomplicated by the fact that we want to offer different completions if we\nthink the thing being completed is a column name in a SQL query. Here it is\nfor reference:\n\n    \n    \n    func (c *sqlCompleter) Do(line []rune, pos int) (newLine [][]rune, length int) { var words []string if w, err := shlex.Split(string(line)); err == nil { words = w } else { // fall back words = strings.Fields(string(line)) } var cWords []string prefix := \"\" lastWord := \"\" if len(words) > 0 && pos > 0 && line[pos-1] != ' ' { lastWord = words[len(words)-1] prefix = strings.ToLower(lastWord) } else if len(words) > 0 { lastWord = words[len(words)-1] } cWords = c.getWords(lastWord) var suggestions [][]rune for _, w := range cWords { lowered := strings.ToLower(w) if strings.HasPrefix(lowered, prefix) { suggestions = append(suggestions, []rune(strings.TrimPrefix(lowered, prefix))) } } if len(suggestions) == 1 && prefix != \"\" && string(suggestions[0]) == \"\" { suggestions = [][]rune{[]rune(\" \")} } return suggestions, len(prefix) } // Simple suggestion function. Returns column name suggestions if the last word in the input has exactly one '.' in it, // otherwise returns all tables, columns, and reserved words. func (c *sqlCompleter) getWords(lastWord string) (s []string) { lastDot := strings.LastIndex(lastWord, \".\") if lastDot > 0 && strings.Count(lastWord, \".\") == 1 { alias := lastWord[:lastDot] return prepend(alias+\".\", c.columnNames) } return c.allWords }\n\nYou install a custom completer with the CustomCompleter() method:\n\n    \n    \n    shell.CustomCompleter(completer)\n\nWe're doing this to to auto-complete SQL keywords and schema elements. Another\ncommon use case would be to complete the names of files in arguments.\n\n# Conclusion\n\nhttps://github.com/abiosoft/ishell is a great package for building interactive\nshells in Go, and we hope it gets more love. It's not in very active\ndevelopment anymore, but it works, is stable, and is the best option for\nbuilding interactive shells that we know of.\n\nHave questions about Dolt, or building interactive shells in Go? Have a\nsuggestion on how to improve this tutorial? Join us on Discord to talk to our\nengineering team and meet other Dolt users.\n\nSHARE\n\nBlog\n\nDolt is open source\n\nJOIN THE DATA EVOLUTION\n\n# Get started with Dolt\n\nOr join our mailing list to get product updates.\n\n", "frontpage": false}
