{"aid": "40020984", "title": "Swift for C++ Practitioners, Part 1: Intro and Value Types", "url": "https://www.douggregor.net/posts/swift-for-cxx-practitioners-value-types/", "domain": "douggregor.net", "votes": 1, "user": "ksec", "posted_at": "2024-04-13 06:27:52", "comments": 0, "source_title": "Swift for C++ Practitioners, Part 1: Intro & Value Types | Doug's Compiler Corner", "source_text": "Swift for C++ Practitioners, Part 1: Intro & Value Types | Doug's Compiler Corner\n\nDoug's Compiler Corner\n\nOriginally posted on 2024-02-01 19:09:00 +0000\n\nLast updated on 2024-04-11 22:26:18 +0000\n\n# Swift for C++ Practitioners, Part 1: Intro & Value Types\n\nThere is a Getting Started guide for Swift that's good for a general audience.\nHowever, I've noticed that folks coming from C++ tend to struggle with certain\naspects of Swift's design, and can get themselves stuck. I think I understand\nwhy: the two languages feel similar enough that someone familiar with C++ will\ntake the idioms and patterns from C++ and project them on to Swift, which\ndoesn't always end up well. So, I want to take a different approach to\nteaching Swift that is specifically geared toward C++ \"practitioners\": folks\nwho write C++ day-to-day and understand not only the C++ language, but its\nstandard library and best practices. For you, dear C++ practitioner, I want to\nteach Swift by mapping from the idioms, patterns, and mental model of C++ into\nSwift. My hope is that you'll come through this series of posts not just\nlearning Swift, but learning how to use Swift well.\n\nAs a C++ programmer, some parts of Swift will feel like magic, such as\nseparately type-checked generics and value types that compose beautifully, and\nwe'll revel in those. I'll show how some of the aspects of C++ that we've\ncollectively come to view as problematic, such as wrong defaults or avoidable\nfoot guns, are addressed by Swift's design. Other parts of Swift will grate\nagainst the sensibilities of a C++ practitioner, and we won't shy away from\nthose, either. Instead, we'll explain what is different, why Swift is designed\nthat way, and how to cope. I live in both worlds: I'm a Swift designer,\nimplementer, and advocate, and yet I've a long history with C++ that includes\nbeing a code owner of Clang and spending a decade on the ISO C++ committee.\nMost of the code I write day-to-day is in the Swift compiler, which is mostly\nC++ but is migrating toward Swift.\n\n> Note: You may have heard about Swift's interoperability with C++. It's a\n> fantastic tool for incrementally moving a C++ code base toward Swift or\n> wrapping up a C++ library in a nicer Swift interface. However, it's the\n> wrong place to start if you know C++ already and want to learn Swift.\n> Instead, I recommend building something purely in Swift first, to get the\n> feel for Swift without the \"pull\" of existing C++ code toward more\n> C++-centric patterns. You'll be able to integrate Swift better into your\n> existing code bases once you have a solid understanding of both languages.\n\nThis is a multi-part series that will walk through the various features of\nSwift. We'll start with the obligatory \"Hello, world\" and then dive straight\ninto value types.\n\n## Hello, World!\n\nOkay, let's get this over with: this is \"Hello, World\" in Swift:\n\n    \n    \n    print(\"Hello, world!\")\n\nBut it's more important to greet you, dear C++ practictioner, so let's\ncustomize it a little bit:\n\n    \n    \n    let reader = \"dear C++ practitioner\" print(\"\"\" Hello, \\(reader)! Today, we shall embark on learning a new programming language, Swift. \"\"\")\n\nThe let is how we declare an immutable variable, like const in C++, but with\nstronger guarantees: we'll get to that later. We've omitted the type because\nSwift does type inference in a manner that's similar to auto in C++, but we\ncould have written the type explicitly with let reader: String. The triple-\nquotes describe a multi-line string literal, and the \\\\(...) syntax within it\nis string interpolation, a feature common in scripting languages that makes it\neasy to plug values into the middle of a string.\n\n## Value types\n\nC++ provides rich support for value types, i.e., types for which each copy is\ncompletely independent of the original. Let's take a simple example with C++\nvectors:\n\n    \n    \n    std::vector<std::string> v1 = { \"Hello\", \"original\" }; std::vector<std::string> v2 = v1; v2[1] = \"copy\";\n\nHere, v1 is a vector containing \"Hello\" and \"original\". When we make a copy\nv2, that copy is completely independent of the original: the change to v2 on\nthe last line, so that it contains \"Hello\" and \"copy\" , doesn't modify the\noriginal v1.\n\nMany C++ types are value types, from builtin types like integers and floating-\npoint types to standard library containers like std::string, std::vector, and\nstd::map. C++ lets you build your own value types by letting you control how a\nclass type is created, copied, and destroyed, so long as you follow the Rule\nof Three/Five/Zero.\n\nSwift also emphasizes value types because they aid local reasoning, which is\nthe ability to look at code in isolation and reason about what it does, and\nwhether it does so correctly. When you copy an instance of a value type, you\ndon't need to worry that something you do will affect the original. As in C++,\nmany Swift types are value types, including String, Array, and Dictionary,\nwhich are analogous to std::string, std::vector, and std::map:\n\n    \n    \n    let v1: [String] = [\"Hello\", \"original\"] // [String] is an array type, can also be spelled Array<String> var v2 = v1 // inferred to also have type [String] v2[1] = \"copy\" print(v1) // prints [\"Hello\", \"original\"] print(v2) // prints [\"Hello\", \"copy\"]\n\nHere we've introduced the var keyword: var introduces variables that can be\nmodified (i.e., they are mutable), whereas let introduces variables that\ncannot be modified (they are immutable). In Swift, we prefer that you use let\nwherever you can, because immutability aids local reasoning: it's easier to\nreason about something if it isn't changing.\n\n### Aggregating values in structs\n\nAs in C++, Swift has structs to aggregate data together. While in C++ the\ndifference between struct and class is almost cosmetic (it only impacts\nwhether the defaults are public vs. private), in Swift they are completely\ndifferent animals. A Swift struct is generally a value type, whereas a Swift\nclass is a class in the Object-Oriented sense of the word, and has reference\nsemantics: copies still refer to the same underlying instance. We'll get back\nto classes in a later post, because structs are one way we build value types\nout of other value types:\n\n    \n    \n    struct LabeledPoint { var x: Double var y: Double var label: String }\n\nStructs containing other value types are themselves value types. For example,\nlet's use that labeled point:\n\n    \n    \n    let p1 = LabeledPoint(x: 0, y: 0, label: \"origin\") var p2 = p1 p2.label = \"center\" print(p1) // LabeledPoint(x: 0, y: 0, label: \"origin\") print(p2) // LabeledPoint(x: 0, y: 0, label: \"center\")\n\nThat first line is creating a new instance of a LabeledPoint, calling an\ninitializer (that's what Swift calls constructors) to produce the new value\nfrom the component parts. The result is on the stack, not the heap, just like\nyou'd expect in C++. Copying the p1 value into p2 produces a completely\nseparate value, just as you'd expect from the corresponding C++ code.\n\n> Labeled arguments: When creating the new LabeledPoint instance, notice that\n> each of the arguments requires a label, e.g., x:, y:, and label:. By\n> default, all function arguments must be labeled at the call site, which\n> communicates information about what the function will be doing with the\n> corresponding argument, aiding readability. This is particularly useful when\n> combined with default arguments. A function can opt out of having a\n> particular argument labeled, of course, and we'll get back to that later.\n\n### Initialization always goes through initializers\n\nC++ has a couple of different ways to initialize an instance of a struct,\nincluding constructor calls, initializer lists, default initialization, and\ncopy initialization. Swift settles on one: calling an initializer.\nInitializers are responsible for initializing all of the fields of the struct\nbefore they return (no excuses). The creation of the LabeledPoint in the\nprevious section is using the memberwise initializer that Swift provides\nautomatically for structs, which initializes the fields in order from the\ncorresponding parameters. We could go ahead and write out this initializer\ndirectly if we wanted to, like this:\n\n    \n    \n    struct LabeledPoint { var x: Double var y: Double var label: String init(x: Double, y: Double, label: String) { self.x = x self.y = y self.label = label } }\n\nThe init keyword is what defines an initializer, and is the equivalent of\nrepeating the class name in C++ to define a constructor, but usually less\nverbose. self is the Swift equivalent to this, but think of it as being a like\na C++ reference (ClassName&) rather than a pointer like it would be in C++\n(ClassName*).\n\nThere is no special syntax for initializing the fields in a struct, like there\nis in C++. Instead, it's just normal assignments to the fields, and the\ncompiler checks that (1) you don't read a field before it's been assigned, and\n(2) all fields have been assigned before self is referenced as a whole object,\nincluding the function return. So let's try out a semantic disaster of an\ninitializer that breaks both rules:\n\n    \n    \n    // in LabeledPoint ... init(x: Double, y: Double, label: String) { self.y = self.x // error: 'self' used before all stored properties are initialized self.x = x if Int.random(in: 0..<2) == 1 { print(self) // error: 'self' used before all stored properties are initialized } } // error: return from initializer without initializing all stored properties\n\nUses of uninitialized variables don't happen in Swift, because of a semantic\nguarantee called definite initialization: the compiler checks that every\nvariable is initialized before it is used, in all execution paths. This\napplies equally to all code, and it helps define away a class of bugs that\nbite us in C++:\n\n    \n    \n    let p: LabeledPoint if y > 0 { p = LabeledPoint(x: 0, y: 0, label: \"origin\") } print(p) // error: constant 'p' used before being initialized\n\nBecause of definite initialization, Swift has no notion of a default\nconstructor the way C++ does. The variable p is not initialized on the line\nwhere it is defined, the way a C++ class with a non-trivial default\nconstructor would be. Rather, you assign to it, and the first assignment is an\ninitialization. You can't read from it before initializing it, so there is no\nundefined behavior due to uninitialized values.\n\nYou could write an initializer that takes no arguments, and perhaps that makes\nsense for points to (say) create the origin point, but Swift will never\nautomatically call it: you'll always call it explicitly. Let's write that out\nso we can demonstrate the Swift equivalent to C++ delegating constructors:\n\n    \n    \n    // also in LabeledPoint init() { self.init(x: 0, y: 0, label: \"origin\") }\n\nThe call to self.init delegates the responsibility for initializing all of the\nfields of self to another initializer. The rules of definite initialization\nkick in here, too: you can't use (or initialize) any of the fields of self\nbefore the self.init call, and after that call self is fully initialized.\n\n### Where's my copy constructor?\n\nBy now, you've probably noted that we could write an initializer that looks\nvery much like a copy constructor:\n\n    \n    \n    // also in LabeledPoint init(_ other: LabeledPoint) { self.x = other.x self.y = other.y self.label = other.label }\n\nThe _ in the declaration of other is a placeholder for \"not named\", and here\nit means that the argument to this initializer is not named. Therefore, we can\ncall this initializer with the syntax LabeledPoint(other), just like one would\nin C++. However, Swift will never implicitly call an initializer like this,\nbecause it's not special in any way.\n\nSwift will copy, move, and destroy instances of structs by performing those\noperations directly on each instance property of the struct. In essence, a\nSwift struct always follows the C++ rule of zero, where one relies on the\ndefault implementations of all of the special constructors, assignment\noperators, and destructor. In practice, this means that it's not possible to\nobserve when Swift is making copies of value types, so the compiler is free to\nmake copies that are necessary for implementing the semantics of the program,\nand optimize away copies when they are no longer needed. The compiler can even\nimplicitly turn a \"copy\" into a move when it determines that the source of the\ncopy is going away.\n\nFor a type that needs hold on to resources, Swift has classes, which I've\nalready noted will be the subject of another post. Swift also has a notion of\n\"noncopyable\" types, but those will come much later. For now, we'll dive\ndeeper into value types.\n\n### Immutability runs deep with value types\n\nEarlier, we introduced let as a way to create immutable local variables. With\nvalue types, immutability is the default. Parameters are immutable unless\notherwise specified, which also includes self:\n\n    \n    \n    // in LabeledPoint func badSwapX(_ other: LabeledPoint) { let tmpX = other.x other.x = self.x // error: 'other' parameter is immutable self.x = tmpX // error: 'self' parameter is immutable }\n\nOne can create methods that mutate self by putting the mutating modifier\nbefore the func keyword. Let's start with a sensible example:\n\n    \n    \n    // in LabeledPoint mutating func reflectOverXAxis() { y = -y }\n\nFor other parameters, one can place inout on the parameter to indicate that it\nis meant to be modified by the function. Formally, mutating on the function is\nequivalant to inout on the self parameter, but Swift uses mutating because it\nreads better. With inout parameters and mutating methods, we can write a\nworking version of the badSwapX method:\n\n    \n    \n    // in LabeledPoint mutating func swapX(_ other: inout LabeledPoint) { let tmpX = other.x other.x = self.x self.x = tmpX }\n\nWhen calling a function with an inout argument, the argument must be prefixed\nwith & to indicate that we're passing it's (logical) address to the function.\nFor example, here's a call to swapX:\n\n    \n    \n    var p1 = LabeledPoint(x: 0, y: 0, label: \"Origin\") var p2 = LabeledPoint(x: 1, y: 1, label: \"Upper right unit\") p1.swapX(&p2)\n\nIf the value we are trying to apply & to is immutable, the Swift compiler\nwould produce an error. Note that there is no prefix & on p1, even though it's\ncalling a mutable method: it's not needed because the name of the method\nshould clearly imply the mutation. Of course, if p1 were immutable, it would\nstill be an error.\n\nThere are two more important things to say about immutability before we move\non to our next kind of value type, enum.\n\nFirst, you cannot cheat immutability any more than you can cheat Death. There\nis no equivalent to the C++ const_cast in Swift. There are no mutable data\nmembers in Swift; even a var member of a struct can only be modified on a var\ninstance of that struct. There are no const T& parameters whose values can\nchange out from underneath you: an immutable value is truly immutable, and the\ncompiler makes sure that no matter how an immutable parameter is actually\npassed (by-value or by-reference), the underlying value won't change. This can\nbe frustrating, because you've given up control about when to pass by-value,\npass by const reference, or pass by rvalue reference to do a move. On the\nother hand, it is liberating: there's no spooky-action-at-a-distance when that\nconst& actually does change underneath you, and you can lean on immutability\nto make it easier to reason about your code.\n\nThat brings us to the second point: there is no aliasing of inout parameters.\nAliasing, as I mean it here, is when two different pass-by-reference\nparameters actually refer to the same underlying instance. If you've ever had\nto go add an if (this == &other) { ... } check into your copy or move\nassignment operator in C++, you know just how vicious unexpected aliasing of\nparameters can be for program semantics. In Swift, we have the law of\nexclusivity, which prevents any such aliasing.\n\n### Memory safety and the law of exclusivity\n\nSwift's law of exclusivity states that two accesses to a given value in memory\ncan only occur simultaneously if both of them are reads, so it is an error to\n(for example) try to form a mutating access (such as passing something inout)\nwhile accessing that value. But this isn't some abstract rule that introduces\nundefined behavior when you mess up: Swift enforces the law of exclusivity\nthrough a combination of static checking (which can produce compiler errors if\nyou produce aliasing) and dynamic checking (when it's not possible for the\ncompiler to prove that there is no aliasing).\n\nStatic checking of the law of exclusivity applies when the value being\naccessed is sufficiently local that it's possible to reason about all possible\naccesses to that value. Value types are great for this, because two\nindependent var instances of value type are guaranteed not to alias. The\ncompiler can correctly determine that the two inout arguments in the call\np1.swapX(&p2) do not alias, because p1 and p2 are separate variables. If one\ninstead wrote p1.swapX(&p1), the compiler would produce an error describing\nthe problem:\n\n    \n    \n    === exclusivity.swift:28 === \u2506 26 \u2502 var p1 = LabeledPoint(x: 0, y: 0, label: \"Origin\") 27 \u2502 var p2 = LabeledPoint(x: 1, y: 1, label: \"Upper right unit\") 28 \u2502 p1.swapX(&p1) \u2502 \u2502 \u2570\u2500 note: conflicting access is here \u2502 \u2570\u2500 error: overlapping accesses to 'p1', but modification requires exclusive access; consider copying to a local variable 29 \u2502\n\nNow, if we're dealing with a variable that isn't local---say it's a global\nvariable (gasp!) or a member of a reference type like a class, then it's\nimpossible to reason about all of the accesses. Let's build a small contrived\nexample of this:\n\n    \n    \n    var globalOrigin = LabeledPoint(x: 0, y: 0, label: \"origin\") func swapXWithGlobalOrigin(_ other: inout LabeledPoint) { other.swapX(&globalOrigin) // is this safe? } func somewhereElse() { swapXWithGlobalOrigin(&globalOrigin) // uh oh }\n\nWithin swapXWithGlobalOrigin, there is no way to know whether some other part\nof the program might access globalOrigin while it runs. So, the Swift compiler\nwill insert a runtime check that tracks when globalOrigin is potentially being\nmodified, and will stop the program if a simultaneous access occurs:\n\n    \n    \n    Simultaneous accesses to 0x100e93008, but modification requires exclusive access. Previous access (a modification) started at t`somewhereElse() + 42 (0x100e8e95a). Current access (a modification) started at: 0 libswiftCore.dylib 0x00007ff82b380890 swift::runtime::AccessSet::insert(swift::runtime::Access*, void*, void*, swift::ExclusivityFlags) + 444 1 libswiftCore.dylib 0x00007ff82b380ae0 swift_beginAccess + 66 2 t 0x0000000100e8e8d0 swapXWithGlobalOrigin(_:) + 59 3 t 0x0000000100e8e930 somewhereElse() + 51 4 t 0x0000000100e8ea40 static Main.main() + 9 5 t 0x0000000100e8ea50 static Main.$main() + 9 6 t 0x0000000100e8ea70 main + 9 7 dyld 0x00007ff81aaa9c10 start + 1942 Fatal access conflict detected.\n\nMost Swift programmers never think about the Law of Exclusivity: it's\nenforcement is there to prevent mistakes that would cause undefined behavior\nmayhem in C++, so it's critical to Swift's memory-safety story. But a lot of\nmutation in Swift works on local values, and the language helps you avoid most\nof these situations, so the runtime checking is rarely encountered in\npractice.\n\n### Enums are the union of enums and unions\n\nEnums are one of Swift's loveliest little features. We borrowed them from CLU,\nand for a time before Swift 1.0 they even used the keyword oneof . A Swift\nenum is a type-safe variant, which subsumes C++'s enum, union, and\nstd::variant in one nice little package. An enum can express one of a set of\nnamed cases, such as a font size expressed via semantic names:\n\n    \n    \n    enum FontSize { case title case paragraph case footnote }\n\nThis enum works just like you'd expect the equivalent C++ enum class. For\nexample:\n\n    \n    \n    let fontSize: FontSize = .paragraph switch fontSize { case .title: print(\"Title\") case .paragraph: print(\"Paragraph\") case .footnote: print(\"Footnote\") }\n\nI snuck a switch statement in there because one often uses switch statements\nto deal with each of the cases in an enum. Switch statements in Swift must\nalways be exhaustive: if you don't handle all possible cases, you need to add\na default clause. This eliminates accidents of omission when (for example)\nsomeone adds a new case, and is commonly a warning in C++ compilers. If you've\nbeen cringing about the missing break statements above, don't: Swift puts a\nbreak before the next case, and if you really want to fall through to the next\ncase, you have to explicitly write fallthrough to do so.\n\nBack to FontSize: the cases of FontSize are inside the type. If you want to\nrefer to the paragraph case, you can do so with FontSize.paragraph. However,\nwhenever there is type information, such as when you're initializing a\nvariable of type FontSize or switching on a value of type FontSize, you can\nuse the leading dot syntax like .paragraph and let Swift's type inference\nfigure out the type. Compare the above to the corresponding C++ enum class:\n\n    \n    \n    enum class FontSize { title, paragraph, footnote }; auto fontSize = FontSize::paragraph; switch (fontSize) { case FontSize::title: print(\"Title\"); break; case FontSize::paragraph: print(\"Paragraph\"); break; case FontSize::footnote: print(\"Footnote\"); break; }\n\nIt's the little things, but they really do add up to cleaner code. Swift's\nleading dot syntax works really nicely with labeled arguments, because the\nargument label implies the type of the argument, leading to very readable\ncode. For example, let's imagine a Font struct that uses FontSize along with\nFontStyle and FontWeight enums, including some default values:\n\n    \n    \n    struct Font { var style: FontStyle = .sanSerif var size: FontSize = .paragraph var weight: FontWeight = .regular }\n\nNow, we can create a new Font like this:\n\n    \n    \n    let font = Font(size: .title, weight: .bold)\n\nNote how the argument labels size and weight naturally describe the arguments\nthat follow them, and the types provide enough information so we don't need to\nwrite out the redundant FontSize and FontWeight types on those arguments.\nMoreover, we are able to use the default argument for style even though it's\nthe first parameter: labeled arguments make default arguments work really\nwell. These are simple design decisions for a language to make, but they\nreinforce readable code.\n\nAlright, back to enums! Imagine that you wrote that FontSize as an enum class\nin C++. Hold it in your mind. It's simple, it works. Now, someone comes along\nand tells you that you need to support custom font sizes, which can be\nexpressed in terms of points. Your nice enum class is out the window, because\nyou can't enumerate all of the custom point sizes. Here's the pattern I would\nuse in C++:\n\n    \n    \n    class FontSize { public: enum Kind { title, paragraph, footnote, custom }; private: Kind kind; int points; // only valid when kind == custom public: FontSize() : kind(paragraph) { } FontSize(Kind kind) : kind(kind) { assert(kind != custom); } static FontSize forCustom() { FontSize size; size.kind = custom; size.points = points; return size; } explicit operator Kind() const { return kind; } // so we can switch int getPoints() const { assert(kind == custom); return points; } };\n\nThat is a lot of code. It is implementing a type-safe union that consists of\nthe three simple cases, plus the one custom case. I cringe ever time I have to\nwrite one of these in C++ (which happens a lot), because it is so much\nboilerplate and it's so easy to make a silly mistake. I've yet to come across\na C++ technique or library that makes this cleaner. Feel free to let me know\nif you have a significantly more elegant solution in C++.\n\nIn Swift, you add one case to FontSize:\n\n    \n    \n    case custom(points: Int)\n\nSwift cases can carry values in them, which is why I said earlier that they\nalso are like C++ unions---without all of the undefined behavior. Given this\ncase, I can create a custom font size:\n\n    \n    \n    let customFont: FontSize = .custom(points: 32)\n\nAnd extend my switch statement accordingly:\n\n    \n    \n    switch fontSize { case .title: print(\"Title\") case .paragraph: print(\"Paragraph\") case .footnote: print(\"Footnote\") case .custom(let pt): print(\"\\(pt) points\") }\n\nSwift provides pattern matching. When we match the custom case, we also\ndeclare a new variable pt to capture the points value. The value pt is only\navailable when one is using a custom font size, so there's no need for runtime\nassertions like kind == custom like we had in C++.\n\nLet's add one more case to our font size, which lets us take an existing font\nsize and scale it by a given factor. It can be expressed like this:\n\n    \n    \n    indirect case scaled(size: FontSize, factor: Double)\n\nThis way, one can construct a font that is 20% larger than the paragraph font\nusing, e.g.,\n\n    \n    \n    FontSize.scaled(size: .paragraph, factor: 1.2)\n\nThe indirect is needed to indicate that the value associated with the case\n(called the associated value in Swift) needs to be stored indirectly, because\nthe associated value contains an instance of FontSize itself. Enums are value\ntypes and generally use stack storage, so the indirect indicates when the\nvalue for the case needs to be moved off to the heap. If the indirect were\nmissing, the compiler would complain because the FontSize type doesn't have a\nfixed size in memory:\n\n    \n    \n    === FontSize.swift:1 === 1 \u2502 enum FontSize { \u2502 \u2570\u2500 error: recursive enum 'FontSize' is not marked 'indirect' 2 \u2502 case title 3 \u2502 case paragraph 4 \u2502 case footnote 5 \u2502 case custom(points: Int) 6 \u2502 case scaled(size: FontSize, factor: Double) \u2502 \u2570\u2500 note: cycle beginning here: (size: FontSize, factor: Double) -> (.0: FontSize) 7 \u2502 } 8 \u2502\n\nIndirect enum cases are useful for building recursive data structures, like a\nbinary tree. We'll come back to those when we can do it properly, with\ngenerics.\n\nNow we can create a nice member function that scales the font instance we have\nby a specific factor:\n\n    \n    \n    // in FontSize func scaled(by factor: Double) -> Self { .scaled(size: self, factor: factor) }\n\nThis can be called as, e.g., myFontSize.scaled(by: 1.2). There are a few\nlittle things to notice here. The first is that enums can have methods just\nlike structs can. They can also have initializers, which must eventually\nassign one of the cases to self. Next, our function is returning Self, which\nis shorthand for \"the type of self\". Finally, look at how the parameter is\nnamed, \"by factor\": here, the argument label is by (it's used at the call\nsite) and the parameter name is factor (it's used inside the body). This is\nbecause the argument label is there to describe the argument at the call site,\ni.e., we're scaling \"by 1.2\", whereas the parameter name is the noun of what\nthe parameter actually is---the factor used in the computation. Before now,\nwe've seen that the two names are generally the same, or the argument label is\nomitted, but separating the two can lead to elegant, readable code\nparticularly when the argument label is a preposition.\n\n## Collections\n\nThe standard Swift collections types Array, Dictionary, and Set are value\ntypes when they are storing value types. For example, we could have an array\nof Font instances, which will behave as a value type:\n\n    \n    \n    var fonts = [Font(size: .title, weight: .bold), Font(size: .paragraph)] // infers type Array<Font>, also written [Font] var oldFonts = fonts // copies the contents of fonts fonts.append(Font(size: .footnote)) print(fonts.count) // 3 print(oldFonts.count) // 2 fonts[1].weight = .bold // doesn't affect oldFonts\n\nDictionaries and sets work similarly. For example, let's build a dictionary\nthat names all of our fonts:\n\n    \n    \n    var fontsDict = [ // infers type Dictionary<String, Font>, also written [String: Font] \"Title\" : Font(size: .title, weight: .bold), \"Paragraph\" : Font(size: .paragraph) ] var oldFontsDict = fontsDict // make a copy fontsDict[\"Footnote\"] = Font(size: .footnote) // add an element print(fontDict.count) // 3 print(oldFontsDict.count) // 2\n\nThe bracket syntax is used for both dictionary literals (when the elements are\nkey: value pairs) and array literals (when the elements are just... elements).\nThe literals are actually extensible: you can use an array literal to\ninitialize a Set, or even your own type, by defining an appropriate\ninitializer and opting in to be \"expressible by\" that literal type using the\ngenerics system. (More on that in a later post, I promise.)\n\n## Regular types\n\nIn C++ we sometimes talk about regular types, defined by Alexander Stepanov,\nwhich are types that behave predictably with respect to value semantics: you\ncan copy them, and the copy is equal to the original. They can be moved,\ndestroyed, and swapped. C++20 has a std::regular concept to capture these\nrequirements.\n\nSwift value types fulfill most of the requirements of a regular type by\ndefault, and are based on the same semantic contract. Swift value types are\nalways copyable, destructible, assignable, and movable. Indeed, you can't\nreally even express these ideas in Swift, it's just the way types behave.\n\nHowever, there are some notable differences from the Stepanov or C++ standard\ndefinitions of a regular type. The first was noted earlier: Swift doesn't have\na notion of \"default construction\" at all, so Swift value types are not\n\"default constructible\". You tend not to need this notion in Swift, though,\nbecause of definite initialization. There is a benefit here for the authors of\ntypes: you don't have to worry about inventing a \"default\" state if one\ndoesn't make sense. For example, imagine an collection that is always non-\nempty: how would you give it a default constructor? You can't without doing\nsomething weird, like adding a single default-constructed element, so such a\ntype can't be regular.\n\nRegular types also have (in)equality operators (== and !=). Swift doesn't\nprovide those for free, but you can either write them yourself with, e.g.,\n\n    \n    \n    // in Font static func ==(lhs: Font, rhs: Font) -> Bool { return lhs.style == rhs.style && lhs.size == rhs.size && lhs.weight == rhs.weight }\n\nor let the compiler do it for you, by putting : Equatable in the type\ndefinition:\n\n    \n    \n    struct Font: Equatable { var style: FontStyle = .sanSerif var size: FontSize = .paragraph var weight: FontWeight = .regular }\n\nThis says that the Font type is Equatable, and the compiler will synthesize\nboth == and != for you based on the data members. You can also put Hashable\nhere to get a hash function that combines the data members, which then allows\nyour type to be used as a key in a Dictionary or a value in a Set. Again, this\nis dipping our toes into Swift's generics system, but for now you can think of\nEquatable as being a little bit like a C++ concept (we call it a protocol in\nSwift), but... better.\n\n## What's next?\n\nWe've talked about value types---a lot. If you're writing Swift, you should\nuse them often, because they provide excellent local reasoning and the ability\nto model most data in a straightforward manner: structs and collections to\naggregate data and enums to capture different choices.\n\nIn the next part of this series, we'll talk about reference types.\nSpecifically, classes, and how Swift supports Object-Oriented Programming.\n\nTagged with:\n\n  * Swift\n  * C++\n  * Value types\n\nGenerated using Publish\n\nRSS feed\n\n", "frontpage": false}
