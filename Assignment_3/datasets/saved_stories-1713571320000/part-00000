{"aid": "40090043", "title": "Choosing Technology to Build On", "url": "https://www.eno-writer.com/012-choosing-technology/", "domain": "eno-writer.com", "votes": 1, "user": "nbrempel", "posted_at": "2024-04-19 18:00:56", "comments": 0, "source_title": "012 - choosing technology to build on", "source_text": "012 - choosing technology to build on | eno writer\n\n# eno writer\n\n# 012 - choosing technology to build on\n\n19 Apr, 2024\n\nWhen I was in grade 6, I really wanted to learn how to program computers so I\ncould make video games. I didn't know anyone who knew much about computers so\nI would go to Chapters and look at the \"Programming\" shelf where there were\nlots of big books on the popular programming languages in the year 2000. I\nsaved up some money and bought a book called \"Teach yourself C++ in 21 Days\".\nI picked this book because it was very thick. I read the book pretty much\ncover to cover. Unfortunately, I didn't know how to actually reproduce the\nexamples in it on the computer I had at home. The pictures in the book looked\ndifferent than what was on my screen. So I gave up and just went back to\nmerely playing video games.\n\nWhen I was in undergrad, a friend and I decided to start a business where\nstudents could sell their notes online. We called it Studybunny. I was doing\nan English degree but thought it might be cool to figure out how to make an\necommerce website. I went online and found a YouTube video where someone wrote\na blog from scratch using a language called PhP with a framework called\nCodeIgniter. It was a really good video and I was confident I could copy\nexactly what he was doing. I carefully followed this video, second by second,\nand was able to get my computer to do the exact same thing.\n\nNow that I had written this code, I could see how to tinker with it to make it\na bit less like a blog and a bit more like an ecommerce site. By making small\nadjustments one at a time, I was able to ever so slowly transform the blog\ninto a website where students could sell notes online.\n\nStudybunny's growth wasn't exactly parabolic, but we kept it running on the\nside as we continued with university. At some point, I learned about this web\nframework called Django which was written in Python. I thought the word\n\"Python\" sounded very cool and was pretty sure I'd read hackers use Python. I\nhad also read that Instagram was built in Django. So I decided to rewrite\nStudybunny in Django as a side project during my first summer of law school.\n\nDjango had good documentation with a nice tutorial that I was able to stumble\nthrough. There were some similarities to the things I learned with PhP and\nCodeIgniter. All I had to do was take something I had already written in\nPhP/CodeIgniter and figure out how to write the same thing in Python/Django. I\ndid this one small piece at a time and by the end of the summer I had a\nworking ecommerce site built in Django.\n\nAfter I completed articling (a 10-month training contract all Canadian lawyers\nhave to complete), I was given about half a year off work before my full time\njob started. A friend of mine was interested in starting a software company\nand we began talking about collaborating. We decided I would write a prototype\nof the software and then we would raise some money to hire real developers to\nbuild the real software. Since I knew Django I decided to write the prototype\nin that.\n\nAt some point around this time, I went to a networking event in Toronto and\nended up chatting to someone who told me all about this exciting new thing\ncalled a Javascript framework. On the internet in 2013, it was now possible to\nhave webpages do all kinds of crazy fantastical things. You could even have an\nentire application inside of a single web page!\n\nI spent the next few days learning all about these magical new javascript\nframeworks. At the time, there were three frameworks to choose from: Angular\n1, Backbone and Ember.js. I read that Trello used Backbone. My wife and I were\nusing Trello to plan our wedding and it was pretty cool. But Ember.js was more\ncutting edge and it had a cute hamster on the logo. I deliberated for a day or\nso and then picked Ember.js because it seemed the easiest to get started with.\nAs it turned out, this is largely because I had no idea how to write\njavascript code and Ember.js required the least amount of Javascript code to\nbe written.\n\nWell, it took us three years to hire our first full time developer and in the\nmeantime that prototype ended up becoming the actual product of our company,\nClosing Folders. As a result, I spent the next TEN YEARS writing Django and\nEmber.js code, every. single. day. These technologies I picked, pretty much on\na whim, turned out to have a massive sustaining impact on the future of my\nwork and business. Today, Closing Folders still runs on Ember.js and Django\nand, while I no longer have anything to do with it, I wouldn't be surprised if\nit still does another ten years from now.\n\nDjango ended up being a pretty good choice. It is still a widely used\ntechnology today. Ember.js was, unfortunately, the wrong choice. The right\nchoice would have been React.js. The only problem is React.js hadn't been\nreleased yet and wouldn't become popular for 1-2 years after. Some might argue\nAngular was the right choice but actually, at the time, it was Angular 1 which\nGoogle would later sunset in favour of Angular 2. All to say, I think Ember.js\nwas as good a choice as any of them at that time. The other great part about\nEmber.js was there was a local meetup in Toronto where I ended up meeting a\nlot of cool people.\n\nAll of this was running through this week when I found myself in a similar\nposition: kicking the tires of huge software libraries that I need to bet the\ncompany on. Except, now I am not naive enough to make these decisions so\nflippantly. Instead, I am paralyzed by their enormity.\n\nWhen I announced eno, I said I would write it \"from scratch\" - my hope was to\nnever have to make these hard decisions. If I just write everything myself,\nthen I can control my destiny for the next decade or more.\n\nUnfortunately there are some wrinkles with this. The first is that, in 2024,\nyou probably want to make an application that can run on Mac, Windows and in a\nweb browser. The most common way to do this is to write the application to run\nin a browser and then use something called Electron to package it as a desktop\napplication for Windows and Mac. Inside that package, is literally a copy of\nGoogle Chrome that runs behind the scenes when you launch the application. The\nperformance is terrible, the file sizes are giant and you are stuck building\nwith browser APIs which, for my purposes, are unsuitable. So, as you can see,\nI'm not a big fan of that.\n\nThere is a fairly recent technology called WASM that allows you to run\ncompiled code in the browser. This means it is now possible to take code you\nwrote for native applications on Windows and Mac and run them in a browser.\nUnfortunately, it's not quite that simple. You need to write Javascript code\nto bridge interactions between your WASM module and the browser's canvas\nenvironment (which you draw your graphics on). Additionally, many things you\ncan do in a native desktop are not possible in a web browser, like saving\nfiles to disk and opening certain types of network connections.\n\nEven if you can get your code to run on all three platforms, each of these\nplatforms has a completely different graphics API: Metal on Mac, Direct3D on\nWindows and WebGPU on Web. That's crazy, so Google has a project called Dawn,\nwhich aims to take WebGPU shaders and recompile them to work natively on the\nother platforms. Alternatively, there is an API called OpenGL which works on\nall the platforms except Web. On Web, there is WebGL, which is similar to\nOpenGL but not the same. OpenGL has 4 versions and each version has a\ndifferent API. Only OpenGL 4 is supported on Mac. I could go on.\n\nThe \"from scratch\" approach would be to write pieces of code to interact\ndirectly with each of these native platforms, implementing three different\ngraphics backends and three different app runtimes (used to create windows and\nreceive input events). The non \"from-scratch\" approach would be build on top\nof a library that abstracts all these differences away. A bunch of these\nlibraries exist but the ones that support web are pretty nascent. I feel a bit\nlike I am back in 2013 picking a Javascript framework again. This time I know\nwhat's at stake.\n\nWhat's my solution? I'm not sure yet. It comes down to a tension between two\nheuristics: (1) use as few extra software libraries as possible and (2) spend\nmost of my time building my own unique software.\n\nNow that I think about it, I have actually made a big technical decision like\nthis with eno already: deciding to write it in Zig. Why did I pick zig? Well,\nhonestly, it just seemed cool and I was excited about it. Maybe I'm still more\nnaive than I think.\n\nIf you enjoyed this post, subscribe below to get notifications for the next\none.\n\nWe also have an RSS feed\n\nPowered by Bear \u0295\u2022\u1d25\u2022\u0294\n\n", "frontpage": false}
