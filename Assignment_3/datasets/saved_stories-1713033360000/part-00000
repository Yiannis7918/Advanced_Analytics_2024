{"aid": "40022752", "title": "Signed Char Lotte", "url": "https://nickdrozd.github.io/2021/03/30/signed-char-lotte.html", "domain": "nickdrozd.github.io", "votes": 1, "user": "aksui", "posted_at": "2024-04-13 12:35:10", "comments": 0, "source_title": "signed char lotte", "source_text": "signed char lotte | Something Something Programming\n\nSomething Something Programming\n\n# signed char lotte\n\nMar 30, 2021\n\n\u201csigned char lotte\u201d is a computer program written by Brian Westley and the\nwinner of the \u201cBest Layout\u201d award in the 1990 International Obfuscated C Code\nContest. The cleverness of the text is staggering. Superficially it reads as\nan epistolary exchange between two (possibly former) lovers, Charlotte and\nCharlie. At the same, it is an executable piece of code whose action is\nthematically related to its story.\n\nIt has been argued that code is not literature, and that it cannot be \u201cread\u201d\nin a straightforward way. \u201csigned char lotte\u201d is not a counterexample to this.\nThe text is essentially a palimpsest, with the lovers\u2019 storyline written over\nand obscuring the code that governs the executable behavior. The former can be\n\u201cread\u201d, but not the latter.\n\nHere is the program in full.\n\n    \n    \n    char*lie; double time, me= !0XFACE, not; int rested, get, out; main(ly, die) char ly, **die ;{ signed char lotte, dear; (char)lotte--; for(get= !me;; not){ 1 - out & out ;lie;{ char lotte, my= dear, **let= !!me *!not+ ++die; (char*)(lie= \"The gloves are OFF this time, I detest you, snot\\n\\0sed GEEK!\"); do {not= *lie++ & 0xF00L* !me; #define love (char*)lie - love 1s *!(not= atoi(let [get -me? (char)lotte- (char)lotte: my- *love - 'I' - *love - 'U' - 'I' - (long) - 4 - 'U' ])- !! (time =out= 'a'));} while( my - dear && 'I'-1l -get- 'a'); break;}} (char)*lie++; (char)*lie++, (char)*lie++; hell:0, (char)*lie; get *out* (short)ly -0-'R'- get- 'a'^rested; do {auto*eroticism, that; puts(*( out - 'c' -('P'-'S') +die+ -2 ));}while(!\"you're at it\"); for (*((char*)&lotte)^= (char)lotte; (love ly) [(char)++lotte+ !!0xBABE];){ if ('I' -lie[ 2 +(char)lotte]){ 'I'-1l ***die; } else{ if ('I' * get *out* ('I'-1l **die[ 2 ])) *((char*)&lotte) -= '4' - ('I'-1l); not; for(get=! get; !out; (char)*lie & 0xD0- !not) return!! (char)lotte;} (char)lotte; do{ not* putchar(lie [out *!not* !!me +(char)lotte]); not; for(;!'a';);}while( love (char*)lie);{ register this; switch( (char)lie [(char)lotte] -1s *!out) { char*les, get= 0xFF, my; case' ': *((char*)&lotte) += 15; !not +(char)*lie*'s'; this +1s+ not; default: 0xF +(char*)lie;}}} get - !out; if (not--) goto hell; exit( (char)lotte);}\n\n# Compilation\n\nIf you try to compile this today, it will almost certainly not work:\n\n    \n    \n    gcc -w charlotte.c -o charlotte charlotte.c: In function \u2018main\u2019: charlotte.c:31:7: error: invalid suffix \"s\" on integer constant 31 | love 1s *!(not= atoi(let | ^~ charlotte.c:93:17: error: invalid suffix \"s\" on integer constant 93 | [(char)lotte] -1s *!out) { | ^~ charlotte.c:99:8: error: invalid suffix \"s\" on integer constant 99 | this +1s+ not; default: 0xF +(char*)lie;}}} | ^~\n\nThe program was written around the time the C standard was getting finalized.\nPrior to standardization, idiosyncratic compiler-specific behavior was more\ncommon. One example of this is the short integer literal suffix: 1s. This is\nakin to the long integer literal suffix: 1l. Both of these are used in \u201csigned\nchar lotte\u201d and were presumably in common use at the time, but only the long\nsuffix made it into the standard. Thus to compile it, every instance of 1s\nmust be changed. In the English-language story reading of the text, 1s stands\nfor the word \u201cis\u201d. Fortunately, 1s can be replaced with 15 to keep the spirit\nof the text. This change does not affect the program\u2019s behavior (!!!).\n\n# Behavior\n\nSpeaking of behavior, here is what the program does:\n\n    \n    \n    $ ./charlotte 5 ./charlotte loves me ./charlotte loves me, not ./charlotte loves me ./charlotte loves me, not ./charlotte loves me\n\nThe author comments:\n\n> This is a \u201cPicking the Daisy\u201d simulation. Now, instead of mangling a daisy,\n> simply run this program with the number of petals desired as the argument.\n\nDespite the simplicity of the behavior, it is utterly unclear how the program\nmanages to implement it. Figuring out how it works is an instructive exercise,\nand the reader might want to attempt it before reading further.\n\n# Formatting\n\nRunning the code through a formatter is a a necessary first step, but not a\nsufficient one. Some manual fixes to the formatted output will probably be\nrequired, as formatters are generally not prepared to deal with such bizarre\nstructure. Properly formatted, the program looks something like this:\n\n    \n    \n    char *lie; double time, me = !0XFACE, not; int rested, get, out; main(ly, die) char ly, **die; { signed char lotte, dear; (char)lotte--; for (get = !me;; not) { 1 - out &out; lie; { char lotte, my = dear, **let = !!me * !not + ++die; (char *)(lie = \"The gloves are OFF this time, I detest you, snot\\n\\0sed GEEK!\"); do { not = *lie++ & 0xF00L * !me; (char *)lie - 1 * !(not = atoi(let[get - me ? (char)lotte - (char)lotte : my - *(char *)lie - -'I' - *(char *)lie - -'U' - 'I' - (long)-4 - 'U']) - !!(time = out = 'a')); } while (my - dear && 'I' - 1l - get - 'a'); break; } } (char)*lie++; (char)*lie++, (char)*lie++; hell: 0, (char)*lie; get *out *(short)ly - 0 - 'R' - get - 'a' ^ rested; do { auto *eroticism, that; puts(*(out - 'c' - ('P' - 'S') + die + -2)); } while (!\"you're at it\"); for (*((char *)&lotte) ^= (char)lotte; ((char *)lie - ly)[(char)++lotte + !!0xBABE];) { if ('I' - lie[2 + (char)lotte]) { 'I' - 1l * **die; } else { if ('I' * get * out * ('I' - 1l * *die[2])) *((char *)&lotte) -= '4' - ('I' - 1l); not; for (get = !get; !out; (char)*lie & 0xD0 - !not) return !!(char)lotte; } (char)lotte; do { not*putchar(lie[out * !not*!!me + (char)lotte]); not; for (; !'a';); } while ((char *)lie - (char *)lie); { register this; switch ((char)lie[(char)lotte] - 1 * !out) { char *les, get = 0xFF, my; case ' ': *((char *)&lotte) += 15; !not + (char)*lie * 's'; this + 1 + not; default: 0xF + (char *)lie; } } } get - !out; if (not--) goto hell; exit((char)lotte); }\n\nIt remains unclear how the program actually does what it does. The primary\nobfuscation trick used is misdirection. You can spend a lot of time trying to\nwork out the purpose and meaning of every line, but in fact most of the code\nis totally useless. Shall I count the ways?\n\n# Useless casts\n\nAll of the following casts can be cut without consequence:\n\n  * (char)\n  * (char*)\n  * (long)\n  * (short)\n\n# Useless statements\n\nMany statements have no effect on anything, and can be cut. A simple example\nof a useless statement is (char)lotte;; it evidently casts signed char lotte\nas a char and then does nothing with it. Obviously this can be cut.\n\nMore sophisticated useless statements can be constructed from arithmetic\noperators:\n\n  * 1 - out & out ;lie;\n  * get - !out;\n  * get *out* (short)ly -0-'R'- get- 'a'^rested;\n\nHowever, a statement that appears useless may not be. Because this is good old\ndependable C, side effects can occur just about anywhere, and it is all but\nimpossible to tell how any one in particular might affect the program\u2019s\nbehavior. Thus any statement with the following operators must be kept: =, ++,\n--, +=, ^=.\n\n# Useless Control Flow\n\nA nice way to add in some extra words to the program without affecting its\noperation is to wrap a code block in a do loop with an always-false while\ncondition. This causes the code to execute exactly as before, but with a\nsuperficially more complex control flow. Here is my favorite example:\n\n    \n    \n    #define love (char*)lie - // ... do{ not* putchar(lie [out *!not* !!me +(char)lotte]); not; for(;!'a';);}while( love (char*)lie);{\n\nWith formatting and preprocessor expansion, this becomes:\n\n    \n    \n    do { not*putchar(lie[out * !not*!!me + (char)lotte]); not; for (; !'a';); } while ((char *)lie - (char *)lie);\n\nBut (char *)lie - (char *)lie will always work out to be falsy, and therefore\nthe expression can be reduced to a simple block:\n\n    \n    \n    not*putchar(lie[out * !not*!!me + (char)lotte]); not; for (; !'a';);\n\nThis block itself contains the strikingly useless loop for (; !'a';);, as well\nas the useless simple statement not;.\n\nBesides overtly useless control flow, specific quirks of C control flow\noperators can be exploited. For example, code in a switch block that comes\nbefore any of the case labels is unreachable, and therefore useless.\n\n    \n    \n    switch ((char)lie[(char)lotte] - 1 * !out) { char *les, get = 0xFF, my; // unreachable case ' ': *((char *)&lotte) += 15; !not + (char)*lie * 's'; this + 1 + not; default: 0xF + (char *)lie; }\n\n# The Crux of the Program\n\nAfter applying these simplfications and doing a little more massaging, the\ntrue nature of the program reveals itself:\n\n    \n    \n    char *lie = \"loves are OFF this time, I detest you, snot\\n\\0\"; int main(int argc, char **argv) { int get = 1; int not = atoi(argv[1]); int lotte; for (; not; not--) { puts(argv[0]); for (lotte = 0; lie[lotte]; lotte++) { if (!('I' - lie[2 + lotte])) { if (get) lotte += 20; get = !get; } putchar(lie[lotte]); switch (lie[lotte]) { case ' ': lotte += 15; } } } exit(lotte); }\n\nThe string char *lie contains as substrings \u201cloves\u201d, \u201cme\u201d, and \u201cnot\u201d. get is a\ntoggle that signals whether or not to print \u201cnot\u201d, while not is the counter\ninput by the user. lotte is the index into lie. The program uses comically\nelaborate logic with hard-coded constants to manipulate lotte into the right\nposition in lie, and that\u2019s how the appropriate messages are printed.\n\nThus it is not merely a matter of obfuscating an otherwise normal program by\ncovering it up with a bunch of weird irrelevant text; fundamentally the\nprogram is already far more difficult to understand than it needs to be. The\nIOCCC judges said that they \u201clike programs that MAKE USE OF A NUMBER OF\nDIFFERENT TYPES OF OBFUSCATION\u201d, and so it is no surprise that \u201csigned char\nlotte\u201d won.\n\n# Discussion Questions\n\n  1. How many reserved keywords are there in C? How many of those are used in \u201csigned char lotte\u201d?\n  2. Why wasn\u2019t the short integer literal suffix included in the C standard? How common was it in pre-standard times? Which compilers included it?\n  3. Is love a toilet?\n  4. What is the purpose of the goto hell; statement?\n  5. How do you suppose this program was constructed?\n\n# Exercises\n\n  1. Analyze Westley\u2019s 1987 IOCCC winner, \u201cAble was I ere I saw elbA\u201d.\n  2. Modify \u201csigned char lotte\u201d so as to include more C keywords.\n  3. Modify GCC so that it compiles the original program correctly.\n\n## Something Something Programming\n\n  * Something Something Programming\n  * nicholasdrozd@gmail.com\n\n  * nickdrozd\n\nMostly thoughts about programming. Maybe other stuff too.\n\n", "frontpage": false}
