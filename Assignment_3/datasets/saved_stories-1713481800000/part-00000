{"aid": "40078413", "title": "Zest: Syntax", "url": "https://www.scattered-thoughts.net/writing/zest-syntax/", "domain": "scattered-thoughts.net", "votes": 1, "user": "eatonphil", "posted_at": "2024-04-18 17:07:46", "comments": 0, "source_title": "Zest: syntax", "source_text": "Zest: syntax\n\n# Zest: syntax\n\nPublished 2024-04-16\n\n(This is part of a series on the design of a language. See the list of posts\nhere.)\n\nPopular advice for designing a language is to focus on semantics and worry\nabout syntax later. So it might seem ill-advised to write about syntax before\nwriting about semantics. But a) I think syntax design is underrated - it has a\nhuge impact on the subjective feel of working with a language, and b) it's\nhard to write about semantics without first explaining the syntax.\n\nWhat do I want from syntax?\n\n  * Easy to parse by machines. Ideally LL(k) or close to.\n  * Easy to parse by humans. Especially when skimming code - it should be possible to at-a-glance pick out the basic structure and important operations.\n  * Pleasant to type. At least on altgr-weur.\n  * Familiar to experienced programmers.\n\nFamiliarity and easy skimming are somewhat in tension, because algol-family\nlanguages use each symbol for a wide range of different roles.\n\n  * [] for arrays, element/field access\n  * () for grouping, function calls, function definitions, tuples\n  * {} for structs/objects, type definitions, blocks\n  * . for field access, method calls, decimals points\n  * : for key-value pairs, type annotations\n  * * for multiplication, pointer types, pointer deref\n  * & for boolean-and, bitwise-and, address-of\n\nI'd like to make these categories more thematically aligned but that often\nconflicts with muscle-memory from other languages. I've mostly ended up with\nfairly sensible categories without introducing too much novelty, except for\nthe ambiguity between field access and decimal points which was too ingrained\nin my muscle memory.\n\n  * [] for compound literals\n  * () for function definitions and calls\n  * {} for grouping and blocks\n  * . for field access and decimal points\n  * : for key-value pairs\n  * regular arithmetic operators * / + -\n  * @ for mutable references\n\nNumbers are as expected. I haven't made decisions yet about syntax for binary,\noctal, hexadecimal, scientific notation etc.\n\n    \n    \n    42\n    \n    \n    3.14\n\n' is for strings. Slightly faster to type than \".\n\n    \n    \n    'Hello world'\n\nStrings can't contain literal newlines.\n\n    \n    \n    // This is a syntax error! 'Hello world'\n\nThis means that no tokens in the language can span a newline, making\nincremental syntax highlighting much easier.\n\nI've been convinced that it's valuable to allow arbitrary non-utf8 byte-\nstrings using integer escapes but I haven't decided on the syntax yet. (The\ndefault string type would still be utf8.)\n\nNames are lower-case and kebab-case.\n\nArithmetic operators must be surrounded by whitespace, so.\n\n  * foo-bar is a single name.\n  * foo - bar is a subtraction.\n  * foo- bar and foo -bar are syntax errors.\n\nSnake-case would have avoided the ambiguity, but is a little slower to type.\n\n= is for binding names to values.\n\n    \n    \n    x = 1 y = x + 1\n\nI considered reusing : for binding as well as for struct keys (below) but:\n\n  * x = 1 brings a new name into scope and x: 1 does not. Distiguishing the two is useful when scanning code to figure out where x is defined.\n  * x += 1 is ubiquitous. Using x +: 1 instead would be foreign, and is also annoying to type.\n\n[] is for compound literals, which are all built out of structs.\n\nThis is a struct:\n\n    \n    \n    ['name': 'Alice', 'role': 'Example person']\n\nIf a key is a string which is also a valid name, then the ' can be omitted.\n\n    \n    \n    [name: 'Alice', role: 'Example person']\n\nIf we actually want to use a variable for a key we can disambiguate.\n\n    \n    \n    k = 'name' [{k}: 'Alice', role: 'Example person']\n\nStruct keys can be any value, not just strings.\n\n    \n    \n    [0: 'zero', 'one': 1, ['three', 'four']: 34]\n\nIf no key is given for an element, then it defaults to a consecutive integer.\n\n    \n    \n    ['a', 'b', 'c'] == [0: 'a', 1: 'b', 2: 'c']\n\nThis avoids needing different syntax for structs vs tuples - they're not\nfundamentally different.\n\nI also added some sugar for the common case where the key and value are the\nsame variable.\n\n    \n    \n    [:foo] == [foo: foo]\n\nAnd of course I allow trailing commas.\n\n    \n    \n    [ 0, 1, 2, ]\n\nTypes are first-class and created by a few keywords.\n\n    \n    \n    // types i32 f32 string // type constructors struct union list map\n\nCombining a type constructor and a struct produces a type.\n\n    \n    \n    struct[name: string, role: string] struct[i32, i32] == struct[0: i32, 1: i32] list[i32] map[i32, string] union[nums: list[i32], strings: list[string]]\n\nCombining a type and a value attempts to cast the value to the type. This is\nhow all values other than numbers/strings/structs are constructed.\n\n    \n    \n    list[string]['a','b','c'] map[string, i32]['one': 1, 'two': 2] result = union[ok: i32, error: string] result[ok: 4] result[error: 'oh no!'] // type error: expected i32, found string result[ok: 'oh no!']\n\nThis is also how values are printed!\n\n    \n    \n    print(result[ok: 4]) // prints: // union[ok: i32, error: string][ok: 4]\n\nThe printing is smart enough to avoid printing redundant types.\n\n    \n    \n    results = list[result] print(results[[ok: 4], [error: 'oh no!']]) // prints: // list[union[ok: i32, error: string]][[ok: 4], [error: 'oh no!']]\n\nFor any value that doesn't contain a mutable reference or a function, you can\npaste the printout back into your code and get a value that compares equal to\nthe original.\n\nStruct fields are accessed with ..\n\n    \n    \n    example = [name: 'Alice', role: 'Example person'] example.'name' == 'Alice' tuple = ['a', 'b', 'c'] tuple.0 == 'a'\n\nThe syntax sugar from structs also applies here.\n\n    \n    \n    example = [name: 'Alice', role: 'Example person'] example.name == 'Alice' tuple = ['a', 'b', 'c'] i = 0 tuple.i // error: key 'i' not found in ['a', 'b', 'c'] tuple.{i} == 'a'\n\nThis produces an ambiguity with decimal points which I manually resolve in the\ngrammar.\n\n    \n    \n    x.0.1 == {x.0}.1 x.0.1 != x.{0.1}\n\nI originally used / for both fields and field access.\n\n    \n    \n    example = [/name 'Alice', /role 'Example person'] example/name == 'Alice'\n\nThis avoids the ambiguity with decimal points and I also think it worked\nbetter visually. Plus the similarity to filesystem paths provides a natural\ninterpretation. But I kept typing example.name anyway. Muscle memory is a\nbitch.\n\nThis is a function call:\n\n    \n    \n    push(list, elem)\n\nFunction arguments use the exact same syntax as structs. So we get named\narguments for free, and function arguments can be represented by structs.\n\n    \n    \n    get(salaries, 'Alice', default: 0) // Equivalently: call(get, [salaries, 'Alice', default: 0])\n\nThis is a function definition:\n\n    \n    \n    get = (obj, key, :default) if has(obj, key) obj.{key} else default\n\nFunction parameters use the same syntax as function arguments and structs, but\nthat syntax is interpreted as a pattern to match against (with what I'm just\ngoing to claim are the obvious semantics).\n\n    \n    \n    first = ([a, b]) a first([1,2]) == 1\n\nPatterns are also allowed in bindings:\n\n    \n    \n    [a, b] = [1, 2] a == 1 b == 2\n\nIn many languages functions can also be associated with types - an expression\nlike foo.bar() would look for the function bar associated with type-of(foo).\n\nThis doesn't really work nicely in a structurally-typed language so I instead\nadded an operator / for uniform function call syntax.\n\n    \n    \n    salaries/get('Alice', default: 0) == get(salaries, 'Alice', default: 0)\n\nUsing / rather than reusing . avoids the obnoxious ambiguity between calling a\nfunction in UFCS-style vs calling a function stored in a field.\n\n    \n    \n    confusing = [get: (key, :default) 42] confusing/get('Alice', default: [error: 'not found']) == [error: 'not found'] confusing.get('Alice', default: [error: 'not found']) == 42\n\nWhen serializing a large value as text, we want the type to come first to\nallow efficient parsing.\n\n    \n    \n    list[i32][0,1,2,...]\n\nBut in patterns we want the type to come after the variable for better\nreadability.\n\nTo support both, I allow using types as functions.\n\n    \n    \n    list[i32][0,1,2] == list[i32]([0,1,2]) == [0,1,2]/list[i32]\n\nIn patterns, applying a type to a parameter acts as a test that the\nparameter's value can be cast to that type.\n\n    \n    \n    first = (x/list[i32]) x/get(0) first([1,2,3]) == 1 first(['a','b','c']) // type error: expected i32, found string\n\n{} is used for blocks. Multiple expressions within a block are separated\neither by newlines or ;.\n\n    \n    \n    do-twice = (f) { f() f() } do-twice = (f) {f(); f()}\n\nA block with a single expression can be used for grouping.\n\n    \n    \n    x - {y + z}\n\nThe value of a block is the value of the last expression.\n\nThe empty block {} returns the empty struct [].\n\n'Expressions separated by newlines' sounds awfully like javascript's\ndisastrous semicolon insertion.\n\nI avoid ambiguities by starting with the rule that expressions can't span\nnewlines, and then adding exceptions only in places where it is obvious that\nthe current expression hasn't finished:\n\n  * Between items inside () or [] or {}.\n  * After a binary operator.\n  * After a /.\n\n    \n    \n    // ok inc = (x) x+1 // syntax error inc = (x) x+1 // ok inc = (x) { x+1 }\n    \n    \n    // ok foo/bar()/quux() // syntax error foo /bar() /quux() // ok foo/ bar()/ quux() // syntax error foo/ bar()/ quux()\n\nThis does make function chaining look less nice, but it feels worth it to\navoid both semicolons and semicolon-insertion.\n\n@ is (tentatively) for mutable references.\n\n    \n    \n    // A mutable reference initialized to the value [x: 0, y: 1] vec @= [x: 0, y: 1] // An assignment @vec.x = vec.x + 1 // Equivalently: @vec.x += 1 // Equivalently: inc = (@x) @x += 1 inc(@vec.x)\n\nMutable references in zest don't behave like mutable variables in java-like\nlanguages or pointers in c-like languages (more on that in later posts). So I\ndeliberately picked a foreign syntax to avoid false familiarity.\n\nI don't allow shadowing names, so forgetting the syntax for assignment doesn't\ncause bugs:\n\n    \n    \n    x @= 0 // ok @x = y // error: name x is already bound x = y\n\nThere are only a few groups for precedence rules:\n\n  1. Binding (=)\n  2. Binary operators (==, +, and etc).\n  3. Chaining operators (., /, function calls etc).\n  4. Mutable paths.\n\nAll are left-associative. Binary operators must be separated by spaces and\ncan't be mixed. Chaining operators must not be separated by spaces and can be\nmixed.\n\n    \n    \n    x = y.z + 1 // parses as x = {{y.z} + 1} a + b + c // parses as {a + b} + c // syntax error: ambiguous precedence between + and - a + b - c a/f().b[c] // parses as {{f(a)}.b}[c]\n\nThe last group, mutable paths, is a slightly awkward hack to make @ and /\ninteract nicely:\n\n    \n    \n    @foo.bar/push(thing) // parses as push(@foo.bar, thing) // rather than @push(foo.bar, thing)\n\nI'm tempted to not have short-circuiting boolean operators at all. The syntax\nfor closures isn't too noisy:\n\n    \n    \n    // more binary operators? {w == x} and {{x == y} or {y == z}} // or just use functions? and(w == x, () or(x == y, () y == z))\n\nThe syntax is practically LL(k). The AST is produced by a recursive descent\nparser with only one-token-lookahead (arguably two-token if you count\nspace/newline tokens). But patterns are parsed as if they were expressions,\neven though only a subset of the expression syntax is supported in patterns.\nInvalid patterns get reported during semantic analysis instead of parsing, but\narguably should be considered part of the grammar.\n\n    \n    \n    // error: field access (.) may not be used in a pattern x.y = 42 // error: `get` is a function and may not be used in a pattern get(a,b) = 42\n\nI think this layered approach is still pretty tooling-friendly though. An\nLL(k) parser is good enough for most IDE interactions. The additional rules\nare easy to check with a single pass over the AST.\n\nIt's also pretty human-friendly. The amount of grammar you need to remember is\nmuch less than if patterns and paths had separate syntax. That makes it easier\nto visually parse code with a quick glance.\n\njamie@scattered-thoughts.net\n\nSupport my work on github sponsors.\n\n", "frontpage": false}
